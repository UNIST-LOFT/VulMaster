[
 {
  "id": 0,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_cal_sad ( VP8_COMP * cpi , MACROBLOCKD * xd , MACROBLOCK * x , int recon_yoffset , int near_sadidx [ ] ) { int near_sad [ 8 ] = { 0 } ; BLOCK * b = & x -> block [ 0 ] ; unsigned char * src_y_ptr = * ( b -> base_src ) ; if ( xd -> mb_to_top_edge == 0 && xd -> mb_to_left_edge == 0 ) { near_sad [ 0 ] = near_sad [ 1 ] = near_sad [ 2 ] = INT_MAX ; } else if ( xd -> mb_to_top_edge == 0 ) { near_sad [ 0 ] = near_sad [ 2 ] = INT_MAX ; <vul-start> near_sad [ 1 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - 16 , xd -> dst . y_stride , UINT_MAX ) ; <vul-end> } else if ( xd -> mb_to_left_edge == 0 ) { near_sad [ 1 ] = near_sad [ 2 ] = INT_MAX ; <vul-start> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX ) ; <vul-end> } else { <vul-start> near_sad [ 0 ] = cpi -> fn_ptr [ BLOCK_16X16 ] . sdf ( src_y_ptr , b -> src_stride , xd -> dst . y_buffer - xd -> dst . y_stride * 16 , xd -> dst . y_stride , UINT_MAX",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> dst . y_stride <vul-end> ) ; } <vul-start> dst . y_stride <vul-end> ) ; } <vul-start> dst . y_stride <vul-end> ) ; near_sad <vul-start> dst . y_stride <vul-end> ) ; near_sad <vul-start> dst . y_stride <vul-end> ) ; } <vul-start> 16 , pre_y_stride <vul-end> ) ; if <vul-start> 16 , pre_y_stride <vul-end> ) ; near_sad <vul-start> pre_y_buffer , pre_y_stride <vul-end> ) ; if <vul-start> 16 , pre_y_stride <vul-end> ) ; if <vul-start> 16 , pre_y_stride <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 1 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 0 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 0 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 1 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 2 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 0 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 1 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 3 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 0 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 4 ] = vpx_sf <vul-end> ( src_y_ptr, <vul-start> 7 ] = vpx_sf <vul-end> ( src_y_ptr,\n"
 },
 {
  "id": 1,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int xfs_setattr_nonsize ( struct xfs_inode * ip , struct iattr * iattr , int flags ) { xfs_mount_t * mp = ip -> i_mount ; struct inode * inode = VFS_I ( ip ) ; int mask = iattr -> ia_valid ; xfs_trans_t * tp ; int error ; kuid_t uid = GLOBAL_ROOT_UID , iuid = GLOBAL_ROOT_UID ; kgid_t gid = GLOBAL_ROOT_GID , igid = GLOBAL_ROOT_GID ; struct xfs_dquot * udqp = NULL , * gdqp = NULL ; struct xfs_dquot * olddquot1 = NULL , * olddquot2 = NULL ; ASSERT ( ( mask & ATTR_SIZE ) == 0 ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & ( ATTR_UID | ATTR_GID ) ) ) { uint qflags = 0 ; if ( ( mask & ATTR_UID ) && XFS_IS_UQUOTA_ON ( mp ) ) { uid = iattr -> ia_uid ; qflags |= XFS_QMOPT_UQUOTA ; } else { uid = inode -> i_uid ; } if ( ( mask & ATTR_GID ) && XFS_IS_GQUOTA_ON ( mp ) ) { gid = iattr -> ia_gid ; qflags |= XFS_QMOPT_GQUOTA ; } else { gid = inode -> i_gid ; } ASSERT ( udqp == NULL ) ; ASSERT ( gdqp == NULL ) ; error = xfs_qm_vop_dqalloc ( ip , xfs_kuid_to_uid ( uid ) , xfs_kgid_to_gid ( gid ) , xfs_get_projid ( ip ) , qflags , & udqp , & gdqp , NULL ) ; if ( error ) return error ; } error = xfs_trans_alloc ( mp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ,",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> tp ) ; <vul-end> return error ;\n"
 },
 {
  "id": 2,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int usb_parse_configuration ( struct usb_device * dev , int cfgidx , struct usb_host_config * config , unsigned char * buffer , int size ) { struct device * ddev = & dev -> dev ; unsigned char * buffer0 = buffer ; int cfgno ; int nintf , nintf_orig ; int i , j , n ; struct usb_interface_cache * intfc ; unsigned char * buffer2 ; int size2 ; struct usb_descriptor_header * header ; int len , retval ; u8 inums [ USB_MAXINTERFACES ] , nalts [ USB_MAXINTERFACES ] ; unsigned iad_num = 0 ; memcpy ( & config -> desc , buffer , USB_DT_CONFIG_SIZE ) ; if ( config -> desc . bDescriptorType != USB_DT_CONFIG || config -> desc . bLength < USB_DT_CONFIG_SIZE || config -> desc . bLength > size ) { dev_err ( ddev , \"invalid descriptor for config index %d: \" \"type = 0x%X, length = %d\\\\n\" , cfgidx , config -> desc . bDescriptorType , config -> desc . bLength ) ; return - EINVAL ; } cfgno = config -> desc . bConfigurationValue ; buffer += config -> desc . bLength ; size -= config -> desc . bLength ; nintf = nintf_orig = config -> desc . bNumInterfaces ; if ( nintf > USB_MAXINTERFACES ) { dev_warn ( ddev , \"config %d has too many interfaces: %d, \" \"using maximum allowed: %d\\\\n\" , cfgno , nintf , USB_MAXINTERFACES ) ; nintf = USB_MAXINTERFACES ; } n = 0 ; for ( ( buffer2 = buffer , size2 = size ) ; size2 > 0 ; (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> USB_DT_INTERFACE_ASSOCIATION ) { struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , \"config %d has an invalid interface association descriptor of length %d, skipping\\\\n\" , cfgno , d -> bLength ) ; continue ; } <vul-start> iad_num ] = d <vul-end> ; iad_num ++\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> USB_DT_INTERFACE_ASSOCIATION ) { struct usb_interface_assoc_descriptor * header ; <vul-start> if ( iad_num >= <vul-end> USB_MAXIADS ) { <vul-start> iad_num ] = header ; if ( iad_num >= USB_MAXIADS ) dev_warn ( ddev, \"too many Interface association Descriptors \" \"than allocated for in \" \"configuration %d\\\\n\", cfgno ) <vul-end> ; } }\n"
 },
 {
  "id": 3,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; <vul-start> if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) <vul-end> <vul-start> return - ENOMEM ; <vul-end> if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <vul-end> card -> user_ctl_count <vul-start> return - ENOMEM <vul-end> ; memcpy (\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start>, err ; unsigned int count ; <vul-start> return - ENOMEM ; count = info -> count ; if ( count > MAX_USER_CONTROLS - count ) count = MAX_USER_CONTROLS\n"
 },
 {
  "id": 4,
  "question": "CWE-285 Code Input Vulnerable Code Is: CWE-285 static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) { struct Client * agent_p = NULL ; struct Client * saslserv_p = NULL ; if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ; if ( strlen ( client_p -> id ) == 3 ) { <vul-start> exit_client ( client_p , client_p , client_p , \"Mixing client and server protocol\" ) ; <vul-end> return 0 ; } saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ; if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) { sendto_one ( source_p , form_str ( ERR_SASLABORTED ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ; return 0 ; } if ( source_p -> localClient -> sasl_complete ) { * source_p -> localClient -> sasl_agent = '\\\\0' ; source_p -> localClient -> sasl_complete = 0 ; } if ( strlen ( parv [ 1 ] ) > 400 ) { sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ; return 0 ; } if ( ! * source_p -> id ) { strcpy ( source_p -> id , generate_uid ( ) ) ; add_to_id_hash ( source_p -> id , source_p ) ; } if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ; if ( agent_p == NULL )",
  "golden_answers": [
   "CWE-285 Fixed Code Lines are: <vul-start> client_p , \"Mixing client and server protocol\" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , ' ' ) ) { exit_client ( client_p , client_p , client_p , \"Malformed AUTHENTICATE\"\n"
  ],
  "generated_answer": "CWE-285 Fixed Code Lines are: <vul-start> 3 ) { free_client ( client_p, client_p ) ; return 0 ; } if ( strlen ( parv [ 1 ] ) > 500 ) {\n"
 },
 {
  "id": 5,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static void parse_input ( h2o_http2_conn_t * conn ) <vul-end> { size_t http2_max_concurrent_requests_per_connection = conn -> super . ctx -> globalconf -> http2 . max_concurrent_requests_per_connection ; int perform_early_exit = 0 ; if ( conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed != http2_max_concurrent_requests_per_connection ) perform_early_exit = 1 ; while ( conn -> state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn -> sock -> input -> size != 0 ) { if ( perform_early_exit == 1 && conn -> num_streams . pull . half_closed + conn -> num_streams . push . half_closed == http2_max_concurrent_requests_per_connection ) goto EarlyExit ; const char * err_desc = NULL ; ssize_t ret = conn -> _read_expect ( conn , ( uint8_t * ) conn -> sock -> input -> bytes , conn -> sock -> input -> size , & err_desc ) ; if ( ret == H2O_HTTP2_ERROR_INCOMPLETE ) { break ; } else if ( ret < 0 ) { if ( ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY ) { enqueue_goaway ( conn , ( int ) ret , err_desc != NULL ? ( h2o_iovec_t ) { ( char * ) err_desc , strlen ( err_desc ) } : ( h2o_iovec_t ) { } ) ; } <vul-start> close_connection ( conn ) ; <vul-end> return ; } h2o_buffer_consume ( & conn -> sock -> input , ret ) ; } if ( ! h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_start ( conn -> sock , on_read ) ; <vul-start> return ; <vul-end> EarlyExit : if ( h2o_socket_is_reading ( conn -> sock ) ) h2o_socket_read_stop ( conn -> sock",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start>     static int <vul-end> parse_input ( h2o_http2_conn_t <vul-start> ) ; } return <vul-start> ( conn ) <vul-end> ; } h2o_buffer_consume <vul-start> ) ; return 0 <vul-start> sock ) ; return 0 ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>     static int <vul-end> parse_input ( h2o_http2_conn_t <vul-start> ) ; } if ( ret == H2O_HTTP2_ERROR_INCOMPLETE ) { <vul-start> close_connection ( conn ) ; return - 1 ; } return ret <vul-end> ; } h2o_buffer_consume <vul-start> on_read ) ; else return ret ; <vul-end> EarlyExit : if <vul-start> sock ) ; return ret ;\n"
 },
 {
  "id": 6,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int _yr_scan_verify_re_match ( YR_SCAN_CONTEXT * context , YR_AC_MATCH * ac_match , uint8_t * data , size_t data_size , size_t data_base , size_t offset ) { CALLBACK_ARGS callback_args ; RE_EXEC_FUNC exec ; int forward_matches = - 1 ; int backward_matches = - 1 ; int flags = 0 ; if ( STRING_IS_GREEDY_REGEXP ( ac_match -> string ) ) flags |= RE_FLAGS_GREEDY ; if ( STRING_IS_NO_CASE ( ac_match -> string ) ) flags |= RE_FLAGS_NO_CASE ; if ( STRING_IS_DOT_ALL ( ac_match -> string ) ) flags |= RE_FLAGS_DOT_ALL ; if ( STRING_IS_FAST_REGEXP ( ac_match -> string ) ) exec = yr_re_fast_exec ; else exec = yr_re_exec ; if ( STRING_IS_ASCII ( ac_match -> string ) ) { forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <vul-start> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <vul-end> NULL , NULL ) ; } if ( STRING_IS_WIDE ( ac_match -> string ) && forward_matches == - 1 ) { flags |= RE_FLAGS_WIDE ; forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <vul-start> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <vul-end> NULL , NULL ) ; } switch ( forward_matches ) { case - 1 : return ERROR_SUCCESS ; case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } if ( forward_matches == 0 && ac_match -> backward_code == NULL ) return ERROR_SUCCESS ; callback_args . string = ac_match -> string",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> offset , offset , <vul-end> flags , NULL <vul-start> offset , offset , <vul-end> flags , NULL <vul-start> , data + offset , data_size -\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> offset, offset!= <vul-end> 0? flags <vul-start> offset, offset!= <vul-end> 0? flags <vul-start> callback_args. string!= NULL && data [ offset ] == RE_START_ABORT ) { FAIL_ON_ERROR ( _yr_scan_match_callback ( ( uint8_t * ) data + offset, data_size - offset, <vul-end> flags | RE_FLAGS_BACKWARDS <vul-start> RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE <vul-end>, & callback_args\n"
 },
 {
  "id": 7,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int open_url ( AVFormatContext * s , AVIOContext * * pb , const char * url , AVDictionary * opts , AVDictionary * opts2 , int * is_http ) { HLSContext * c = s -> priv_data ; AVDictionary * tmp = NULL ; const char * proto_name = NULL ; int ret ; av_dict_copy ( & tmp , opts , 0 ) ; av_dict_copy ( & tmp , opts2 , 0 ) ; if ( av_strstart ( url , \"crypto\" , NULL ) ) { if ( url [ 6 ] == '+' || url [ 6 ] == ':' ) proto_name = avio_find_protocol_name ( url + 7 ) ; } if ( ! proto_name ) proto_name = avio_find_protocol_name ( url ) ; if ( ! proto_name ) return AVERROR_INVALIDDATA ; <vul-start> if ( ! av_strstart ( proto_name , \"http\" , NULL ) && ! av_strstart ( proto_name , \"file\" , NULL ) ) <vul-end> return AVERROR_INVALIDDATA ; if ( ! strncmp ( proto_name , url , strlen ( proto_name ) ) && url [ strlen ( proto_name ) ] == ':' ) ; else if ( av_strstart ( url , \"crypto\" , NULL ) && ! strncmp ( proto_name , url + 7 , strlen ( proto_name ) ) && url [ 7 + strlen ( proto_name ) ] == ':' ) ; else if ( strcmp ( proto_name , \"file\" ) || ! strncmp ( url , \"file,\" , 5 ) ) return AVERROR_INVALIDDATA ; ret = s -> io_open ( s , pb , url , AVIO_FLAG_READ , & tmp",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; if ( <vul-end> av_strstart ( proto_name <vul-start> ( proto_name , \"file\" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , \"ALL\" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , \"Filename extension of \\\\\\'%s\\\\\\' is not a common multimedia extension, blocked for security reasons.\\\\n\" \"If you wish to override this adjust allowed_extensions, you can set it to \\\\\\'ALL\\\\\\' to allow all\\\\n\" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <vul-start> , NULL ) ) { ; } else <vul-end> return AVERROR_INVALIDDATA ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start>, \"file\", NULL ) &&! av_strstart ( proto_name, \"file,\",\n"
 },
 {
  "id": 8,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc ( struct usb_interface * intf ) { const void * buf = intf -> altsetting -> extra ; size_t buflen = intf -> altsetting -> extralen ; struct usb_cdc_union_desc * union_desc ; if ( ! buf ) { dev_err ( & intf -> dev , \"Missing descriptor data\\\\n\" ) ; return NULL ; } if ( ! buflen ) { dev_err ( & intf -> dev , \"Zero length descriptor\\\\n\" ) ; return NULL ; } <vul-start> while ( buflen > 0 ) { <vul-end> union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bDescriptorType == USB_DT_CS_INTERFACE && union_desc -> bDescriptorSubType == USB_CDC_UNION_TYPE ) { dev_dbg ( & intf -> dev , \"Found union header\\\\n\" ) ; <vul-start> return union_desc ; <vul-end> } buflen -= union_desc -> bLength ; buf += union_desc -> bLength ; } dev_err ( & intf -> dev , \"Missing CDC union descriptor\\\\n\" ) ; return NULL ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , \"Too large descriptor\\\\n\" ) ; return NULL ; } <vul-end> if ( union_desc <vul-start> \"Found union header\\\\n\" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , \"Union descriptor to short (%d vs %zd\\\\n)\" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <vul-end> ; } buflen\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> NULL ; } if ( intf -> altsetting -> desc. bNumEndpoints < 1 ) { dev_err ( & intf -> dev, \"Invalid number of endpoints\\\\n\" ) ; return NULL ; } <vul-start> \"Found union header\\\\n\" ) ; if ( union_desc -> bLength < buflen ) { dev_err ( & intf -> dev, \"Invalid descriptor buffer length\\\\n\" ) ; return NULL ; }\n"
 },
 {
  "id": 9,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 <vul-end> ; break ; <vul-start> n ) && ( <vul-start> ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) <vul-start> += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , \"bare * has associated type comment\" ) ; return NULL ; } <vul-start> ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } <vul-end> if ( i <vul-start> ; i += 2 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 <vul-end> ; break ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> arg ) ; if ( i + 2 >= NCH ( n ) ) { ast_error ( c, CHILD ( n, i ), \"too many arguments\" ) ; return NULL ; } <vul-start> || ( i <vul-end> == NCH ( <vul-start> += 2 ; if ( i < NCH ( n ) ) { i += 3 ; if ( TYPE ( CHILD ( n, i ) ) == TYPE_COMMENT ) { i += 4 ; } else { ast_error ( c, CHILD ( n, i ), \"too many arguments\" ) ; return NULL ; } } <vul-start> return NULL ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n, i ) ) == COMMA ) ) { ast_error ( c, CHILD ( n, i ), \"named arguments must follow bare *\" ) ; return NULL ; i = res ; } else { <vul-start> += 3 ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n, i ) ) == TYPE_COMMENT ) { i += 3 ; if ( i < NCH ( n ) ) { ast_error ( c, CHILD ( n, i ), \"too many arguments\" ) ; return NULL ; } }\n"
 },
 {
  "id": 10,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ctxt -> rip_relative && likely ( ctxt -> memopp )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ( ctxt -> <vul-end> goffset ) ctxt\n"
 },
 {
  "id": 11,
  "question": "CWE-358 Code Input Vulnerable Code Is: CWE-358 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <vul-start> int is_udplite = IS_UDPLITE ( sk ) ; <vul-end> int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <vul-start> if ( udp_lib_checksum_complete ( skb ) ) <vul-end> goto csum_copy_err ; } <vul-start> if ( skb_csum_unnecessary ( skb ) ) <vul-end> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg",
  "golden_answers": [
   "CWE-358 Fixed Code Lines are: <vul-start> ( sk ) ; bool checksum_valid = false <vul-start> partial_cov ) { checksum_valid = ! <vul-end> udp_lib_checksum_complete ( skb <vul-start> ( skb ) ; if ( ! checksum_valid <vul-start> } if ( checksum_valid ||\n"
  ],
  "generated_answer": "CWE-358 Fixed Code Lines are: <vul-start> ( sk ) ; struct udphdr * eth_hdr <vul-start> partial_cov ) { eth_hdr = skb_orphan ( skb ) ; <vul-start> } if ( skb_is_gso ( skb ) && <vul-start> slow ) ; if (! skb_is_gso ( skb ) && ( ( struct udphdr * ) skb ) -> opt. optlen ) { err = udpv6_recv_gpo_err ( sk, msg, skb ) ; if ( err == - EINVAL ) goto csum_copy_err ; } else { sin6_init_skb ( skb, 0, sizeof ( * sin6 ) ) ; * addr_len = sizeof ( * sin6 ) ; } } <vul-start> ( skb ) <vul-end> ; if (\n"
 },
 {
  "id": 12,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int TIFFFlushData1 ( TIFF * tif ) { if ( tif -> tif_rawcc > 0 && tif -> tif_flags & TIFF_BUF4WRITE ) { if ( ! isFillOrder ( tif , tif -> tif_dir . td_fillorder ) && ( tif -> tif_flags & TIFF_NOBITREV ) == 0 ) TIFFReverseBits ( ( uint8 * ) tif -> tif_rawdata , tif -> tif_rawcc ) ; if ( ! TIFFAppendToStrip ( tif , isTiled ( tif ) ? tif -> tif_curtile : tif -> tif_curstrip , tif -> tif_rawdata , tif -> tif_rawcc ) ) <vul-start> return ( 0 ) ; <vul-end> tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; } return ( 1 ) ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <vul-start> 0 ) ; }\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> tif_rawcc ) ) { TIFFErrorExt ( tif -> tif_clientdata, \"tif_flush_data1\" ) ; <vul-start> 0 ) ; }\n"
 },
 {
  "id": 13,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static unsigned long ioapic_read_indirect ( struct kvm_ioapic * ioapic , unsigned long addr , unsigned long length ) { unsigned long result = 0 ; switch ( ioapic -> ioregsel ) { case IOAPIC_REG_VERSION : result = ( ( ( ( IOAPIC_NUM_PINS - 1 ) & 0xff ) << 16 ) | ( IOAPIC_VERSION_ID & 0xff ) ) ; break ; case IOAPIC_REG_APIC_ID : case IOAPIC_REG_ARB_ID : result = ( ( ioapic -> id & 0xf ) << 24 ) ; break ; default : { u32 redir_index = ( ioapic -> ioregsel - 0x10 ) >> 1 ; u64 redir_content ; <vul-start> ASSERT ( redir_index < IOAPIC_NUM_PINS ) ; <vul-end> <vul-start> redir_content = ioapic -> redirtbl [ redir_index ] . bits ; <vul-end> result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ; break ; } } return result ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> u64 redir_content ; if <vul-end> ( redir_index < <vul-start> < IOAPIC_NUM_PINS ) <vul-end> redir_content = ioapic <vul-start> ] . bits ; else redir_content = ~ 0ULL\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> u64 redir_content ; if <vul-end> ( redir_index < <vul-start> IOAPIC_NUM_PINS ) ; return <vul-end> ioapic -> redirtbl <vul-start> ]. bits <vul-end> ; break ;\n"
 },
 {
  "id": 14,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void update_golden_frame_stats ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; if ( cm -> refresh_golden_frame ) { if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; if ( ( cpi -> pass != 2 ) && ( cpi -> frames_till_gf_update_due > 0 ) ) { cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; if ( ( cm -> frame_type != KEY_FRAME ) && ! cpi -> source_alt_ref_active ) { cpi -> gf_overspend_bits += ( cpi -> projected_frame_size - cpi -> inter_frame_target ) ; } cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } <vul-start> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <vul-end> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; cm -> refresh_golden_frame = 0 ; cpi -> frames_since_golden = 0 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; if ( cpi -> oxcf . fixed_q >= 0 && cpi -> oxcf . play_alternate && ! cpi -> common . refresh_alt_ref_frame ) { cpi -> source_alt_ref_pending = 1 ; cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; } if ( ! cpi -> source_alt_ref_pending ) cpi -> source_alt_ref_active = 0 ; if ( cpi -> frames_till_gf_update_due > 0 ) cpi -> frames_till_gf_update_due -- ; } else if ( ! cpi -> common . refresh_alt_ref_frame",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> frames_till_gf_update_due ; } memset <vul-end> ( cpi ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> frames_till_gf_update_due ; } memset <vul-end> ( cpi ->\n"
 },
 {
  "id": 15,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 SPL_METHOD ( SplFileObject , fread ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; long length = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & length ) == FAILURE ) { return ; } if ( length <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length parameter must be greater than 0\" ) ; RETURN_FALSE ; } <vul-start> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <vul-end> Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length parameter must be no more than %d\" , INT_MAX ) ; RETURN_FALSE ; }\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX ) ; RETURN_FALSE ; }\n"
 },
 {
  "id": 16,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void perf_event_mmap_output ( struct perf_event * event , struct perf_mmap_event * mmap_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int size = mmap_event -> event_id . header . size ; int ret ; perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , <vul-start> mmap_event -> event_id . header . size , 0 , 0 ) ; <vul-end> if ( ret ) goto out ; mmap_event -> event_id . pid = perf_event_pid ( event , current ) ; mmap_event -> event_id . tid = perf_event_tid ( event , current ) ; perf_output_put ( & handle , mmap_event -> event_id ) ; __output_copy ( & handle , mmap_event -> file_name , mmap_event -> file_size ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : mmap_event -> event_id . header . size = size ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> header . size <vul-end> , 0 )\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> size, 0 <vul-end> ) ; if\n"
 },
 {
  "id": 17,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static __be32 nfsd3_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd3_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ; <vul-start> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <vul-end> error = - EOPNOTSUPP ; goto out_errno ; <vul-start> } <vul-end> error = fh_want_write ( fh ) ; if ( error ) <vul-start> goto out_errno ; <vul-end> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; if ( error ) goto out_drop_write ; <vul-start> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <vul-end> ACL_TYPE_DEFAULT ) ; out_drop_write : fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; RETURN_STATUS ( nfserr ) ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) <vul-end> goto out_errno ; <vul-start> goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access <vul-end> ) ; if <vul-start> error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <vul-end> , argp -> <vul-start> argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ; <vul-end> fh_drop_write ( fh\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) <vul-end> goto out_errno ; <vul-start> goto out_errno ; <vul-end> error = inode <vul-start> ) goto out_errno <vul-end> ; error = <vul-start> goto out_drop_write ; fh_lock ( fh ) ; error = set_posix_acl ( inode, ACL_TYPE_ACCESS <vul-end>, argp -> <vul-start> argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <vul-end> ; out_errno :\n"
 },
 {
  "id": 18,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 <vul-start> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <vul-end> { jas_stream_t * in ; jas_iccprof_t * prof ; if ( ! ( in = jas_stream_memopen ( JAS_CAST ( char * , buf ) , len ) ) ) goto error ; if ( ! ( prof = jas_iccprof_load ( in ) ) ) goto error ; jas_stream_close ( in ) ; return prof ; error : if ( in ) jas_stream_close ( in ) ; return 0 ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * jas_iccprof_createfrombuf ( jas_uchar <vul-end> * buf ,\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * jas_iccprof_createfrombuf ( jas_uchar <vul-end> * buf,\n"
 },
 {
  "id": 19,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int vcc_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct atm_vcc * vcc ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( __SO_LEVEL_MATCH ( optname , level ) && len != __SO_SIZE ( optname ) ) return - EINVAL ; vcc = ATM_SD ( sock ) ; switch ( optname ) { case SO_ATMQOS : if ( ! test_bit ( ATM_VF_HASQOS , & vcc -> flags ) ) return - EINVAL ; return copy_to_user ( optval , & vcc -> qos , sizeof ( vcc -> qos ) ) ? - EFAULT : 0 ; case SO_SETCLP : return put_user ( vcc -> atm_options & ATM_ATMOPT_CLP ? 1 : 0 , ( unsigned long __user * ) optval ) ? - EFAULT : 0 ; case SO_ATMPVC : { struct sockaddr_atmpvc pvc ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ; <vul-start> pvc . sap_family = AF_ATMPVC ; <vul-end> pvc . sap_addr . itf = vcc -> dev -> number ; pvc . sap_addr . vpi = vcc -> vpi ; pvc . sap_addr . vci = vcc -> vci ; return copy_to_user ( optval , & pvc , sizeof ( pvc ) ) ? - EFAULT : 0 ; } default : if ( level == SOL_SOCKET ) return - EINVAL ; break ; } if ( ! vcc -> dev || ! vcc",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> - ENOTCONN ; memset ( & pvc , 0 , sizeof ( pvc ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> - ENOTCONN ; memset ( & pvc, 0, sizeof ( pvc ) ) ;\n"
 },
 {
  "id": 20,
  "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 static void lockd_down_net ( struct svc_serv * serv , struct net * net ) { struct lockd_net * ln = net_generic ( net , lockd_net_id ) ; if ( ln -> nlmsvc_users ) { if ( -- ln -> nlmsvc_users == 0 ) { nlm_shutdown_hosts_net ( net ) ; <vul-start> cancel_delayed_work_sync ( & ln -> grace_period_end ) ; <vul-end> locks_end_grace ( & ln -> lockd_manager ) ; svc_shutdown_net ( serv , net ) ; dprintk ( \"lockd_down_net: per-net data destroyed; net=%p\\\\n\" , net ) ; } } else { printk ( KERN_ERR \"lockd_down_net: no users! task=%p, net=%p\\\\n\" , nlmsvc_task , net ) ; BUG ( ) ; } }",
  "golden_answers": [
   "CWE-404 Fixed Code Lines are: <vul-start> net ) ; <vul-end> svc_shutdown_net ( serv\n"
  ],
  "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> net ) ; locks_end_grace ( & ln -> lockd_manager ) ; <vul-start> ln -> grace_period_end <vul-end> ) ; svc_shutdown_net\n"
 },
 {
  "id": 21,
  "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 static int cp2112_gpio_get_all ( struct gpio_chip * chip ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <vul-start> unsigned long flags ; <vul-end> int ret ; <vul-start> spin_lock_irqsave ( & dev -> lock , flags ) ; <vul-end> ret = hid_hw_raw_request ( hdev , CP2112_GPIO_GET , buf , CP2112_GPIO_GET_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_GET_LENGTH ) { hid_err ( hdev , \"error requesting GPIO values: %d\\\\n\" , ret ) ; ret = ret < 0 ? ret : - EIO ; goto exit ; } ret = buf [ 1 ] ; exit : <vul-start> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <vul-end> return ret ; }",
  "golden_answers": [
   "CWE-404 Fixed Code Lines are: <vul-start> -> in_out_buffer ; <vul-end> int ret ; <vul-start> int ret ; mutex_lock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; ret <vul-start> ; exit : mutex_unlock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; return\n"
  ],
  "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> -> in_out_buffer ; <vul-end> int ret ; <vul-start> int ret ; mutex_lock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; ret <vul-start> ; exit : mutex_unlock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; return\n"
 },
 {
  "id": 22,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <vul-start> kfree ( resp ) ; <vul-end> return res ; }",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> : kfree ( req ) ; kfree (\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; out : sas_free_smp_req ( req ) ;\n"
 },
 {
  "id": 23,
  "question": "CWE-285 Code Input Vulnerable Code Is: CWE-285 int xfs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error = 0 ; if ( ! acl ) goto set_acl ; error = - E2BIG ; if ( acl -> a_count > XFS_ACL_MAX_ENTRIES ( XFS_M ( inode -> i_sb ) ) ) return error ; if ( type == ACL_TYPE_ACCESS ) { <vul-start> umode_t mode = inode -> i_mode ; <vul-end> <vul-start> error = posix_acl_equiv_mode ( acl , & mode ) ; <vul-end> <vul-start> if ( error <= 0 ) { <vul-end> acl = NULL ; if ( error < 0 ) return error ; <vul-start> } <vul-end> error = xfs_set_mode ( inode , mode ) ; if ( error ) return error ; } set_acl : return __xfs_set_acl ( inode , type , acl ) ; }",
  "golden_answers": [
   "CWE-285 Fixed Code Lines are: <vul-start> { umode_t mode <vul-end> ; error = <vul-start> ; error = posix_acl_update_mode ( inode <vul-end> , & mode <vul-start> , & mode , & acl <vul-start> if ( error <vul-end> ) return error <vul-start> return error ; <vul-end> error = xfs_set_mode\n"
  ],
  "generated_answer": "CWE-285 Fixed Code Lines are: <vul-start> { umode_t mode ; error = posix_acl_update_mode ( inode <vul-end>, & mode <vul-start>, & mode, & acl ) ; if ( error <vul-end> ) return error <vul-start> return error ; <vul-end> error = xfs_set_mode\n"
 },
 {
  "id": 24,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int netbk_count_requests ( struct xenvif * vif , struct xen_netif_tx_request * first , struct xen_netif_tx_request * txp , int work_to_do ) { RING_IDX cons = vif -> tx . req_cons ; int frags = 0 ; if ( ! ( first -> flags & XEN_NETTXF_more_data ) ) return 0 ; do { if ( frags >= work_to_do ) { <vul-start> netdev_dbg ( vif -> dev , \"Need more frags\\\\n\" ) ; <vul-end> return - frags ; } if ( unlikely ( frags >= MAX_SKB_FRAGS ) ) { <vul-start> netdev_dbg ( vif -> dev , \"Too many frags\\\\n\" ) ; <vul-end> return - frags ; } memcpy ( txp , RING_GET_REQUEST ( & vif -> tx , cons + frags ) , sizeof ( * txp ) ) ; if ( txp -> size > first -> size ) { <vul-start> netdev_dbg ( vif -> dev , \"Frags galore\\\\n\" ) ; <vul-end> return - frags ; } first -> size -= txp -> size ; frags ++ ; if ( unlikely ( ( txp -> offset + txp -> size ) > PAGE_SIZE ) ) { <vul-start> netdev_dbg ( vif -> dev , \"txp->offset: %x, size: %u\\\\n\" , <vul-end> <vul-start> txp -> offset , txp -> size ) ; <vul-end> return - frags ; } } while ( ( txp ++ ) -> flags & XEN_NETTXF_more_data ) ; return frags ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> work_to_do ) { netdev_err <vul-end> ( vif -> <vul-start> dev , \"Need more frags\\\\n\" ) ; netbk_fatal_tx_err ( vif <vul-start> ) ) { netdev_err <vul-end> ( vif -> <vul-start> dev , \"Too many frags\\\\n\" ) ; netbk_fatal_tx_err ( vif <vul-start> size ) { netdev_err ( vif -> dev , \"Frag is bigger than frame.\\\\n\" ) ; netbk_fatal_tx_err ( vif <vul-end> ) ; return <vul-start> ) ) { netdev_err <vul-end> ( vif -> <vul-start> txp -> size ) ; netbk_fatal_tx_err ( vif\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> work_to_do ) { netdev_err <vul-end> ( vif -> <vul-start> dev, \"Need more frags\\\\n\" ) ; netbk_fatal_tx_err ( vif <vul-start> ) ) { netdev_err <vul-end> ( vif -> <vul-start> size ) { netdev_err <vul-end> ( vif -> <vul-start> ) ) { netdev_err <vul-end> ( vif -> <vul-start> txp -> size ) ; netbk_fatal_tx_err ( vif\n"
 },
 {
  "id": 25,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void aodv_extension ( netdissect_options * ndo , const struct aodv_ext * ep , u_int length ) { <vul-start> const struct aodv_hello * ah ; <vul-end> switch ( ep -> type ) { case AODV_EXT_HELLO : ah = ( const struct aodv_hello * ) ( const void * ) ep ; ND_TCHECK ( * ah ) ; if ( length < sizeof ( struct aodv_hello ) ) <vul-start> goto trunc ; <vul-end> ND_PRINT ( ( ndo , \"\\\\n\\\\text HELLO %ld ms\" , ( unsigned long ) EXTRACT_32BITS ( & ah -> interval ) ) ) ; break ; default : ND_PRINT ( ( ndo , \"\\\\n\\\\text %u %u\" , ep -> type , ep -> length ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , \" [|hello]\" ) ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> aodv_hello * ah ; ND_TCHECK ( * ep ) <vul-start> goto trunc ; if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , \"\\\\n\\\\text HELLO - bad length %u\" , ep -> length ) ) ; break ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> aodv_hello * ah ; if ( length > ( u_int ) ep -> length ) goto trunc <vul-start> ) goto trunc ; ND_TCHECK_32BITS ( & ah -> interval )\n"
 },
 {
  "id": 26,
  "question": "CWE-667 Code Input Vulnerable Code Is: CWE-667 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <vul-start> down_write ( & mm -> mmap_sem ) ; <vul-end> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret",
  "golden_answers": [
   "CWE-667 Fixed Code Lines are: <vul-start> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock\n"
  ],
  "generated_answer": "CWE-667 Fixed Code Lines are: <vul-start> mmap_sem ) ; if (! mmget_still_valid ( mm ) ) goto out_unlock ;\n"
 },
 {
  "id": 27,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void ifb_setup ( struct net_device * dev ) { dev -> destructor = free_netdev ; dev -> netdev_ops = & ifb_netdev_ops ; ether_setup ( dev ) ; dev -> tx_queue_len = TX_Q_LIMIT ; dev -> features |= IFB_FEATURES ; dev -> vlan_features |= IFB_FEATURES ; dev -> flags |= IFF_NOARP ; dev -> flags &= ~ IFF_MULTICAST ; <vul-start> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <vul-end> random_ether_addr ( dev -> dev_addr ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <vul-end> ; random_ether_addr (\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <vul-end> ; random_ether_addr (\n"
 },
 {
  "id": 28,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 void mono_gc_cleanup ( void ) { # ifdef DEBUG g_message ( \"%s: cleaning up finalizer\" , __func__ ) ; # endif if ( ! gc_disabled ) { ResetEvent ( shutdown_event ) ; finished = TRUE ; if ( mono_thread_internal_current ( ) != gc_thread ) { mono_gc_finalize_notify ( ) ; if ( WaitForSingleObjectEx ( shutdown_event , 2000 , FALSE ) == WAIT_TIMEOUT ) { int ret ; suspend_finalizers = TRUE ; mono_thread_internal_stop ( gc_thread ) ; ret = WaitForSingleObjectEx ( gc_thread -> handle , 100 , TRUE ) ; if ( ret == WAIT_TIMEOUT ) { g_warning ( \"Shutting down finalizer thread timed out.\" ) ; } else { Sleep ( 100 ) ; } } } gc_thread = NULL ; # ifdef HAVE_BOEHM_GC GC_finalizer_notifier = NULL ; # endif } DeleteCriticalSection ( & handle_section ) ; DeleteCriticalSection ( & allocator_section ) ; DeleteCriticalSection ( & finalizer_mutex ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> finalizer_mutex ) ; DeleteCriticalSection ( & reference_queue_mutex ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> finalizer_mutex ) ; DeleteCriticalSection ( & reference_queue_mutex ) ;\n"
 },
 {
  "id": 29,
  "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 static int install_process_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; <vul-start> return ret != - EEXIST ? ret : 0 ; <vul-end> } return commit_creds ( new ) ; }",
  "golden_answers": [
   "CWE-404 Fixed Code Lines are: <vul-start> ; return ret <vul-end> ; } return\n"
  ],
  "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> ) ; return ( <vul-start>!= - EEXIST )\n"
 },
 {
  "id": 30,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static zend_bool add_post_var ( zval * arr , post_var_data_t * var , zend_bool eof ) { <vul-start> char * ksep , * vsep , * val ; <vul-end> size_t klen , vlen ; size_t new_vlen ; if ( var -> ptr >= var -> end ) { return 0 ; } <vul-start> vsep = memchr ( var -> ptr , '&' , var -> end - var -> ptr ) ; <vul-end> if ( ! vsep ) { <vul-start> if ( ! eof ) { <vul-end> return 0 ; } else { vsep = var -> end ; } } ksep = memchr ( var -> ptr , '=' , vsep - var -> ptr ) ; if ( ksep ) { * ksep = '\\\\0' ; klen = ksep - var -> ptr ; vlen = vsep - ++ ksep ; } else { ksep = \"\" ; klen = vsep - var -> ptr ; vlen = 0 ; } php_url_decode ( var -> ptr , klen ) ; val = estrndup ( ksep , vlen ) ; if ( vlen ) { vlen = php_url_decode ( val , vlen ) ; } if ( sapi_module . input_filter ( PARSE_POST , var -> ptr , & val , vlen , & new_vlen ) ) { php_register_variable_safe ( var -> ptr , val , new_vlen , arr ) ; } efree ( val ) ; var -> ptr = vsep + ( vsep != var -> end ) ; <vul-start> return 1 ; <vul-end> }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> { char * start , * <vul-start> 0 ; } start = var -> ptr + var -> already_scanned ; <vul-start> = memchr ( start <vul-end> , '&' , <vul-start> -> end - start <vul-end> ) ; if <vul-start> eof ) { var -> already_scanned = var -> end - var -> ptr ; <vul-start> end ) ; var -> already_scanned = 0 ;\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> eof ) { const <vul-start> 0 ; } size_t var_end = var -> end - var -> ptr ; <vul-start> = memchr ( var_end <vul-end>, '&', <vul-start> -> end - var_end <vul-end> ) ; if <vul-start> eof ) { var -> end = var_end - var -> ptr ; <vul-start> end ) ; var -> end = var_end ;\n"
 },
 {
  "id": 31,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void set_cfg_option ( char * opt_string ) { char * sep , * sep2 , szSec [ 1024 ] , szKey [ 1024 ] , szVal [ 1024 ] ; sep = strchr ( opt_string , ':' ) ; if ( ! sep ) { fprintf ( stderr , \"Badly formatted option %s - expected Section:Name=Value\\\\n\" , opt_string ) ; return ; } { const size_t sepIdx = sep - opt_string ; <vul-start> strncpy ( szSec , opt_string , sepIdx ) ; <vul-end> szSec [ sepIdx ] = 0 ; } sep ++ ; sep2 = strchr ( sep , '=' ) ; if ( ! sep2 ) { fprintf ( stderr , \"Badly formatted option %s - expected Section:Name=Value\\\\n\" , opt_string ) ; return ; } { const size_t sepIdx = sep2 - sep ; <vul-start> strncpy ( szKey , sep , sepIdx ) ; <vul-end> szKey [ sepIdx ] = 0 ; <vul-start> strcpy ( szVal , sep2 + 1 ) ; <vul-end> } if ( ! stricmp ( szKey , \"*\" ) ) { if ( stricmp ( szVal , \"null\" ) ) { fprintf ( stderr , \"Badly formatted option %s - expected Section:*=null\\\\n\" , opt_string ) ; return ; } gf_cfg_del_section ( cfg_file , szSec ) ; return ; } if ( ! stricmp ( szVal , \"null\" ) ) { szVal [ 0 ] = 0 ; } gf_cfg_set_key ( cfg_file , szSec , szKey , szVal [ 0 ] ? szVal : NULL ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> - opt_string ; if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , \"Badly formatted option %s - Section name is too long\\\\n\" , opt_string ) ; return ; } <vul-start> - sep ; if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , \"Badly formatted option %s - key name is too long\\\\n\" , opt_string ) ; return ; } <vul-start> = 0 ; if ( strlen ( <vul-end> sep2 + 1 <vul-start> + 1 ) >= sizeof ( szVal ) ) { fprintf ( stderr , \"Badly formatted option %s - value is too long\\\\n\" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> - opt_string ; memcpy <vul-end> ( szSec, <vul-start> - sep ; memcpy <vul-end> ( szKey, <vul-start> = 0 ; memcpy <vul-end> ( szVal,\n"
 },
 {
  "id": 32,
  "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 int __sys_recvmmsg ( int fd , struct mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct timespec * timeout ) { int fput_needed , err , datagrams ; struct socket * sock ; struct mmsghdr __user * entry ; struct compat_mmsghdr __user * compat_entry ; struct msghdr msg_sys ; struct timespec end_time ; if ( timeout && poll_select_set_timeout ( & end_time , timeout -> tv_sec , timeout -> tv_nsec ) ) return - EINVAL ; datagrams = 0 ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) return err ; err = sock_error ( sock -> sk ) ; if ( err ) goto out_put ; entry = mmsg ; compat_entry = ( struct compat_mmsghdr __user * ) mmsg ; while ( datagrams < vlen ) { if ( MSG_CMSG_COMPAT & flags ) { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) compat_entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = __put_user ( err , & compat_entry -> msg_len ) ; ++ compat_entry ; } else { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = put_user ( err , & entry -> msg_len ) ; ++ entry ; } if ( err ) break ; ++ datagrams ; if ( flags & MSG_WAITFORONE ) flags",
  "golden_answers": [
   "CWE-19 Fixed Code Lines are: <vul-start> ) ; } if ( err == 0 ) goto out_put ; if ( datagrams <vul-end> == 0 ) <vul-start> == 0 ) { datagrams = err ; goto out_put ; } <vul-end> if ( err <vul-start> err ; } out_put : fput_light ( sock -> file , fput_needed ) ; <vul-start> datagrams ; } <vul-end>      \n"
  ],
  "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> ) ; } if ( err == 0 ) return datagrams ; <vul-start> == 0 ) { <vul-end> if ( datagrams <vul-start> err ; } } out_put : fput_light ( sock -> file, fput_needed ) ; <vul-start> datagrams ; } <vul-end>      \n"
 },
 {
  "id": 33,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t udpReceiveDatagram ( Socket * socket , SocketMsg * message , uint_t flags ) { error_t error ; SocketQueueItem * queueItem ; if ( ( flags & SOCKET_FLAG_DONT_WAIT ) == 0 ) { if ( socket -> receiveQueue == NULL ) { socket -> eventMask = SOCKET_EVENT_RX_READY ; osResetEvent ( & socket -> event ) ; osReleaseMutex ( & netMutex ) ; osWaitForEvent ( & socket -> event , socket -> timeout ) ; osAcquireMutex ( & netMutex ) ; } } if ( socket -> receiveQueue != NULL ) { queueItem = socket -> receiveQueue ; message -> length = netBufferRead ( message -> data , queueItem -> buffer , queueItem -> offset , message -> size ) ; <vul-start> message -> srcIpAddr = queueItem -> srcIpAddr ; <vul-end> message -> srcPort = queueItem -> srcPort ; message -> destIpAddr = queueItem -> destIpAddr ; message -> ttl = queueItem -> ancillary . ttl ; # if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ; message -> destMacAddr = queueItem -> ancillary . destMacAddr ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) message -> switchPort = queueItem -> ancillary . port ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) message -> timestamp = queueItem -> ancillary . timestamp ; # endif if ( ( flags & SOCKET_FLAG_PEEK ) == 0 ) { socket -> receiveQueue = queueItem -> next ; netBufferFree ( queueItem -> buffer ) ; } udpUpdateEvents ( socket ) ; error = NO_ERROR ; } else { message -> length",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; message -> interface = queueItem -> interface ; message ->\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; message -> interface = queueItem -> interface ; message ->\n"
 },
 {
  "id": 34,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 <vul-start> int hns_nic_net_xmit_hw ( struct net_device * ndev , <vul-end> struct sk_buff * skb , struct hns_nic_ring_data * ring_data ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; struct hnae_ring * ring = ring_data -> ring ; struct device * dev = ring_to_dev ( ring ) ; struct netdev_queue * dev_queue ; struct skb_frag_struct * frag ; int buf_num ; int seg_num ; dma_addr_t dma ; int size , next_to_use ; int i ; switch ( priv -> ops . maybe_stop_tx ( & skb , & buf_num , ring ) ) { case - EBUSY : ring -> stats . tx_busy ++ ; goto out_net_tx_busy ; case - ENOMEM : ring -> stats . sw_err_cnt ++ ; netdev_err ( ndev , \"no memory to xmit!\\\\n\" ) ; goto out_err_tx_ok ; default : break ; } seg_num = skb_shinfo ( skb ) -> nr_frags + 1 ; next_to_use = ring -> next_to_use ; size = skb_headlen ( skb ) ; dma = dma_map_single ( dev , skb -> data , size , DMA_TO_DEVICE ) ; if ( dma_mapping_error ( dev , dma ) ) { netdev_err ( ndev , \"TX head DMA map failed\\\\n\" ) ; ring -> stats . sw_err_cnt ++ ; goto out_err_tx_ok ; } priv -> ops . fill_desc ( ring , skb , size , dma , seg_num == 1 ? 1 : 0 , buf_num , DESC_TYPE_SKB , ndev -> mtu ) ; for ( i = 1 ; i < seg_num ; i ++ ) { frag = & skb_shinfo ( skb ) -> frags [ i",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start>       netdev_tx_t <vul-end> hns_nic_net_xmit_hw ( struct <vul-start> len ) ; netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>       static <vul-start> len ) ; if (! priv -> ae_handle -> tx_skb_fatal_tx ) netdev_warn ( ndev, \"Not in tx state\\\\n\" ) ;\n"
 },
 {
  "id": 35,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ; <vul-start> assert ( ( cc % stride ) == 0 ) ; <vul-end> if ( cc > stride ) { cc -= stride ; if ( stride == 3 ) { unsigned int r1 , g1 , b1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ] ; do { r1 = cp [ 3 ] ; cp [ 3 ] = ( unsigned char ) ( ( r1 - r2 ) & 0xff ) ; r2 = r1 ; g1 = cp [ 4 ] ; cp [ 4 ] = ( unsigned char ) ( ( g1 - g2 ) & 0xff ) ; g2 = g1 ; b1 = cp [ 5 ] ; cp [ 5 ] = ( unsigned char ) ( ( b1 - b2 ) & 0xff ) ; b2 = b1 ; cp += 3 ; } while ( ( cc -= 3 ) > 0 ) ; } else if ( stride == 4 ) { unsigned int r1 , g1 , b1 , a1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ]",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> horDiff8 ( TIFF <vul-start> ) cp0 ; if <vul-end> ( ( cc <vul-start> % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"horDiff8\" , \"%s\" , \"(cc%stride)!=0\" ) ; return 0 ; } <vul-end> if ( cc <vul-start> ; } } return 1 ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> horDiff8 ( TIFF <vul-start> ) cp0 ; if <vul-end> ( ( cc <vul-start> % stride )!= 0 ) { TIFFErrorExt ( tif -> tif_clientdata, \"horDiff8\", \"%s\", \"(cc%stride)!=0\" ) ; return 0 ; } <vul-end> if ( cc <vul-start> ; } } return 1 ;\n"
 },
 {
  "id": 36,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_pick_intra_mode ( MACROBLOCK * x , int * rate_ ) { int error4x4 , error16x16 = INT_MAX ; int rate , best_rate = 0 , distortion , best_sse ; MB_PREDICTION_MODE mode , best_mode = DC_PRED ; int this_rd ; unsigned int sse ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; xd -> mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; pick_intra_mbuv_mode ( x ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { xd -> mode_info_context -> mbmi . mode = mode ; vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ; <vul-start> distortion = vp8_variance16x16 <vul-end> ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ; rate = x -> mbmode_cost [ xd -> frame_type ] [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( error16x16 > this_rd ) { error16x16 = this_rd ; best_mode = mode ; best_sse = sse ; best_rate = rate ; } } xd -> mode_info_context -> mbmi . mode = best_mode ; error4x4 = pick_intra4x4mby_modes ( x , & rate , & best_sse ) ; if ( error4x4 < error16x16 ) { xd -> mode_info_context -> mbmi . mode = B_PRED ; best_rate",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; distortion = vpx_variance16x16 <vul-end> ( * (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; distortion = vp8_variance16x16_mode <vul-end> ( * (\n"
 },
 {
  "id": 37,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void m_stop ( struct seq_file * m , void * v ) { struct proc_maps_private * priv = m -> private ; struct vm_area_struct * vma = v ; <vul-start> vma_stop ( priv , vma ) ; <vul-end> if ( priv -> task ) put_task_struct ( priv -> task ) ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> = v ; if ( ! IS_ERR ( vma ) )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = v ; if ( priv -> in_remap ) return ;\n"
 },
 {
  "id": 38,
  "question": "CWE-552 Code Input Vulnerable Code Is: CWE-552 static ssize_t _hostsock_readv ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <vul-start> if ( ! sock || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <vul-end> OE_RAISE_ERRNO ( OE_EINVAL ) ; <vul-start> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <vul-end> <vul-start> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <vul-end> if ( oe_syscall_recvv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <vul-start> if ( ret > 0 ) <vul-end> { if ( oe_iov_sync ( iov , iovcnt , buf , buf_size ) != 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) ; } done : if ( buf ) oe_free ( buf ) ; return ret ; }",
  "golden_answers": [
   "CWE-552 Fixed Code Lines are: <vul-start> = 0 ; size_t data_size = 0 ; <vul-start> , & buf_size , & data_size <vul-start> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <vul-start> ( ret > ( ssize_t ) ( data_size ) ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret >\n"
  ],
  "generated_answer": "CWE-552 Fixed Code Lines are: <vul-start> = 0 ; size_t data_size = 0 ; <vul-start>, & buf_size, & data_size <vul-start> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <vul-start> } if ( ret > ( ssize_t ) data_size <vul-end> ) { if\n"
 },
 {
  "id": 39,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 void send_ldap_result_ext ( Slapi_PBlock * pb , int err , char * matched , char * text , int nentries , struct berval * * urls , BerElement * ber ) { Slapi_Operation * operation ; passwdPolicy * pwpolicy = NULL ; Connection * conn = NULL ; Slapi_DN * sdn = NULL ; const char * dn = NULL ; ber_tag_t tag ; int flush_ber_element = 1 ; ber_tag_t bind_method = 0 ; int internal_op ; int i , rc , logit = 0 ; char * pbtext ; slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & bind_method ) ; slapi_pblock_get ( pb , SLAPI_OPERATION , & operation ) ; slapi_pblock_get ( pb , SLAPI_CONNECTION , & conn ) ; if ( text ) { pbtext = text ; } else { <vul-start> slapi_pblock_get ( pb , SLAPI_PB_RESULT_TEXT , & pbtext ) ; <vul-end> } if ( operation == NULL ) { slapi_log_err ( SLAPI_LOG_ERR , \"send_ldap_result_ext\" , \"No operation found: slapi_search_internal_set_pb was incomplete (invalid \\'base\\' ?)\\\\n\" ) ; return ; } if ( operation -> o_status == SLAPI_OP_STATUS_RESULT_SENT ) { return ; } if ( ber != NULL ) { flush_ber_element = 0 ; } if ( err != LDAP_SUCCESS ) { if ( err == LDAP_INVALID_CREDENTIALS || err == LDAP_INAPPROPRIATE_AUTH || err == LDAP_AUTH_METHOD_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_REQUIRED || err == LDAP_CONFIDENTIALITY_REQUIRED || err == LDAP_INSUFFICIENT_ACCESS || err == LDAP_AUTH_UNKNOWN ) { slapi_counter_increment ( g_get_global_snmp_vars ( ) -> ops_tbl . dsSecurityErrors ) ; } else if ( err != LDAP_REFERRAL && err != LDAP_OPT_REFERRALS && err != LDAP_PARTIAL_RESULTS )",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ( pb , SLAPI_RESULT_TEXT <vul-end> , & pbtext\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ( pb, SLAPI_RESULT_TEXT <vul-end>, & pbtext\n"
 },
 {
  "id": 40,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t enc624j600Init ( NetInterface * interface ) { uint16_t temp ; Enc624j600Context * context ; TRACE_INFO ( \"Initializing ENC624J600 Ethernet controller...\\\\r\\\\n\" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; context = ( Enc624j600Context * ) interface -> nicContext ; context -> nextPacket = ENC624J600_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } enc624j600SoftReset ( interface ) ; <vul-start> enc624j600WriteReg ( interface , ENC624J600_REG_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ; <vul-end> if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) { <vul-start> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR1 ) ; <vul-end> interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ; <vul-start> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR2 ) ; <vul-end> interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ; <vul-start> temp = enc624j600ReadReg ( interface , ENC624J600_REG_MAADR3 ) ; <vul-end> interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ; macAddrToEui64 ( & interface -> macAddr , & interface -> eui64 ) ; } else { temp = htole16 ( interface -> macAddr . w [ 0 ] ) ; <vul-start> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR1 , temp ) ; <vul-end> temp = htole16 ( interface -> macAddr . w [ 1 ] ) ; <vul-start> enc624j600WriteReg ( interface , ENC624J600_REG_MAADR2 , temp ) ; <vul-end> temp = htole16 ( interface -> macAddr . w [ 2 ] ) ; <vul-start>",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <vul-end> ) ; if <vul-start> ( interface , ENC624J600_MAADR1 <vul-end> ) ; interface <vul-start> ( interface , ENC624J600_MAADR2 <vul-end> ) ; interface <vul-start> ( interface , ENC624J600_MAADR3 <vul-end> ) ; interface <vul-start> ( interface , ENC624J600_MAADR1 <vul-end> , temp ) <vul-start> ( interface , ENC624J600_MAADR2 <vul-end> , temp ) <vul-start> ( interface , ENC624J600_MAADR3 <vul-end> , temp ) <vul-start> ( interface , ENC624J600_ERXST <vul-end> , ENC624J600_RX_BUFFER_START ) <vul-start> ( interface , ENC624J600_ERXTAIL <vul-end> , ENC624J600_RX_BUFFER_STOP ) <vul-start> ( interface , ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_EHT1 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_EHT2 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_EHT3 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_EHT4 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_MAMXFL <vul-end> , ETH_MAX_FRAME_SIZE ) <vul-start> ( interface , ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_EIR <vul-end> , 0x0000 ) <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE <vul-end> ) ; enc624j600SetBit <vul-start> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_RXEN <vul-end> ) ; enc624j600DumpReg\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( interface, ENC624J600_ECON2, ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH ) ; enc624j600WriteReg ( interface, ENC624J600_ECON2, ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <vul-end> ) ; if <vul-start> ( interface, ENC624J600_ERXST, ENC624J600_RX_BUFFER_START <vul-end> ) ; enc624j600WriteReg <vul-start> ( interface, ENC624J600_ERXTAIL, ENC624J600_RX_BUFFER_STOP <vul-end> ) ; enc624j600WriteReg <vul-start> ( interface, ENC624J600_ERXFCON, ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ELOC_RUNTEN | ENC624J600_ELOC_UCEN | ENC624J600_ELOC_BCEN <vul-end> ) ; enc624j600WriteReg <vul-start> ( interface, ENC624J600_EHT1 <vul-end>, 0x0000 ) <vul-start> ( interface, ENC624J600_EHT2 <vul-end>, 0x0000 ) <vul-start> ( interface, ENC624J600_EHT3 <vul-end>, 0x0000 ) <vul-start> ( interface, ENC624J600_EHT4 <vul-end>, 0x0000 ) <vul-start> ( interface, ENC624J600_MAMXFL, ETH_MAX_FRAME_SIZE <vul-end> ) ; enc624j600WritePhyReg <vul-start> ( interface, ENC624J600_PHANA, ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10FD | ENC624J600_AD11 | ENC624J600_AD12 | EN"
 },
 {
  "id": 41,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; char * fmtname ; int debug ; size_t max_mem ; <vul-start> if ( jas_init ( ) ) { <vul-end> abort ( ) ; } cmdname = argv [ 0 ] ; <vul-start> infile = 0 ; <vul-end> verbose = 0 ; debug = 0 ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) max_mem = JAS_DEFAULT_MAX_MEM_USAGE ; # endif while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( \"%s\\\\n\" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case OPT_INFILE : infile = jas_optarg ; break ; <vul-start> case OPT_MAXMEM : <vul-end> max_mem = strtoull ( jas_optarg , 0 , 10 ) ; break ; case OPT_HELP : default : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) jas_set_max_mem_usage ( max_mem ) ; # endif if ( infile ) { if ( ! ( instream = jas_stream_fopen ( infile , \"rb\" ) ) ) { fprintf ( stderr , \"cannot open input image file %s\\\\n\" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> size_t max_mem ; size_t max_samples ; char optstr [ 32 ] ; <vul-start> 0 ] ; max_samples = 64 * JAS_MEBI ; <vul-start> break ; case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <vul-start> ) ; } snprintf ( optstr , sizeof ( optstr ) , \"max_samples=%-zu\" , max_samples ) ; <vul-start> , fmtid , optstr <vul-end> ) ) ) <vul-start> ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( \"format name lookup failed\\\\n\" ) ; return EXIT_FAILURE ; } if ( ! ( <vul-start> 0 ; } printf ( \"%s %d %d %d %d %ld\\\\n\" , fmtname <vul-end> , numcmpts , <vul-start> , depth , JAS_CAST ( long , <vul-end> jas_image_rawsize ( image <vul-start> jas_image_rawsize ( image )\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> size_t max_mem ; size_t num_samples ; <vul-start> 0 ] ; num_samples = 0 ; <vul-start> break ; case OPT_MAX_SAMPLE_SIZE : max_mem = JAS_DEFAULT_MAX_SAMPLE_SIZE ; break ; case <vul-start>, 0 ) ; num_samples = JAS_MIN ( num_samples, 0 ) ; if ( num_samples == 0 ) { jas_stream_close ( instream ) ; fprintf ( stderr, \"cannot load image\\\\n\" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ; if ( max_mem < 0 ) { jas_deprecated ( \"maximum number of components exceeded (%zu)\\\\n\", max_mem ) ; } <vul-end> if ( numcmpts <vul-start> ( image ) ; num_samples = 0 <vul-start> fmtid ) ) ; if (! fmtname ) { jas_deprecated ( \"format not specified (%s)\\\\n\", jas_optarg ) ; } printf ( \"%s %d %d %d %d %ld\\\\n\", fmtname, numcmpts, width, height, depth, ( long ) jas_image_rawsize ( image ) ) ; jas_image_destroy ( image ) ; jas_image_clearfmts ( ) ; return EXIT_SUCCESS ; } if ( infile ) { if (! ( image = jas_image_decode ( instream, fmtid, 0 ) ) ) { jas_stream_close ( instream ) ; fprintf ( stderr, \"cannot load image\\\\n\" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ; if ( debug ) { jas_setdbglevel ( debug ) ; } if ( num_samples > 0 ) { if ( <vul-start> ) ) { jas_eprintf ( \"warning: image has no components\\\\n\" ) ; } <vul-start> ) ) ; <vul-end> jas_image_destroy ( image <vul-start> ) ) ; <vul-end> jas_image_clearfmts ( ) ;\n"
 },
 {
  "id": 42,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void update_state ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <vul-end> int mi_row , int mi_col , BLOCK_SIZE bsize , int output_enabled ) { int i , x_idx , y ; VP9_COMMON * const cm = & cpi -> common ; <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd -> plane ; MODE_INFO * mi = & ctx -> mic ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; MODE_INFO * mi_addr = xd -> mi [ 0 ] ; <vul-start> const struct segmentation * const seg = & cm -> seg ; <vul-end> const int mis = cm -> mi_stride ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; int max_plane ; assert ( mi -> mbmi . sb_type == bsize ) ; * mi_addr = * mi ; <vul-start> if ( seg -> enabled && output_enabled ) { <vul-end> if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; mi_addr -> mbmi . segment_id = <vul-start> vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <vul-end> } <vul-start> else if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) { <vul-end> vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cpi , ThreadData * td , <vul-start> -> common ; RD_COUNTS * const rdc = & td -> rd_counts ; <vul-start> x = & td <vul-end> -> mb ; <vul-start> cm -> seg ; const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h <vul-start> * mi ; * x -> mbmi_ext = ctx -> mbmi_ext ; <vul-start> seg -> enabled <vul-end> ) { if <vul-start> . segment_id = get_segment_id <vul-end> ( cm , <vul-start> ) ; } <vul-end> if ( cpi <vul-start> , bsize , ctx -> rate , ctx -> dist , x -> skip <vul-end> ) ; } <vul-start> ; if ( <vul-end> is_inter_block ( mbmi <vul-start> -> skip ; memcpy <vul-end> ( x -> <vul-start> , sizeof ( ctx -> zcoeff_blk [ 0 ] <vul-end> ) * ctx <vul-start> ) return ; <vul-end> # if CONFIG_INTERNAL_STATS <vul-start> { vp9_update_mv_count ( td <vul-end> ) ; if <vul-start> ) ; ++ td -> counts -> <vul-end> switchable_interp [ ctx <vul-start> ; } } rdc -> comp_pred_diff <vul-end> [ SINGLE_REFERENCE ] <vul-start> -> single_pred_diff ; rdc -> comp_pred_diff <vul-end> [ COMPOUND_REFERENCE ] <vul-start> -> comp_pred_diff ; rdc -> comp_pred_diff <vul-end> [ REFERENCE_MODE_SELECT ] <vul-start> ++ i ) rdc -> filter_diff <vul-end> [ i ] <vul-start> ] ; } for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, ThreadData * td, <vul-start> x = & td <vul-end> -> mb ; <vul-start> struct segmentation * const <vul-start> * mi ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_update_segment_id ( cm, td, map, bsize, mi_row, mi_col, 1, 1 ) ; } else if ( xd -> oxcf. aq_mode == COMPLEXITY_AQ ) { if ( seg -> enabled && output_enabled ) { vp9_highbd_update_segment_id ( cm, td, map, bsize, mi_row, mi_col, 1, 1 ) ; } else if ( xd -> oxcf. aq_mode == CYCLIC_REFRESH_AQ ) { if ( seg -> enabled && xd -> bd > 8 ) { vp9_highbd_update_segment_id ( cm, td, map, bsize, mi_row, mi_col, 1, 1 ) ; } else { vp9_highbd_update_segment_id ( cm, td, map, bsize, mi_row, mi_col, 0, 1 ) ; } } else { vp9_update_segment_id ( cm, td, map, bsize, mi_row, mi_col ) ; } } else { if ( seg -> enabled && xd -> bd < 8 ) { vp9_highbd_update_segment_id ( cm, td, map, bsize, mi_row, mi_col, 1, 1 ) ; } else { <vul-start> -> skip ; memcpy <vul-end> ( x -> <vul-start> -> single_pred_diff ; memcpy <vul-end> ( x -> <vul-start> -> comp_pred_diff ; memcpy <vul-end> ( x -> <vul-start> -> hybrid_pred_diff ; memcpy <vul-end> ( x -> <vul-start> ] ; } } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_update_segment_id ( cm, td, map, bsize, 0, 1 ) ; } else { <vul-start> -> best"
 },
 {
  "id": 43,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 void gdImageWBMPCtx ( gdImagePtr image , int fg , gdIOCtx * out ) { <vul-start> int x , y , pos ; <vul-end> Wbmp * wbmp ; if ( ( wbmp = createwbmp ( gdImageSX ( image ) , gdImageSY ( image ) , WBMP_WHITE ) ) == NULL ) { gd_error ( \"Could not create WBMP\" ) ; return ; } pos = 0 ; for ( y = 0 ; y < gdImageSY ( image ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( image ) ; x ++ ) { <vul-start> if ( gdImageGetPixel ( image , x , y ) == fg ) { <vul-end> wbmp -> bitmap [ pos ] = WBMP_BLACK ; } pos ++ ; } } if ( writewbmp ( wbmp , & gd_putout , out ) ) { gd_error ( \"Could not save WBMP\" ) ; } freewbmp ( wbmp ) ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> out ) { _gdImageWBMPCtx <vul-end> ( image , <vul-start> ( image , fg , out <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> out ) { _gdImageWBMPCtx <vul-end> ( image, <vul-start> image, fg, out <vul-end> ) ; }\n"
 },
 {
  "id": 44,
  "question": "CWE-601 Code Input Vulnerable Code Is: CWE-601 static int oidc_handle_logout ( request_rec * r , oidc_cfg * c , oidc_session_t * session ) { oidc_provider_t * provider = NULL ; char * url = NULL ; <vul-start> oidc_util_get_request_parameter ( r , OIDC_REDIRECT_URI_REQUEST_LOGOUT , & url ) ; <vul-end> oidc_debug ( r , \"enter (url=%s)\" , url ) ; if ( oidc_is_front_channel_logout ( url ) ) { return oidc_handle_logout_request ( r , c , session , url ) ; } else if ( oidc_is_back_channel_logout ( url ) ) { return oidc_handle_logout_backchannel ( r , c ) ; } if ( ( url == NULL ) || ( apr_strnatcmp ( url , \"\" ) == 0 ) ) { url = c -> default_slo_url ; } else { <vul-start> const char * error_description = NULL ; <vul-end> apr_uri_t uri ; if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) { const char * error_description = apr_psprintf ( r -> pool , \"Logout URL malformed: %s\" , url ) ; oidc_error ( r , \"%s\" , error_description ) ; return oidc_util_html_send_error ( r , c -> error_template , <vul-start> \"Malformed URL\" , error_description , <vul-end> HTTP_INTERNAL_SERVER_ERROR ) ; } const char * c_host = oidc_get_current_url_host ( r ) ; if ( ( uri . hostname != NULL ) && ( ( strstr ( c_host , uri . hostname ) == NULL ) || ( strstr ( uri . hostname , c_host ) == NULL ) ) ) { error_description = apr_psprintf ( r -> pool , \"logout value \\\\\"%s\\\\\" does not match the hostname of the current request",
  "golden_answers": [
   "CWE-601 Fixed Code Lines are: <vul-start> = NULL ; char * error_str = NULL ; char * error_description = NULL ; <vul-start> } else { if ( oidc_validate_post_logout_url ( r , url , & error_str , & error_description ) == FALSE ) { <vul-end> return oidc_util_html_send_error ( <vul-start> -> error_template , error_str , error_description , HTTP_BAD_REQUEST <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-601 Fixed Code Lines are: <vul-start> = NULL ; apr_uri_t uri ; <vul-start> } else { <vul-end> if ( apr_uri_parse <vul-start>, \"Malformed URL\", url <vul-end>, HTTP_INTERNAL_SERVER_ERROR )\n"
 },
 {
  "id": 45,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int tiffcp ( TIFF * in , TIFF * out ) { <vul-start> uint16 bitspersample , samplesperpixel = 1 ; <vul-end> uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ; copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , \"tiffcp: %s: Can\\'t copy/convert subsampled image.\\\\n\" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel ==",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { uint16 bitspersample = 1\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> out ) { uint32 bitspersample, samplesperpixel = 1 ; uint32 <vul-end> input_compression, input_photometric\n"
 },
 {
  "id": 46,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int pci_emul_dinit ( struct vmctx * ctx , struct pci_vdev * dev , char * opts ) { <vul-start> int error ; <vul-end> struct pci_emul_dummy * dummy ; dummy = calloc ( 1 , sizeof ( struct pci_emul_dummy ) ) ; dev -> arg = dummy ; pci_set_cfgdata16 ( dev , PCIR_DEVICE , 0x0001 ) ; pci_set_cfgdata16 ( dev , PCIR_VENDOR , 0x10DD ) ; pci_set_cfgdata8 ( dev , PCIR_CLASS , 0x02 ) ; <vul-start> error = pci_emul_add_msicap ( dev , PCI_EMUL_MSI_MSGS ) ; <vul-end> assert ( error == 0 ) ; <vul-start> error = pci_emul_alloc_bar ( dev , 0 , PCIBAR_IO , DIOSZ ) ; <vul-end> assert ( error == 0 ) ; <vul-start> error = pci_emul_alloc_bar ( dev , 1 , PCIBAR_MEM32 , DMEMSZ ) ; <vul-end> assert ( error == 0 ) ; error = pci_emul_alloc_bar ( dev , 2 , PCIBAR_MEM32 , DMEMSZ ) ; <vul-start> assert ( error == 0 ) ; <vul-end> return 0 ; }",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> opts ) { <vul-end> struct pci_emul_dummy * <vul-start> 0x02 ) ; return <vul-end> pci_emul_add_msicap ( dev <vul-start> , PCI_EMUL_MSI_MSGS ) || <vul-end> pci_emul_alloc_bar ( dev <vul-start> , DIOSZ ) || <vul-end> pci_emul_alloc_bar ( dev <vul-start> , DMEMSZ ) || <vul-end> pci_emul_alloc_bar ( dev <vul-start> DMEMSZ ) ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> opts ) { <vul-end> struct pci_emul_dummy * <vul-start> 0x02 ) ; return <vul-end> pci_emul_add_msicap ( dev <vul-start> PCI_EMUL_MSI_MSGS ) ; <vul-end> } <vul-start> 0 ) ; return <vul-end> pci_emul_alloc_bar ( dev <vul-start> PCIBAR_IO, DIOSZ <vul-end> ) ; assert <vul-start> 0 ) ; return <vul-end> pci_emul_alloc_bar ( dev <vul-start> DMEMSZ ) ; <vul-end> }    \n"
 },
 {
  "id": 47,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { <vul-start> ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; <vul-end> return - 1 ; } EVP_MD_CTX_init ( & ctx ) ; if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( &",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY <vul-end> , ASN1_R_INVALID_BIT_STRING_BITS_LEFT )\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; } if (! signature -> length ) { ASN1err (\n"
 },
 {
  "id": 48,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) <vul-start> { <vul-end> if ( ( ctx -> clockid == CLOCK_REALTIME || ctx -> clockid == CLOCK_REALTIME_ALARM ) && ( flags & TFD_TIMER_ABSTIME ) && ( flags & TFD_TIMER_CANCEL_ON_SET ) ) { if ( ! ctx -> might_cancel ) { ctx -> might_cancel = true ; spin_lock ( & cancel_lock ) ; list_add_rcu ( & ctx -> clist , & cancel_list ) ; spin_unlock ( & cancel_lock ) ; } <vul-start> } else if ( ctx -> might_cancel ) { <vul-end> timerfd_remove_cancel ( ctx ) ; } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> flags ) { spin_lock ( & ctx -> cancel_lock ) ; <vul-start> } } else { __timerfd_remove_cancel <vul-end> ( ctx ) <vul-start> ) ; } spin_unlock ( & ctx -> cancel_lock ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> flags ) { if (! ctx -> might_cancel ) return ; <vul-start> ) ; } <vul-end> if ( ctx <vul-start> -> might_cancel ) <vul-end> timerfd_remove_cancel ( ctx <vul-start> ) ; } <vul-end>      \n"
 },
 {
  "id": 49,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void print_attr_string ( netdissect_options * ndo , register const u_char * data , u_int length , u_short attr_code ) { register u_int i ; ND_TCHECK2 ( data [ 0 ] , length ) ; switch ( attr_code ) { case TUNNEL_PASS : if ( length < 3 ) <vul-start> { <vul-end> ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return ; } if ( * data && ( * data <= 0x1F ) ) ND_PRINT ( ( ndo , \"Tag[%u] \" , * data ) ) ; else ND_PRINT ( ( ndo , \"Tag[Unused] \" ) ) ; data ++ ; length -- ; ND_PRINT ( ( ndo , \"Salt %u \" , EXTRACT_16BITS ( data ) ) ) ; data += 2 ; length -= 2 ; break ; case TUNNEL_CLIENT_END : case TUNNEL_SERVER_END : case TUNNEL_PRIV_GROUP : case TUNNEL_ASSIGN_ID : case TUNNEL_CLIENT_AUTH : case TUNNEL_SERVER_AUTH : if ( * data <= 0x1F ) { if ( length < 1 ) <vul-start> { <vul-end> ND_PRINT ( ( ndo , \"%s\" , tstr ) ) ; return ; } if ( * data ) ND_PRINT ( ( ndo , \"Tag[%u] \" , * data ) ) ; else ND_PRINT ( ( ndo , \"Tag[Unused] \" ) ) ; data ++ ; length -- ; } break ; <vul-start> case EGRESS_VLAN_NAME : <vul-end> ND_PRINT ( ( ndo , \"%s (0x%02x) \" , tok2str ( rfc4675_tagged , \"Unknown tag\" , * data ) , * data ) ) ; data ++ ; length -- ; break ; } <vul-start> for ( i =",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> < 3 ) goto trunc ; <vul-end> if ( * <vul-start> < 1 ) goto trunc ; if ( * data ) ND_PRINT ( ( ndo , \"Tag[%u] \" , * data ) ) ; else ND_PRINT ( ( ndo , \"Tag[Unused] \" ) ) ; data ++ ; length -- ; } <vul-end> break ; case <vul-start> case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ; <vul-start> = 0 ; i < length && * data <vul-end> ; i ++\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> < 3 ) goto trunc ; <vul-end> if ( * <vul-start> < 1 ) goto trunc ; <vul-end> if ( * <vul-start> } break ; # ifdef ENABLE_ETHERNET case EGRESS_VLAN_NAME : ND_PRINT ( ( ndo, \"%s (0x%02x) \", tok2str ( rfc4675_tagged, \"Unknown tag\", * data ), * data ) ; data ++ ; length -- ; break ; } for ( i = 0 ; i < length ; i ++, data ++ ) { if ( * data == 0 ) break ; <vul-end> ND_PRINT ( ( <vul-start> break ; } <vul-end> ND_PRINT ( (\n"
 },
 {
  "id": 50,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int strncat_from_utf8_libarchive2 ( struct archive_string * as , const void * _p , size_t len , struct archive_string_conv * sc ) { const char * s ; int n ; char * p ; char * end ; uint32_t unicode ; # if HAVE_WCRTOMB mbstate_t shift_state ; memset ( & shift_state , 0 , sizeof ( shift_state ) ) ; # else wctomb ( NULL , L'\\\\0' ) ; # endif ( void ) sc ; if ( archive_string_ensure ( as , as -> length + len + 1 ) == NULL ) return ( - 1 ) ; s = ( const char * ) _p ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - MB_CUR_MAX - 1 ; while ( ( n = _utf8_to_unicode ( & unicode , s , len ) ) != 0 ) { wchar_t wc ; if ( p >= end ) { as -> length = p - as -> s ; if ( archive_string_ensure ( as , <vul-start> as -> length + len * 2 + 1 ) == NULL ) <vul-end> return ( - 1 ) ; p = as -> s + as -> length ; end = as -> s + as -> buffer_length - MB_CUR_MAX - 1 ; } if ( n < 0 ) { n *= - 1 ; wc = L'?' ; } else wc = ( wchar_t ) unicode ; s += n ; len -= n ; # if HAVE_WCRTOMB n = ( int )",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> -> length + max ( <vul-start> len * 2 , ( size_t ) MB_CUR_MAX )\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> + len * 4 <vul-end> + 1 )\n"
 },
 {
  "id": 51,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 interval * PGTYPESinterval_from_asc ( char * str , char * * endptr ) { interval * result = NULL ; fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; tm -> tm_year = 0 ; tm -> tm_mon = 0 ; tm -> tm_mday = 0 ; tm -> tm_hour = 0 ; tm -> tm_min = 0 ; tm -> tm_sec = 0 ; fsec = 0 ; <vul-start> if ( strlen ( str ) >= sizeof ( lowstr ) ) <vul-end> { errno = PGTYPES_INTVL_BAD_INTERVAL ; <vul-start> return NULL ; <vul-end> } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; <vul-start> return NULL ; <vul-end> } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } <vul-start> if ( tm2interval ( tm , fsec , result )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( str ) > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <vul-end> ) { errno <vul-start> = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <vul-end> ) { errno <vul-start> = PGTYPES_INTVL_BAD_INTERVAL ; <vul-end> free ( result <vul-start> NULL ; } <vul-end> errno = 0\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( str ) > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str, lowstr, field, ftype, & nf, ptr )!= 0 || ( DecodeInterval ( field, ftype, nf, & dtype, tm, & fsec )!= 0 && DecodeISO8601Interval ( str, & dtype, tm, & fsec )!= 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if (! result ) return NULL ; if ( dtype!= DTK_DELTA ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } if ( tm2interval ( tm, fsec, result )!= 0 ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } errno = 0 ; <vul-end> if ( ParseDateTime <vul-start> = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; <vul-end> return NULL ; <vul-start> NULL ; } <vul-end>      \n"
 },
 {
  "id": 52,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void sas_unregister_devs_sas_addr ( struct domain_device * parent , int phy_id , bool last ) { struct expander_device * ex_dev = & parent -> ex_dev ; struct ex_phy * phy = & ex_dev -> ex_phy [ phy_id ] ; struct domain_device * child , * n , * found = NULL ; if ( last ) { list_for_each_entry_safe ( child , n , & ex_dev -> children , siblings ) { if ( SAS_ADDR ( child -> sas_addr ) == SAS_ADDR ( phy -> attached_sas_addr ) ) { set_bit ( SAS_DEV_GONE , & child -> state ) ; if ( child -> dev_type == SAS_EDGE_EXPANDER_DEVICE || child -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) sas_unregister_ex_tree ( parent -> port , child ) ; else sas_unregister_dev ( parent -> port , child ) ; found = child ; break ; } } sas_disable_routing ( parent , phy -> attached_sas_addr ) ; } memset ( phy -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; if ( phy -> port ) { sas_port_delete_phy ( phy -> port , phy -> phy ) ; sas_device_set_phy ( found , phy -> port ) ; if ( phy -> port -> num_phys == 0 ) <vul-start> sas_port_delete ( phy -> port ) ; <vul-end> phy -> port = NULL ; } }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <vul-end> ) ; phy\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> == 0 ) sas_destruct_devices ( phy ) ;\n"
 },
 {
  "id": 53,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 bool CompileKeymap ( XkbFile * file , struct xkb_keymap * keymap , enum merge_mode merge ) { bool ok ; XkbFile * files [ LAST_KEYMAP_FILE_TYPE + 1 ] = { NULL } ; enum xkb_file_type type ; struct xkb_context * ctx = keymap -> ctx ; for ( file = ( XkbFile * ) file -> defs ; file ; file = ( XkbFile * ) file -> common . next ) { if ( file -> file_type < FIRST_KEYMAP_FILE_TYPE || file -> file_type > LAST_KEYMAP_FILE_TYPE ) { <vul-start> log_err ( ctx , \"Cannot define %s in a keymap file\\\\n\" , <vul-end> <vul-start> xkb_file_type_to_string ( file -> file_type ) ) ; <vul-end> continue ; } if ( files [ file -> file_type ] ) { log_err ( ctx , \"More than one %s section in keymap file; \" \"All sections after the first ignored\\\\n\" , xkb_file_type_to_string ( file -> file_type ) ) ; continue ; } files [ file -> file_type ] = file ; } ok = true ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { if ( files [ type ] == NULL ) { log_err ( ctx , \"Required section %s missing from keymap\\\\n\" , xkb_file_type_to_string ( type ) ) ; ok = false ; } } if ( ! ok ) return false ; for ( type = FIRST_KEYMAP_FILE_TYPE ; type <= LAST_KEYMAP_FILE_TYPE ; type ++ ) { log_dbg ( ctx , \"Compiling %s \\\\\"%s\\\\\"\\\\n\" , xkb_file_type_to_string ( type ) , files [ type ] -> name ) ; ok = compile_file_fns [ type",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> LAST_KEYMAP_FILE_TYPE ) { if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , \"Geometry sections are not supported; ignoring\\\\n\" ) ; } else { <vul-start> ) ) ; }\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( ctx, \"Cannot define %s in a keymap file: \" <vul-end>, xkb_file_type_to_string ( <vul-start> file_type ) ) ; log_err ( ctx, \"Invalid file type %s\\\\n\", xkb_file_type_to_string ( file -> file_type )\n"
 },
 {
  "id": 54,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_rtcd ( ) { <vul-start> vpx_scale_rtcd ( ) ; <vul-end> once ( setup_rtcd_internal ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( ) { <vul-end> once ( setup_rtcd_internal\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( ) { vpx_rtcd <vul-end> ( ) ;\n"
 },
 {
  "id": 55,
  "question": "CWE-611 Code Input Vulnerable Code Is: CWE-611 <vul-start> static VALUE from_document ( VALUE klass , VALUE document ) <vul-end> { xmlDocPtr doc ; xmlSchemaParserCtxtPtr ctx ; xmlSchemaPtr schema ; VALUE errors ; VALUE rb_schema ; <vul-start> Data_Get_Struct ( document , xmlDoc , doc ) ; <vul-end> <vul-start> doc = doc -> doc ; <vul-end> if ( has_blank_nodes_p ( DOC_NODE_CACHE ( doc ) ) ) { rb_raise ( rb_eArgError , \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\" ) ; } ctx = xmlSchemaNewDocParserCtxt ( doc ) ; errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; # endif schema = xmlSchemaParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlSchemaFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , \"Could not parse document\" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , \"@errors\" , errors ) ; <vul-start> return rb_schema ; <vul-end> return Qnil ; }",
  "golden_answers": [
   "CWE-611 Fixed Code Lines are: <vul-start> VALUE from_document ( int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; int parse_options_int ; <vul-end> xmlDocPtr doc ; <vul-start> VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , \"11\" , & document , & parse_options ) ; <vul-start> doc -> doc ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( \"ParseOptions\" ) ) , rb_intern ( \"DEFAULT_SCHEMA\" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( \"to_i\" ) , 0 ) ) <vul-start> errors ) ; rb_iv_set ( rb_schema , \"@parse_options\" , parse_options ) ;\n"
  ],
  "generated_answer": "CWE-611 Fixed Code Lines are: <vul-start> VALUE from_document ( int argc, VALUE * argv, VALUE klass ) { VALUE document ; VALUE parse_options ; xmlDocPtr doc ; xmlSchemaParserCtxtPtr ctx ; xmlSchemaPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc, argv, \"11\", & document, & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml, rb_intern ( \"ParseOptions\" ) ), rb_intern ( \"DEFAULT_SCHEMA\" ) ) ; } ctx = xmlSchemaNewDocParserCtxt ( doc ) ; errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors, Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx, Nokogiri_error_array_pusher, ( void * ) errors ) ; # endif <vul-end> ctx = xmlSchemaNewDocParserCtxt <vul-start> errors ) ; rb_iv_set ( rb_schema, \"@parse_options\", parse_options ) ;\n"
 },
 {
  "id": 56,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 TfLiteIntArray * TfLiteIntArrayCreate ( int size ) { <vul-start> TfLiteIntArray * ret = <vul-end> <vul-start> ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ; <vul-end> ret -> size = size ; return ret ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> size ) { int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; if ( alloc_size <= 0 ) return NULL ; <vul-start> ) malloc ( alloc_size ) ; if ( ! ret ) return ret <vul-end> ; ret ->\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> size ) { return TfLiteIntArrayCreateWithSize ( size, <vul-end> ( TfLiteIntArray * <vul-start> ( TfLiteIntArray * ) <vul-end> malloc ( TfLiteIntArrayGetSizeInBytes <vul-start> size ) ) <vul-end> ; }  \n"
 },
 {
  "id": 57,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int gs_can_open ( struct net_device * netdev ) { struct gs_can * dev = netdev_priv ( netdev ) ; struct gs_usb * parent = dev -> parent ; int rc , i ; struct gs_device_mode * dm ; u32 ctrlmode ; rc = open_candev ( netdev ) ; if ( rc ) return rc ; if ( atomic_add_return ( 1 , & parent -> active_channels ) == 1 ) { for ( i = 0 ; i < GS_MAX_RX_URBS ; i ++ ) { struct urb * urb ; u8 * buf ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) return - ENOMEM ; buf = usb_alloc_coherent ( dev -> udev , sizeof ( struct gs_host_frame ) , GFP_KERNEL , & urb -> transfer_dma ) ; if ( ! buf ) { netdev_err ( netdev , \"No memory left for USB buffer\\\\n\" ) ; usb_free_urb ( urb ) ; return - ENOMEM ; } usb_fill_bulk_urb ( urb , dev -> udev , usb_rcvbulkpipe ( dev -> udev , GSUSB_ENDPOINT_IN ) , buf , sizeof ( struct gs_host_frame ) , gs_usb_receive_bulk_callback , parent ) ; urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; usb_anchor_urb ( urb , & parent -> rx_submitted ) ; rc = usb_submit_urb ( urb , GFP_KERNEL ) ; if ( rc ) { if ( rc == - ENODEV ) netif_device_detach ( dev -> netdev ) ; netdev_err ( netdev , \"usb_submit failed (err=%d)\\\\n\" , rc ) ; <vul-start> usb_unanchor_urb ( urb ) ; <vul-end> break ; } usb_free_urb ( urb ) ; } } dm",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> ) ; usb_unanchor_urb ( urb ) ; usb_free_urb\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> rc ) ; usb_free_urb ( urb ) ;\n"
 },
 {
  "id": 58,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void psf_asciiheader_printf ( SF_PRIVATE * psf , const char * format , ... ) { va_list argptr ; int maxlen ; char * start ; <vul-start> maxlen = strlen ( ( char * ) psf -> header ) ; <vul-end> <vul-start> start = ( ( char * ) psf -> header ) + maxlen ; <vul-end> <vul-start> maxlen = sizeof ( psf -> header ) - maxlen ; <vul-end> va_start ( argptr , format ) ; vsnprintf ( start , maxlen , format , argptr ) ; va_end ( argptr ) ; start [ maxlen - 1 ] = 0 ; <vul-start> psf -> headindex = strlen ( ( char * ) psf -> header ) ; <vul-end> return ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> psf -> header . ptr <vul-start> psf -> header . ptr <vul-start> ; maxlen = <vul-end> psf -> header <vul-start> psf -> header . len <vul-end> - maxlen ; <vul-start> ; psf -> header . indx <vul-end> = strlen ( <vul-start> psf -> header . ptr\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * start ; char * header ; <vul-start> psf -> header ) ; header = ( ( char * ) psf -> header <vul-start> start = ( <vul-end> header ) + <vul-start> = sizeof ( <vul-end> header ) - <vul-start> = 0 ; <vul-end> return ; }\n"
 },
 {
  "id": 59,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 socket_t * socket_accept ( const socket_t * socket ) { assert ( socket != NULL ) ; <vul-start> int fd = accept ( socket -> fd , NULL , NULL ) ; <vul-end> if ( fd == INVALID_FD ) { LOG_ERROR ( \"%s unable to accept socket: %s\" , __func__ , strerror ( errno ) ) ; return NULL ; } socket_t * ret = ( socket_t * ) osi_calloc ( sizeof ( socket_t ) ) ; if ( ! ret ) { close ( fd ) ; LOG_ERROR ( \"%s unable to allocate memory for socket.\" , __func__ ) ; return NULL ; } ret -> fd = fd ; return ret ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> int fd = TEMP_FAILURE_RETRY ( <vul-start> NULL , NULL )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> int fd = TEMP_FAILURE_RETRY ( <vul-start>, NULL ) )\n"
 },
 {
  "id": 60,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_ARP_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) ) { pr_notice ( \"arptables: loop hook %u pos %u %08X.\\\\n\" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ) ; <vul-start> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <vul-end> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <vul-start> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <vul-end> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> if ( ( unconditional ( e <vul-end> ) && ( <vul-start> verdict < 0 <vul-end> ) || visited\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> if ( ( unconditional ( e <vul-end> ) && ( <vul-start> verdict < 0 <vul-end> ) || visited\n"
 },
 {
  "id": 61,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int perf_event_task_enable ( void ) <vul-start> { <vul-end> struct perf_event * event ; mutex_lock ( & current -> perf_event_mutex ) ; <vul-start> list_for_each_entry ( event , & current -> perf_event_list , owner_entry ) <vul-end> <vul-start> perf_event_for_each_child ( event , perf_event_enable ) ; <vul-end> mutex_unlock ( & current -> perf_event_mutex ) ; return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> void ) { struct perf_event_context * ctx ; <vul-start> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <vul-start> ( event , _perf_event_enable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <vul-end> mutex_unlock ( &\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> void ) { struct perf_event_context * ctx ; <vul-start> perf_event_mutex ) ; ctx = perf_event_ctx_lock ( ) ; list_for_each_entry ( event, & ctx <vul-end> -> perf_event_list, <vul-start>, owner_entry ) { mutex_unlock ( & current -> perf_event_mutex ) ; return 0 ; } <vul-end> mutex_unlock ( &\n"
 },
 {
  "id": 62,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int gs_usb_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct gs_usb * dev ; int rc = - ENOMEM ; unsigned int icount , i ; <vul-start> struct gs_host_config hconf = { <vul-end> . byte_order = 0x0000beef , } ; <vul-start> struct gs_device_config dconf ; <vul-end> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <vul-start> & hconf , <vul-end> <vul-start> sizeof ( hconf ) , <vul-end> 1000 ) ; <vul-start> if ( rc < 0 ) { <vul-end> dev_err ( & intf -> dev , \"Couldn\\'t send data format (err=%d)\\\\n\" , rc ) ; return rc ; <vul-start> } <vul-end> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <vul-start> & dconf , <vul-end> <vul-start> sizeof ( dconf ) , <vul-end> 1000 ) ; if ( rc < 0 ) { dev_err ( & intf -> dev , \"Couldn\\'t get device config: (err=%d)\\\\n\" , rc ) ; <vul-start> return rc ; <vul-end> } icount = dconf . icount + 1 ; dev_info ( & intf -> dev , \"Configuring for %d interfaces\\\\n\" , icount ) ; if ( icount > GS_MAX_INTF ) { dev_err ( & intf -> dev , \"Driver cannot handle more that",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; struct gs_host_config * hconf <vul-end> ; struct gs_device_config <vul-start> ; struct gs_device_config * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <vul-end> ; rc = <vul-start> . bInterfaceNumber , <vul-end> hconf , sizeof <vul-start> , sizeof ( * <vul-start> 1000 ) ; kfree ( hconf ) ; <vul-start> rc ; } dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <vul-start> . bInterfaceNumber , <vul-end> dconf , sizeof <vul-start> , sizeof ( * <vul-start> rc ) ; kfree ( dconf ) ; return rc ; } icount = dconf -> <vul-end> icount + 1 <vul-start> GS_MAX_INTF ) ; kfree ( dconf ) ; <vul-start> ! dev ) { kfree ( dconf ) ; <vul-start> - ENOMEM ; } <vul-start> , intf , <vul-end> dconf ) ; <vul-start> ; kfree ( dconf ) ; kfree ( <vul-start> dev ; } kfree ( dconf ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> i ; struct usb_interface_descriptor * altsetting = NULL ; struct <vul-start> struct gs_device_config dconf ; if ( intf -> altsetting [ 0 ]. desc. bNumEndpoints < 1 ) return - ENODEV <vul-start> bInterfaceNumber, & altsetting -> desc <vul-end>, sizeof ( <vul-start>, sizeof ( altsetting -> desc <vul-end> ), 1000 <vul-start> if ( rc < 1 <vul-end> ) { dev_err <vul-start> return rc ; <vul-end> rc = usb_control_msg <vul-start> bInterfaceNumber, & altsetting -> desc <vul-end>, sizeof ( <vul-start>, sizeof ( altsetting -> desc <vul-end> ), 1000 <vul-start> return rc ; } rc = usb_control_msg ( interface_to_usbdev ( intf ), usb_rcvctrlpipe ( interface_to_usbdev ( intf ), 0 ), GS_USB_BREQ_DEVICE_CONFIG, USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE, 1, altsetting [ 0 ]. desc. bInterfaceNumber, & dconf, sizeof ( dconf ), 1000 ) ; if ( rc < 0 ) { dev_err ( & intf -> dev, \"Couldn\\'t get device config: (err=%d)\\\\n\", rc ) ; return rc ; } <vul-end> icount = dconf <vul-start> dev ; } if ( altsetting ) { if (! dev -> priv ) { dev_err ( & intf -> dev, \"Invalid interface id\\\\n\" ) ; return - EINVAL ; } dev -> priv -> priv = altsetting ; }\n"
 },
 {
  "id": 63,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 : <vul-start> p += 2 ; <vul-end> n += 2 ; len -= 2 ; break ; case 0x40 : <vul-start> p += 3 ; <vul-end> n += 3 ; len -= 3 ; break ; case 0x80 : <vul-start> p += 4 ; <vul-end> n += 4 ; len -= 4 ; break ; case 0xC0 : <vul-start> l = p [ 1 ] ; <vul-end> if ( l < 10 || l > 20 ) return - 1 ; if ( * p == FAC_CCITT_DEST_NSAP ) { memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> case 0x00 : if ( len < 2 ) return - 1 ; <vul-start> case 0x40 : if ( len < 3 ) return - 1 ; <vul-start> case 0x80 : if ( len < 4 ) return - 1 ; <vul-start> case 0xC0 : if ( len < 2 ) return - 1 ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> case 0x00 : if ( len < 2 ) return - 1 ; <vul-start> case 0x40 : if ( len < 3 ) return - 1 ; <vul-start> case 0x80 : if ( len < 4 ) return - 1 ; <vul-start> case 0xC0 : if ( len < 2 ) return - 1 ;\n"
 },
 {
  "id": 64,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 unsigned long insn_get_seg_base ( struct pt_regs * regs , int seg_reg_idx ) { <vul-start> struct desc_struct * desc ; <vul-end> short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return - 1L ; if ( v8086_mode ( regs ) ) return ( unsigned long ) ( sel << 4 ) ; if ( user_64bit_mode ( regs ) ) { unsigned long base ; if ( seg_reg_idx == INAT_SEG_REG_FS ) rdmsrl ( MSR_FS_BASE , base ) ; else if ( seg_reg_idx == INAT_SEG_REG_GS ) rdmsrl ( MSR_KERNEL_GS_BASE , base ) ; else base = 0 ; return base ; } if ( ! sel ) return - 1L ; <vul-start> desc = get_desc ( sel ) ; <vul-end> <vul-start> if ( ! desc ) <vul-end> return - 1L ; <vul-start> return get_desc_base ( desc ) ; <vul-end> }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> { struct desc_struct <vul-end> desc ; short <vul-start> - 1L ; <vul-end> if ( ! <vul-start> if ( ! get_desc ( & desc , sel ) <vul-end> ) return - <vul-start> return get_desc_base ( &\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> { struct desc_struct <vul-end> desc ; short <vul-start> - 1L ; <vul-end> if (! <vul-start> if (! get_desc ( & <vul-start> return get_desc_base ( &\n"
 },
 {
  "id": 65,
  "question": "CWE-863 Code Input Vulnerable Code Is: CWE-863 void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( \"Unexpected off_t/time_t size\" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( \"ambiguous target\" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , \"\" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for (",
  "golden_answers": [
   "CWE-863 Fixed Code Lines are: <vul-start> ; if ( * cp == '\\\\0' || <vul-end> strchr ( cp <vul-start> ) != NULL || <vul-end> strcmp ( cp <vul-start> ( cp , \".\" ) == 0 || strcmp ( cp , <vul-start> ) == 0 <vul-end> ) { run_err\n"
  ],
  "generated_answer": "CWE-863 Fixed Code Lines are: <vul-start> if ( ( ( cp == 0 ) && ( <vul-start>!= NULL ) )\n"
 },
 {
  "id": 66,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; daemon ( 1 , 0 ) ; openlog ( \"KVP\" , 0 , LOG_USER ) ; syslog ( LOG_INFO , \"KVP starting; pid is:%d\" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , \"Failed to initialize the pools\" ) ; exit ( - 1 ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , \"netlink socket creation failed; error:%d\" , fd ) ; exit ( - 1 ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , \"bind failed; error:%d\" , error ) ; close ( fd ) ; exit ( - 1 ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message ->",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; <vul-start> ; len = recvfrom <vul-end> ( fd , <vul-start> ) , 0 , addr_p , & addr_l <vul-start> len < 0 || addr . nl_pid <vul-start> ( LOG_ERR , \"recvfrom failed; pid:%u error:%d %s\" , addr . nl_pid , errno , strerror ( errno ) <vul-end> ) ; close\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>. events = POLLIN | <vul-start> 1 ) ; do { <vul-start> ( fd, ( char * ) <vul-start>, sizeof ( struct hv_kvp_recv_buffer ), 0 ) ; } while ( ( len < 0 ) && ( <vul-end> recv ( fd <vul-start>, 0 )!= len ) <vul-end> ) ; if <vul-start> ( LOG_ERR, \"Received packet from untrusted pool; error:%d\" <vul-end>, len ) <vul-start> 1 ) ; do { <vul-start> ( fd, ( char * ) <vul-start>, sizeof ( struct hv_kvp_recv_buffer ), 0 ) ; } while ( ( len < 0 ) && ( <vul-end> recv ( fd <vul-start>, 0 )!= len ) ) ; syslog ( LOG_ERR, \"Received packet from untrusted pool; error:%d\", len <vul-end> ) ; close\n"
 },
 {
  "id": 67,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * purgekeys_2_svc ( purgekeys_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg , * funcname ; <vul-start> gss_buffer_desc client_name , service_name ; <vul-end> OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = \"kadm5_purgekeys\" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_MODIFY , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_MODIFY ; log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_purgekeys ( ( void * ) handle , arg -> princ , arg -> keepkvno ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
 },
 {
  "id": 68,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void oz_usb_rx ( struct oz_pd * pd , struct oz_elt * elt ) { struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ; struct oz_usb_ctx * usb_ctx ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ] ; if ( usb_ctx ) oz_usb_get ( usb_ctx ) ; spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; if ( usb_ctx == NULL ) return ; if ( usb_ctx -> stopped ) goto done ; if ( usb_hdr -> elt_seq_num != 0 ) { if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 ) goto done ; } usb_ctx -> rx_seq_num = usb_hdr -> elt_seq_num ; switch ( usb_hdr -> type ) { case OZ_GET_DESC_RSP : { struct oz_get_desc_rsp * body = ( struct oz_get_desc_rsp * ) usb_hdr ; <vul-start> int data_len = elt -> length - <vul-end> <vul-start> sizeof ( struct oz_get_desc_rsp ) + 1 ; <vul-end> u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , \"USB_REQ_GET_DESCRIPTOR - cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport ,",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) usb_hdr ; u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <vul-end> data_len = elt <vul-start> -> length - ( <vul-start> ( struct oz_get_desc_rsp ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , \"USB_REQ_GET_DESCRIPTOR - cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <vul-start> ) + 1 <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) usb_hdr ; u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON, \"USB_REQ_GET_DESCRIPTOR - cnf\\\\n\" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport, body -> req_id, body -> rcode, body -> data, data_len, offs, total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_set_config_cnf ( usb_ctx -> hport, body -> req_id, body -> rcode, body -> data, elt -> length <vul-end> ) ; }\n"
 },
 {
  "id": 69,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static struct nfs4_opendata * nfs4_opendata_alloc ( struct path * path , <vul-start> struct nfs4_state_owner * sp , int flags , <vul-end> const struct iattr * attrs ) { struct dentry * parent = dget_parent ( path -> dentry ) ; struct inode * dir = parent -> d_inode ; struct nfs_server * server = NFS_SERVER ( dir ) ; struct nfs4_opendata * p ; p = kzalloc ( sizeof ( * p ) , GFP_KERNEL ) ; if ( p == NULL ) goto err ; p -> o_arg . seqid = nfs_alloc_seqid ( & sp -> so_seqid ) ; if ( p -> o_arg . seqid == NULL ) goto err_free ; p -> path . mnt = mntget ( path -> mnt ) ; p -> path . dentry = dget ( path -> dentry ) ; p -> dir = parent ; p -> owner = sp ; atomic_inc ( & sp -> so_count ) ; p -> o_arg . fh = NFS_FH ( dir ) ; <vul-start> p -> o_arg . open_flags = flags , <vul-end> p -> o_arg . clientid = server -> nfs_client -> cl_clientid ; p -> o_arg . id = sp -> so_owner_id . id ; p -> o_arg . name = & p -> path . dentry -> d_name ; p -> o_arg . server = server ; p -> o_arg . bitmask = server -> attr_bitmask ; p -> o_arg . claim = NFS4_OPEN_CLAIM_NULL ; if ( flags & O_EXCL ) { u32 * s = ( u32 * ) p -> o_arg . u",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> nfs4_state_owner * sp , fmode_t fmode <vul-start> open_flags = flags ; p -> o_arg . fmode = fmode & ( FMODE_READ | FMODE_WRITE ) ; <vul-end> p -> o_arg\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * sp, fmode_t fmode, <vul-start>. open_flags = fmode <vul-end>, p ->\n"
 },
 {
  "id": 70,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; <vul-start> int err = 0 ; <vul-end> if ( ! asoc ) return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> err = 0 ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> err = 0 ; if ( id >= SCTP_MAX_ASSERTIONS ) return - EINVAL\n"
 },
 {
  "id": 71,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { <vul-start> struct page * pages [ NFS4ACL_MAXPAGES ] ; <vul-end> struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; <vul-start> struct page * localpage = NULL ; <vul-end> int ret ; if ( buflen < PAGE_SIZE ) { localpage = alloc_page ( GFP_KERNEL ) ; resp_buf = page_address ( localpage ) ; if ( localpage == NULL ) <vul-start> return - ENOMEM ; <vul-end> args . acl_pages [ 0 ] = localpage ; args . acl_pgbase = 0 ; args . acl_len = PAGE_SIZE ; } else { resp_buf = buf ; buf_to_pages ( buf , buflen , args . acl_pages , & args . acl_pgbase ) ; } ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; <vul-start> if ( res . acl_len > args . acl_len ) <vul-end> <vul-start> nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; <vul-end> else <vul-start> nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; <vul-end> if",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> [ NFS4ACL_MAXPAGES ] = { NULL , } <vul-start> , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <vul-end> == NULL ) <vul-start> == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( \"%s  buf %p buflen %ld npages %d args.acl_len %ld\\\\n\" , __func__ , buf , buflen , npages , args . acl_len ) ; <vul-end> ret = nfs4_call_sync <vul-start> goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( <vul-end> acl_len > args <vul-start> , NULL , <vul-end> acl_len ) ; <vul-start> inode , resp_buf + res . acl_data_offset , <vul-end> acl_len ) ; <vul-start> ; if ( <vul-end> acl_len > buflen <vul-start> goto out_free ; _copy_from_pages <vul-end> ( buf , <vul-start> ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = <vul-end> acl_len ; out_free <vul-start> ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <vul-end> ) __free_page ( <vul-start> ) __free_page ( pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <vul-end> ) ; return\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ) { struct nfs_getaclargs args = {. fh = NFS_FH ( inode ),. acl_pages = NULL,. acl_len = buflen, } ; struct page * resp_buf ; size_t len <vul-end> ; struct page <vul-start> } ; struct nfs_getaclres res = {. acl_len = buflen, } ; void * localpage = NULL ; int ret <vul-end> ; if ( <vul-start> == NULL ) { ret = <vul-end> - ENOMEM ; <vul-start> return - ENOMEM <vul-end> ; } else <vul-start> goto out_free ; len = min ( sizeof ( struct nfs_getaclres ), res. acl_len ) ; if ( len <vul-end> > args. <vul-start>. acl_len ) ret = <vul-end> nfs4_write_cached_acl ( inode <vul-start>, NULL, len <vul-end> ) ; else <vul-start>, resp_buf, len ) ; if ( buf ) { ret = - ERANGE ; if ( len <vul-end> > buflen ) <vul-start> goto out_free ; memcpy ( buf, resp_buf, len ) ; } ret = res. <vul-end> acl_len ; out_free <vul-start> : if (! ret ) <vul-end> __free_page ( localpage <vul-start> __free_page ( localpage ) ; if ( localpage ) __free_page ( localpage\n"
 },
 {
  "id": 72,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , header [ 228 ] ; unsigned char * cb1 = NULL , * cb2 = NULL ; size_t cb1_len , cb2_len , alloc_len ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = __json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = __json_array_string ( val , 5 ) ; nbit = __json_array_string ( val , 6 ) ; ntime = __json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; <vul-start> if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { <vul-end> <vul-start> if ( job_id ) <vul-end> free ( job_id ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; free ( pool -> swork . job_id ) ; pool -> swork . job_id = job_id ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free <vul-end> ( job_id ) <vul-start> ( job_id ) ; free ( coinbase1 ) ; <vul-end> free ( coinbase2\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; free ( job_id ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; <vul-start> ntime ) { <vul-end> goto out ;\n"
 },
 {
  "id": 73,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <vul-start> utee_param_to_param ( param , callee_params ) ; <vul-end> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> return res ; res = utee_param_to_param ( utc , <vul-end> param , callee_params <vul-start> , callee_params ) ; if ( res != TEE_SUCCESS ) return res\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> return res ; res = <vul-start> param, callee_params ) ; if ( res!= TEE_SUCCESS ) return res\n"
 },
 {
  "id": 74,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int cipso_v4_sock_getattr ( struct sock * sk , struct netlbl_lsm_secattr * secattr ) { <vul-start> struct ip_options * opt ; <vul-end> <vul-start> opt = inet_sk ( sk ) -> opt ; <vul-end> <vul-start> if ( opt == NULL || opt -> cipso == 0 ) <vul-end> return - ENOMSG ; <vul-start> return cipso_v4_getattr ( opt -> __data + opt -> cipso - sizeof ( struct iphdr ) , <vul-end> secattr ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ) { struct ip_options_rcu <vul-end> * opt ; <vul-start> * opt ; int res = - ENOMSG ; rcu_read_lock ( ) ; opt = rcu_dereference ( <vul-end> inet_sk ( sk <vul-start> sk ) -> inet_opt ) <vul-end> ; if ( <vul-start> if ( opt && opt -> opt . cipso ) res = <vul-end> cipso_v4_getattr ( opt <vul-start> ( opt -> opt . <vul-start> + opt -> opt . <vul-start> secattr ) ; rcu_read_unlock ( ) ; return res ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> secattr ) { int ret ; struct ip_options_rcu <vul-end> * opt ; <vul-start> * opt ; opt = rcu_dereference_protected ( sk -> sk_omem_alloc, 1 ) ; if (! opt ) return - ENOMEM <vul-end> ; if ( <vul-start> || opt -> opt. <vul-start> - ENOMSG ; ret = <vul-end> cipso_v4_getattr ( opt <vul-start> ( opt -> opt. <vul-start> secattr ) ; rcu_assign_pointer ( opt -> inet_opt, opt ) ; return ret ;\n"
 },
 {
  "id": 75,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadDIBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { DIBInfo dib_info ; Image * image ; IndexPacket index ; ssize_t bit , y ; MagickBooleanType status ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_line , length ; ssize_t count ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & dib_info , 0 , sizeof ( dib_info ) ) ; dib_info . size = ReadBlobLSBLong ( image ) ; if ( dib_info . size != 40 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; dib_info . width = ( short ) ReadBlobLSBLong ( image ) ; dib_info . height = ( short ) ReadBlobLSBLong ( image ) ; dib_info . planes = ReadBlobLSBShort ( image ) ; dib_info . bits_per_pixel = ReadBlobLSBShort ( image",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> height ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } if ( ( dib_info. columns < 0 ) || ( dib_info. columns > 64 ) ) ThrowReaderException ( CorruptImageError, \"ImproperImageHeader\" ) ; if (\n"
 },
 {
  "id": 76,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static void nfs4_xdr_enc_getacl ( struct rpc_rqst * req , struct xdr_stream * xdr , struct nfs_getaclargs * args ) { struct compound_hdr hdr = { . minorversion = nfs4_xdr_minorversion ( & args -> seq_args ) , } ; uint32_t replen ; encode_compound_hdr ( xdr , req , & hdr ) ; encode_sequence ( xdr , & args -> seq_args , & hdr ) ; encode_putfh ( xdr , args -> fh , & hdr ) ; <vul-start> replen = hdr . replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1 ; <vul-end> encode_getattr_two ( xdr , FATTR4_WORD0_ACL , 0 , & hdr ) ; xdr_inline_pages ( & req -> rq_rcv_buf , replen << 2 , args -> acl_pages , args -> acl_pgbase , args -> acl_len ) ; <vul-start> encode_nops ( & hdr ) ; <vul-end> }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> + op_decode_hdr_maxsz + <vul-end> 1 ; encode_getattr_two <vul-start> acl_len ) ; xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz <vul-end> + 1 ; <vul-start> acl_len ) ; if ( args -> acl_len > NFS4_MAX_ACL_SIZE ) { nfs_set_rsp_error ( req, \"fattr size mismatch %u!= %u\", args -> acl_len, NFS4_MAX_ACL_SIZE ) ; }\n"
 },
 {
  "id": 77,
  "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 static int ssl_verify_cert ( struct tunnel * tunnel ) { int ret = - 1 ; int cert_valid = 0 ; unsigned char digest [ SHA256LEN ] ; unsigned int len ; struct x509_digest * elem ; char digest_str [ SHA256STRLEN ] , * subject , * issuer ; char * line ; int i ; X509_NAME * subj ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( \"Unable to get gateway certificate.\\\\n\" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else <vul-start> char common_name [ FIELD_SIZE + 1 ] ; <vul-end> if ( subj && X509_NAME_get_text_by_NID ( subj , NID_commonName , common_name , FIELD_SIZE ) > 0 && strncasecmp ( common_name , tunnel -> config -> gateway_host , <vul-start> FIELD_SIZE ) == 0 ) <vul-end> cert_valid = 1 ; # endif if ( cert_valid && SSL_get_verify_result ( tunnel -> ssl_handle ) == X509_V_OK ) { log_debug ( \"Gateway certificate validation succeeded.\\\\n\" ) ; ret = 0 ; goto free_cert ; } log_debug ( \"Gateway certificate validation failed.\\\\n\" ) ; if ( X509_digest ( cert , EVP_sha256 ( ) , digest , & len ) <= 0 || len != SHA256LEN ) { log_error ( \"Could not compute certificate sha256 digest.\\\\n\" ) ; goto free_cert ; } for",
  "golden_answers": [
   "CWE-295 Fixed Code Lines are: <vul-start> ; # else if ( validate_hostname ( <vul-end> tunnel -> config <vul-start> -> gateway_host , cert ) == MatchFound <vul-end> ) cert_valid =\n"
  ],
  "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> ; # else int has_tstr = 0 ; if ( subj && X509_NAME_get_text_by_NID ( subj, NID_commonName <vul-end>, tunnel -> <vul-start> -> gateway_host, & has_tstr ) == 0 && strncasecmp ( tunnel -> config -> gateway_host, has_tstr <vul-end>, tunnel -> <vul-start>, tunnel -> config -> gateway_host_len <vul-end> ) == 0\n"
 },
 {
  "id": 78,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void rpc_init_task ( struct rpc_task * task , const struct rpc_task_setup * task_setup_data ) { memset ( task , 0 , sizeof ( * task ) ) ; atomic_set ( & task -> tk_count , 1 ) ; task -> tk_flags = task_setup_data -> flags ; task -> tk_ops = task_setup_data -> callback_ops ; task -> tk_calldata = task_setup_data -> callback_data ; INIT_LIST_HEAD ( & task -> tk_task ) ; task -> tk_garb_retry = 2 ; task -> tk_cred_retry = 2 ; <vul-start> task -> tk_priority = task_setup_data -> priority - RPC_PRIORITY_LOW ; <vul-end> task -> tk_owner = current -> tgid ; task -> tk_workqueue = task_setup_data -> workqueue ; if ( task -> tk_ops -> rpc_call_prepare != NULL ) task -> tk_action = rpc_prepare_task ; task -> tk_start = ktime_get ( ) ; dprintk ( \"RPC: new task initialized, procpid %u\\\\n\" , task_pid_nr ( current ) ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ; task -> tk_rebind_retry = 2 ; task ->\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> -> tk_priority = min ( <vul-start> priority - RPC_PRIORITY_LOW, 0 )\n"
 },
 {
  "id": 79,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 vpx_codec_err_t vpx_codec_destroy ( vpx_codec_ctx_t * ctx ) { vpx_codec_err_t res ; if ( ! ctx ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { <vul-start> if ( ctx -> priv -> alg_priv ) <vul-end> <vul-start> ctx -> iface -> destroy ( ctx -> priv -> alg_priv ) ; <vul-end> ctx -> iface = NULL ; ctx -> name = NULL ; ctx -> priv = NULL ; res = VPX_CODEC_OK ; } return SAVE_STATUS ( ctx , res ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; else { <vul-end> ctx -> iface <vul-start> -> destroy ( ( vpx_codec_alg_priv_t * ) <vul-start> ctx -> priv <vul-end> ) ; ctx\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> priv -> priv_alg_priv <vul-end> ) ctx -> <vul-start> -> priv -> priv_alg_priv <vul-end> ) ; ctx\n"
 },
 {
  "id": 80,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 void build_ntlmssp_negotiate_blob ( unsigned char * pbuffer , struct cifs_ses * ses ) { NEGOTIATE_MESSAGE * sec_blob = ( NEGOTIATE_MESSAGE * ) pbuffer ; __u32 flags ; memset ( pbuffer , 0 , sizeof ( NEGOTIATE_MESSAGE ) ) ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmNegotiate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <vul-start> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <vul-end> <vul-start> if ( ses -> server -> sign ) { <vul-end> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-start> } <vul-end> sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> WorkstationName . BufferOffset = 0 ; sec_blob -> WorkstationName . Length = 0 ; sec_blob -> WorkstationName . MaximumLength = 0 ; sec_blob -> DomainName . BufferOffset = 0 ; sec_blob -> DomainName . Length = 0 ; sec_blob -> DomainName . MaximumLength = 0 ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <vul-start> -> sign ) <vul-end> flags |= NTLMSSP_NEGOTIATE_SIGN <vul-start> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-end> sec_blob -> NegotiateFlags\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM <vul-end> ; if ( <vul-start> -> server -> ntlmssp -> <vul-start> |= NTLMSSP_NEGOTIATE_KEY_XCH ; if ( ses -> server -> sign ) flags |= NTLMSSP_NEGOTIATE_SIGN ;\n"
 },
 {
  "id": 81,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int vp8_rd_pick_best_mbsegmentation ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * best_ref_mv , int best_rd , int * mdcounts , int * returntotrate , int * returnyrate , int * returndistortion , int mvthresh ) { int i ; BEST_SEG_INFO bsi ; <vul-start> vpx_memset ( & bsi , 0 , sizeof ( bsi ) ) ; <vul-end> bsi . segment_rd = best_rd ; bsi . ref_mv = best_ref_mv ; bsi . mvp . as_int = best_ref_mv -> as_int ; bsi . mvthresh = mvthresh ; bsi . mdcounts = mdcounts ; for ( i = 0 ; i < 16 ; i ++ ) { bsi . modes [ i ] = ZERO4X4 ; } if ( cpi -> compressor_speed == 0 ) { rd_check_segment ( cpi , x , & bsi , BLOCK_16X8 ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X16 ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X8 ) ; rd_check_segment ( cpi , x , & bsi , BLOCK_4X4 ) ; } else { int sr ; rd_check_segment ( cpi , x , & bsi , BLOCK_8X8 ) ; if ( bsi . segment_rd < best_rd ) { int col_min = ( ( best_ref_mv -> as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int row_min = ( ( best_ref_mv -> as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int col_max = ( best_ref_mv -> as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ; int row_max = ( best_ref_mv -> as_mv . row >>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> BEST_SEG_INFO bsi ; memset <vul-end> ( & bsi\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> BEST_SEG_INFO bsi ; memset <vul-end> ( & bsi\n"
 },
 {
  "id": 82,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , \"(s=%d) processRequest(): read(): %m\" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , \"(s=%d) request connection closed\" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <vul-start> if ( p + l > buf + n ) { <vul-end> syslog ( LOG_WARNING , \"bad request (length encoding l=%u n=%u)\" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , \"bad request (length=0, type=%d)\" , type ) ; goto error ; } syslog ( LOG_INFO , \"(s=%d) request",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; if ( l > ( unsigned ) ( <vul-end> buf + n <vul-start> buf + n - p ) <vul-start> ; if ( l > ( unsigned ) ( <vul-end> buf + n <vul-start> buf + n - p ) <vul-start> ; if ( l > ( unsigned ) ( <vul-end> buf + n <vul-start> buf + n - p ) <vul-start> ; if ( l > ( unsigned ) ( <vul-end> buf + n <vul-start> buf + n - p )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( ( type == MINISSDPD_SEARCH_ALL && ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn, ( const char * ) p, l ) ) || ( type == MINISSDPD_SEARCH_USN && ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn, ( const char * ) p, l ) ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m, rp ) ; memcpy ( rp, serv -> location, m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m, rp ) ; memcpy ( rp, serv -> usn, m ) ; rp += m ; nrep ++ ; } } if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st, ( const char * ) p, l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn, ( const char * ) p, l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { if ( m == 0 ) { syslog ( LOG_WARNING, \"bad request (length encoding l=%u n=%u)\", l, ( unsigned ) n ) ; goto error ; } syslog ( LOG_INFO, \"(s=%d) response : %d device%s\", req -> socket, nrep, type == MINISSDPD_SEARCH_TYPE? \"s\" : \"\" ) ; if ( newserv ) { syslog ( LOG_DEBUG, \"(s=%d) service: %m\", newserv -> socket ) ; goto error ; } serv = newserv ; if ( strlen ( serv ) >= ( sizeof ( struct service ) ) ) { syslog ( LOG_ERR, \"cannot allocate memory\" ) ; goto error ; } if ( newserv -> l > ( ssize_t ) l ) { syslog ( LOG_ERR, \"bad request (length of service: %m\", newserv -> l ) ; goto error ; } nrep ++ ; if ( ( nrep < 255 ) ) { syslog ( LOG_WARNING,"
 },
 {
  "id": 83,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static long vhost_net_set_backend ( struct vhost_net * n , unsigned index , int fd ) { struct socket * sock , * oldsock ; struct vhost_virtqueue * vq ; struct vhost_net_virtqueue * nvq ; struct vhost_net_ubuf_ref * ubufs , * oldubufs = NULL ; int r ; mutex_lock ( & n -> dev . mutex ) ; r = vhost_dev_check_owner ( & n -> dev ) ; if ( r ) goto err ; if ( index >= VHOST_NET_VQ_MAX ) { r = - ENOBUFS ; goto err ; } vq = & n -> vqs [ index ] . vq ; nvq = & n -> vqs [ index ] ; mutex_lock ( & vq -> mutex ) ; if ( ! vhost_vq_access_ok ( vq ) ) { r = - EFAULT ; goto err_vq ; } sock = get_socket ( fd ) ; if ( IS_ERR ( sock ) ) { r = PTR_ERR ( sock ) ; goto err_vq ; } oldsock = rcu_dereference_protected ( vq -> private_data , lockdep_is_held ( & vq -> mutex ) ) ; if ( sock != oldsock ) { ubufs = vhost_net_ubuf_alloc ( vq , sock && vhost_sock_zcopy ( sock ) ) ; if ( IS_ERR ( ubufs ) ) { r = PTR_ERR ( ubufs ) ; goto err_ubufs ; } vhost_net_disable_vq ( n , vq ) ; rcu_assign_pointer ( vq -> private_data , sock ) ; r = vhost_init_used ( vq ) ; if ( r ) goto err_used ; r = vhost_net_enable_vq ( n , vq ) ; if ( r ) goto",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> oldubufs ) { vhost_net_ubuf_put_wait_and_free <vul-end> ( oldubufs ) <vul-start> ( ubufs ) vhost_net_ubuf_put_wait_and_free <vul-end> ( ubufs )\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> oldubufs ) { r = <vul-start> ( oldubufs ) ; if ( r ) goto err_ubufs <vul-start> ( ubufs ) r = <vul-start> ( ubufs ) ; err_ubufs :\n"
 },
 {
  "id": 84,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , \"unimplemented HWCR wrmsr: 0x%llx\\\\n\" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , \"unimplemented MMIO_CONF_BASE wrmsr: \" \"0x%llx\\\\n\" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\\\n\" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( !",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> | 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> PAGE_MASK | 1 ) ; if ( data == 0 ) vcpu -> arch. pv_time_enabled = false ; else vcpu -> arch. pv_time_enabled = true <vul-end> ; break ;\n"
 },
 {
  "id": 85,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_alloc_compressor_data ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int width = cm -> Width ; int height = cm -> Height ; if ( vp8_alloc_frame_buffers ( cm , width , height ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffers\" ) ; if ( vp8_alloc_partition_data ( cpi ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate partition data\" ) ; if ( ( width & 0xf ) != 0 ) width += 16 - ( width & 0xf ) ; if ( ( height & 0xf ) != 0 ) height += 16 - ( height & 0xf ) ; if ( vp8_yv12_alloc_frame_buffer ( & cpi -> pick_lf_lvl_frame , width , height , VP8BORDERINPIXELS ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate last frame buffer\" ) ; if ( vp8_yv12_alloc_frame_buffer ( & cpi -> scaled_source , width , height , VP8BORDERINPIXELS ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , \"Failed to allocate scaled source buffer\" ) ; vpx_free ( cpi -> tok ) ; { # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING unsigned int tokens = 8 * 24 * 16 ; # else unsigned int tokens = cm -> mb_rows * cm -> mb_cols * 24 * 16 ; # endif CHECK_MEM_ERROR ( cpi -> tok , vpx_calloc ( tokens , sizeof ( * cpi -> tok ) ) ) ; } cpi -> zeromv_count = 0 ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; memset <vul-end> ( cpi -> <vul-start> ) ) ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { vp8_denoiser_free ( & cpi -> denoiser ) ; vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ; } # endif\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; memset <vul-end> ( cpi -> <vul-start> ) ) ; memset <vul-end> ( cpi ->\n"
 },
 {
  "id": 86,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int jpc_dec_tiledecode ( jpc_dec_t * dec , jpc_dec_tile_t * tile ) { int i ; int j ; jpc_dec_tcomp_t * tcomp ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; int compno ; int rlvlno ; int bandno ; int adjust ; int v ; jpc_dec_ccp_t * ccp ; jpc_dec_cmpt_t * cmpt ; if ( jpc_dec_decodecblks ( dec , tile ) ) { jas_eprintf ( \"jpc_dec_decodecblks failed\\\\n\" ) ; return - 1 ; } for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { ccp = & tile -> cp -> ccps [ compno ] ; for ( rlvlno = 0 , rlvl = tcomp -> rlvls ; rlvlno < tcomp -> numrlvls ; ++ rlvlno , ++ rlvl ) { if ( ! rlvl -> bands ) { continue ; } for ( bandno = 0 , band = rlvl -> bands ; bandno < rlvl -> numbands ; ++ bandno , ++ band ) { if ( ! band -> data ) { continue ; } jpc_undo_roi ( band -> data , band -> roishift , ccp -> roishift - band -> roishift , band -> numbps ) ; if ( tile -> realmode ) { jas_matrix_asl ( band -> data , JPC_FIX_FRACBITS ) ; jpc_dequantize ( band -> data , band -> absstepsize ) ; } } } } for ( compno = 0 , tcomp = tile -> tcomps ; compno < dec -> numcomps ; ++ compno , ++ tcomp ) { ccp =",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> jas_eprintf ( \"RCT requires at least three components\\\\n\" ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( \"RCT requires all components have the same domain\\\\n\" <vul-start> 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( \"RCT requires all components have the same domain\\\\n\" ) ; return - 1 ; }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> 3 ) { if ( tile -> realmode ) { jas_eprintf ( \"RCT requires at least three components, but is a real\\\\n\" ) ; return - 1 ; } <vul-end> return - 1 <vul-start> 1 ; } if (! <vul-start> -> data, dec -> numcomps,\n"
 },
 {
  "id": 87,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void Bezier ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { <vul-start> outpos += <vul-end> sprintf ( outpos , \"\\\\n %12.3f %12.3f %12.3f %12.3f %12.3f %12.3f c\" , x1 , y1 , x2 , y2 , x3 , y3 ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> y3 ) { sprintf ( outputbuffer <vul-end> , \"\\\\n %12.3f %12.3f %12.3f %12.3f %12.3f %12.3f c\" , <vul-start> y3 ) ; sendClean ( outputbuffer ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> y3 ) { sprintf ( outputbuffer <vul-end>, \"\\\\n %12.3f %12.3f %12.3f %12.3f %12.3f c\", <vul-start> y3 ) ; sendClean ( outputbuffer ) ;\n"
 },
 {
  "id": 88,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void loadServerConfigFromString ( char * config ) { char * err = NULL ; int linenum = 0 , totlines , i ; int slaveof_linenum = 0 ; sds * lines ; lines = sdssplitlen ( config , strlen ( config ) , \"\\\\n\" , 1 , & totlines ) ; for ( i = 0 ; i < totlines ; i ++ ) { sds * argv ; int argc ; linenum = i + 1 ; lines [ i ] = sdstrim ( lines [ i ] , \" \\\\t\\\\r\\\\n\" ) ; if ( lines [ i ] [ 0 ] == '#' || lines [ i ] [ 0 ] == '\\\\0' ) continue ; argv = sdssplitargs ( lines [ i ] , & argc ) ; if ( argv == NULL ) { err = \"Unbalanced quotes in configuration line\" ; goto loaderr ; } if ( argc == 0 ) { sdsfreesplitres ( argv , argc ) ; continue ; } sdstolower ( argv [ 0 ] ) ; if ( ! strcasecmp ( argv [ 0 ] , \"timeout\" ) && argc == 2 ) { server . maxidletime = atoi ( argv [ 1 ] ) ; if ( server . maxidletime < 0 ) { err = \"Invalid timeout value\" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , \"tcp-keepalive\" ) && argc == 2 ) { server . tcpkeepalive = atoi ( argv [ 1 ] ) ; if ( server . tcpkeepalive < 0 ) {",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> == - 1 || class == CLIENT_TYPE_MASTER ) { err = \"Unrecognized client limit class: the user specified \" \"an invalid one, or \\'master\\' which has no buffer limits.\" <vul-end> ; goto loaderr\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int soft_seconds ; int debug = 0 ; <vul-start> loaderr ; } if (! strcasecmp ( argv [ 0 ], \"debug\" ) && argc == 2 ) { debug = yesnotoi ( argv [ 1 ] ) ; if ( debug < 0 ) { err = \"Invalid debug value\" ; goto loaderr ; } } else if (! strcasecmp ( argv [ 0 ], \"tcp-keepalive\" ) && argc == 2 ) { if ( server. tcp_keepalive < 0 ) { err = \"Invalid tcp-keepalive value\" ; goto loaderr ; } } else if (! strcasecmp ( argv [ 0 ], \"dir\" ) && argc == 2 ) { if ( chdir ( argv [ 1 ] ) == - 1 ) { err = \"Can\\'t chdir to \\'%s\\': %s\", argv [ 1 ], strerror ( errno ) ) ; goto loaderr ; } } else if (! strcasecmp ( argv [ 0 ], \"unix-timeout\" ) && argc == 2 ) { server. unix_timeout = atoi ( argv [ 1 ] ) ; if ( server. unixtimeout < 0 ) { err = \"Invalid unix-timeout value\" ; goto loaderr ; } } else if (! strcasecmp ( argv [ 0 ], \"tcp-keepalive\" ) && argc == 2 ) { server. tcp_keepalive = atoi ( argv [ 1 ] ) ; if ( server. tcp_keepalive < 0 ) { err = \"Invalid tcp-keepalive value\" ; goto loaderr ; } } else if (! strcasecmp ( argv [ 0 ], \"bind\" ) && argc == 2 ) { if ( server. bindaddr_count == 0 ) { err = \"Invalid bind address count\" ; goto loaderr ; } } else if (! strcasecmp ( argv [ 0 ], \"dir\" ) && argc == 2 ) { if ( server. dir == 0 ) { server. dir = zstrdup ( argv [ 1 ] ) ; } else if (! strcasecmp ( argv [ 0 ], \"unix-timeout\" ) && argc == 2 ) { server. timeout = atoi ( argv [ 1 ] ) ; if ( server. timeout < 0 ) { err = \"Invalid timeout value\" ; goto loaderr ; } } else if (! strcasecmp ( argv [ 0 ], \"tcp-keep"
 },
 {
  "id": 89,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const char * parse_string ( cJSON * item , const char * str , const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \\'\\\\\"\\' ) { * ep = str ; return 0 ; } <vul-start> while ( * end_ptr != \\'\\\\\"\\' && * end_ptr && ++ len ) if ( * end_ptr ++ == '\\\\\\\\' ) end_ptr ++ ; <vul-end> out = ( char * ) cJSON_malloc ( len + 1 ) ; if ( ! out ) return 0 ; item -> valuestring = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) { if ( * ptr != '\\\\\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\\\b' ; break ; case 'f' : * ptr2 ++ = '\\\\f' ; break ; case 'n' : * ptr2 ++ = '\\\\n' ; break ; case 'r' : * ptr2 ++ = '\\\\r' ; break ; case 't' : * ptr2 ++ = '\\\\t' ; break ; case 'u' : uc = parse_hex4 ( ptr + 1 ) ; ptr += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } if ( (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ++ len ) { <vul-start> == '\\\\\\\\' ) { if ( * end_ptr == '\\\\0' ) { return 0 ; } end_ptr ++ ; } } <vul-end> out = (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } while ( end_ptr < end_ptr && <vul-start> == '\\\\\\\\' ) { end_ptr ++ ; } <vul-end> out = (\n"
 },
 {
  "id": 90,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 ssize_t tcp_splice_read ( struct socket * sock , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) { struct sock * sk = sock -> sk ; struct tcp_splice_state tss = { . pipe = pipe , . len = len , . flags = flags , } ; long timeo ; ssize_t spliced ; int ret ; sock_rps_record_flow ( sk ) ; if ( unlikely ( * ppos ) ) return - ESPIPE ; ret = spliced = 0 ; lock_sock ( sk ) ; timeo = sock_rcvtimeo ( sk , sock -> file -> f_flags & O_NONBLOCK ) ; while ( tss . len ) { ret = __tcp_splice_read ( sk , & tss ) ; if ( ret < 0 ) break ; else if ( ! ret ) { if ( spliced ) break ; if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { ret = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) ret = - ENOTCONN ; break ; } if ( ! timeo ) { ret = - EAGAIN ; break ; } <vul-start> sk_wait_data ( sk , & timeo , NULL ) ; <vul-end> if ( signal_pending ( current ) ) { ret = sock_intr_errno ( timeo ) ; break ; } continue ; } tss . len -= ret ; spliced",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;\n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> break ; } if (! sk_is_gso ( sk ) ) { release_sock ( sk ) ; ret = - EBADF ; break ; }\n"
 },
 {
  "id": 91,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 bool inode_owner_or_capable ( const struct inode * inode ) <vul-start> { <vul-end> if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ; <vul-start> if ( inode_capable ( inode , CAP_FOWNER ) ) <vul-end> return true ; return false ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> inode ) { struct user_namespace * ns ; <vul-start> return true ; ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <vul-end> ) ) return\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> inode ) { struct user_namespace * user_ns = current_user_ns ( ) ; <vul-start>, CAP_FOWNER ) && user_ns -> user_ns!= current_ns ( )\n"
 },
 {
  "id": 92,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; <vul-start> if ( ! fs_searchpaths ) <vul-end> Com_Error ( ERR_FATAL , \"Filesystem call made without initialization\" ) ; <vul-start> for ( search = fs_searchpaths ; search ; search = search -> next ) <vul-end> <vul-start> { <vul-end> len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } # ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , \"%s\\\\n\" , filename ) ; # endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> long len ; qboolean isLocalConfig ; <vul-start> \"Filesystem call made without initialization\" ) ; isLocalConfig = ! strcmp ( filename , \"autoexec.cfg\" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <vul-start> next ) { if ( isLocalConfig && search -> pack ) continue ;\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> long len ; dirdata_t dirdata ; <vul-start> \"Filesystem call made without initialization\" ) ; dirdata = { 0 } ; <vul-start> next ) { if (! file ||! dirdata. data ) { Com_Error ( ERR_FATAL, \"Filesystem call made without data\" ) ; return - 1 ; }\n"
 },
 {
  "id": 93,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void write_profile ( BITSTREAM_PROFILE profile , <vul-start> struct vp9_write_bit_buffer * wb ) { <vul-end> <vul-start> assert ( profile < MAX_PROFILES ) ; <vul-end> <vul-start> vp9_wb_write_bit ( wb , profile & 1 ) ; <vul-end> <vul-start> vp9_wb_write_bit ( wb , profile >> 1 ) ; <vul-end> <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> profile , struct vpx_write_bit_buffer <vul-end> * wb ) <vul-start> wb ) { switch ( profile ) { case PROFILE_0 : vpx_wb_write_literal ( wb , 0 , 2 ) ; break ; case PROFILE_1 : vpx_wb_write_literal <vul-end> ( wb , <vul-start> ( wb , 2 , 2 ) ; break ; case PROFILE_2 : vpx_wb_write_literal <vul-end> ( wb , <vul-start> ( wb , 1 , 2 ) ; break ; case PROFILE_3 : vpx_wb_write_literal ( wb , 6 , 3 ) ; break ; default : assert ( 0 <vul-end> ) ; } <vul-start> ) ; } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> profile, struct vpx_write_bit_buffer <vul-end> * wb ) <vul-start> wb ) { if <vul-end> ( profile < <vul-start> ( profile < MAX_PROFILES ) { vpx_wb_write_bit <vul-end> ( wb, <vul-start> 1 ) ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> ) ; } }\n"
 },
 {
  "id": 94,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static bool check_underflow ( const struct arpt_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <vul-start> if ( ! unconditional ( & e -> arp ) ) <vul-end> return false ; t = arpt_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ! unconditional ( e <vul-end> ) ) return\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>! unconditional ( e <vul-end> ) ) return\n"
 },
 {
  "id": 95,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( \"%s failed vm entry %x\\\\n\" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <vul-start> return 1 ; <vul-end> case EXIT_REASON_CR_ACCESS :",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> case EXIT_REASON_VMON : case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu, vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_vmx_exit_handled_dr ( vcpu, vmcs12 ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu, vmcs12, exit_reason ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12, CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12, CPU_BASED_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_TPR_BELOW_THRESHOLD :\n"
 },
 {
  "id": 96,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void IGDstartelt ( void * d , const char * name , int l ) { <vul-start> struct IGDdatas * datas = ( struct IGDdatas * ) d ; <vul-end> memcpy ( datas -> cureltname , name , l ) ; datas -> cureltname [ l ] = '\\\\0' ; datas -> level ++ ; if ( ( l == 7 ) && ! memcmp ( name , \"service\" , l ) ) { datas -> tmp . controlurl [ 0 ] = '\\\\0' ; datas -> tmp . eventsuburl [ 0 ] = '\\\\0' ; datas -> tmp . scpdurl [ 0 ] = '\\\\0' ; datas -> tmp . servicetype [ 0 ] = '\\\\0' ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * ) d ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) d ; if ( l >= sizeof ( datas -> cureltname ) ) { return ; }\n"
 },
 {
  "id": 97,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyMODINIT_FUNC PyInit__ast ( void ) { PyObject * m , * d ; if ( ! init_types ( ) ) return NULL ; m = PyModule_Create ( & _astmodule ) ; if ( ! m ) return NULL ; d = PyModule_GetDict ( m ) ; if ( PyDict_SetItemString ( d , \"AST\" , ( PyObject * ) & AST_type ) < 0 ) return NULL ; if ( PyModule_AddIntMacro ( m , PyCF_ONLY_AST ) < 0 ) return NULL ; <vul-start> if ( PyDict_SetItemString ( d , \"mod\" , ( PyObject * ) mod_type ) < 0 ) return NULL ; <vul-end> if ( PyDict_SetItemString ( d , \"Module\" , ( PyObject * ) Module_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Interactive\" , ( PyObject * ) Interactive_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Expression\" , ( PyObject * ) Expression_type ) < 0 ) return NULL ; <vul-start> if ( PyDict_SetItemString ( d , \"Suite\" , ( PyObject * ) Suite_type ) < 0 ) return <vul-end> NULL ; if ( PyDict_SetItemString ( d , \"stmt\" , ( PyObject * ) stmt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"FunctionDef\" , ( PyObject * ) FunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"AsyncFunctionDef\" , ( PyObject * ) AsyncFunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"ClassDef\" , ( PyObject * ) ClassDef_type ) < 0 ) return NULL ;",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; if ( PyModule_AddIntMacro ( m , PyCF_TYPE_COMMENTS ) < 0 ) return NULL ; if ( <vul-start> ( d , \"FunctionType\" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , <vul-start> * ) withitem_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"type_ignore\" , ( PyObject * ) type_ignore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"TypeIgnore\" , ( PyObject * ) TypeIgnore_type\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( d, \"TypeFlags\", ( PyObject * ) TypeFlags_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d, <vul-start> ( d, \"TypeFlags\", ( PyObject * ) TypeFlags_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d, <vul-start> ( d, \"TypeFlags\", ( PyObject * ) TypeFlags_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d,\n"
 },
 {
  "id": 98,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static OPJ_BOOL opj_j2k_write_mco ( opj_j2k_t * p_j2k , struct opj_stream_private * p_stream , struct opj_event_mgr * p_manager ) { OPJ_BYTE * l_current_data = 00 ; OPJ_UINT32 l_mco_size ; opj_tcp_t * l_tcp = 00 ; opj_simple_mcc_decorrelation_data_t * l_mcc_record ; OPJ_UINT32 i ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; l_tcp = & ( p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] ) ; <vul-start> l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ; <vul-end> l_mco_size = 5 + l_tcp -> m_nb_mcc_records ; if ( l_mco_size > p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size ) { OPJ_BYTE * new_header_tile_data = ( OPJ_BYTE * ) opj_realloc ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data , l_mco_size ) ; if ( ! new_header_tile_data ) { opj_free ( p_j2k -> m_specific_param . m_encoder . m_header_tile_data ) ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data = NULL ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = 0 ; opj_event_msg ( p_manager , EVT_ERROR , \"Not enough memory to write MCO marker\\\\n\" ) ; return OPJ_FALSE ; } p_j2k -> m_specific_param . m_encoder . m_header_tile_data = new_header_tile_data ; p_j2k -> m_specific_param . m_encoder . m_header_tile_data_size = l_mco_size ; } <vul-start> opj_write_bytes ( l_current_data , J2K_MS_MCO , 2 ) ; <vul-end> l_current_data += 2 ; opj_write_bytes ( l_current_data , l_mco_size - 2 , 2 ) ; l_current_data += 2 ; opj_write_bytes ( l_current_data , l_tcp -> m_nb_mcc_records , 1 ) ; ++ l_current_data ; l_mcc_record = l_tcp -> m_mcc_records ; for ( i = 0 ;",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ] ) ; <vul-end> l_mco_size = 5 <vul-start> l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ] ) ; if ( l_tcp -> m_nb_mcc_records > 20 ) { opj_event_msg ( p_manager, EVT_ERROR, \"Too many MCC records\\\\n\" ) ; return OPJ_FALSE ; } <vul-start> ; } } if ( p_j2k -> m_specific_param. m_encoder. m_header_tile_data_size!= 0 ) { opj_free ( p_j2k -> m_specific_param. m_encoder. m_header_tile_data ) ; p_j2k -> m_specific_param. m_encoder. m_header_tile_data = NULL ; p_j2k -> m_specific_param. m_encoder. m_header_tile_data_size = 0 ; }\n"
 },
 {
  "id": 99,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void ctrycatchfinally ( JF , js_Ast * trystm , js_Ast * catchvar , js_Ast * catchstm , js_Ast * finallystm ) { int L1 , L2 , L3 ; L1 = emitjump ( J , F , OP_TRY ) ; { L2 = emitjump ( J , F , OP_TRY ) ; { cstm ( J , F , finallystm ) ; emit ( J , F , OP_THROW ) ; } label ( J , F , L2 ) ; if ( F -> strict ) { checkfutureword ( J , F , catchvar ) ; if ( ! strcmp ( catchvar -> string , \"arguments\" ) ) jsC_error ( J , catchvar , \"redefining \\'arguments\\' is not allowed in strict mode\" ) ; if ( ! strcmp ( catchvar -> string , \"eval\" ) ) jsC_error ( J , catchvar , \"redefining \\'eval\\' is not allowed in strict mode\" ) ; } emitline ( J , F , catchvar ) ; emitstring ( J , F , OP_CATCH , catchvar -> string ) ; cstm ( J , F , catchstm ) ; emit ( J , F , OP_ENDCATCH ) ; <vul-start> L3 = emitjump ( J , F , OP_JUMP ) ; <vul-end> } label ( J , F , L1 ) ; cstm ( J , F , trystm ) ; emit ( J , F , OP_ENDTRY ) ; label ( J , F , L3 ) ; cstm ( J , F , finallystm ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> OP_ENDCATCH ) ; emit ( J , F , OP_ENDTRY ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> OP_ENDCATCH ) ; if ( J -> type == OP_TYPE_COMMENT ) { checkfutureword ( J, catchvar ) ; if (! strcmp ( catchvar -> string, \"type_comment\" ) ) jsC_error ( J, catchvar, \"redefining \\'type_comment\\' is not allowed in strict mode\" ) ; }\n"
 },
 {
  "id": 100,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 struct lookahead_ctx * vp9_lookahead_init ( unsigned int width , unsigned int height , unsigned int subsampling_x , unsigned int subsampling_y , <vul-start> unsigned int depth ) { <vul-end> struct lookahead_ctx * ctx = NULL ; depth = clamp ( depth , 1 , MAX_LAG_BUFFERS ) ; depth += MAX_PRE_FRAMES ; ctx = calloc ( 1 , sizeof ( * ctx ) ) ; if ( ctx ) { <vul-start> unsigned int i ; <vul-end> ctx -> max_sz = depth ; ctx -> buf = calloc ( depth , sizeof ( * ctx -> buf ) ) ; if ( ! ctx -> buf ) goto bail ; for ( i = 0 ; i < depth ; i ++ ) <vul-start> if ( vp9_alloc_frame_buffer ( & ctx -> buf [ i ] . img , <vul-end> width , height , subsampling_x , subsampling_y , <vul-start> VP9_ENC_BORDER_IN_PIXELS ) ) <vul-end> goto bail ; } return ctx ; bail : vp9_lookahead_destroy ( ctx ) ; return NULL ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <vul-start> ctx ) { const int legacy_byte_alignment = 0 ; <vul-start> ) if ( vpx_alloc_frame_buffer <vul-end> ( & ctx <vul-start> , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , legacy_byte_alignment <vul-end> ) ) goto\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> unsigned int depth, vpx_bit_depth_t bit_depth <vul-start> unsigned int i ; unsigned int ret <vul-start> i ++ ) ret = <vul-end> vp9_alloc_frame_buffer ( & <vul-start>, VP9_ENC_BORDER_IN_PIXELS ) ; if ( ret ) goto bail ; ctx -> buf [ i ]. img. bit_depth = bit_depth <vul-end> ; } return\n"
 },
 {
  "id": 101,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int mlx5_fpga_conn_create_cq ( struct mlx5_fpga_conn * conn , int cq_size ) { struct mlx5_fpga_device * fdev = conn -> fdev ; struct mlx5_core_dev * mdev = fdev -> mdev ; u32 temp_cqc [ MLX5_ST_SZ_DW ( cqc ) ] = { 0 } ; u32 out [ MLX5_ST_SZ_DW ( create_cq_out ) ] ; struct mlx5_wq_param wqp ; struct mlx5_cqe64 * cqe ; int inlen , err , eqn ; unsigned int irqn ; void * cqc , * in ; __be64 * pas ; u32 i ; cq_size = roundup_pow_of_two ( cq_size ) ; MLX5_SET ( cqc , temp_cqc , log_cq_size , ilog2 ( cq_size ) ) ; wqp . buf_numa_node = mdev -> priv . numa_node ; wqp . db_numa_node = mdev -> priv . numa_node ; err = mlx5_cqwq_create ( mdev , & wqp , temp_cqc , & conn -> cq . wq , & conn -> cq . wq_ctrl ) ; if ( err ) return err ; for ( i = 0 ; i < mlx5_cqwq_get_size ( & conn -> cq . wq ) ; i ++ ) { cqe = mlx5_cqwq_get_wqe ( & conn -> cq . wq , i ) ; cqe -> op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK ; } inlen = MLX5_ST_SZ_BYTES ( create_cq_in ) + sizeof ( u64 ) * conn -> cq . wq_ctrl . buf . npages ; in = kvzalloc ( inlen , GFP_KERNEL ) ; if ( ! in ) { err = - ENOMEM ; goto err_cqwq ; } err = mlx5_vector2eqn ( mdev , smp_processor_id ( ) , &",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> ( err ) { kvfree ( in ) ; <vul-start> goto err_cqwq ; }\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> if ( err < 0 <vul-start> ) goto err_cqwq ; err = - EINVAL\n"
 },
 {
  "id": 102,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void set_good_speed_feature ( VP9_COMP * cpi , VP9_COMMON * cm , SPEED_FEATURES * sf , int speed ) { <vul-start> sf -> adaptive_rd_thresh = 1 ; <vul-end> sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ; sf -> allow_skip_recode = 1 ; if ( speed >= 1 ) { <vul-start> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; <vul-end> <vul-start> sf -> less_rectangular_check = 1 ; <vul-end> <vul-start> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <vul-end> : USE_LARGESTALL ; if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ; sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search = 1 ; <vul-start> sf -> auto_mv_step_size = 1 ; <vul-end> sf -> adaptive_rd_thresh = 2 ; <vul-start> sf -> subpel_iters_per_step = 1 ; <vul-end> sf -> mode_skip_start = 10 ; sf -> adaptive_pred_interp_filter = 1 ; sf -> recode_loop = ALLOW_RECODE_KFARFGF ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <vul-start> sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <vul-end> } if ( speed >= 2 ) { <vul-start> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <vul-end> : USE_LARGESTALL ; <vul-start> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <vul-end> sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> speed ) { const int boosted = frame_is_boosted ( cpi ) ; <vul-start> adaptive_rd_thresh = 1 <vul-end> ; sf -> <vul-start> 1 ) { if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <vul-start> cm ) ; } <vul-start> ; sf -> <vul-end> use_rd_breakout = 1 <vul-start> ; sf -> mv . <vul-start> ; sf -> mv . <vul-start> ] = INTRA_DC_H_V ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 <vul-start> -> tx_size_search_method = frame_is_boosted <vul-end> ( cpi ) <vul-start> : USE_LARGESTALL ; sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = <vul-end> ( cm -> <vul-start> ( cm -> frame_type == KEY_FRAME ) ? 0 : <vul-end> FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER <vul-start> ; sf -> allow_partition_search_skip = 1 <vul-end> ; } if <vul-start> 3 ) { sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <vul-end> ; sf -> <vul-start> ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <vul-end> = 1 ; <vul-start> ; sf -> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE <vul-end> ; sf -> <vul-start> = 4 ; if ( cm -> frame_type != KEY_FRAME ) <vul-start> -> mode_search_skip_flags |= <vul-end> FLAG_EARLY_TERMINATE ; sf <vul-start> ; sf -> <vul-end> use_lp32x32fdct = 1 <vul-start> use_lp32x32fdct = 1 ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <vul-start> ; sf -> <vul-end> optimize_coefficients = 0 <vul-start> ; sf -> mv . <vul-start> i ] = INTRA_DC <vul-end> ; sf -> <vul-start> i ] = INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <vul-end> ; } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { sf -> <vul-end> recode_loop = ( <vul-start> { sf -> <vul-end> use_square_partition_only =! <vul-start> ; sf -> <vul-end> less_rectangular_check = 1 <vul-start> -> tx_size_search_method = vp9_get_tx_size_search_method ( cpi ) <vul-end> ; sf -> <vul-start> ; sf -> <vul-end> use_rd_breakout = 1 <vul-start> ; sf -> <vul-end> mode_skip_start = 10 <vul-start> ; sf -> <vul-end> mode_search_skip_flags = FLAG_SKIP_COMP_REFMISMATCH <vul-start> ] = INTRA_DC_H_V <vul-end> ; } if <vul-start> { sf -> <vul-end> adaptive_y_mode_mask [ TX_32X32 <vul-start> i ] = INTRA_Y_SPLIT <vul-end> ; sf -> <vul-start> -> intra_uv_mode_mask [ TX_16X16 <vul-end> ] = INTRA_DC_H_V <vul-start> ; sf -> <vul-end> adaptive_pred_interp_filter = 2 <vul-start> ; sf -> reference_masking = 1 ; sf -> mode_search_skip_flags = ( speed < 1 )? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ; sf -> last_partitioning_redo_frequency = 3 ; } if ( speed >= 3 ) { if ( MIN ( cm -> width, cm -> height ) >= 720 ) sf -> disable_split_mask = DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ; } if ( speed >= 4 ) { sf -> use_square_partition_only = 1 ; sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi )? USE_FULL_RD : USE_LARGESTALL <vul-end> ; } if <vul-start> ; sf -> <vul-end> use_square_partition_only = 1 <vul-start> ; sf -> <vul-end> adaptive_rd_thresh = 4 <vul-start> ; sf -> <vul-end> mode_skip_start = 10 <vul-start> -> mode_skip_start = ( speed < 1 )? SKIP_PRE_LOOP_REDUCED : <vul-start> ; sf -> <vul-end> adaptive_pred_interp_filter = 2 <vul-start> -> intra_y"
 },
 {
  "id": 103,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int __br_mdb_del ( struct net_bridge * br , struct br_mdb_entry * entry ) { struct net_bridge_mdb_htable * mdb ; struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; struct br_ip ip ; int err = - EINVAL ; if ( ! netif_running ( br -> dev ) || br -> multicast_disabled ) return - EINVAL ; if ( timer_pending ( & br -> multicast_querier_timer ) ) return - EBUSY ; ip . proto = entry -> addr . proto ; if ( ip . proto == htons ( ETH_P_IP ) ) ip . u . ip4 = entry -> addr . u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) else ip . u . ip6 = entry -> addr . u . ip6 ; # endif spin_lock_bh ( & br -> multicast_lock ) ; mdb = mlock_dereference ( br -> mdb , br ) ; mp = br_mdb_ip_get ( mdb , & ip ) ; if ( ! mp ) goto unlock ; for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( ! p -> port || p -> port -> dev -> ifindex != entry -> ifindex ) continue ; if ( p -> port -> state == BR_STATE_DISABLED ) goto unlock ; rcu_assign_pointer ( * pp , p -> next ) ; hlist_del_init ( & p -> mglist ) ; del_timer ( & p -> timer ) ;",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> -> mglist && mp -> timer_armed &&\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> mglist && mp -> timer_armed &&\n"
 },
 {
  "id": 104,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info ctinfo , u_int8_t pf , unsigned int hooknum , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; enum ip_conntrack_dir dir = CTINFO2DIR ( ctinfo ) ; struct dccp_hdr _dh , * dh ; u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ; <vul-start> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <vul-end> BUG_ON ( dh == NULL ) ; type = dh -> dccph_type ; if ( type == DCCP_PKT_RESET && ! test_bit ( IPS_SEEN_REPLY_BIT , & ct -> status ) ) { nf_ct_kill_acct ( ct , ctinfo , skb ) ; return NF_ACCEPT ; } spin_lock_bh ( & ct -> lock ) ; role = ct -> proto . dccp . role [ dir ] ; old_state = ct -> proto . dccp . state ; new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; switch ( new_state ) { case CT_DCCP_REQUEST : if ( old_state == CT_DCCP_TIMEWAIT && role == CT_DCCP_ROLE_SERVER ) { ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_SERVER ; } break ; case CT_DCCP_RESPOND : if ( old_state == CT_DCCP_REQUEST ) ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; break ; case CT_DCCP_PARTOPEN : if ( old_state == CT_DCCP_RESPOND && type == DCCP_PKT_ACK",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ) , & _dh <vul-end> ) ; BUG_ON\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ct_dccp_roles role ; if ( dir >= AF_INET ) return NF_ACCEPT ;\n"
 },
 {
  "id": 105,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <vul-start> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <vul-end> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> 0 ; i < <vul-end> SERDES_MAX ; i\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 0 ; i < <vul-end> SERDES_MAX ; i\n"
 },
 {
  "id": 106,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static ext4_io_end_t * ext4_init_io_end ( struct inode * inode ) <vul-end> { ext4_io_end_t * io = NULL ; <vul-start> io = kmalloc ( sizeof ( * io ) , GFP_NOFS ) ; <vul-end> if ( io ) { igrab ( inode ) ; io -> inode = inode ; io -> flag = 0 ; io -> offset = 0 ; io -> size = 0 ; <vul-start> io -> error = 0 ; <vul-end> INIT_WORK ( & io -> work , ext4_end_io_work ) ; INIT_LIST_HEAD ( & io -> list ) ; } return io ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> inode * inode , gfp_t flags <vul-start> io ) , flags <vul-end> ) ; if <vul-start> ; io -> page = NULL <vul-end> ; INIT_WORK (\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> inode * inode, struct ext4_inode_info * ei <vul-start> ; io = kzalloc <vul-end> ( sizeof ( <vul-start> ; io -> ei = ei ; io ->\n"
 },
 {
  "id": 107,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int gtStripContig ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileContigRoutine put = img -> put . contig ; uint32 row , y , nrow , nrowsub , rowstoread ; tmsize_t pos ; unsigned char * buf = NULL ; uint32 rowsperstrip ; uint16 subsamplinghor , subsamplingver ; uint32 imagewidth = img -> width ; tmsize_t scanline ; int32 fromskew , toskew ; int ret = 1 , flip ; tmsize_t maxstripsize ; TIFFGetFieldDefaulted ( tif , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplingver == 0 ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , \"Invalid vertical YCbCr subsampling\" ) ; return ( 0 ) ; } maxstripsize = TIFFStripSize ( tif ) ; flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { y = h - 1 ; toskew = - ( int32 ) ( w + w ) ; } else { y = 0 ; toskew = - ( int32 ) ( w - w ) ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; scanline = TIFFScanlineSize ( tif ) ; fromskew = ( w < imagewidth ? imagewidth - w : 0 ) ; for ( row = 0 ; row < h ; row += nrow ) <vul-start> { <vul-end> rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; nrow = ( row + rowstoread > h ? h -",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> nrow ) { uint32 temp ; <vul-start> % subsamplingver ; temp = ( row + img -> row_offset ) % rowsperstrip + nrowsub ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , \"Integer overflow in gtStripContig\" ) ; return 0 ; } <vul-start> , maxstripsize , temp <vul-end> * scanline )\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> += nrow ) { if ( row >= h ) { TIFFErrorExt ( tif -> tif_clientdata, TIFFFileName ( tif ), \"Integer overflow in gtStripContig\" ) ; return 0 ; } <vul-end> rowstoread = rowsperstrip <vul-start>, maxstripsize, scanline, <vul-end> ( row + <vul-start> % subsamplingver ; if ( row >= h ) { TIFFErrorExt ( tif -> tif_clientdata, TIFFFileName ( tif ), \"Integer overflow in gtStripContig\" ) ; return 0 ; }\n"
 },
 {
  "id": 108,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void ikev2_parent_inI2outR2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( \"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , \"%s: Request was disconnected from state\" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI2outR2_tail ( pcrc , r ) ; if ( e > STF_FAIL ) { int v2_notify_num = e - STF_FAIL ; DBG_log ( \"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\" , enum_name ( & ikev2_notify_names , v2_notify_num ) ) ; } else if ( e != STF_OK ) { DBG_log ( \"ikev2_parent_inI2outR2_tail returned %s\" , enum_name ( & stfstatus_name , e ) ) ; } if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; <vul-start> passert ( GLOBALS_ARE_RESET ( ) ) ;",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> }    \n"
 },
 {
  "id": 109,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; <vul-start> int copied , error = - EINVAL ; <vul-end> msg -> msg_namelen = 0 ; if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( \"%d -= %d\\\\n\" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> = - EINVAL <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = - EINVAL <vul-end> ; if (\n"
 },
 {
  "id": 110,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 tsize_t t2p_readwrite_pdf_image_tile ( T2P * t2p , TIFF * input , TIFF * output , ttile_t tile ) { uint16 edge = 0 ; tsize_t written = 0 ; unsigned char * buffer = NULL ; tsize_t bufferoffset = 0 ; unsigned char * samplebuffer = NULL ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; uint16 i = 0 ; ttile_t tilecount = 0 ; ttile_t septilecount = 0 ; tsize_t septilesize = 0 ; # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint32 xuint32 = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; edge |= t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; edge |= t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; if ( ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) && ( ( edge == 0 ) # if defined ( JPEG_SUPPORT ) || defined ( OJPEG_SUPPORT ) || ( t2p -> pdf_compression == T2P_COMPRESS_JPEG ) # endif ) ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawTile ( input , tile , ( tdata_t )",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> if ( count > <vul-end> 4 ) {\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> if ( count > 2 <vul-end> ) { int\n"
 },
 {
  "id": 111,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void joint_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bsize , int_mv * frame_mv , int mi_row , int mi_col , int_mv single_newmv [ MAX_REF_FRAMES ] , int * rate_mv ) { <vul-start> const int pw = 4 * num_4x4_blocks_wide_lookup [ bsize ] ; <vul-end> const int ph = 4 * num_4x4_blocks_high_lookup [ bsize ] ; MACROBLOCKD * xd = & x -> e_mbd ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; const int refs [ 2 ] = { mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] } ; int_mv ref_mv [ 2 ] ; int ite , ref ; <vul-start> uint8_t * second_pred = vpx_memalign ( 16 , pw * ph * sizeof ( uint8_t ) ) ; <vul-end> <vul-start> const InterpKernel * kernel = vp9_get_interp_kernel ( mbmi -> interp_filter ) ; <vul-end> struct buf_2d backup_yv12 [ 2 ] [ MAX_MB_PLANE ] ; <vul-start> struct buf_2d scaled_first_yv12 = xd -> plane [ 0 ] . pre [ 0 ] ; <vul-end> int last_besterr [ 2 ] = { INT_MAX , INT_MAX } ; const YV12_BUFFER_CONFIG * const scaled_ref_frame [ 2 ] = { vp9_get_scaled_ref_frame ( cpi , mbmi -> ref_frame [ 0 ] ) , vp9_get_scaled_ref_frame ( cpi , mbmi -> ref_frame [ 1 ] ) } ; <vul-start> for ( ref = 0 ; ref < 2 ; ++ ref ) { <vul-end> <vul-start> ref_mv [ ref ] = mbmi -> ref_mvs [ refs [",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) { const VP9_COMMON * const cm = & cpi -> common ; const <vul-start> , ref ; <vul-end> const InterpKernel * <vul-start> * kernel = vp9_filter_kernels [ <vul-end> mbmi -> interp_filter <vul-start> mbmi -> interp_filter ] ; struct scale_factors sf <vul-end> ; struct buf_2d <vul-start> MAX_MB_PLANE ] ; <vul-end> int last_besterr [ <vul-start> ) } ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , second_pred_alloc_16 [ 64 * 64 ] ) ; uint8_t * second_pred ; # else DECLARE_ALIGNED ( 16 , uint8_t , second_pred [ 64 * 64 ] ) ; # endif <vul-start> ref ] = x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> as_int ; } # if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height ) ; # endif <vul-start> -> sadperbit16 ; MV <vul-end> tmp_mv ; int <vul-start> 1 ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { second_pred = CONVERT_TO_BYTEPTR ( second_pred_alloc_16 ) ; vp9_highbd_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE , xd -> bd ) ; } else { second_pred = ( uint8_t * ) second_pred_alloc_16 ; <vul-start> as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; } # else vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; # endif if ( id ) xd -> <vul-end> plane [ 0 <vul-start> ) ; tmp_mv <vul-end> = frame_mv [ <vul-start> ] ] . as_mv ; tmp_mv <vul-end> . col >>= <vul-start> ; tmp_mv . <vul-end> row >>= 3 <vul-start> , & tmp_mv , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] <vul-start> . as_mv , second_pred <vul-end> ) ; if <vul-start> , & tmp_mv <vul-end> , & ref_mv <vul-start> = cpi -> find_fractional_mv_step <vul-end> ( x , <vul-start> , & tmp_mv , & ref_mv [ id ] <vul-start> . as_mv , <vul-end> cpi -> common <vul-start> -> sf . mv . subpel_iters_per_step , NULL , <vul-end> x -> nmvjointcost <vul-start> 0 ] = ref_yv12 [ 0 ] <vul-end> ; if ( <vul-start> ] ] . as_mv = tmp_mv <vul-end> ; last_besterr [ <vul-start> as_mv , & x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> ) ; } <vul-end> }    \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { const int ref_width = 4 * num_4x4_blocks_wide_lookup [ bsize ] ; const int ref_height = 4 * num_4x4_blocks_high_lookup [ bsize ] ; MACROBLOCKD * x <vul-end> = & x <vul-start>, ref ; <vul-end> const InterpKernel * <vul-start> * kernel = vp9_filter_kernels [ <vul-end> mbmi -> interp_filter <vul-start> mbmi -> interp_filter ] <vul-end> ; struct buf_2d <vul-start> struct buf_2d scaled_first_yv12 [ 2 ] ; int last_besterr [ 2 ] = { INT_MAX, INT_MAX } ; const YV12_BUFFER_CONFIG * const scaled_ref_frame [ 2 ] = { mbmi -> ref_frame [ 0 ], mbmi -> ref_frame [ 1 ] } ; const int16_t * const ref_mvs [ 2 ] = { mbmi -> ref_mvs [ ref ], mbmi -> ref_frame [ 2 ] } ; const int16_t * const second_pred = vpx_memalign ( 16, pw * ph * sizeof ( uint8_t ) ) ; const int low_res_pred = vpx_memalign ( 16, tmp_width * ph * sizeof ( int ) ) ; const int low_res_pred = vpx_memalign ( 16, tmp_height * ph * sizeof ( int ) ) <vul-end> ; int last_besterr <vul-start> ; ref < 3 <vul-end> ; ++ ref <vul-start> ref ) { const int mv = ref_mv [ ref ] ; <vul-start> as_mv ) ; const int subpel_iters_per_step = vp9_get_subpel_iters_per_step ( ref_mv [ ref ], xd -> plane [ 0 ]. pre [ ref ] = vp9_get_scaled_ref_frame ( cpi, ref_mv [ ref ] ) ; int i ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <vul-start> 0 ] = ref_mvs [ ref ] [ 0 ] ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { for ( i = 0 ; i < MAX_MB_PLANE ; ++"
 },
 {
  "id": 112,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int compat_get_timex ( struct timex * txc , const struct compat_timex __user * utp ) { struct compat_timex tx32 ; <vul-start> if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) <vul-end> return - EFAULT ; txc -> modes = tx32 . modes ; txc -> offset = tx32 . offset ; txc -> freq = tx32 . freq ; txc -> maxerror = tx32 . maxerror ; txc -> esterror = tx32 . esterror ; txc -> status = tx32 . status ; txc -> constant = tx32 . constant ; txc -> precision = tx32 . precision ; txc -> tolerance = tx32 . tolerance ; txc -> time . tv_sec = tx32 . time . tv_sec ; txc -> time . tv_usec = tx32 . time . tv_usec ; txc -> tick = tx32 . tick ; txc -> ppsfreq = tx32 . ppsfreq ; txc -> jitter = tx32 . jitter ; txc -> shift = tx32 . shift ; txc -> stabil = tx32 . stabil ; txc -> jitcnt = tx32 . jitcnt ; txc -> calcnt = tx32 . calcnt ; txc -> errcnt = tx32 . errcnt ; txc -> stbcnt = tx32 . stbcnt ; return 0 ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> compat_timex tx32 ; memset ( txc , 0 , sizeof ( struct timex ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> compat_timex tx32 ; memset ( txc, 0, sizeof ( * txc ) ) ;\n"
 },
 {
  "id": 113,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static INT AirPDcapScanForKeys ( PAIRPDCAP_CONTEXT ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , AIRPDCAP_SEC_ASSOCIATION_ID id ) { const UCHAR * addr ; guint bodyLength ; PAIRPDCAP_SEC_ASSOCIATION sta_sa ; PAIRPDCAP_SEC_ASSOCIATION sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8E } ; const guint8 bt_dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0D , 0x02 , 0X0C } ; const EAPOL_RSN_KEY * pEAPKey ; # ifdef _DEBUG # define MSGBUF_LEN 255 CHAR msgbuf [ MSGBUF_LEN ] ; # endif AIRPDCAP_DEBUG_TRACE_START ( \"AirPDcapScanForKeys\" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Authentication: EAPOL packet\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"Not EAPOL-Key\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } bodyLength = pntoh16 ( data + offset + 2 ) ; <vul-start> if ( ( tot_len - offset - 4 ) < bodyLength ) { <vul-end> AIRPDCAP_DEBUG_PRINT_LINE ( \"AirPDcapScanForKeys\" , \"EAPOL body too short\" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } offset += 4 ; pEAPKey",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> if ( ( ( <vul-start> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( tot_len < offset + 4 +\n"
 },
 {
  "id": 114,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void fill_variance ( int64_t s2 , int64_t s , int c , var * v ) { v -> sum_square_error = s2 ; v -> sum_error = s ; <vul-start> v -> count = c ; <vul-end> <vul-start> if ( c > 0 ) <vul-end> v -> variance = ( int ) ( 256 * ( v -> sum_square_error - v -> sum_error * v -> sum_error / v -> count ) / v -> count ) ; else v -> variance = 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; v -> log2_count <vul-end> = c ; <vul-start> = c ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = s ; if ( c > 0 ) v -> variance = ( int ) ( 256 * ( v -> sum_square_error - v -> sum_error * v -> sum_error / v -> count ) / v -> count ) ; else <vul-start> = c ; <vul-end> v -> variance\n"
 },
 {
  "id": 115,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void * sock_poll_thread ( void * arg ) { struct pollfd pfds [ MAX_POLL ] ; memset ( pfds , 0 , sizeof ( pfds ) ) ; int h = ( intptr_t ) arg ; for ( ; ; ) { prepare_poll_fds ( h , pfds ) ; <vul-start> int ret = poll ( pfds , ts [ h ] . poll_count , - 1 ) ; <vul-end> if ( ret == - 1 ) { APPL_TRACE_ERROR ( \"poll ret -1, exit the thread, errno:%d, err:%s\" , errno , strerror ( errno ) ) ; break ; } if ( ret != 0 ) { int need_process_data_fd = TRUE ; if ( pfds [ 0 ] . revents ) { asrt ( pfds [ 0 ] . fd == ts [ h ] . cmd_fdr ) ; if ( ! process_cmd_sock ( h ) ) { APPL_TRACE_DEBUG ( \"h:%d, process_cmd_sock return false, exit...\" , h ) ; break ; } if ( ret == 1 ) need_process_data_fd = FALSE ; else ret -- ; } if ( need_process_data_fd ) process_data_sock ( h , pfds , ret ) ; } else { APPL_TRACE_DEBUG ( \"no data, select ret: %d\" , ret ) } ; } ts [ h ] . thread_id = - 1 ; APPL_TRACE_DEBUG ( \"socket poll thread exiting, h:%d\" , h ) ; return 0 ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> int ret = TEMP_FAILURE_RETRY ( <vul-start> , - 1 )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> int ret = TEMP_FAILURE_RETRY ( <vul-start>, - 1 )\n"
 },
 {
  "id": 116,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static OPJ_BOOL opj_j2k_write_all_tile_parts ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , opj_stream_private_t * p_stream , struct opj_event_mgr * p_manager ) { OPJ_UINT32 tilepartno = 0 ; OPJ_UINT32 l_nb_bytes_written = 0 ; OPJ_UINT32 l_current_nb_bytes_written ; OPJ_UINT32 l_part_tile_size ; OPJ_UINT32 tot_num_tp ; OPJ_UINT32 pino ; OPJ_BYTE * l_begin_data ; opj_tcp_t * l_tcp = 00 ; opj_tcd_t * l_tcd = 00 ; opj_cp_t * l_cp = 00 ; l_tcd = p_j2k -> m_tcd ; l_cp = & ( p_j2k -> m_cp ) ; l_tcp = l_cp -> tcps + p_j2k -> m_current_tile_number ; tot_num_tp = opj_j2k_get_num_tp ( l_cp , 0 , p_j2k -> m_current_tile_number ) ; ++ p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; for ( tilepartno = 1 ; tilepartno < tot_num_tp ; ++ tilepartno ) { p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number = tilepartno ; l_current_nb_bytes_written = 0 ; l_part_tile_size = 0 ; l_begin_data = p_data ; <vul-start> if ( ! opj_j2k_write_sot ( p_j2k , p_data , & l_current_nb_bytes_written , p_stream , <vul-end> p_manager ) ) { return OPJ_FALSE ; } l_nb_bytes_written += l_current_nb_bytes_written ; p_data += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_part_tile_size += l_current_nb_bytes_written ; l_current_nb_bytes_written = 0 ; if ( ! opj_j2k_write_sod ( p_j2k , l_tcd , p_data , & l_current_nb_bytes_written , p_total_data_size , p_stream , p_manager ) ) { return OPJ_FALSE ; } p_data += l_current_nb_bytes_written ; l_nb_bytes_written += l_current_nb_bytes_written ; p_total_data_size -= l_current_nb_bytes_written ; l_part_tile_size += l_current_nb_bytes_written ; opj_write_bytes ( l_begin_data + 6 , l_part_tile_size , 4 ) ; if ( OPJ_IS_CINEMA ( l_cp -> rsiz ) ) { opj_j2k_update_tlm (",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> , p_data , p_total_data_size , <vul-start> , p_data , p_total_data_size ,\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>, p_data, p_total_data_size, <vul-start>, p_data, p_total_data_size,\n"
 },
 {
  "id": 117,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; <vul-start> break ; <vul-end> } return TRUE ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> objp ) ; * objp = NULL ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> objp ) ; else return FALSE ;\n"
 },
 {
  "id": 118,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) <vul-end> { WLog_DBG ( TAG , \"%s (Len: %\" PRIu16 \" MaxLen: %\" PRIu16 \" BufferOffset: %\" PRIu32 \")\" , name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ; if ( fields -> Len > 0 ) winpr_HexDump ( TAG , WLOG_DEBUG , fields -> Buffer , fields -> Len ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start>       static\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>       static\n"
 },
 {
  "id": 119,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static void ecryptfs_decode_from_filename ( unsigned char * dst , size_t * dst_size , const unsigned char * src , size_t src_size ) { u8 current_bit_offset = 0 ; size_t src_byte_offset = 0 ; size_t dst_byte_offset = 0 ; if ( dst == NULL ) { ( * dst_size ) = ecryptfs_max_decoded_size ( src_size ) ; goto out ; } while ( src_byte_offset < src_size ) { unsigned char src_byte = filename_rev_map [ ( int ) src [ src_byte_offset ] ] ; switch ( current_bit_offset ) { case 0 : dst [ dst_byte_offset ] = ( src_byte << 2 ) ; current_bit_offset = 6 ; break ; case 6 : dst [ dst_byte_offset ++ ] |= ( src_byte >> 4 ) ; dst [ dst_byte_offset ] = ( ( src_byte & 0xF ) << 4 ) ; current_bit_offset = 4 ; break ; case 4 : dst [ dst_byte_offset ++ ] |= ( src_byte >> 2 ) ; dst [ dst_byte_offset ] = ( src_byte << 6 ) ; current_bit_offset = 2 ; break ; case 2 : dst [ dst_byte_offset ++ ] |= ( src_byte ) ; <vul-start> dst [ dst_byte_offset ] = 0 ; <vul-end> current_bit_offset = 0 ; break ; } src_byte_offset ++ ; } ( * dst_size ) = dst_byte_offset ; out : return ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> src_byte ) ; <vul-end> current_bit_offset = 0\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> src_byte ) ; if ( dst_byte_offset >= * dst_size ) { ( * dst_size ) = 0 ; return ; }\n"
 },
 {
  "id": 120,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = NULL ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = NULL ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { if ( type != ICMPV6_PKT_TOOBIG && ! ( type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = NULL ; } addr_type = ipv6_addr_type ( & hdr ->",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ifindex ; else { dst = skb_dst ( skb ) ; <vul-start> = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; } <vul-end> if ( (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ifindex ; else { struct ipv6_txoptions * opt ; <vul-start> dev ) ; opt = rcu_dereference ( skb_dst ( skb ) -> opt ) ; if ( opt ) { iif = opt -> ifindex ; opt -> if_index = iif ; } }\n"
 },
 {
  "id": 121,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int sched_read_attr ( struct sched_attr __user * uattr , struct sched_attr * attr , unsigned int usize ) { int ret ; if ( ! access_ok ( VERIFY_WRITE , uattr , usize ) ) return - EFAULT ; if ( usize < sizeof ( * attr ) ) { unsigned char * addr ; unsigned char * end ; addr = ( void * ) attr + usize ; end = ( void * ) attr + sizeof ( * attr ) ; for ( ; addr < end ; addr ++ ) { if ( * addr ) goto err_size ; } attr -> size = usize ; } <vul-start> ret = copy_to_user ( uattr , attr , usize ) ; <vul-end> if ( ret ) return - EFAULT ; out : return ret ; err_size : ret = - E2BIG ; goto out ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> , attr , attr -> size <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> usize ; } if ( attr -> size > UINT_MAX - usize ) return - E2BIG ;\n"
 },
 {
  "id": 122,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int putint ( jas_stream_t * out , int sgnd , int prec , long val ) { int n ; int c ; bool s ; <vul-start> ulong tmp ; <vul-end> assert ( ( ! sgnd && prec >= 1 ) || ( sgnd && prec >= 2 ) ) ; if ( sgnd ) { val = encode_twos_comp ( val , prec ) ; } assert ( val >= 0 ) ; val &= ( 1 << prec ) - 1 ; n = ( prec + 7 ) / 8 ; while ( -- n >= 0 ) { c = ( val >> ( n * 8 ) ) & 0xff ; if ( jas_stream_putc ( out , c ) != c ) return - 1 ; } return 0 ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> bool s ; jas_ulong <vul-end> tmp ; assert\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> bool s ; jas_ulong <vul-end> tmp ; assert\n"
 },
 {
  "id": 123,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 void luaD_shrinkstack ( lua_State * L ) { int inuse = stackinuse ( L ) ; <vul-start> int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ; <vul-end> if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ; if ( inuse <= ( LUAI_MAXSTACK - EXTRA_STACK ) && goodsize < L -> stacksize ) luaD_reallocstack ( L , goodsize , 0 ) ; else condmovestack ( L , { } , { } ) ; luaE_shrinkCI ( L ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> = inuse + BASIC_STACK_SIZE <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> 2 * EXTRA_STACK ; if ( goodsize < 0 ) return\n"
 },
 {
  "id": 124,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 int init_pci ( struct vmctx * ctx ) { struct mem_range mr ; struct pci_vdev_ops * ops ; struct businfo * bi ; struct slotinfo * si ; struct funcinfo * fi ; size_t lowmem ; int bus , slot , func ; int success_cnt = 0 ; int error ; pci_emul_iobase = PCI_EMUL_IOBASE ; pci_emul_membase32 = vm_get_lowmem_limit ( ctx ) ; pci_emul_membase64 = PCI_EMUL_MEMBASE64 ; create_gsi_sharing_groups ( ) ; for ( bus = 0 ; bus < MAXBUSES ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; bi -> iobase = pci_emul_iobase ; bi -> membase32 = pci_emul_membase32 ; bi -> membase64 = pci_emul_membase64 ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == NULL ) continue ; ops = pci_emul_finddev ( fi -> fi_name ) ; <vul-start> assert ( ops != NULL ) ; <vul-end> pr_notice ( \"pci init %s\\\\r\\\\n\" , fi -> fi_name ) ; error = pci_emul_init ( ctx , ops , bus , slot , func , fi ) ; if ( error ) { pr_err ( \"pci %s init failed\\\\n\" , fi -> fi_name ) ; goto pci_emul_init_fail ; } success_cnt ++ ; } } pci_emul_iobase += BUSIO_ROUNDUP ; pci_emul_iobase = roundup2 ( pci_emul_iobase , BUSIO_ROUNDUP ) ; bi -> iolimit = pci_emul_iobase",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> fi_name ) ; if ( ! ops ) { pr_warn ( \"No driver for device [%s]\\\\n\" , fi -> fi_name ) ; continue ; } <vul-end> pr_notice ( \"pci init %s\\\\r\\\\n\" <vul-start> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <vul-end> ; bzero ( <vul-start> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <vul-end> ; bzero ( <vul-start> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <vul-end> ; return 0 <vul-start> fi_name ) ; if ( ! ops ) { pr_warn ( \"No driver for device [%s]\\\\n\" , fi -> fi_name ) ; continue ; } <vul-end> pci_emul_deinit ( ctx\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> fi_name ) ; if ( ops == NULL ) goto pci_emul_init_fail <vul-end> ; pr_notice ( <vul-start> mr ) ; if ( ops == NULL ) goto pci_emul_init_fail <vul-end> ; pr_notice ( <vul-start> fi_name ) ; if <vul-end> ( ops!= <vul-start>!= NULL ) goto pci_emul_deinit <vul-end> ; pci_emul_deinit (\n"
 },
 {
  "id": 125,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 void bn_mul_comba4 ( BN_ULONG * r , BN_ULONG * a , BN_ULONG * b ) { <vul-start> BN_ULONG t1 , t2 ; <vul-end> BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 0 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 0 ] , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 2 ] , b [ 0 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 0 ] , b [ 2 ] , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 1 ] , b [ 2 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 2 ] , b [ 1 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 0 ] , c1 , c2 , c3 ) ;",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> ) { BN_ULONG <vul-end> c1 , c2\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> ) { BN_ULONG <vul-end> c1, c2\n"
 },
 {
  "id": 126,
  "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static int ivr_read_header ( AVFormatContext * s ) { unsigned tag , type , len , tlen , value ; int i , j , n , count , nb_streams = 0 , ret ; uint8_t key [ 256 ] , val [ 256 ] ; AVIOContext * pb = s -> pb ; AVStream * st ; int64_t pos , offset , temp ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; if ( tag == MKTAG ( '.' , 'R' , '1' , 'M' ) ) { if ( avio_rb16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; avio_skip ( pb , 5 ) ; temp = avio_rb64 ( pb ) ; while ( ! avio_feof ( pb ) && temp ) { offset = temp ; temp = avio_rb64 ( pb ) ; } avio_skip ( pb , offset - avio_tell ( pb ) ) ; if ( avio_r8 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; len = avio_rb32 ( pb ) ; avio_skip ( pb , len ) ; if ( avio_r8 ( pb ) != 2 ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 16 ) ; pos = avio_tell ( pb ) ; tag = avio_rl32 ( pb ) ; } if ( tag != MKTAG ( '.' , 'R' , 'E' , 'C' ) ) return AVERROR_INVALIDDATA ; if ( avio_r8 ( pb",
  "golden_answers": [
   "CWE-834 Fixed Code Lines are: <vul-start> j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> ) ) ; }\n"
  ],
  "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> ) ) ; }\n"
 },
 {
  "id": 127,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } result = PyType_GenericNew ( alias_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_asname , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
 },
 {
  "id": 128,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void jpc_qmfb_join_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t joinbuf [ QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = joinbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int hstartcol ; if ( bufsize > QMFB_JOINBUFSIZE ) { if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } hstartcol = ( numrows + 1 - parity ) >> 1 ; n = hstartcol ; srcptr = & a [ 0 ] ; dstptr = buf ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } srcptr += stride ; dstptr += JPC_QMFB_COLGRPSIZE ; } srcptr = & a [ hstartcol * stride ] ; dstptr = & a [ ( 1 - parity ) * stride ] ; n = numrows - hstartcol ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += 2 * stride ; srcptr += stride",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: \n"
 },
 {
  "id": 129,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) { if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , \"GAB2\" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) { uint8_t desc [ 256 ] ; int score = AVPROBE_SCORE_EXTENSION , ret ; AVIStream * ast = st -> priv_data ; AVInputFormat * sub_demuxer ; AVRational time_base ; int size ; AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ; AVProbeData pd ; unsigned int desc_len = avio_rl32 ( pb ) ; if ( desc_len > pb -> buf_end - pb -> buf_ptr ) goto error ; ret = avio_get_str16le ( pb , desc_len , desc , sizeof ( desc ) ) ; avio_skip ( pb , desc_len - ret ) ; if ( * desc ) av_dict_set ( & st -> metadata , \"title\" , desc , 0 ) ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; size = pb -> buf_end - pb -> buf_ptr ; pd = ( AVProbeData ) { . buf = av_mallocz ( size + AVPROBE_PADDING_SIZE ) , . buf_size = size } ; if ( ! pd . buf ) goto error ; memcpy ( pd . buf , pb -> buf_ptr , size ) ; sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ; av_freep",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; if ( strcmp ( sub_demuxer -> name , \"srt\" ) && strcmp ( sub_demuxer -> name , \"ass\" ) ) goto error ; if (\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> avformat_alloc_context ( ) ) ||! pb -> buf_end - pb -> buf_ptr\n"
 },
 {
  "id": 130,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_cyclic_refresh_setup ( VP9_COMP * const cpi ) { VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; CYCLIC_REFRESH * const cr = cpi -> cyclic_refresh ; struct segmentation * const seg = & cm -> seg ; <vul-start> unsigned char * const seg_map = cpi -> segmentation_map ; <vul-end> <vul-start> const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( cm , rc ) ; <vul-end> if ( ! apply_cyclic_refresh || ( cm -> frame_type == KEY_FRAME ) || <vul-start> ( cpi -> svc . temporal_layer_id > 0 ) ) { <vul-end> vpx_memset ( seg_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; vp9_disable_segmentation ( & cm -> seg ) ; <vul-start> if ( cm -> frame_type == KEY_FRAME ) <vul-end> <vul-start> cr -> sb_index = 0 ; <vul-end> return ; } else { int qindex_delta = 0 ; <vul-start> int i , block_count , bl_index , sb_rows , sb_cols , sbs_in_frame ; <vul-end> int xmis , ymis , x , y , qindex2 ; <vul-start> const float rate_ratio_qdelta = 2.0 ; <vul-end> vp9_clear_system_state ( ) ; cr -> max_sbs_perframe = 10 ; cr -> max_qdelta_perc = 50 ; cr -> min_block_size = BLOCK_8X8 ; cr -> time_for_refresh = 1 ; cr -> thresh_rate_sb = ( rc -> sb64_target_rate * 256 ) >> 2 ; cr -> thresh_dist_sb = 8 * ( int ) ( vp9_convert_qindex_to_q ( cm -> base_qindex ) * vp9_convert_qindex_to_q ( cm -> base_qindex ) ) ; if ( cpi -> sf . use_nonrd_pick_mode ) { cr -> thresh_rate_sb",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> seg ; <vul-end> const int apply_cyclic_refresh <vul-start> , rc ) ; if ( cm -> current_video_frame == 0 ) cr -> low_content_avg = 0.0 <vul-start> > 0 ) || ( cpi -> svc . spatial_layer_id > 0 ) ) { unsigned char * const seg_map = cpi -> segmentation_map ; memset <vul-end> ( seg_map , <vul-start> == KEY_FRAME ) { memset ( cr -> last_coded_q_map , MAXQ , cm -> mi_rows * cm -> mi_cols * sizeof ( * cr -> last_coded_q_map ) ) ; <vul-start> = 0 ; } <vul-start> 0 ; int <vul-end> qindex2 ; const <vul-start> qindex2 ; const double q = vp9_convert_qindex_to_q ( cm -> base_qindex , cm -> bit_depth ) ; vpx_clear_system_state ( ) ; cr -> thresh_rate_sb = ( ( int64_t ) ( rc -> sb64_target_rate ) << 8 ) << 2 ; cr -> thresh_dist_sb = ( ( int64_t ) ( q * q ) ) << 2 ; vp9_enable_segmentation ( & cm -> seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , CR_SEGMENT_ID_BASE , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST1 , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , cr -> rate_ratio_qdelta ) ; cr -> qindex_delta [ 1 ] = qindex_delta <vul-end> ; qindex2 = <vul-start> ( seg , CR_SEGMENT_ID_BOOST1 <vul-end> , SEG_LVL_ALT_Q , <vul-start> qindex_delta ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , MIN ( CR_MAX_RATE_TARGET_RATIO , 0.1 * cr -> rate_boost_fac * cr -> rate_ratio_qdelta ) ) ; cr -> qindex_delta [ 2 ] = qindex_delta ; vp9_set_segdata ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q , qindex_delta ) ; cyclic_refresh_update_map ( cpi ) <vul-end> ; } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> seg ; const int is_keyframe = <vul-end> ( cm -> <vul-start> qindex2 ) ; int apply_cyclic_refresh = vp9_cyclic_refresh_bitrate ( rc, is_keyframe ) ; if ( is_keyframe ) { if ( cpi -> svc. spatial_layer_id > 0 ) { const int layer = LAYER_IDS_TO_IDX ( cpi -> svc. spatial_layer_id, cm -> mi_rows, cm -> mi_cols ) ; if ( layer < 0 ) { vpx_memset ( seg_map, 0, sizeof ( * seg_map ) ) ; vp9_enable_segmentation ( & <vul-end> seg ) ; <vul-start> ; if ( layer < 0 ) { <vul-end> cr -> sb_index <vul-start> -> sb_index = - 1 ; } else { vp9_disable_segmentation ( & cm -> seg ) ; } } else { vp9_set_segdata ( seg, 1, SEG_LVL_ALT_Q, qindex_delta ) ; } } else { vp9_disable_segmentation ( & cm -> seg ) ; if ( is_keyframe ) { <vul-end> return ; } <vul-start>, bl_index, sb_rows, sb_cols, sbs_in_frame <vul-end> ; int xmis <vul-start> float rate_ratio_qdelta = 0.0 <vul-end> ; cr -> <vul-start> qindex2 ) ; const int apply_cyclic_refresh = apply_cyclic_refresh_bitrate ( rc, is_keyframe ) ; if ( is_keyframe ) { sb_cols = ( cm -> mi_cols + 1 ) / MI_BLOCK_SIZE ; sb_rows = ( cm -> mi_rows + 1 ) / MI_BLOCK_SIZE ; sbs_in_frame = sb_cols * sb_rows ; seg -> max_sbs_perframe = 10 ; cr -> max_qdelta_perc = 50 ; cr -> min_block_size = BLOCK_8X8 ; cr -> thresh_rate_sb = ( rc -> sb64_target_rate * 256 ) >> 3 ; cr -> thresh_dist_sb = 4 * ( int ) ( vp9_convert_qindex_to_q ( cm -> base_qindex ) * vp9_"
 },
 {
  "id": 131,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static expr_ty ast_for_atom ( struct compiling * c , const node * n ) { node * ch = CHILD ( n , 0 ) ; switch ( TYPE ( ch ) ) { case NAME : { PyObject * name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case STRING : { PyObject * kind , * str = parsestrplus ( c , n ) ; <vul-start> const char * raw , * s = STR ( CHILD ( n , 0 ) ) ; <vul-end> int quote = Py_CHARMASK ( * s ) ; char * ch , s_kind [ 3 ] = { 0 , 0 , 0 } ; ch = s_kind ; raw = s ; while ( * raw && * raw != '\\\\'' && * raw != \\'\"\\' ) { * ch ++ = * raw ++ ; } kind = PyUnicode_FromString ( s_kind ) ; if ( ! kind ) { return NULL ; } if ( ! str ) { # ifdef Py_USING_UNICODE if ( PyErr_ExceptionMatches ( PyExc_UnicodeError ) ) { PyObject * type , * value , * tback , * errstr ; PyErr_Fetch ( & type , & value , & tback ) ; errstr = PyObject_Str ( value ) ; if ( errstr ) { <vul-start> char * s = \"\" ; <vul-end> char buf [ 128 ] ; s = _PyUnicode_AsString ( errstr )",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , 0 ) <vul-end> ) ; char <vul-start> errstr ) { const\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, * s <vul-end> ; char * <vul-start> errstr ) { <vul-end> char buf [ <vul-start> 128 ] ; if ( quote == Py_QUOTER_NON_BINARY ) { string type_comment ; type_comment = NEW_TYPE_COMMENT ( CHILD ( n, 0 ) ) ; if (! type_comment ) return NULL ; s = _PyUnicode_AsString ( errstr ) ; } else { <vul-start> ) ; } } <vul-start> str ) { const char * s = STR ( CHILD ( n, 0 ) ) ; <vul-start> quote ) { if ( quote == Py_QUOTER_NON_BINARY ) { string type_comment = NEW_TYPE_COMMENT ( CHILD ( n, 0 ) ) ; if (! string ) return NULL ; <vul-start> ) ; } } else { if ( quote == Py_QUOTER_NON_BINARY ) { string type_comment = NEW_TYPE_COMMENT ( CHILD ( n, 1 ) ) ; if (! string ) return NULL ; } <vul-start> ) ; } }\n"
 },
 {
  "id": 132,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void rtc_irq_eoi_tracking_reset ( struct kvm_ioapic * ioapic ) { ioapic -> rtc_status . pending_eoi = 0 ; <vul-start> bitmap_zero ( ioapic -> rtc_status . dest_map . map , KVM_MAX_VCPUS ) ; <vul-end> }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> . map , KVM_MAX_VCPU_ID <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; ioapic -> rtc_status. dest_map. count = 0 ;\n"
 },
 {
  "id": 133,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) { char * input_string ; char * option_name ; char * option_value ; char * input_ptr ; <vul-start> int is_keyframe_qaunt_set = 0 ; <vul-end> vpx_codec_err_t res = VPX_CODEC_OK ; if ( options == NULL ) return VPX_CODEC_OK ; input_string = strdup ( options ) ; option_name = strtok_r ( input_string , \"=\" , & input_ptr ) ; while ( option_name != NULL ) { option_value = strtok_r ( NULL , \" \" , & input_ptr ) ; if ( option_value == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"option missing value: %s\\\\n\" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } <vul-start> if ( strcmp ( \"encoding-mode\" , option_name ) == 0 ) { <vul-end> res = set_option_encoding_mode ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ; <vul-start> } else if ( strcmp ( \"layers\" , option_name ) == 0 ) { <vul-end> svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( \"scale-factors\" , option_name ) == 0 ) { res = parse_scale_factors ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ; <vul-start> } else if ( strcmp ( \"quantizers\" , option_name ) == 0 ) { <vul-end> res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ; if ( res != VPX_CODEC_OK ) break ; <vul-start> if ( ! is_keyframe_qaunt_set ) { <vul-end> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; memcpy ( get_svc_internal ( svc_ctx ) ->",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * input_ptr ; SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; vpx_codec_err_t res = VPX_CODEC_OK ; int i , alt_ref_enabled = 0 <vul-end> ; if ( <vul-start> ( strcmp ( \"spatial-layers\" , option_name ) == 0 ) { svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( \"temporal-layers\" , option_name ) == 0 ) { svc_ctx -> temporal_layers = atoi ( option_value ) ; } else if ( strcmp ( \"scale-factors\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , SCALE_FACTOR , option_value , si -> svc_params . scaling_factor_num , si -> svc_params . scaling_factor_den <vul-end> ) ; if <vul-start> ( strcmp ( \"max-quantizers\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL <vul-end> ) ; if <vul-start> ( strcmp ( \"min-quantizers\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL <vul-end> ) ; if <vul-start> ) break ; } else if ( strcmp ( \"auto-alt-refs\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL <vul-end> ) ; if <vul-start> ) break ; } else if ( strcmp ( \"bitrates\" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( \"multi-frame-contexts\" , option_name ) == 0 ) { si -> use_multiple_frame_contexts = atoi ( option_value ) <vul-end> ; } else <vul-start> input_string ) ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ; } if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ; if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc: auto alt ref: Maxinum %d(REF_FRAMES - layers) layers could\" \"enabled auto alt reference frame, but % layers are enabled\\\\n\" , REF_FRAMES - svc_ctx -> spatial_layers , alt_ref_enabled ) ; res = VPX_CODEC_INVALID_PARAM ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * input_ptr ; <vul-end> vpx_codec_err_t res = <vul-start> break ; } # if CONFIG_VP9_HIGHBITDEPTH if ( svc_ctx -> cur_buf -> flags & VPX_FLAG_HIGHBITDEPTH ) { set_highbitdepth ( option_value ) ; } # endif <vul-start> break ; } # if CONFIG_VP10_HIGHBITDEPTH if ( svc_ctx -> cur_buf -> flags & VPX_FLAG_HIGHBITDEPTH ) { set_highbitdepth ( option_value ) ; } # endif <vul-start> break ; } # if CONFIG_VP10_HIGHBITDEPTH if ( svc_ctx -> cur_buf -> flags & VPX_FLAG_HIGHBITDEPTH ) { set_highbitdepth ( option_value ) ; } # endif <vul-start> input_string ) ; # if CONFIG_VP10_HIGHBITDEPTH if ( svc_ctx -> cur_buf -> flags & VPX_FLAG_HIGHBITDEPTH ) { set_highbitdepth ( option_value ) ; } # endif\n"
 },
 {
  "id": 134,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { typedef struct { unsigned char Type [ 4 ] ; unsigned int nRows ; unsigned int nCols ; unsigned int imagf ; unsigned int nameLen ; } MAT4_HDR ; long ldblk ; EndianType endian ; Image * rotate_image ; MagickBooleanType status ; MAT4_HDR HDR ; QuantumInfo * quantum_info ; QuantumFormatType format_type ; register ssize_t i ; ssize_t count , y ; unsigned char * pixels ; unsigned int depth ; <vul-start> ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; <vul-end> while ( EOFBlob ( image ) != MagickFalse ) { ldblk = ReadBlobLSBLong ( image ) ; if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) break ; HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 0 ] = ldblk ; if ( HDR . Type [ 3 ] != 0 ) break ; if ( HDR . Type [ 2 ] != 0 ) break ; if ( HDR . Type [ 0 ] == 0 ) { HDR . nRows = ReadBlobLSBLong ( image ) ; HDR . nCols = ReadBlobLSBLong ( image ) ; HDR . imagf = ReadBlobLSBLong ( image ) ; HDR . nameLen = ReadBlobLSBLong ( image ) ; endian",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> int depth ; quantum_info = ( QuantumInfo * ) NULL ; <vul-start> ) ; } if ( quantum_info != ( QuantumInfo * ) NULL )\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> int depth ; size_t size ; <vul-start> ) ; } size = ( ssize_t ) GetBlobSize ( image ) ; if ( size < 0 ) break ; <vul-start> ) break ; if ( size == 0 ) break ; <vul-start> ) pixels, size <vul-end>, exception ) <vul-start> ) break ; size = ( ssize_t ) GetBlobSize ( image ) ; if ( size < 0 ) break ; <vul-start> ) pixels, size <vul-end>, exception )\n"
 },
 {
  "id": 135,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int powermate_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( intf ) ; struct usb_host_interface * interface ; struct usb_endpoint_descriptor * endpoint ; struct powermate_device * pm ; struct input_dev * input_dev ; int pipe , maxp ; int error = - ENOMEM ; <vul-start> interface = intf -> cur_altsetting ; <vul-end> endpoint = & interface -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_int_in ( endpoint ) ) return - EIO ; usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0a , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , interface -> desc . bInterfaceNumber , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; pm = kzalloc ( sizeof ( struct powermate_device ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! pm || ! input_dev ) goto fail1 ; if ( powermate_alloc_buffers ( udev , pm ) ) goto fail2 ; pm -> irq = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> irq ) goto fail2 ; pm -> config = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> config ) goto fail3 ; pm -> udev = udev ; pm -> intf = intf ; pm -> input = input_dev ; usb_make_path ( udev , pm -> phys , sizeof ( pm -> phys ) ) ; strlcat ( pm -> phys , \"/input0\" , sizeof ( pm -> phys ) ) ; spin_lock_init ( & pm -> lock ) ; switch (",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> - ENOMEM ; if ( intf -> num_altsetting < 1 ) return - ENODEV ;\n"
 },
 {
  "id": 136,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , <vul-start> const char * data , int optional ) <vul-end> { # ifdef HAVE_STATVFS struct statvfs sb ; # endif <vul-start> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <vul-end> if ( optional ) { INFO ( \"failed to mount \\'%s\\' on \\'%s\\' (optional): %s\" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( \"failed to mount \\'%s\\' on \\'%s\\'\" , fsname , target ) ; return - 1 ; } } if ( ( mountflags & MS_REMOUNT ) || ( mountflags & MS_BIND ) ) { DEBUG ( \"remounting %s on %s to respect bind or remount options\" , fsname ? fsname : \"(none)\" , target ? target : \"(none)\" ) ; unsigned long rqd_flags = 0 ; if ( mountflags & MS_RDONLY ) rqd_flags |= MS_RDONLY ; # ifdef HAVE_STATVFS if ( statvfs ( fsname , & sb ) == 0 ) { unsigned long required_flags = rqd_flags ; if ( sb . f_flag & MS_NOSUID ) required_flags |= MS_NOSUID ; if ( sb . f_flag & MS_NODEV ) required_flags |= MS_NODEV ; if ( sb . f_flag & MS_RDONLY ) required_flags |= MS_RDONLY ; if ( sb . f_flag & MS_NOEXEC ) required_flags |= MS_NOEXEC ; DEBUG ( \"(at remount) flags for %s was %lu, required extra flags are %lu\" , fsname , sb . f_flag , required_flags",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> , int optional , const char * rootfs <vul-start> endif if ( safe_mount <vul-end> ( fsname , <vul-start> MS_REMOUNT , data , rootfs <vul-start> , data ) < 0\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> char * data, uid_t uid, gid_t gid <vul-start> MS_REMOUNT, data, uid, gid <vul-start> ) ) { if ( uid!= sb. f_uid || gid!= sb. f_gid ) { SYSERROR ( \"failed to mount \\'%s\\' on \\'%s\\' (uid: %lu, gid: %lu)\", fsname, target, sb. f_uid, gid ) ; return - 1 ; } <vul-start> | MS_REMOUNT, data, uid, gid <vul-end> ) ) {\n"
 },
 {
  "id": 137,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int simulate_llsc ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == LL ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <vul-start> 1 , 0 , regs , 0 ) ; <vul-end> return simulate_ll ( regs , opcode ) ; } if ( ( opcode & OPCODE ) == SC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <vul-start> 1 , 0 , regs , 0 ) ; <vul-end> return simulate_sc ( regs , opcode ) ; } return - 1 ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> PERF_COUNT_SW_EMULATION_FAULTS , 1 <vul-end> , regs , <vul-start> , 1 , <vul-end> regs , 0\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, 0 <vul-start>, 1, <vul-end> regs, 0 <vul-start>, 1, <vul-end> regs, 0\n"
 },
 {
  "id": 138,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int main ( int argc , char * * argv ) { mode_t old_umask ; <vul-start> cleanup_free char * base_path = NULL ; <vul-end> int clone_flags ; char * old_cwd = NULL ; pid_t pid ; int event_fd = - 1 ; int child_wait_fd = - 1 ; int setup_finished_pipe [ ] = { - 1 , - 1 } ; const char * new_cwd ; uid_t ns_uid ; gid_t ns_gid ; struct stat sbuf ; uint64_t val ; int res UNUSED ; cleanup_free char * seccomp_data = NULL ; size_t seccomp_len ; struct sock_fprog seccomp_prog ; cleanup_free char * args_data = NULL ; if ( argc == 2 && ( strcmp ( argv [ 1 ] , \"--version\" ) == 0 ) ) print_version_and_exit ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; acquire_privs ( ) ; if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) die_with_error ( \"prctl(PR_SET_NO_NEW_CAPS) failed\" ) ; read_overflowids ( ) ; argv0 = argv [ 0 ] ; if ( isatty ( 1 ) ) host_tty_dev = ttyname ( 1 ) ; argv ++ ; argc -- ; if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; parse_args ( & argc , ( const char * * * ) & argv ) ; args_data = opt_args_data ; opt_args_data = NULL ; if ( ( requested_caps [ 0 ] || requested_caps [ 1 ] ) && is_privileged ) die ( \"--cap-add in setuid mode can be used only by root\" ) ;",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> mode_t old_umask ; const <vul-end> char * base_path <vul-start> ; base_path = \"/tmp\" ; <vul-end> __debug__ ( (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> char * base_path = NULL ; cleanup_free char * new_cwd <vul-start> \"Can\\'t open /proc\" ) ; if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( \"setsid\" ) ; <vul-start> = xasprintf ( \"/run/user/%d/.bubblewrap\" <vul-end>, real_uid ) <vul-start> = xasprintf ( \"/tmp/.bubblewrap-%d\" <vul-end>, real_uid ) <vul-start> clone_flags ) ; if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( \"setsid\" ) ; <vul-start> base_path ) ; if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( \"setsid\" ) ;\n"
 },
 {
  "id": 139,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; <vul-start> if ( ! head ) { <vul-end> WARN_ON_ONCE ( swhash -> online ) ; return - EINVAL ; <vul-start> } <vul-end> hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ; if ( WARN_ON_ONCE ( <vul-start> ! head ) ) <vul-end> return - EINVAL <vul-start> - EINVAL ; <vul-end> hlist_add_head_rcu ( &\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>! head ) <vul-end> return - EINVAL <vul-start> - EINVAL ; <vul-end> hlist_add_head_rcu ( &\n"
 },
 {
  "id": 140,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 u_int chdlc_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , register const u_char * p ) { <vul-start> register u_int length = h -> len ; <vul-end> register u_int caplen = h -> caplen ; if ( caplen < CHDLC_HDRLEN ) { ND_PRINT ( ( ndo , \"[|chdlc]\" ) ) ; return ( caplen ) ; } <vul-start> return ( chdlc_print ( ndo , p , length ) ) ; <vul-end> }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> p ) { return <vul-end> chdlc_print ( ndo <vul-start> , p , h -> len <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) { register <vul-end> u_int caplen = <vul-start> p, length, 0\n"
 },
 {
  "id": 141,
  "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 void nlmsvc_grant_reply ( struct nlm_cookie * cookie , __be32 status ) { struct nlm_block * block ; dprintk ( \"grant_reply: looking for cookie %x, s=%d \\\\n\" , * ( unsigned int * ) ( cookie -> data ) , status ) ; if ( ! ( block = nlmsvc_find_block ( cookie ) ) ) return ; <vul-start> if ( block ) { <vul-end> if ( status == nlm_lck_denied_grace_period ) { nlmsvc_insert_block ( block , 10 * HZ ) ; } else { nlmsvc_unlink_block ( block ) ; } <vul-start> } <vul-end> nlmsvc_release_block ( block ) ; }",
  "golden_answers": [
   "CWE-404 Fixed Code Lines are: <vul-start> ; if ( <vul-end> status == nlm_lck_denied_grace_period <vul-start> ) ; } <vul-end> nlmsvc_release_block ( block\n"
  ],
  "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> ( block ) <vul-end> nlmsvc_insert_block ( block <vul-start> ) ; } <vul-end> nlmsvc_release_block ( block\n"
 },
 {
  "id": 142,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int hfsplus_readdir ( struct file * filp , void * dirent , filldir_t filldir ) { struct inode * inode = filp -> f_path . dentry -> d_inode ; struct super_block * sb = inode -> i_sb ; int len , err ; char strbuf [ HFSPLUS_MAX_STRLEN + 1 ] ; hfsplus_cat_entry entry ; struct hfs_find_data fd ; struct hfsplus_readdir_data * rd ; u16 type ; if ( filp -> f_pos >= inode -> i_size ) return 0 ; err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & fd ) ; if ( err ) return err ; hfsplus_cat_build_key ( sb , fd . search_key , inode -> i_ino , NULL ) ; err = hfs_brec_find ( & fd ) ; if ( err ) goto out ; switch ( ( u32 ) filp -> f_pos ) { case 0 : if ( filldir ( dirent , \".\" , 1 , 0 , inode -> i_ino , DT_DIR ) ) goto out ; filp -> f_pos ++ ; case 1 : <vul-start> hfs_bnode_read ( fd . bnode , & entry , fd . entryoffset , <vul-end> fd . entrylength ) ; if ( be16_to_cpu ( entry . type ) != HFSPLUS_FOLDER_THREAD ) { printk ( KERN_ERR \"hfs: bad catalog folder thread\\\\n\" ) ; err = - EIO ; goto out ; } if ( fd . entrylength < HFSPLUS_MIN_THREAD_SZ ) { printk ( KERN_ERR \"hfs: truncated catalog thread\\\\n\" ) ; err = - EIO ; goto out ; } if ( filldir ( dirent , \"..\" , 2 , 1 ,",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <vul-start> out ; } if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; }\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> case 1 : if ( fd. entrylength < HFSPLUS_MIN_THREAD_SZ ) { printk ( KERN_ERR \"hfs: truncated catalog thread\\\\n\" ) ; err = - EIO ; goto out ; } <vul-start> out ; } if ( fd. entrylength < HFSPLUS_MIN_THREAD_SZ ) { printk ( KERN_ERR \"hfs: truncated catalog thread\\\\n\" ) ; err = - EIO ; goto out ; }\n"
 },
 {
  "id": 143,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int jpc_dec_process_siz ( jpc_dec_t * dec , jpc_ms_t * ms ) { jpc_siz_t * siz = & ms -> parms . siz ; int compno ; int tileno ; jpc_dec_tile_t * tile ; jpc_dec_tcomp_t * tcomp ; int htileno ; int vtileno ; jpc_dec_cmpt_t * cmpt ; <vul-start> dec -> xstart = siz -> xoff ; <vul-end> dec -> ystart = siz -> yoff ; dec -> xend = siz -> width ; dec -> yend = siz -> height ; dec -> tilewidth = siz -> tilewidth ; dec -> tileheight = siz -> tileheight ; dec -> tilexoff = siz -> tilexoff ; dec -> tileyoff = siz -> tileyoff ; dec -> numcomps = siz -> numcomps ; if ( ! ( dec -> cp = jpc_dec_cp_create ( dec -> numcomps ) ) ) { return - 1 ; } if ( ! ( dec -> cmpts = jas_alloc2 ( dec -> numcomps , sizeof ( jpc_dec_cmpt_t ) ) ) ) { return - 1 ; } for ( compno = 0 , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ cmpt ) { cmpt -> prec = siz -> comps [ compno ] . prec ; cmpt -> sgnd = siz -> comps [ compno ] . sgnd ; cmpt -> hstep = siz -> comps [ compno ] . hsamp ; cmpt -> vstep = siz -> comps [ compno ] . vsamp ; cmpt -> width = JPC_CEILDIV ( dec -> xend , cmpt -> hstep ) - JPC_CEILDIV (",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * cmpt ; size_t size ; <vul-start> tileheight ) ; if ( ! jas_safe_size_mul ( <vul-end> dec -> numhtiles <vul-start> dec -> numhtiles , <vul-end> dec -> numvtiles <vul-start> dec -> numvtiles , & size <vul-end> ) ) { <vul-start> 1 ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( \"numtiles = %d; numhtiles = %d; numvtiles = %d;\\\\n\" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * cmpt ; int i ; <vul-start> tileheight ) ; for ( i = 0 ; i < dec -> numhtiles ; ++ i ) { dec -> tiles [ i ]. xstart = 0 ; dec -> tiles [ i ]. ystart = 0 ; dec -> tiles [ i ]. tileheight = 0 ; } <vul-start> 1 ; } dec -> cp -> width = dec -> xend / dec -> numhtiles ; dec -> cp -> height = dec -> yend / dec -> numvtiles ;\n"
 },
 {
  "id": 144,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int ccid3_hc_tx_getsockopt ( struct sock * sk , const int optname , int len , u32 __user * optval , int __user * optlen ) { const struct ccid3_hc_tx_sock * hc = ccid3_hc_tx_sk ( sk ) ; struct tfrc_tx_info tfrc ; const void * val ; switch ( optname ) { case DCCP_SOCKOPT_CCID_TX_INFO : if ( len < sizeof ( tfrc ) ) return - EINVAL ; <vul-start> tfrc . tfrctx_x = hc -> tx_x ; <vul-end> tfrc . tfrctx_x_recv = hc -> tx_x_recv ; tfrc . tfrctx_x_calc = hc -> tx_x_calc ; tfrc . tfrctx_rtt = hc -> tx_rtt ; tfrc . tfrctx_p = hc -> tx_p ; tfrc . tfrctx_rto = hc -> tx_t_rto ; tfrc . tfrctx_ipi = hc -> tx_t_ipi ; len = sizeof ( tfrc ) ; val = & tfrc ; break ; default : return - ENOPROTOOPT ; } if ( put_user ( len , optlen ) || copy_to_user ( optval , val , len ) ) return - EFAULT ; return 0 ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> - EINVAL ; memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> - EINVAL ; memset ( & tfrc, 0, sizeof ( tfrc ) ) ;\n"
 },
 {
  "id": 145,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 struct lldpd_mgmt * lldpd_alloc_mgmt ( int family , void * addrptr , size_t addrsize , u_int32_t iface ) { struct lldpd_mgmt * mgmt ; log_debug ( \"alloc\" , \"allocate a new management address (family: %d)\" , family ) ; if ( family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST ) { errno = EAFNOSUPPORT ; return NULL ; } if ( addrsize > LLDPD_MGMT_MAXADDRSIZE ) { errno = EOVERFLOW ; return NULL ; } mgmt = calloc ( 1 , sizeof ( struct lldpd_mgmt ) ) ; if ( mgmt == NULL ) { errno = ENOMEM ; return NULL ; } mgmt -> m_family = family ; <vul-start> assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ; <vul-end> memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ; mgmt -> m_addrsize = addrsize ; mgmt -> m_iface = iface ; return mgmt ; }",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> = family ; <vul-end> memcpy ( &\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> = family ; <vul-end> memcpy ( &\n"
 },
 {
  "id": 146,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int jp2_pclr_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_pclr_t * pclr = & box -> data . pclr ; int lutsize ; unsigned int i ; unsigned int j ; int_fast32_t x ; pclr -> lutdata = 0 ; <vul-start> if ( jp2_getuint16 ( in , & pclr -> numlutents ) || <vul-end> jp2_getuint8 ( in , & pclr -> numchans ) ) { return - 1 ; } lutsize = pclr -> numlutents * pclr -> numchans ; if ( ! ( pclr -> lutdata = jas_alloc2 ( lutsize , sizeof ( int_fast32_t ) ) ) ) { return - 1 ; } if ( ! ( pclr -> bpc = jas_alloc2 ( pclr -> numchans , sizeof ( uint_fast8_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < pclr -> numchans ; ++ i ) { if ( jp2_getuint8 ( in , & pclr -> bpc [ i ] ) ) { return - 1 ; } } for ( i = 0 ; i < pclr -> numlutents ; ++ i ) { for ( j = 0 ; j < pclr -> numchans ; ++ j ) { if ( jp2_getint ( in , ( pclr -> bpc [ j ] & 0x80 ) != 0 , ( pclr -> bpc [ j ] & 0x7f ) + 1 , & x ) ) { return - 1 ; } pclr -> lutdata [ i * pclr -> numchans + j ] = x ; } }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> = 0 ; pclr -> bpc = 0 ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ; if ( jp2_getuint32 <vul-end> ( in,\n"
 },
 {
  "id": 147,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_fht4x4_c ( const int16_t * input , int16_t * output , <vul-end> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <vul-start> vp9_fdct4x4_c ( input , output , stride ) ; <vul-end> } else { <vul-start> int16_t out [ 4 * 4 ] ; <vul-end> <vul-start> int16_t * outptr = & out [ 0 ] ; <vul-end> int i , j ; <vul-start> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <vul-end> const transform_2d ht = FHT_4 [ tx_type ] ; for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ; if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) <vul-start> outptr [ j * 4 + i ] = temp_out [ j ] ; <vul-end> } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j + i * 4 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) output [ j + i * 4 ] = ( temp_out",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * input , tran_low_t <vul-end> * output , <vul-start> DCT_DCT ) { vpx_fdct4x4_c <vul-end> ( input , <vul-start> } else { tran_low_t <vul-end> out [ 4 <vul-start> 4 ] ; <vul-end> int i , <vul-start> , j ; tran_low_t <vul-end> temp_in [ 4 <vul-start> ++ j ) out <vul-end> [ j *\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * input, tran_low_t <vul-end> * output, <vul-start> DCT_DCT ) { vpx_fdct4x4_c <vul-end> ( input, <vul-start> } else { tran_low_t <vul-end> out [ 4 <vul-start> 4 ] ; <vul-end> int i, <vul-start>, j ; tran_low_t <vul-end> temp_in [ 4 <vul-start> ++ j ) out <vul-end> [ j *\n"
 },
 {
  "id": 148,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void t1mac_output_ascii ( char * s , int len ) { if ( blocktyp == POST_BINARY ) { output_current_post ( ) ; blocktyp = POST_ASCII ; } if ( len > 0 && s [ len - 1 ] == '\\\\n' ) s [ len - 1 ] = '\\\\r' ; t1mac_output_data ( ( byte * ) s , len ) ; if ( strncmp ( s , \"/FontName\" , 9 ) == 0 ) { <vul-start> for ( s += 9 ; isspace ( * s ) ; s ++ ) ; <vul-end> if ( * s == '/' ) { const char * t = ++ s ; <vul-start> while ( * t && ! isspace ( * t ) ) t ++ ; <vul-end> free ( font_name ) ; font_name = ( char * ) malloc ( t - s + 1 ) ; memcpy ( font_name , s , t - s ) ; font_name [ t - s ] = 0 ; } } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; isspace ( ( unsigned char ) <vul-start> ! isspace ( ( unsigned char )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> += 9 ; isprint ( * s ) && <vul-start>! isspace ( ( unsigned char ) <vul-start> ) t ++ ; if ( t - s > 9 ) return\n"
 },
 {
  "id": 149,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) { int ret , ret2 , i ; kadm5_policy_ent_rec pol ; krb5_boolean have_pol = FALSE ; krb5_db_entry * kdb ; krb5_tl_data * tl_data_orig ; osa_princ_ent_rec adb ; kadm5_server_handle_t handle = server_handle ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; <vul-start> if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || <vul-end> ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ; <vul-start> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <vul-end> return KADM5_BAD_MASK ; <vul-start> if ( entry == ( kadm5_principal_ent_t ) NULL ) <vul-end> return EINVAL ; if ( mask & KADM5_TL_DATA ) { tl_data_orig = entry -> tl_data ; while ( tl_data_orig ) { if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; tl_data_orig = tl_data_orig -> tl_data_next ; } } ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; if ( ret ) return ( ret ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ; if ( ret ) goto done ; adb . aux_attributes |= KADM5_POLICY ;",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; if ( entry == NULL ) return EINVAL ; if ( <vul-start> KADM5_POLICY ) && entry -> policy == NULL <vul-end> ) return KADM5_BAD_MASK <vul-start> ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( mask & KADM5_TL_DATA ) { tl_data_orig = entry -> tl_data ; while ( tl_data_orig && <vul-start> & KADM5_POLICY ) ) { if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; tl_data_orig = tl_data_orig -> tl_data_next ; } } if ( mask & KADM5_LAST_PWD_CHANGE ) { if ( mask & KADM5_MOD_TIME ) return KADM5_BAD_MOD_TIME ; tl_data_orig = tl_data_orig -> last_PWD_change ; } if ( mask & KADM5_POLICY_CLR <vul-end> ) return KADM5_BAD_MASK <vul-start> return KADM5_BAD_MASK ; } else <vul-end> if ( mask\n"
 },
 {
  "id": 150,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) { MXFContext * mxf = arg ; int item_num = avio_rb32 ( pb ) ; int item_len = avio_rb32 ( pb ) ; if ( item_len != 18 ) { avpriv_request_sample ( pb , \"Primer pack item length %d\" , item_len ) ; return AVERROR_PATCHWELCOME ; } <vul-start> if ( item_num > 65536 ) { <vul-end> av_log ( mxf -> fc , AV_LOG_ERROR , \"item_num %d is too large\\\\n\" , item_num ) ; return AVERROR_INVALIDDATA ; } if ( mxf -> local_tags ) av_log ( mxf -> fc , AV_LOG_VERBOSE , \"Multiple primer packs\\\\n\" ) ; av_free ( mxf -> local_tags ) ; mxf -> local_tags_count = 0 ; mxf -> local_tags = av_calloc ( item_num , item_len ) ; if ( ! mxf -> local_tags ) return AVERROR ( ENOMEM ) ; mxf -> local_tags_count = item_num ; avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; return 0 ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> item_num > 65536 || item_num < 0\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> if ( item_num >= <vul-end> 65536 ) {\n"
 },
 {
  "id": 151,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 l_int32 gplotMakeOutput ( GPLOT * gplot ) { <vul-start> char buf [ L_BUF_SIZE ] ; <vul-end> char * cmdname ; l_int32 ignore ; PROCNAME ( \"gplotMakeOutput\" ) ; if ( ! gplot ) return ERROR_INT ( \"gplot not defined\" , procName , 1 ) ; gplotGenCommandFile ( gplot ) ; gplotGenDataFiles ( gplot ) ; cmdname = genPathname ( gplot -> cmdname , NULL ) ; # ifndef _WIN32 <vul-start> snprintf ( buf , L_BUF_SIZE , \"gnuplot %s\" , cmdname ) ; <vul-end> # else <vul-start> snprintf ( buf , L_BUF_SIZE , \"wgnuplot %s\" , cmdname ) ; <vul-end> # endif # ifndef OS_IOS ignore = system ( buf ) ; # endif LEPT_FREE ( cmdname ) ; return 0 ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; char <vul-start> ( buf , L_BUFSIZE <vul-end> , \"gnuplot %s\" , <vul-start> ( buf , L_BUFSIZE <vul-end> , \"wgnuplot %s\" ,\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; char <vul-start> ( buf, L_BUFSIZE <vul-end>, \"gnuplot %s\", <vul-start> ( buf, L_BUFSIZE <vul-end>, \"wgnuplot %s\",\n"
 },
 {
  "id": 152,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void videobuf_vm_close ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; struct videobuf_queue * q = map -> q ; int i ; <vul-start> dprintk ( 2 , \"vm_close %p [count=%d,vma=%08lx-%08lx]\\\\n\" , map , <vul-end> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count -- ; if ( 0 == map -> count ) { dprintk ( 1 , \"munmap %p q=%p\\\\n\" , map , q ) ; mutex_lock ( & q -> lock ) ; for ( i = 0 ; i < VIDEO_MAX_FRAME ; i ++ ) { if ( NULL == q -> bufs [ i ] ) continue ; if ( q -> bufs [ i ] -> map != map ) continue ; q -> ops -> buf_release ( q , q -> bufs [ i ] ) ; q -> bufs [ i ] -> map = NULL ; q -> bufs [ i ] -> baddr = 0 ; } mutex_unlock ( & q -> lock ) ; kfree ( map ) ; } return ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( 2 , \"vm_close %p [count=%u,vma=%08lx-%08lx]\\\\n\" <vul-end> , map ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( 2, \"vm_close %p [count=%u,vma=%08lx-%08lx]\\\\n\" <vul-end>, map,\n"
 },
 {
  "id": 153,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ; <vul-start> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <vul-end> int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ; if ( linesize < 0 ) return linesize ; for ( i = 0 ; i < h ; i ++ ) { plane_checksum [ plane ] = av_adler32_update ( plane_checksum [ plane ] , data , linesize ) ; checksum = av_adler32_update ( checksum , data , linesize ) ; data += frame -> linesize [ plane ] ; } } av_log ( ctx , AV_LOG_INFO , \"n:%\" PRId64 \" pts:%s pts_time:%s pos:%\" PRId64 \" \" \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \" \"checksum:%08X plane_checksum:[%08X\" , inlink -> frame_count , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & inlink -> time_base ) , av_frame_get_pkt_pos ( frame ) , desc -> name , frame -> sample_aspect_ratio . num , frame -> sample_aspect_ratio . den , frame ->",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> frame -> data [ plane ] && frame -> linesize <vul-start> [ plane ] && frame -> linesize [ plane ]\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> [ plane ] && frame -> linesize [ plane ] <vul-start> [ plane ] && frame -> linesize [ plane ]\n"
 },
 {
  "id": 154,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static const char * parse_array ( cJSON * item , const char * value ) <vul-end> { cJSON * child ; if ( * value != '[' ) { <vul-start> ep = value ; <vul-end> return 0 ; } item -> type = cJSON_Array ; value = skip ( value + 1 ) ; if ( * value == ']' ) <vul-start> return value + 1 ; <vul-end> <vul-start> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <vul-end> return 0 ; <vul-start> if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) ) <vul-end> return 0 ; while ( * value == ',' ) { cJSON * new_item ; if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ; child -> next = new_item ; new_item -> prev = child ; <vul-start> child = new_item ; <vul-end> <vul-start> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <vul-end> return 0 ; } if ( * value == ']' ) <vul-start> return value + 1 ; <vul-end> ep = value ; return 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> char * value , const char * * ep <vul-start> '[' ) { * ep = value ; return 0 ; <vul-end> } item -> <vul-start> == ']' ) return value + 1 ; <vul-end> item -> child <vul-start> cJSON_New_Item ( ) ; if ( ! item -> child ) return 0 ; <vul-end> value = skip <vul-start> ( value ) , ep ) ) ; if ( ! value ) <vul-end> return 0 ; <vul-start> = child ; child = new_item ; <vul-end> value = skip <vul-start> + 1 ) , ep ) ) ; if ( ! value ) <vul-end> return 0 ; <vul-start> == ']' ) return value + 1 ; * ep = value ; <vul-end> return 0 ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> char * value, const char * * ep <vul-start> '[' ) { * ep = value ; return 0 ; <vul-end> } item -> <vul-start> == ']' ) return value + 1 ; <vul-end> item -> child <vul-start> cJSON_New_Item ( ) ; if (! item -> child ) return 0 ; <vul-end> value = skip <vul-start> ( value ), ep ) ) ; if (! value ) <vul-end> return 0 ; <vul-start> = child ; child = new_item ; <vul-end> value = skip <vul-start> + 1 ), ep ) ) ; if (! value ) <vul-end> return 0 ; <vul-start> == ']' ) return value + 1 ; * ep = value ; <vul-end> return 0 ;\n"
 },
 {
  "id": 155,
  "question": "CWE-77 Code Input Vulnerable Code Is: CWE-77 int <vul-start> run_cmd ( int fd , ... ) <vul-end> { pid_t pid ; sigset_t sigm , sigm_old ; sigemptyset ( & sigm ) ; sigaddset ( & sigm , SIGTERM ) ; sigprocmask ( SIG_BLOCK , & sigm , & sigm_old ) ; pid = fork ( ) ; if ( pid < 0 ) { sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; fd_printf ( STO , \"*** cannot fork: %s ***\\\\r\\\\n\" , strerror ( errno ) ) ; return - 1 ; } else if ( pid ) { int status , r ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; do { r = waitpid ( pid , & status , 0 ) ; } while ( r < 0 && errno == EINTR ) ; term_apply ( STI ) ; if ( WIFEXITED ( status ) ) { fd_printf ( STO , \"\\\\r\\\\n*** exit status: %d ***\\\\r\\\\n\" , WEXITSTATUS ( status ) ) ; return WEXITSTATUS ( status ) ; } else if ( WIFSIGNALED ( status ) ) { fd_printf ( STO , \"\\\\r\\\\n*** killed by signal: %d ***\\\\r\\\\n\" , WTERMSIG ( status ) ) ; return - 1 ; } else { fd_printf ( STO , \"\\\\r\\\\n*** abnormal termination: 0x%x ***\\\\r\\\\n\" , r ) ; return - 1 ; } } else { long fl ; <vul-start> char cmd [ 512 ] ; <vul-end> term_remove ( STI ) ; term_erase ( fd ) ; fl = fcntl ( fd , F_GETFL ) ; fl &= ~ O_NONBLOCK ; fcntl ( fd , F_SETFL",
  "golden_answers": [
   "CWE-77 Fixed Code Lines are: <vul-start> int fd , const char * cmd , const char * args_extra <vul-end> ) { pid_t <vul-start> long fl ; int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <vul-end> ; term_remove ( <vul-start> STO ) ; argc = 0 ; r = split_quoted <vul-end> ( cmd , <vul-start> ( cmd , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , \"Cannot parse command\\\\n\" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , \"Cannot parse extra args\\\\n\" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , \"No command given\\\\n\" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , \"$ %s %s\\\\n\" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <vul-end> fd_printf ( STDERR_FILENO <vul-start> ( STDERR_FILENO , \"exec: %s\\\\n\" , strerror ( errno ) <vul-end> ) ; exit <vul-start> ; exit ( RUNCMD_EXEC_FAIL <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-77 Fixed Code Lines are: <vul-start> int run_cmd ( <vul-end> ) { pid_t <vul-start> char cmd [ 1024 <vul-end> ] ; term_remove <vul-start> '\\\\0' ; } <vul-end> establish_child_signal_handlers ( ) <vul-start> NULL ) ; <vul-end> } }  \n"
 },
 {
  "id": 156,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( \"mvs.stt\" , \"a\" ) ; mb_index = 0 ; fprintf ( mvs , \"Mb Modes for Frame %d\\\\n\" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , \"%2d \" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , \"\\\\n\" ) ; mb_index ++ ; } fprintf ( mvs , \"\\\\n\" ) ; mb_index = 0 ; fprintf ( mvs , \"Mb mv ref for Frame %d\\\\n\" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , \"%2d \" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , \"\\\\n\" ) ; mb_index ++ ; } fprintf ( mvs , \"\\\\n\" ) ; mb_index = 0 ; fprintf ( mvs , \"UV Modes for Frame %d\\\\n\" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , \"%2d \" , mi [ mb_index ] .",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , \"\\\\n\" ) <vul-end> ; fprintf ( <vul-start> \"\\\\n\" ) ; <vul-end> fprintf ( mvs\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( mvs, \"Mvs for Frame %d\\\\n\", frame ) ; { int mb_row ; for ( mb_row = 0 ; mb_row < 4 * rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs, \"%2d \", mi [ mb_index ]. mbmi [ bindex ]. as_mode ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs, \"\\\\n\" ) ; } fprintf ( mvs, \"\\\\n\" ) ; mb_index = 0 ; fprintf ( mvs, \"Mb mv ref for Frame %d\\\\n\", frame ) ; { int b_row ; for ( b_col ; b_row ++ ) { int b_col ; int bindex ; for ( bindex = 0 ; bindex < 4 * cols ; bindex ++ ) { fprintf ( mvs, \"%2d:%-3d \", mi [ mb_index ]. mbmi [ bindex ]. bmi [ bindex ]. as_mv. row, mi [ mb_index ]. mbmi [ bindex ]. mbmi [ bindex ]. mv. as_mv. col ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs, \"\\\\n\" ) ; } mb_index ++ ; fprintf ( mvs, \"\\\\n\" ) ; } fprintf ( mvs, \"\\\\n\" ) ; mb_index = 0 ; fprintf ( mvs, \"Mvs for Frame %d\\\\n\", frame ) ; { int b_row ; for ( b_col ; b_col < 4 * rows ; b_col ++ ) { fprintf ( mvs, \"%2d \", mi [ mb_index ]. mbmi [ bindex ]. mbmi [ bindex ]. mv. as_mv. row, mi [ mb_index ]. mbmi [ bindex ]. mbmi [ bindex ]. mv. as_mv. col ) ; mb_index ++ ; fprintf ( mvs, \"\\\\n\" ) ; } mb_index ++ ; fprintf ( mvs, \"\\\\n\" ) ; mb_index = 0 ; fprintf ( mvs, \"Mb mv ref"
 },
 {
  "id": 157,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static struct kioctx * ioctx_alloc ( unsigned nr_events ) { struct mm_struct * mm = current -> mm ; struct kioctx * ctx ; int err = - ENOMEM ; nr_events = max ( nr_events , num_possible_cpus ( ) * 4 ) ; nr_events *= 2 ; if ( ( nr_events > ( 0x10000000U / sizeof ( struct io_event ) ) ) || ( nr_events > ( 0x10000000U / sizeof ( struct kiocb ) ) ) ) { pr_debug ( \"ENOMEM: nr_events too high\\\\n\" ) ; return ERR_PTR ( - EINVAL ) ; } if ( ! nr_events || ( unsigned long ) nr_events > ( aio_max_nr * 2UL ) ) return ERR_PTR ( - EAGAIN ) ; ctx = kmem_cache_zalloc ( kioctx_cachep , GFP_KERNEL ) ; if ( ! ctx ) return ERR_PTR ( - ENOMEM ) ; ctx -> max_reqs = nr_events ; if ( percpu_ref_init ( & ctx -> users , free_ioctx_users ) ) goto err ; if ( percpu_ref_init ( & ctx -> reqs , free_ioctx_reqs ) ) goto err ; spin_lock_init ( & ctx -> ctx_lock ) ; spin_lock_init ( & ctx -> completion_lock ) ; mutex_init ( & ctx -> ring_lock ) ; init_waitqueue_head ( & ctx -> wait ) ; INIT_LIST_HEAD ( & ctx -> active_reqs ) ; ctx -> cpu = alloc_percpu ( struct kioctx_cpu ) ; if ( ! ctx -> cpu ) goto err ; if ( aio_setup_ring ( ctx ) < 0 ) goto err ; atomic_set ( & ctx -> reqs_available , ctx -> nr_events - 1 ) ; ctx -> req_batch =",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ; err : <vul-end> free_percpu ( ctx\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ; err : atomic_set ( & ctx -> nr_io_events, 0 ) ;\n"
 },
 {
  "id": 158,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } <vul-start> if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { <vul-end> return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( \"all tiles are outside the image area\\\\n\" ) ; return - 1 ; } if (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> comps = jas_alloc3 ( in, siz -> numcomps, <vul-end> sizeof ( jpc_sizcomp_t\n"
 },
 {
  "id": 159,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static ssize_t driver_override_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) { struct platform_device * pdev = to_platform_device ( dev ) ; <vul-start> char * driver_override , * old = pdev -> driver_override , * cp ; <vul-end> if ( count > PATH_MAX ) return - EINVAL ; driver_override = kstrndup ( buf , count , GFP_KERNEL ) ; if ( ! driver_override ) return - ENOMEM ; cp = strchr ( driver_override , '\\\\n' ) ; if ( cp ) * cp = '\\\\0' ; <vul-start> if ( strlen ( driver_override ) ) { <vul-end> pdev -> driver_override = driver_override ; } else { kfree ( driver_override ) ; pdev -> driver_override = NULL ; } <vul-start> kfree ( old ) ; <vul-end> return count ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> , * old <vul-end> , * cp <vul-start> = '\\\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <vul-start> NULL ; } device_unlock ( dev ) ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start>, * old <vul-end>, * cp <vul-start> = '\\\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <vul-start> NULL ; } device_unlock ( dev ) ;\n"
 },
 {
  "id": 160,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <vul-start> int yy , mm , dd , hr , min , sec , csec ; <vul-end> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = \"\" , direction [ 6 ] = \"\" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d:\" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <vul-start> \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" , <vul-end> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine: purported control blade line doesn\\'t have code values\" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <vul-start> \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d,",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> sec , csec , <vul-end> pkt_len ; int <vul-start> ( line , \"%4d-%2d-%2d,%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" <vul-end> , & yy <vul-start> ( line , \"%5s (%127[A-Za-z0-9/:]), Length:%9d, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d, Err:%9d [%8x, %8x]\" <vul-end> , direction , <vul-start> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"cosine: packet header has a negative packet length\" ) ; return FALSE\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int num_items_scanned ; guint pkt_len ; int pro, off, pri, rm ; int direction [ 6 ] = \"\" ; char * if_name [ COSINE_MAX_IF_NAME_LEN ] = \"\" ; int if_len_scanned = 0 ; if ( sscanf ( line, \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d [%8x %8x]\", <vul-end> if_name, & <vul-start> ( line, \"%4d-%2d-%2d:%2d:%2d.%9d: %5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d [%8x %8x]\" <vul-end>, direction, <vul-start> ( line, \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d [%8x %8x]\" <vul-end>, direction, <vul-start> FALSE ; } if ( sscanf ( line, \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pri:%9d, RM:%9d [%8x %8x]\", <vul-end> direction, if_name <vul-start> FALSE ; } if ( sscanf ( line, \"%5s (%127[A-Za-z0-9/:]), Length:%9u, Pro:%9d, Off:%9d, Pri:%9d, RM:%9d [%8x %8x]\", <vul-end> if_name, & <vul-start> off, & rm, & error, & code1, & code2 ) == 7 ) { if ( num_items_scanned!= 11 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( \"cosine: file has %u-byte packet bigger than maximum of %u\", pkt_len, WTAP_MAX_IF_NAME_LEN ) ; return FALSE ; } if"
 },
 {
  "id": 161,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void tv_details_row_activated ( GtkTreeView * tree_view , GtkTreePath * tree_path_UNUSED , GtkTreeViewColumn * column , gpointer user_data ) { gchar * item_name ; struct problem_item * item = get_current_problem_item_or_NULL ( tree_view , & item_name ) ; if ( ! item || ! ( item -> flags & CD_FLAG_TXT ) ) goto ret ; if ( ! strchr ( item -> content , '\\\\n' ) ) goto ret ; gint exitcode ; gchar * arg [ 3 ] ; arg [ 0 ] = ( char * ) \"xdg-open\" ; arg [ 1 ] = concat_path_file ( g_dump_dir_name , item_name ) ; arg [ 2 ] = NULL ; const gboolean spawn_ret = g_spawn_sync ( NULL , arg , NULL , G_SPAWN_SEARCH_PATH | G_SPAWN_STDOUT_TO_DEV_NULL , NULL , NULL , NULL , NULL , & exitcode , NULL ) ; if ( spawn_ret == FALSE || exitcode != EXIT_SUCCESS ) { GtkWidget * dialog = gtk_dialog_new_with_buttons ( _ ( \"View/edit a text file\" ) , GTK_WINDOW ( g_wnd_assistant ) , GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT , NULL , NULL ) ; GtkWidget * vbox = gtk_dialog_get_content_area ( GTK_DIALOG ( dialog ) ) ; GtkWidget * scrolled = gtk_scrolled_window_new ( NULL , NULL ) ; GtkWidget * textview = gtk_text_view_new ( ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( \"_Save\" ) , GTK_RESPONSE_OK ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( \"_Cancel\" ) , GTK_RESPONSE_CANCEL ) ; gtk_box_pack_start ( GTK_BOX ( vbox ) , scrolled , TRUE , TRUE , 0 ) ; gtk_widget_set_size_request ( scrolled , 640 , 480 ) ; gtk_widget_show",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> == GTK_RESPONSE_OK ) { <vul-start> item_name ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; }\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> == GTK_RESPONSE_OK ) { save_text_from_text_view ( GTK_TEXT_VIEW ( textview ), item_name ) ; } <vul-end> gtk_widget_destroy ( textview\n"
 },
 {
  "id": 162,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 int main ( int argc , char * * argv ) { setlocale ( LC_ALL , \"\" ) ; # if ENABLE_NLS bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; # endif abrt_init ( argv ) ; const char * program_usage_string = _ ( \"& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\\\\n\" \"\\\\t[-r REPO]\\\\n\" \"\\\\n\" \"Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\\\\n\" \"ABRT system cache.\" ) ; enum { OPT_v = 1 << 0 , OPT_y = 1 << 1 , OPT_i = 1 << 2 , OPT_e = 1 << 3 , OPT_r = 1 << 4 , OPT_s = 1 << 5 , } ; const char * build_ids = \"build_ids\" ; const char * exact = NULL ; const char * repo = NULL ; const char * size_mb = NULL ; struct options program_options [ ] = { OPT__VERBOSE ( & g_verbose ) , OPT_BOOL ( 'y' , \"yes\" , NULL , _ ( \"Noninteractive, assume \\'Yes\\' to all questions\" ) ) , OPT_STRING ( 'i' , \"ids\" , & build_ids , \"BUILD_IDS_FILE\" , _ ( \"- means STDIN, default: build_ids\" ) ) , OPT_STRING ( 'e' , \"exact\" , & exact , \"EXACT\" , _ ( \"Download only specified files\" ) ) , OPT_STRING ( 'r' , \"repo\" , & repo , \"REPO\" , _ ( \"Pattern to use when searching for repos, default: *debug*\" ) ) , OPT_STRING ( 's' , \"size_mb\" , & size_mb , \"SIZE_MB\" , _ ( \"Ignored option\" ) ) , OPT_END ( ) } ; const unsigned opts",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> ) ; } char tmp_directory [ ] = LARGE_DATA_TMP_DIR \"/abrt-tmp-debuginfo.XXXXXX\" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( \"Failed to create working directory\" ) ; log_info ( \"Created working directory: %s\" , tmp_directory ) ; const char * args [ 13 <vul-end> ] ; { <vul-start> ++ ] = \"--tmpdir\" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <vul-start> ) ; } pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( \"fork\" ) ; if ( pid == 0 ) { <vul-start> ) ; } int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( \"waitpid\" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( \"Removed working directory: %s\" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( \"Failed to remove working directory\" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( \"Child terminated with signal %d\" , WTERMSIG ( status ) ) ; error_msg_and_die ( \"Child exit failed\" ) ; }\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> char * args [ 19 ] ; args [ i ++ ] = \"--\" ; args [ i ] = NULL ; if ( g_verbose > 0 ) IGNORE_RESULT ( setvbuf ( stdout, NULL, _ ( \"Not supported in this system\" ) ) ; if ( build_ids_self_fd!= NULL ) close ( build_ids_self_fd ) ; args <vul-start> ) ; } <vul-end> if ( egid <vul-start> EXECUTABLE ) ; args [ i ++ ] = NULL ;\n"
 },
 {
  "id": 163,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 protected int file_trycdf ( struct magic_set * ms , int fd , const unsigned char * buf , size_t nbytes ) { cdf_info_t info ; cdf_header_t h ; cdf_sat_t sat , ssat ; cdf_stream_t sst , scn ; cdf_dir_t dir ; int i ; const char * expn = \"\" ; const char * corrupt = \"corrupt: \" ; info . i_fd = fd ; info . i_buf = buf ; info . i_len = nbytes ; if ( ms -> flags & MAGIC_APPLE ) return 0 ; if ( cdf_read_header ( & info , & h ) == - 1 ) return 0 ; # ifdef CDF_DEBUG cdf_dump_header ( & h ) ; # endif if ( ( i = cdf_read_sat ( & info , & h , & sat ) ) == - 1 ) { expn = \"Can\\'t read SAT\" ; goto out0 ; } # ifdef CDF_DEBUG cdf_dump_sat ( \"SAT\" , & sat , CDF_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_ssat ( & info , & h , & sat , & ssat ) ) == - 1 ) { expn = \"Can\\'t read SSAT\" ; goto out1 ; } # ifdef CDF_DEBUG cdf_dump_sat ( \"SSAT\" , & ssat , CDF_SHORT_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_dir ( & info , & h , & sat , & dir ) ) == - 1 ) { expn = \"Can\\'t read directory\" ; goto out2 ; } const cdf_directory_t * root_storage ; if ( ( i",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> scn , root_storage <vul-end> ) ) <\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> root_storage -> d_storage_uuid, 0\n"
 },
 {
  "id": 164,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int ndp_sock_recv ( struct ndp * ndp ) { struct ndp_msg * msg ; enum ndp_msg_type msg_type ; size_t len ; int err ; msg = ndp_msg_alloc ( ) ; if ( ! msg ) return - ENOMEM ; len = ndp_msg_payload_maxlen ( msg ) ; err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 , <vul-start> & msg -> addrto , & msg -> ifindex ) ; <vul-end> if ( err ) { err ( ndp , \"Failed to receive message\" ) ; goto free_msg ; } <vul-start> dbg ( ndp , \"rcvd from: %s, ifindex: %u\" , <vul-end> <vul-start> str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ; <vul-end> if ( len < sizeof ( * msg -> icmp6_hdr ) ) { warn ( ndp , \"rcvd icmp6 packet too short (%luB)\" , len ) ; err = 0 ; goto free_msg ; } err = ndp_msg_type_by_raw_type ( & msg_type , msg -> icmp6_hdr -> icmp6_type ) ; if ( err ) { err = 0 ; goto free_msg ; } ndp_msg_init ( msg , msg_type ) ; ndp_msg_payload_len_set ( msg , len ) ; if ( ! ndp_msg_check_valid ( msg ) ) { warn ( ndp , \"rcvd invalid ND message\" ) ; err = 0 ; goto free_msg ; } dbg ( ndp , \"rcvd %s, len: %zuB\" , ndp_msg_type_info ( msg_type ) -> strabbr , len ) ; if ( ! ndp_msg_check_opts ( msg ) ) { err = 0 ; goto free_msg ; } err = ndp_call_handlers",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> msg -> ifindex , & msg -> hoplimit <vul-start> ( ndp , \"rcvd from: %s, ifindex: %u, hoplimit: %d\" <vul-end> , str_in6_addr ( <vul-start> msg -> ifindex , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , \"ignoring packet with bad hop limit (%d)\" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <vul-end> if ( len\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> & msg -> ifindex, & msg -> addrfrom <vul-end> ) ; if <vul-start> ( ndp, \"rcvd from: %s, ifindex: %i\" <vul-end>, str_in6_addr ( <vul-start> msg -> ifindex, & msg -> addrfrom\n"
 },
 {
  "id": 165,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int command_read ( struct pci_dev * dev , int offset , u16 * value , void * data ) { <vul-start> int i ; <vul-end> int ret ; <vul-start> ret = xen_pcibk_read_config_word ( dev , offset , value , data ) ; <vul-end> if ( ! pci_is_enabled ( dev ) ) return ret ; for ( i = 0 ; i < PCI_ROM_RESOURCE ; i ++ ) { if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) <vul-start> * value |= PCI_COMMAND_IO ; <vul-end> if ( dev -> resource [ i ] . flags & IORESOURCE_MEM ) * value |= PCI_COMMAND_MEMORY ; } return ret ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ) { int ret = pci_read_config_word <vul-end> ( dev , <vul-start> offset , value ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <vul-end> * value |= <vul-start> * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; <vul-end> return ret ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> data ) { u16 val ; int i <vul-end> ; ret = <vul-start>, data ) ; if ( ret < 2 ) return ret <vul-start> * value |= PCI_COMMAND_IO ; if ( ret == 2 ) * value |=\n"
 },
 {
  "id": 166,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static PyObject * _pickle_UnpicklerMemoProxy_copy_impl ( UnpicklerMemoProxyObject * self ) { <vul-start> Py_ssize_t i ; <vul-end> PyObject * new_memo = PyDict_New ( ) ; if ( new_memo == NULL ) return NULL ; for ( i = 0 ; i < self -> unpickler -> memo_size ; i ++ ) { int status ; PyObject * key , * value ; value = self -> unpickler -> memo [ i ] ; if ( value == NULL ) continue ; key = PyLong_FromSsize_t ( i ) ; if ( key == NULL ) goto error ; status = PyDict_SetItem ( new_memo , key , value ) ; Py_DECREF ( key ) ; if ( status < 0 ) goto error ; } return new_memo ; error : Py_DECREF ( new_memo ) ; return NULL ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> self ) { size_t <vul-end> i ; PyObject\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> self ) { size_t <vul-end> i ; PyObject\n"
 },
 {
  "id": 167,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static MB_PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) { <vul-end> <vul-start> return ( MB_PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static PREDICTION_MODE read_intra_mode ( vpx_reader <vul-end> * r , <vul-start> r , const vpx_prob <vul-end> * p ) <vul-start> { return ( PREDICTION_MODE ) vpx_read_tree <vul-end> ( r ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static PREDICTION_MODE <vul-end> read_intra_mode ( vp9_reader <vul-start> r, const vpx_prob <vul-end> * p ) <vul-start> { return ( PREDICTION_MODE <vul-end> ) vp9_read_tree (\n"
 },
 {
  "id": 168,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int create_qp_common ( struct mlx5_ib_dev * dev , struct ib_pd * pd , struct ib_qp_init_attr * init_attr , struct ib_udata * udata , struct mlx5_ib_qp * qp ) { struct mlx5_ib_resources * devr = & dev -> devr ; int inlen = MLX5_ST_SZ_BYTES ( create_qp_in ) ; struct mlx5_core_dev * mdev = dev -> mdev ; <vul-start> struct mlx5_ib_create_qp_resp resp ; <vul-end> struct mlx5_ib_cq * send_cq ; struct mlx5_ib_cq * recv_cq ; unsigned long flags ; u32 uidx = MLX5_IB_DEFAULT_UIDX ; struct mlx5_ib_create_qp ucmd ; struct mlx5_ib_qp_base * base ; int mlx5_st ; void * qpc ; u32 * in ; int err ; mutex_init ( & qp -> mutex ) ; spin_lock_init ( & qp -> sq . lock ) ; spin_lock_init ( & qp -> rq . lock ) ; mlx5_st = to_mlx5_st ( init_attr -> qp_type ) ; if ( mlx5_st < 0 ) return - EINVAL ; if ( init_attr -> rwq_ind_tbl ) { if ( ! udata ) return - ENOSYS ; err = create_rss_raw_qp_tir ( dev , qp , pd , init_attr , udata ) ; return err ; } if ( init_attr -> create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK ) { if ( ! MLX5_CAP_GEN ( mdev , block_lb_mc ) ) { mlx5_ib_dbg ( dev , \"block multicast loopback isn\\'t supported\\\\n\" ) ; return - EINVAL ; } else { qp -> flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK ; } } if ( init_attr -> create_flags & ( IB_QP_CREATE_CROSS_CHANNEL | IB_QP_CREATE_MANAGED_SEND | IB_QP_CREATE_MANAGED_RECV ) ) { if ( ! MLX5_CAP_GEN ( mdev , cd ) ) { mlx5_ib_dbg ( dev , \"cross-channel isn\\'t",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> struct mlx5_ib_create_qp_resp resp = { }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> struct mlx5_ib_create_qp_resp resp ; struct ib_qp_attr * pattr <vul-start> EINVAL ; } if ( init_attr -> create_flags & IB_QP_CREATE_COMPLIANT_PASS ) { if (! MLX5_CAP_GEN ( mdev, tx_buf_pool ) ) { mlx5_ib_dbg ( dev, \"cannot create_COMPLIANT_PASS\\\\n\" ) ; return - EINVAL ; } pattr = & qp -> attr ; resp. pattr = & pattr ; <vul-start> -> create_flags & IB_QP_CREATE_COMPLIANT_PASS || init_attr -> create_flags &\n"
 },
 {
  "id": 169,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_init_mbmode_probs ( VP8_COMMON * x ) { <vul-start> vpx_memcpy ( x -> fc . ymode_prob , vp8_ymode_prob , sizeof ( vp8_ymode_prob ) ) ; <vul-end> <vul-start> vpx_memcpy ( x -> fc . uv_mode_prob , vp8_uv_mode_prob , sizeof ( vp8_uv_mode_prob ) ) ; <vul-end> <vul-start> vpx_memcpy ( x -> fc . sub_mv_ref_prob , sub_mv_ref_prob , sizeof ( sub_mv_ref_prob ) ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> x ) { memcpy <vul-end> ( x -> <vul-start> ) ) ; memcpy <vul-end> ( x -> <vul-start> ) ) ; memcpy <vul-end> ( x ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> x ) { memcpy <vul-end> ( x -> <vul-start> ) ) ; memcpy <vul-end> ( x -> <vul-start> ) ) ; memcpy <vul-end> ( x ->\n"
 },
 {
  "id": 170,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int br_multicast_add_group ( struct net_bridge * br , struct net_bridge_port * port , struct br_ip * group ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p ; struct net_bridge_port_group __rcu * * pp ; unsigned long now = jiffies ; int err ; spin_lock ( & br -> multicast_lock ) ; if ( ! netif_running ( br -> dev ) || ( port && port -> state == BR_STATE_DISABLED ) ) goto out ; mp = br_multicast_new_group ( br , port , group ) ; err = PTR_ERR ( mp ) ; if ( IS_ERR ( mp ) ) goto err ; if ( ! port ) { <vul-start> hlist_add_head ( & mp -> mglist , & br -> mglist ) ; <vul-end> mod_timer ( & mp -> timer , now + br -> multicast_membership_interval ) ; goto out ; } for ( pp = & mp -> ports ; ( p = mlock_dereference ( * pp , br ) ) != NULL ; pp = & p -> next ) { if ( p -> port == port ) goto found ; if ( ( unsigned long ) p -> port < ( unsigned long ) port ) break ; } p = kzalloc ( sizeof ( * p ) , GFP_ATOMIC ) ; err = - ENOMEM ; if ( unlikely ( ! p ) ) goto err ; p -> addr = * group ; p -> port = port ; p -> next = * pp ; hlist_add_head ( & p -> mglist , & port -> mglist",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> port ) { if ( hlist_unhashed ( & mp -> mglist ) )\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> port ) { if ( mp -> timer_armed ) goto out ;\n"
 },
 {
  "id": 171,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 cJSON * cJSON_CreateObject ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_Object ; return item ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: \n"
 },
 {
  "id": 172,
  "question": "CWE-129 Code Input Vulnerable Code Is: CWE-129 static av_cold int vqa_decode_init ( AVCodecContext * avctx ) { VqaContext * s = avctx -> priv_data ; int i , j , codebook_index , ret ; s -> avctx = avctx ; avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; if ( s -> avctx -> extradata_size != VQA_HEADER_SIZE ) { av_log ( s -> avctx , AV_LOG_ERROR , \"expected extradata size of %d\\\\n\" , VQA_HEADER_SIZE ) ; return AVERROR ( EINVAL ) ; } s -> vqa_version = s -> avctx -> extradata [ 0 ] ; switch ( s -> vqa_version ) { case 1 : case 2 : break ; case 3 : avpriv_report_missing_feature ( avctx , \"VQA Version %d\" , s -> vqa_version ) ; return AVERROR_PATCHWELCOME ; default : avpriv_request_sample ( avctx , \"VQA Version %i\" , s -> vqa_version ) ; return AVERROR_PATCHWELCOME ; } s -> width = AV_RL16 ( & s -> avctx -> extradata [ 6 ] ) ; s -> height = AV_RL16 ( & s -> avctx -> extradata [ 8 ] ) ; <vul-start> if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) { <vul-end> s -> width = s -> height = 0 ; return ret ; } s -> vector_width = s -> avctx -> extradata [ 10 ] ; s -> vector_height = s -> avctx -> extradata [ 11 ] ; s -> partial_count = s -> partial_countdown = s -> avctx -> extradata [ 13 ] ; if ( ( s -> vector_width != 4",
  "golden_answers": [
   "CWE-129 Fixed Code Lines are: <vul-start> ( ret = ff_set_dimensions ( avctx , <vul-end> s -> width <vul-start> s -> height <vul-end> ) ) <\n"
  ],
  "generated_answer": "CWE-129 Fixed Code Lines are: <vul-start> ] ) ; s -> pix_fmt = AV_PIX_FMT_PAL8 ; if ( s -> width < 1 || s -> height < 1 ) { avpriv_report_missing_feature ( avctx, \"VQA Version %i\", s -> vqa_version ) ; return AVERROR_PATCHWELCOME ; }\n"
 },
 {
  "id": 173,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; <vul-start> DPRINTF ( 4 , ( \"enabling filegen for %s statistics \\'%s%s\\'\\\\n\" , <vul-end> filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; <vul-start> filegen_flag = filegen -> flag ; <vul-end> filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ;",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , \"stats %s unrecognized\" , filegen_string ) ; continue ; } <vul-start> filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , \"filegen category \\'%s\\' unrecognized\" , filegen_file ) ; continue ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 4, ( \"enabling filegen for \\'%s\\' statistics \\'%s%s\\'\\\\n\" <vul-end>, filegen_string, <vul-start> filegen_file ) ; if ( filegen == NULL ) { msyslog ( LOG_ERR, ( \"Invalid filegen file %s\", filegen_file ) ) ; exit ( 1 ) ; } filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts!= NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> value. i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR, \"Unknown filegen flag token %d\", my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen, filegen_file, filegen_type, filegen_flag ) ; } } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node!= NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; filegen = filegen_get ( filegen_file ) ; filegen = HEAD_PFIFO ( my_node -> filegen_opts ) ; for ( ; my_node!= NULL ; my_node = my_node -> link ) { filegen_string = keyword ( my_node -> filegen_token"
 },
 {
  "id": 174,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags ) { struct mm_struct * mm = vma -> vm_mm ; struct dev_pagemap * pgmap = NULL ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; <vul-start> if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) { <vul-end> pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { pgmap = get_dev_pagemap ( pte_pfn ( pte ) , NULL ) ; if ( pgmap ) page = pte_page ( pte ) ;",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ) && ! can_follow_write_pte ( pte , flags <vul-end> ) ) {\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) &&! pte_trans_huge_or_write <vul-end> ( pte )\n"
 },
 {
  "id": 175,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void vhost_net_ubuf_put_and_wait ( struct vhost_net_ubuf_ref * ubufs ) { kref_put ( & ubufs -> kref , vhost_net_zerocopy_done_signal ) ; wait_event ( ubufs -> wait , ! atomic_read ( & ubufs -> kref . refcount ) ) ; <vul-start> kfree ( ubufs ) ; <vul-end> }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ) ) ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ) ) ; if ( ubufs -> bufs ) kfree ( ubufs -> bufs ) ;\n"
 },
 {
  "id": 176,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int verify_compat_iovec ( struct msghdr * kern_msg , struct iovec * kern_iov , struct sockaddr_storage * kern_address , int mode ) { int tot_len ; if ( kern_msg -> msg_namelen ) { if ( mode == VERIFY_READ ) { int err = move_addr_to_kernel ( kern_msg -> msg_name , kern_msg -> msg_namelen , kern_address ) ; if ( err < 0 ) return err ; } <vul-start> kern_msg -> msg_name = kern_address ; <vul-end> } else kern_msg -> msg_name = NULL ; tot_len = iov_from_user_compat_to_kern ( kern_iov , ( struct compat_iovec __user * ) kern_msg -> msg_iov , kern_msg -> msg_iovlen ) ; if ( tot_len >= 0 ) kern_msg -> msg_iov = kern_iov ; return tot_len ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> err ; } if ( kern_msg -> msg_name )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> err ; } else if ( kern_msg -> msg_namelen == 0 ) { memset ( kern_msg -> msg_name, 0, sizeof ( struct sockaddr_storage ) ) ; }\n"
 },
 {
  "id": 177,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <vul-end> int mi_row , int mi_col , vp9_reader * r ) { <vul-start> struct segmentation * const seg = & cm -> seg ; <vul-end> const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; int segment_id ; if ( ! seg -> enabled ) return 0 ; <vul-start> if ( ! seg -> update_map ) <vul-end> <vul-start> return 0 ; <vul-end> segment_id = read_segment_id ( r , seg ) ; <vul-start> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <vul-end> return segment_id ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> const cm , int mi_offset , int x_mis , int y_mis , vpx_reader <vul-end> * r ) <vul-start> cm -> seg <vul-end> ; int segment_id <vul-start> -> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <vul-start> return 0 ; } <vul-start> ( cm , mi_offset , x_mis , y_mis <vul-end> , segment_id )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int read_intra_segment_id ( vpx_reader * r, BLOCK_SIZE bsize, int mi_row, int mi_col, vpx_reader <vul-end> * const r <vul-start> r ) { int segment_id ; if ( xd -> num_mbs_left < 1 || xd -> num_mbs_left > BLOCK_16X16 ) { vpx_log ( VPX_LOG_ERROR, \"vpx: too many mbs in segment\" ) ; return - 1 ; } <vul-end> if (! <vul-start> return 0 ; <vul-end> segment_id = read_segment_id <vul-start> -> update_map ) { vpx_log ( VPX_LOG_ERROR, \"vpx: too many update map\" ) ; return - 1 ; } <vul-end> segment_id = read_segment_id <vul-start> seg ) ; if ( seg -> update_map [ segment_id ]. enabled ) { vpx_log ( VPX_LOG_ERROR, \"vpx: too many update map\" ) ; return - 1 ; } else { <vul-start> segment_id ) ; }\n"
 },
 {
  "id": 178,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; if ( len > 1 ) { if ( <vul-start> <= 127 ) { <vul-start> -> size ; } else { <vul-end> op -> jump <vul-start> -> size ; } } else { op -> jump = addr ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = R_ANAL_OP_TYPE_CJMP ; int min_size = sizeof ( addrbuf ) - 1 ; min_size = ( int ) <vul-end> ( 256 - <vul-start> [ 1 ] ) ; if ( min_size > max_size ) { r_anal_esil_set_error ( anal, R_ANAL_ERR_INVALID_ARGUMENTS, \"Invalid jump size\" ) ; return - 1 ; } <vul-end> _6502_anal_esil_ccall ( op <vul-start> = addr - min_size <vul-end> ; op -> <vul-start> -> size ; min_size = sizeof ( addrbuf ) - 1 ; <vul-start> -> esil, \"%s[a+,+,=,a]\" <vul-end>, addrbuf )\n"
 },
 {
  "id": 179,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 void Init_ossl_cipher ( void ) { # if 0 mOSSL = rb_define_module ( \"OpenSSL\" ) ; eOSSLError = rb_define_class_under ( mOSSL , \"OpenSSLError\" , rb_eStandardError ) ; # endif cCipher = rb_define_class_under ( mOSSL , \"Cipher\" , rb_cObject ) ; eCipherError = rb_define_class_under ( cCipher , \"CipherError\" , eOSSLError ) ; rb_define_alloc_func ( cCipher , ossl_cipher_alloc ) ; rb_define_copy_func ( cCipher , ossl_cipher_copy ) ; rb_define_module_function ( cCipher , \"ciphers\" , ossl_s_ciphers , 0 ) ; rb_define_method ( cCipher , \"initialize\" , ossl_cipher_initialize , 1 ) ; rb_define_method ( cCipher , \"reset\" , ossl_cipher_reset , 0 ) ; rb_define_method ( cCipher , \"encrypt\" , ossl_cipher_encrypt , - 1 ) ; rb_define_method ( cCipher , \"decrypt\" , ossl_cipher_decrypt , - 1 ) ; rb_define_method ( cCipher , \"pkcs5_keyivgen\" , ossl_cipher_pkcs5_keyivgen , - 1 ) ; rb_define_method ( cCipher , \"update\" , ossl_cipher_update , - 1 ) ; rb_define_method ( cCipher , \"final\" , ossl_cipher_final , 0 ) ; rb_define_method ( cCipher , \"name\" , ossl_cipher_name , 0 ) ; rb_define_method ( cCipher , \"key=\" , ossl_cipher_set_key , 1 ) ; rb_define_method ( cCipher , \"auth_data=\" , ossl_cipher_set_auth_data , 1 ) ; rb_define_method ( cCipher , \"auth_tag=\" , ossl_cipher_set_auth_tag , 1 ) ; rb_define_method ( cCipher , \"auth_tag\" , ossl_cipher_get_auth_tag , - 1 ) ; rb_define_method ( cCipher , \"auth_tag_len=\" , ossl_cipher_set_auth_tag_len , 1 ) ; rb_define_method ( cCipher , \"authenticated?\" , ossl_cipher_is_authenticated , 0 ) ; rb_define_method ( cCipher , \"key_len=\" , ossl_cipher_set_key_length , 1 ) ; rb_define_method ( cCipher , \"key_len\" , ossl_cipher_key_length , 0 ) ; rb_define_method ( cCipher , \"iv=\" , ossl_cipher_set_iv ,",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> \"auth_tag_len\" ) ; id_key_set = rb_intern_const ( \"key_set\" ) ;\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> \"auth_tag_len\" ) ; id_auth_tag = rb_intern_const ( \"auth_tag\" ) ;\n"
 },
 {
  "id": 180,
  "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 static int <vul-start> ext2_xattr_cache_insert ( struct buffer_head * bh ) <vul-end> { __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; <vul-start> struct mb_cache_entry * ce ; <vul-end> int error ; <vul-start> ce = mb_cache_entry_alloc ( ext2_xattr_cache , GFP_NOFS ) ; <vul-end> if ( ! ce ) return - ENOMEM ; <vul-start> error = mb_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; <vul-end> if ( error ) { <vul-start> mb_cache_entry_free ( ce ) ; <vul-end> if ( error == - EBUSY ) { ea_bdebug ( bh , \"already in cache (%d cache entries)\" , atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ; error = 0 ; } <vul-start> } else { <vul-end> <vul-start> ea_bdebug ( bh , \"inserting [%x] (%d cache entries)\" , ( int ) hash , <vul-end> atomic_read ( & ext2_xattr_cache -> c_entry_count ) ) ; mb_cache_entry_release ( ce ) ; } return error ; }",
  "golden_answers": [
   "CWE-19 Fixed Code Lines are: <vul-start> int ext2_xattr_cache_insert ( struct mb2_cache * cache , <vul-start> h_hash ) ; <vul-end> int error ; <vul-start> int error ; error = mb2_cache_entry_create ( cache , GFP_NOFS , hash <vul-end> , bh -> <vul-start> bh -> b_blocknr <vul-end> ) ; if <vul-start> error ) { <vul-end> if ( error <vul-start> } } else <vul-end> ea_bdebug ( bh <vul-start> ( bh , \"inserting [%x]\" <vul-end> , ( int <vul-start> int ) hash ) ; <vul-end> return error ;\n"
  ],
  "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> buffer_head * bh, struct mb2_cache * ext2_mb_cache <vul-start> h_hash ) ; <vul-end> int error ; <vul-start> int error ; error = mb2_cache_entry_create <vul-end> ( ext2_xattr_cache, <vul-start> ext2_xattr_cache, GFP_NOFS, hash, <vul-end> bh -> b_blocknr <vul-start> bh -> b_blocknr <vul-end> ) ; if <vul-start> error ) { <vul-end> if ( error <vul-start> 0 ; } mb2_cache_entry_free ( ext2_mb_cache, ce ) ; <vul-end> return error ;\n"
 },
 {
  "id": 181,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 int dbd_db_login ( SV * dbh , imp_dbh_t * imp_dbh , char * dbname , char * user , char * password ) { # ifdef dTHR dTHR ; # endif dTHX ; D_imp_xxh ( dbh ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , \"imp_dbh->connect: dsn = %s, uid = %s, pwd = %s\\\\n\" , dbname ? dbname : \"NULL\" , user ? user : \"NULL\" , password ? password : \"NULL\" ) ; imp_dbh -> stats . auto_reconnects_ok = 0 ; imp_dbh -> stats . auto_reconnects_failed = 0 ; imp_dbh -> bind_type_guessing = FALSE ; imp_dbh -> bind_comment_placeholders = FALSE ; imp_dbh -> has_transactions = TRUE ; imp_dbh -> auto_reconnect = FALSE ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_dbh -> enable_utf8 = FALSE ; # endif if ( ! my_login ( aTHX_ dbh , imp_dbh ) ) { <vul-start> do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , <vul-end> mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; return FALSE ; } DBIc_ACTIVE_on ( imp_dbh ) ; DBIc_on ( imp_dbh , DBIcf_IMPSET ) ; return TRUE ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ) ) { if ( imp_dbh -> pmysql )\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ) ) { imp_dbh -> bind_type_guessing = FALSE ; imp_dbh -> bind_comment_placeholders = FALSE ;\n"
 },
 {
  "id": 182,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int treo_attach ( struct usb_serial * serial ) { struct usb_serial_port * swap_port ; if ( ! ( ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == HANDSPRING_VENDOR_ID ) || ( le16_to_cpu ( serial -> dev -> descriptor . idVendor ) == KYOCERA_VENDOR_ID ) ) || ( serial -> num_interrupt_in == 0 ) ) return 0 ; <vul-start> # define COPY_PORT ( dest , src ) do { int i ; for ( i = 0 ; i < ARRAY_SIZE ( src -> read_urbs ) ; ++ i ) { dest -> read_urbs [ i ] = src -> read_urbs [ i ] ; dest -> read_urbs [ i ] -> context = dest ; dest -> bulk_in_buffers [ i ] = src -> bulk_in_buffers [ i ] ; } dest -> read_urb = src -> read_urb ; dest -> bulk_in_endpointAddress = src -> bulk_in_endpointAddress ; dest -> bulk_in_buffer = src -> bulk_in_buffer ; dest -> bulk_in_size = src -> bulk_in_size ; dest -> interrupt_in_urb = src -> interrupt_in_urb ; dest -> interrupt_in_urb -> context = dest ; dest -> interrupt_in_endpointAddress = src -> interrupt_in_endpointAddress ; dest -> interrupt_in_buffer = src -> interrupt_in_buffer ; } while ( 0 ) ; <vul-end> swap_port = kmalloc ( sizeof ( * swap_port ) , GFP_KERNEL ) ; if ( ! swap_port ) return - ENOMEM ; COPY_PORT ( swap_port , serial -> port [ 0 ] ) ; COPY_PORT ( serial -> port [ 0 ] , serial -> port [ 1 ] ) ; COPY_PORT ( serial -> port [ 1 ] ,",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , \"missing endpoints\\\\n\" ) ; return - ENODEV ; }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> -> interrupt_in_buffer ; \\\\\\n} <vul-end> while ( 0 <vul-start> 0 ) ; if (! src -> interrupt_in_urb ) { kfree ( swap_port ) ; return - ENODEV ; }\n"
 },
 {
  "id": 183,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_decoder_remove ( VP9Decoder * pbi ) { <vul-start> VP9_COMMON * const cm = & pbi -> common ; <vul-end> int i ; <vul-start> vp9_remove_common ( cm ) ; <vul-end> vp9_worker_end ( & pbi -> lf_worker ) ; <vul-start> vpx_free ( pbi -> lf_worker . data1 ) ; <vul-end> for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { <vul-start> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <vul-end> <vul-start> vp9_worker_end ( worker ) ; <vul-end> <vul-start> vpx_free ( worker -> data1 ) ; <vul-end> <vul-start> vpx_free ( worker -> data2 ) ; <vul-end> } vpx_free ( pbi -> tile_workers ) ; <vul-start> if ( pbi -> num_tile_workers ) { <vul-end> const int sb_rows = mi_cols_aligned_to_sb ( cm -> mi_rows ) >> MI_BLOCK_SIZE_LOG2 ; <vul-start> vp9_loop_filter_dealloc ( & pbi -> lf_row_sync , sb_rows ) ; <vul-end> } vpx_free ( pbi ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> pbi ) { <vul-end> int i ; <vul-start> int i ; vpx_get_worker_interface ( ) -> end <vul-end> ( & pbi <vul-start> lf_worker . data1 ) ; vpx_free ( pbi -> tile_data <vul-start> i ) { VPxWorker <vul-end> * const worker <vul-start> i ] ; vpx_get_worker_interface ( ) -> end <vul-end> ( worker ) <vul-start> worker ) ; } vpx_free ( pbi -> tile_worker_data <vul-end> ) ; vpx_free <vul-start> ; vpx_free ( pbi -> tile_worker_info ) ; <vul-end> vpx_free ( pbi <vul-start> pbi -> num_tile_workers > 0 ) { <vul-end> vp9_loop_filter_dealloc ( & <vul-start> pbi -> lf_row_sync <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> pbi ) { VPxWorker * const worker <vul-end> = & pbi <vul-start> & pbi -> lf_worker <vul-end> ; int i <vul-start> int i ; vpx_free <vul-end> ( pbi -> <vul-start> lf_worker ) ; vpx_free <vul-end> ( pbi -> <vul-start> i ) { VPxWorker * const worker <vul-end> = & pbi <vul-start> i ] ; vpx_free <vul-end> ( worker ) <vul-start> worker ) ; vpx_free <vul-end> ( worker -> <vul-start> data1 ) ; vpx_free <vul-end> ( worker -> <vul-start> data2 ) ; } vpx_free ( pbi -> tile_workers ) ; if ( worker -> data1 ) { vpx_free ( worker -> data1 ) ; vpx_free ( worker -> data2 ) ; } <vul-end> vp9_free ( pbi <vul-start> ( pbi -> lf_row_sync ) ; <vul-end> vpx_free ( pbi\n"
 },
 {
  "id": 184,
  "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 void wiki_handle_http_request ( HttpRequest * req ) { HttpResponse * res = http_response_new ( req ) ; char * page = http_request_get_path_info ( req ) ; char * command = http_request_get_query_string ( req ) ; char * wikitext = \"\" ; util_dehttpize ( page ) ; if ( ! strcmp ( page , \"/\" ) ) { if ( access ( \"WikiHome\" , R_OK ) != 0 ) wiki_redirect ( res , \"/WikiHome?create\" ) ; page = \"/WikiHome\" ; } if ( ! strcmp ( page , \"/styles.css\" ) ) { http_response_set_content_type ( res , \"text/css\" ) ; http_response_printf ( res , \"%s\" , CssData ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , \"/favicon.ico\" ) ) { http_response_set_content_type ( res , \"image/ico\" ) ; http_response_set_data ( res , FaviconData , FaviconDataLen ) ; http_response_send ( res ) ; exit ( 0 ) ; } page = page + 1 ; if ( ! strncmp ( page , \"api/\" , 4 ) ) { char * p ; page += 4 ; for ( p = page ; * p != '\\\\0' ; p ++ ) if ( * p == '?' ) { * p = '\\\\0' ; break ; } wiki_handle_rest_call ( req , res , page ) ; exit ( 0 ) ; } <vul-start> if ( strchr ( page , '/' ) ) <vul-end> { http_response_set_status ( res , 404 , \"Not Found\" ) ; http_response_printf ( res , \"<html><body>404 Not Found</body></html>\\\\n\" ) ; http_response_send ( res ) ; exit",
  "golden_answers": [
   "CWE-22 Fixed Code Lines are: <vul-start> } if ( ! page_name_is_good ( page <vul-end> ) ) {\n"
  ],
  "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start> } if (! strcmp ( page, \"/api/\" ) ) { char * p ; p = page + 4 ; for ( p = page ; * p!= '\\\\0' ; p ++ ) if ( * p == '?' ) { break ; } wiki_handle_rest_call ( req, res, page ) ; exit ( 0 ) ; } if (\n"
 },
 {
  "id": 185,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int cg_rmdir ( const char * path ) { struct fuse_context * fc = fuse_get_context ( ) ; <vul-start> char * fpath = NULL , * cgdir = NULL , * controller ; <vul-end> const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { ret = - EINVAL ; goto out ; } <vul-start> fprintf ( stderr , \"rmdir: verifying access to %s:%s (req path %s)\\\\n\" , <vul-end> controller , cgdir , path ) ; if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { ret = - EACCES ; goto out ; } <vul-start> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <vul-end> ret = - EACCES ; goto out ; } <vul-start> if ( ! cgfs_remove ( controller , cgroup ) ) { <vul-end> ret = - EINVAL ; goto out ; } ret = 0 ; out : free ( cgdir ) ; <vul-start> return ret ; <vul-end> }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> , * controller , * next = NULL <vul-start> out ; } <vul-end> if ( ! <vul-start> , cgroup , & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY <vul-end> ) ) { <vul-start> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { ret = - EACCES ; goto out ; } if ( ! <vul-start> cgdir ) ; free ( next ) ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, * controller, * pid <vul-start> out ; } <vul-end> if (! <vul-start> out ; } pid = get_pid ( fc -> pid ) ; if (! pid ) { ret = - ENOENT ; goto out ; } <vul-start>! caller_is_in_ancestor ( <vul-end> pid, controller <vul-start> out ; } ret = cgfs_rmdir <vul-end> ( controller, <vul-start>, cgroup ) <vul-end> ; out : <vul-start> ) ; return ret <vul-end> ; }  \n"
 },
 {
  "id": 186,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <vul-start> int do_rf64 = 0 , write_junk = 1 ; <vul-end> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <vul-start> DS64Chunk ds64_chunk ; <vul-end> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( \"can\\'t create valid RIFF wav header for non-normalized floating data!\" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( \"total_data_bytes = %lld, so rf64\" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( \"total_data_bytes = %lld, so riff\" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> write_junk = 1 , table_length = 0 <vul-start> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <vul-start> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <vul-end> sizeof ( junkchunk <vul-start> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <vul-start> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <vul-start> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , \"dmmy\" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <vul-start> ) ) ) ) { error_line ( \"can\\'t write .WAV data, disk probably full!\" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( \"can\\'t write .WAV data, disk probably full!\" ) ; return FALSE ; } if ( <vul-end> ( write_junk &&\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> write_junk = 1, write_junk_bytes = 0 <vul-start> ; DS64Chunk ds64_chunk ; DS64Chunk ds64_chunk_copy <vul-start> total_data_bytes ; } if ( write_junk ) { CLEAR ( ds64_chunk ) ; ds64_chunk. riffSize64 = total_riff_bytes ; ds64_chunk. dataSize64 = total_data_bytes ; write_junk_bytes = 0 ; } <vul-start> ) || ( do_rf64 <vul-end> && (! <vul-start> ) ) || bcount!= sizeof ( ds64_chunk ) ) ) { error_line ( \"can\\'t write.WAV data!\" ) ; return FALSE ; } if (! DoWriteFile ( outfile, & ds64hdr, sizeof ( ds64hdr ), & bcount ) || bcount!= sizeof ( ds64_chunk ) ) { error_line ( \"can\\'t write.WAV data!\" ) ; return FALSE ; } <vul-end> if ( write_junk\n"
 },
 {
  "id": 187,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( \"error: cannot get box\\\\n\" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( \"error: expecting signature box\\\\n\" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( \"incorrect magic number\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( \"expecting file type box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf (",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> != JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> < JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> != JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> < JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> : JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> >= JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts ( <vul-start> < JAS_CAST ( jas_uint <vul-end> , jas_image_numcmpts (\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start>!= JAS_CAST ( jas_uint <vul-end>, jas_image_numcmpts ( <vul-start> < JAS_CAST ( jas_uint <vul-end>, jas_image_numcmpts ( <vul-start>!= JAS_CAST ( jas_uint <vul-end>, jas_image_numcmpts (\n"
 },
 {
  "id": 188,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int jpc_tsfb_synthesize ( jpc_tsfb_t * tsfb , jas_seq2d_t * a ) { <vul-start> return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb , <vul-end> jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> numlvls > 0 && jas_seq2d_size ( a )\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> a ) { if ( tsfb == NULL ) return 0 ; if <vul-end> ( tsfb -> <vul-start> ( tsfb, a, tsfb -> ref_idx, tsfb -> base_x, tsfb -> base_y, tsfb -> numlvls <vul-end> ) : 0\n"
 },
 {
  "id": 189,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 void btsock_rfc_signaled ( UNUSED_ATTR int fd , int flags , uint32_t user_id ) { pthread_mutex_lock ( & slot_lock ) ; rfc_slot_t * slot = find_rfc_slot_by_id ( user_id ) ; if ( ! slot ) goto out ; bool need_close = false ; if ( flags & SOCK_THREAD_FD_RD && ! slot -> f . server ) { if ( slot -> f . connected ) { int size = 0 ; <vul-start> if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) ) <vul-end> <vul-start> pthread_mutex_unlock ( & slot_lock ) ; <vul-end> <vul-start> BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ; <vul-end> } else { LOG_ERROR ( \"%s socket signaled for read while disconnected, slot: %d, channel: %d\" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( flags & SOCK_THREAD_FD_WR ) { if ( ! slot -> f . connected || ! flush_incoming_que_on_wr_signal ( slot ) ) { LOG_ERROR ( \"%s socket signaled for write while disconnected (or write failure), slot: %d, channel: %d\" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; <vul-start> if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) <vul-end> cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ;",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ) || ( TEMP_FAILURE_RETRY ( <vul-start> & size ) ) <vul-start> size ) ) { <vul-end> BTA_JvRfcommWrite ( slot <vul-start> id ) ; } <vul-start> ( need_close || TEMP_FAILURE_RETRY ( <vul-start> , & size )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ) || ( TEMP_FAILURE_RETRY ( <vul-start> & size ) ) || ( TEMP_FAILURE_RETRY ( <vul-end> BTA_JvRfcommWrite ( slot <vul-start> slot -> id ) <vul-start> ) || ( TEMP_FAILURE_RETRY ( <vul-start> & size ) ) || ( TEMP_FAILURE_RETRY ( <vul-end> BTA_JvRfcommWrite ( slot <vul-start> -> id ) )\n"
 },
 {
  "id": 190,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void sas_init_port ( struct asd_sas_port * port , struct sas_ha_struct * sas_ha , int i ) { memset ( port , 0 , sizeof ( * port ) ) ; port -> id = i ; INIT_LIST_HEAD ( & port -> dev_list ) ; INIT_LIST_HEAD ( & port -> disco_list ) ; INIT_LIST_HEAD ( & port -> destroy_list ) ; <vul-start> spin_lock_init ( & port -> phy_list_lock ) ; <vul-end> INIT_LIST_HEAD ( & port -> phy_list ) ; port -> ha = sas_ha ; spin_lock_init ( & port -> dev_list_lock ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_devices ) ;\n"
 },
 {
  "id": 191,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int rds_ib_laddr_check ( __be32 addr ) { int ret ; struct rdma_cm_id * cm_id ; struct sockaddr_in sin ; cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ) ; if ( IS_ERR ( cm_id ) ) return PTR_ERR ( cm_id ) ; memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; sin . sin_addr . s_addr = addr ; ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin ) ; <vul-start> if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) <vul-end> ret = - EADDRNOTAVAIL ; rdsdebug ( \"addr %pI4 ret %d node type %d\\\\n\" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ) ; rdma_destroy_id ( cm_id ) ; return ret ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ( ret || ! cm_id -> device ||\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( ret ||! cm_id -> device ||\n"
 },
 {
  "id": 192,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int dccp_error ( struct net * net , struct nf_conn * tmpl , struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info * ctinfo , u_int8_t pf , unsigned int hooknum ) { struct dccp_hdr _dh , * dh ; unsigned int dccp_len = skb -> len - dataoff ; unsigned int cscov ; const char * msg ; <vul-start> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <vul-end> if ( dh == NULL ) { msg = \"nf_ct_dccp: short packet \" ; goto out_invalid ; } if ( dh -> dccph_doff * 4 < sizeof ( struct dccp_hdr ) || dh -> dccph_doff * 4 > dccp_len ) { msg = \"nf_ct_dccp: truncated/malformed packet \" ; goto out_invalid ; } cscov = dccp_len ; if ( dh -> dccph_cscov ) { cscov = ( dh -> dccph_cscov - 1 ) * 4 ; if ( cscov > dccp_len ) { msg = \"nf_ct_dccp: bad checksum coverage \" ; goto out_invalid ; } } if ( net -> ct . sysctl_checksum && hooknum == NF_INET_PRE_ROUTING && nf_checksum_partial ( skb , hooknum , dataoff , cscov , IPPROTO_DCCP , pf ) ) { msg = \"nf_ct_dccp: bad checksum \" ; goto out_invalid ; } if ( dh -> dccph_type >= DCCP_PKT_INVALID ) { msg = \"nf_ct_dccp: reserved packet type \" ; goto out_invalid ; } return NF_ACCEPT ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , pf , 0 , skb , NULL , NULL , NULL",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ) , & _dh <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> * msg ; int ret ; <vul-start>, & dh ) ; if ( dh == NULL ) return NF_ACCEPT ; if ( dh -> dccph_doff + sizeof ( struct dccp_hdr ) > dccp_len ) goto out_invalid ; ret = nf_ct_dccp_check_header ( net, skb, hooknum, dataoff, cscov, IPPROTO_DCCP\n"
 },
 {
  "id": 193,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) return luaL_argerror ( L , 0 , \"MessagePack pack needs input.\" ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , \"Too many arguments for MessagePack pack.\" ) ; buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { <vul-start> lua_pushvalue ( L , i ) ; <vul-end> mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ++ ) { luaL_checkstack ( L , 1 , \"in function mp_check\" ) ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ++ ) { luaL_checkstack ( L, 1, \"in function mp_pack\" ) ;\n"
 },
 {
  "id": 194,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static inline int check_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , const nodemask_t * nodes , unsigned long flags , void * private ) { pmd_t * pmd ; unsigned long next ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; split_huge_page_pmd ( vma -> vm_mm , pmd ) ; <vul-start> if ( pmd_none_or_clear_bad ( pmd ) ) <vul-end> continue ; if ( check_pte_range ( vma , pmd , addr , next , nodes , flags , private ) ) return - EIO ; } while ( pmd ++ , addr = next , addr != end ) ; return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ; if ( pmd_none_or_trans_huge_or_clear_bad <vul-end> ( pmd )\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; if ( pmd_none_or_trans_huge_or_clear_bad <vul-end> ( pmd )\n"
 },
 {
  "id": 195,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int __vcpu_run ( struct kvm_vcpu * vcpu ) { int r ; struct kvm * kvm = vcpu -> kvm ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; <vul-start> r = vapic_enter ( vcpu ) ; <vul-end> if ( r ) { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; return r ; } r = 1 ; while ( r > 0 ) { if ( vcpu -> arch . mp_state == KVM_MP_STATE_RUNNABLE && ! vcpu -> arch . apf . halted ) r = vcpu_enter_guest ( vcpu ) ; else { srcu_read_unlock ( & kvm -> srcu , vcpu -> srcu_idx ) ; kvm_vcpu_block ( vcpu ) ; vcpu -> srcu_idx = srcu_read_lock ( & kvm -> srcu ) ; if ( kvm_check_request ( KVM_REQ_UNHALT , vcpu ) ) { kvm_apic_accept_events ( vcpu ) ; switch ( vcpu -> arch . mp_state ) { case KVM_MP_STATE_HALTED : vcpu -> arch . pv . pv_unhalted = false ; vcpu -> arch . mp_state = KVM_MP_STATE_RUNNABLE ; case KVM_MP_STATE_RUNNABLE : vcpu -> arch . apf . halted = false ; break ; case KVM_MP_STATE_INIT_RECEIVED : break ; default : r = - EINTR ; break ; } } } if ( r <= 0 ) break ; clear_bit ( KVM_REQ_PENDING_TIMER , & vcpu -> requests ) ; if ( kvm_cpu_has_pending_timer ( vcpu ) ) kvm_inject_pending_timer_irqs ( vcpu ) ; if ( dm_request_for_irq_injection ( vcpu ) ) { r = - EINTR ; vcpu -> run -> exit_reason = KVM_EXIT_INTR ; ++ vcpu -> stat .",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> srcu ) ; <vul-end> r = 1 <vul-start> srcu_idx ) ; <vul-end> return r ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; r = vcpu_eject_guest_active <vul-end> ( vcpu ) <vul-start> srcu_idx ) ; vcpu_eject_guest_active ( vcpu ) ;\n"
 },
 {
  "id": 196,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ; <vul-start> guint pkt_len ; <vul-end> int pktnum , hr , min , sec , csec ; char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , \"%9d] %2d:%2d:%2d.%9d %9s %9s\" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"toshiba: record header isn\\'t valid\" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\\\0' ; } while ( strcmp ( line , \"OFFSET 0001-0203\" ) != 0 ) ; <vul-start> num_items_scanned = sscanf ( line + 64 , \"LEN=%9u\" , & pkt_len ) ; <vul-end> if (",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> int num_items_scanned ; int pkt_len , <vul-end> pktnum , hr <vul-start> + 64 , \"LEN=%9d\" <vul-end> , & pkt_len <vul-start> g_strdup ( \"toshiba: OFFSET line doesn\\'t have valid LEN item\" ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( \"toshiba: packet header has a negative packet length\"\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> int num_items_scanned ; int <vul-end> pktnum, hr <vul-start> + 64, \"LEN=%9u\" <vul-end>, & pkt_len <vul-start> * err_info = g_strdup_printf ( \"toshiba: File has %u-byte packet bigger than maximum of %u\", pkt_len, WTAP_MAX_PACKET_SIZE <vul-end> ) ; return\n"
 },
 {
  "id": 197,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void dissect_ppi ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) { proto_tree * ppi_tree = NULL , * ppi_flags_tree = NULL , * seg_tree = NULL , * ampdu_tree = NULL ; proto_tree * agg_tree = NULL ; proto_item * ti = NULL ; tvbuff_t * next_tvb ; int offset = 0 ; guint version , flags ; gint tot_len , data_len ; guint data_type ; guint32 dlt ; guint32 n_ext_flags = 0 ; guint32 ampdu_id = 0 ; fragment_head * fd_head = NULL ; fragment_item * ft_fdh = NULL ; gint mpdu_count = 0 ; gchar * mpdu_str ; gboolean first_mpdu = TRUE ; guint last_frame = 0 ; gint len_remain , ampdu_len = 0 ; <vul-start> struct ieee_802_11_phdr phdr ; <vul-end> col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"PPI\" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; version = tvb_get_guint8 ( tvb , offset ) ; flags = tvb_get_guint8 ( tvb , offset + 1 ) ; tot_len = tvb_get_letohs ( tvb , offset + 2 ) ; dlt = tvb_get_letohl ( tvb , offset + 4 ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , \"PPI version %u, %u bytes\" , version , tot_len ) ; if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_ppi , tvb , 0 , tot_len , \"PPI version %u, %u bytes\" , version , tot_len ) ; ppi_tree = proto_item_add_subtree ( ti , ett_ppi_pph ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_version , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ti",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> struct ieee_802_11_phdr phdr ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <vul-start> } else { wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new <vul-end> ( wtap_encap_dissector_table , <vul-start> ( wtap_encap_dissector_table , wtap_encap <vul-end> , next_tvb , <vul-start> pinfo , tree , TRUE , phdrp\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> struct ieee_802_11_phdr phdr ; struct ieee_80211_txq * q <vul-start> } if ( dlt == WT_QPS_T ) { if ( ppi_gf_macppi_add_frames_list ( pinfo, ppi_tree, offset, data_len, & q ) == 0 ) { dissector_ppi ( pinfo, ppi_tree, offset, data_len, ENC_NA ) ; } } else { if ( <vul-start> ppi_tree ) ; }\n"
 },
 {
  "id": 198,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 sds sdsnewlen ( const void * init , size_t initlen ) { void * sh ; sds s ; char type = sdsReqType ( initlen ) ; if ( type == SDS_TYPE_5 && initlen == 0 ) type = SDS_TYPE_8 ; int hdrlen = sdsHdrSize ( type ) ; unsigned char * fp ; <vul-start> sh = s_malloc ( hdrlen + initlen + 1 ) ; <vul-end> if ( sh == NULL ) return NULL ; if ( init == SDS_NOINIT ) init = NULL ; else if ( ! init ) memset ( sh , 0 , hdrlen + initlen + 1 ) ; s = ( char * ) sh + hdrlen ; fp = ( ( unsigned char * ) s ) - 1 ; switch ( type ) { case SDS_TYPE_5 : { * fp = type | ( initlen << SDS_TYPE_BITS ) ; break ; } case SDS_TYPE_8 : { SDS_HDR_VAR ( 8 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_16 : { SDS_HDR_VAR ( 16 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_32 : { SDS_HDR_VAR ( 32 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_64 : { SDS_HDR_VAR ( 64 , s ) ; sh -> len = initlen ; sh -> alloc =",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * fp ; assert ( initlen + hdrlen + 1 > initlen ) ;\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * fp ; if ( initlen > SIZE_MAX - hdrlen ) return NULL ;\n"
 },
 {
  "id": 199,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static long pipe_set_size ( struct pipe_inode_info * pipe , unsigned long nr_pages ) { struct pipe_buffer * bufs ; if ( nr_pages < pipe -> nrbufs ) return - EBUSY ; bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN ) ; if ( unlikely ( ! bufs ) ) return - ENOMEM ; if ( pipe -> nrbufs ) { unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs ; if ( tail < pipe -> buffers ) tail = 0 ; else tail &= ( pipe -> buffers - 1 ) ; head = pipe -> nrbufs - tail ; if ( head ) memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) ) ; if ( tail ) memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) ) ; } <vul-start> pipe -> curbuf = 0 ; <vul-end> kfree ( pipe -> bufs ) ; pipe -> bufs = bufs ; pipe -> buffers = nr_pages ; return nr_pages * PAGE_SIZE ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ) ; } if (! bufs -> data ) { struct user_struct * user = get_current_user ( ) ; if (! too_many_pipe_buffers_hard ( user ) ) memcpy ( bufs, user -> user -> user -> user -> user -> user, sizeof ( struct user_struct ) ) ; }\n"
 },
 {
  "id": 200,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void llc_cmsg_rcv ( struct msghdr * msg , struct sk_buff * skb ) { struct llc_sock * llc = llc_sk ( skb -> sk ) ; if ( llc -> cmsg_flags & LLC_CMSG_PKTINFO ) { <vul-start> struct llc_pktinfo info ; <vul-end> info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ; llc_pdu_decode_dsap ( skb , & info . lpi_sap ) ; llc_pdu_decode_da ( skb , info . lpi_mac ) ; put_cmsg ( msg , SOL_LLC , LLC_OPT_PKTINFO , sizeof ( info ) , & info ) ; } }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> struct llc_pktinfo info ; memset ( & info , 0 , sizeof ( info ) )\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> struct llc_pktinfo info ; memset ( & info, 0, sizeof ( info ) )\n"
 },
 {
  "id": 201,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int au1200fb_fb_mmap ( struct fb_info * info , struct vm_area_struct * vma ) { <vul-start> unsigned int len ; <vul-end> unsigned long start = 0 , off ; <vul-start> struct au1200fb_device * fbdev = info -> par ; <vul-end> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= _CACHE_MASK ; <vul-start> return io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , <vul-end> vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> vma ) { <vul-end> struct au1200fb_device * <vul-start> info -> par <vul-end> ; vma -> <vul-start> _CACHE_MASK ; return vm_iomap_memory <vul-end> ( vma , <vul-start> ( vma , fbdev -> fb_phys , fbdev -> fb_len <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vma ) { <vul-end> struct au1200fb_device * <vul-start> info -> par <vul-end> ; vma -> <vul-start> |= _CACHE_MASK ; if ( vma -> vm_pgoff + fbdev -> fb_len > vma -> vm_end - vma -> vm_start ) { return - EINVAL ; }\n"
 },
 {
  "id": 202,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void call_bind_status ( struct rpc_task * task ) { int status = - EIO ; if ( task -> tk_status >= 0 ) { dprint_status ( task ) ; task -> tk_status = 0 ; task -> tk_action = call_connect ; return ; } switch ( task -> tk_status ) { case - ENOMEM : dprintk ( \"RPC: %5u rpcbind out of memory\\\\n\" , task -> tk_pid ) ; rpc_delay ( task , HZ >> 2 ) ; goto retry_timeout ; case - EACCES : dprintk ( \"RPC: %5u remote rpcbind: RPC program/version \" \"unavailable\\\\n\" , task -> tk_pid ) ; if ( task -> tk_msg . rpc_proc -> p_proc == 0 ) { status = - EOPNOTSUPP ; break ; } <vul-start> rpc_delay ( task , 3 * HZ ) ; <vul-end> goto retry_timeout ; case - ETIMEDOUT : dprintk ( \"RPC: %5u rpcbind request timed out\\\\n\" , task -> tk_pid ) ; goto retry_timeout ; case - EPFNOSUPPORT : dprintk ( \"RPC: %5u unrecognized remote rpcbind service\\\\n\" , task -> tk_pid ) ; break ; case - EPROTONOSUPPORT : dprintk ( \"RPC: %5u remote rpcbind version unavailable, retrying\\\\n\" , task -> tk_pid ) ; task -> tk_status = 0 ; task -> tk_action = call_bind ; return ; case - ECONNREFUSED : case - ECONNRESET : case - ENOTCONN : case - EHOSTDOWN : case - EHOSTUNREACH : case - ENETUNREACH : case - EPIPE : dprintk ( \"RPC: %5u remote rpcbind unreachable: %d\\\\n\" , task -> tk_pid , task -> tk_status ) ; if ( ! RPC_IS_SOFTCONN ( task ) )",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> break ; } if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> break ; } if ( task -> tk_msg. rpc_proc -> p_flags & RPC_PROC_FLAG_RETRY ) { dprintk ( \"RPC: %5u remote rpcbind service timed out\\\\n\", task -> tk_pid ) ; status = - EOPNOTSUPP ; break ; }\n"
 },
 {
  "id": 203,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int mincore_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { spinlock_t * ptl ; struct vm_area_struct * vma = walk -> vma ; pte_t * ptep ; unsigned char * vec = walk -> private ; int nr = ( end - addr ) >> PAGE_SHIFT ; ptl = pmd_trans_huge_lock ( pmd , vma ) ; if ( ptl ) { memset ( vec , 1 , nr ) ; spin_unlock ( ptl ) ; goto out ; } if ( pmd_trans_unstable ( pmd ) ) { <vul-start> __mincore_unmapped_range ( addr , end , vma , vec ) ; <vul-end> goto out ; } ptep = pte_offset_map_lock ( walk -> mm , pmd , addr , & ptl ) ; for ( ; addr != end ; ptep ++ , addr += PAGE_SIZE ) { pte_t pte = * ptep ; if ( pte_none ( pte ) ) <vul-start> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <vul-end> vma , vec ) ; else if ( pte_present ( pte ) ) * vec = 1 ; else { swp_entry_t entry = pte_to_swp_entry ( pte ) ; <vul-start> if ( non_swap_entry ( entry ) ) { <vul-end> * vec = 1 ; } else { # ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ; # else WARN_ON ( 1 ) ; * vec = 1 ; # endif } } vec ++ ; } pte_unmap_unlock ( ptep - 1 , ptl ) ; out",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ) ) { memset ( vec , 1 , nr <vul-end> ) ; goto <vul-start> pte ) ) * vec = 0 <vul-end> ; else if <vul-start> pte ) ; * vec = ! ! <vul-end> non_swap_entry ( entry <vul-start> ( entry ) ; <vul-end> } vec ++\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ) { if (! vma -> vm_file -> f_dentry ) <vul-start> pte ) ) { if (! vma -> vm_file -> f_dentry ) <vul-start> vec ) ; else vec = 1 ; } <vul-start> entry ) ) * vec = 1 ; else <vul-end> { # ifdef\n"
 },
 {
  "id": 204,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int peer_recv_callback ( rdpTransport * transport , wStream * s , void * extra ) { freerdp_peer * client = ( freerdp_peer * ) extra ; rdpRdp * rdp = client -> context -> rdp ; switch ( rdp -> state ) { case CONNECTION_STATE_INITIAL : if ( ! rdp_server_accept_nego ( rdp , s ) ) return - 1 ; if ( rdp -> nego -> selected_protocol & PROTOCOL_NLA ) { sspi_CopyAuthIdentity ( & client -> identity , & ( rdp -> nego -> transport -> credssp -> identity ) ) ; IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , TRUE ) ; credssp_free ( rdp -> nego -> transport -> credssp ) ; <vul-start> } <vul-end> else { IFCALLRET ( client -> Logon , client -> authenticated , client , & client -> identity , FALSE ) ; } break ; case CONNECTION_STATE_NEGO : if ( ! rdp_server_accept_mcs_connect_initial ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CONNECT : if ( ! rdp_server_accept_mcs_erect_domain_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ERECT_DOMAIN : if ( ! rdp_server_accept_mcs_attach_user_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_ATTACH_USER : if ( ! rdp_server_accept_mcs_channel_join_request ( rdp , s ) ) return - 1 ; break ; case CONNECTION_STATE_MCS_CHANNEL_JOIN : if ( rdp -> settings -> DisableEncryption ) { if ( ! rdp_server_accept_client_keys ( rdp , s ) ) return - 1 ; break ; } rdp -> state = CONNECTION_STATE_ESTABLISH_KEYS ; case CONNECTION_STATE_ESTABLISH_KEYS",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; rdp -> nego -> transport -> credssp = NULL ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; client -> established = TRUE ;\n"
 },
 {
  "id": 205,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int exfat_mount ( struct exfat * ef , const char * spec , const char * options ) { int rc ; enum exfat_mode mode ; exfat_tzset ( ) ; memset ( ef , 0 , sizeof ( struct exfat ) ) ; parse_options ( ef , options ) ; if ( match_option ( options , \"ro\" ) ) mode = EXFAT_MODE_RO ; else if ( match_option ( options , \"ro_fallback\" ) ) mode = EXFAT_MODE_ANY ; else mode = EXFAT_MODE_RW ; ef -> dev = exfat_open ( spec , mode ) ; if ( ef -> dev == NULL ) return - EIO ; if ( exfat_get_mode ( ef -> dev ) == EXFAT_MODE_RO ) { if ( mode == EXFAT_MODE_ANY ) ef -> ro = - 1 ; else ef -> ro = 1 ; } ef -> sb = malloc ( sizeof ( struct exfat_super_block ) ) ; if ( ef -> sb == NULL ) { exfat_close ( ef -> dev ) ; exfat_error ( \"failed to allocate memory for the super block\" ) ; return - ENOMEM ; } memset ( ef -> sb , 0 , sizeof ( struct exfat_super_block ) ) ; if ( exfat_pread ( ef -> dev , ef -> sb , sizeof ( struct exfat_super_block ) , 0 ) < 0 ) { exfat_close ( ef -> dev ) ; free ( ef -> sb ) ; exfat_error ( \"failed to read boot sector\" ) ; return - EIO ; } if ( memcmp ( ef -> sb -> oem_name , \"EXFAT \" , 8",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> exfat_error ( \"exFAT file system is not found\" ) ; return - EIO ; } if ( ef -> sb -> sector_bits < 9 ) { exfat_close ( ef -> dev ) ; exfat_error ( \"too small sector size: 2^%hhd\" , ef -> sb -> sector_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { exfat_close ( ef -> dev ) ; exfat_error ( \"too big cluster size: 2^(%hhd+%hhd)\" , ef -> sb -> sector_bits , ef -> sb -> spc_bits ) ; free ( ef -> sb <vul-start> } if ( <vul-end> le64_to_cpu ( ef\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; exfat_error ( \"unsupported FAT file system is not found\" <vul-end> ) ; return <vul-start> ; exfat_error ( \"too big cluster size: 2^%d\" <vul-end>, ( int\n"
 },
 {
  "id": 206,
  "question": "CWE-134 Code Input Vulnerable Code Is: CWE-134 static void thunar_transfer_job_copy_node ( ThunarTransferJob * job , ThunarTransferNode * node , GFile * target_file , GFile * target_parent_file , GList * * target_file_list_return , GError * * error ) { ThunarThumbnailCache * thumbnail_cache ; ThunarApplication * application ; ThunarJobResponse response ; GFileInfo * info ; GError * err = NULL ; GFile * real_target_file = NULL ; gchar * base_name ; _thunar_return_if_fail ( THUNAR_IS_TRANSFER_JOB ( job ) ) ; _thunar_return_if_fail ( node != NULL && G_IS_FILE ( node -> source_file ) ) ; _thunar_return_if_fail ( target_file == NULL || node -> next == NULL ) ; _thunar_return_if_fail ( ( target_file == NULL && target_parent_file != NULL ) || ( target_file != NULL && target_parent_file == NULL ) ) ; _thunar_return_if_fail ( error == NULL || * error == NULL ) ; application = thunar_application_get ( ) ; thumbnail_cache = thunar_application_get_thumbnail_cache ( application ) ; g_object_unref ( application ) ; for ( ; err == NULL && node != NULL ; node = node -> next ) { if ( G_LIKELY ( target_file == NULL ) ) { base_name = g_file_get_basename ( node -> source_file ) ; target_file = g_file_get_child ( target_parent_file , base_name ) ; g_free ( base_name ) ; } else target_file = g_object_ref ( target_file ) ; info = g_file_query_info ( node -> source_file , G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , exo_job_get_cancellable ( EXO_JOB ( job ) ) , & err ) ; if ( info == NULL ) { g_object_unref ( target_file ) ; break ; } <vul-start> exo_job_info_message ( EXO_JOB ( job ) , g_file_info_get_display_name ( info ) ) ; <vul-end> retry_copy",
  "golden_answers": [
   "CWE-134 Fixed Code Lines are: <vul-start> job ) , \"%s\" ,\n"
  ],
  "generated_answer": "CWE-134 Fixed Code Lines are: <vul-start> break ; } if ( info -> type == G_FILE_INFO_TYPE_UNKNOWN && g_file_info_get_filename ( info ) == NULL ) { err = G_IO_ERROR ; g_object_unref ( target_file ) ; break ; }\n"
 },
 {
  "id": 207,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 <vul-start> static void nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , <vul-end> UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; <vul-start> UINT32 tempWidth ; <vul-end> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; <vul-start> for ( y = 0 ; y < context -> height ; y ++ ) <vul-end> { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start>     static BOOL <vul-end> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <vul-start> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <vul-start> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <vul-start> ) ; } return TRUE ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>     static BOOL <vul-end> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <vul-start> ; UINT32 tempWidth ; if (! context ) return FALSE <vul-start> -> ColorLossLevel ; if ( scanline == 0 ) return FALSE ; <vul-start> BYTE a_val ; if ( scanline == 0 ) return FALSE ;\n"
 },
 {
  "id": 208,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 SYSCALL_DEFINE3 ( shmctl , int , shmid , int , cmd , struct shmid_ds __user * , buf ) { struct shmid_kernel * shp ; int err , version ; struct ipc_namespace * ns ; if ( cmd < 0 || shmid < 0 ) return - EINVAL ; version = ipc_parse_version ( & cmd ) ; ns = current -> nsproxy -> ipc_ns ; switch ( cmd ) { case IPC_INFO : case SHM_INFO : case SHM_STAT : case IPC_STAT : return shmctl_nolock ( ns , shmid , cmd , version , buf ) ; case IPC_RMID : case IPC_SET : return shmctl_down ( ns , shmid , cmd , buf , version ) ; case SHM_LOCK : case SHM_UNLOCK : { struct file * shm_file ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock1 ; } audit_ipc_obj ( & ( shp -> shm_perm ) ) ; err = security_shm_shmctl ( shp , cmd ) ; if ( err ) goto out_unlock1 ; ipc_lock_object ( & shp -> shm_perm ) ; if ( ! ns_capable ( ns -> user_ns , CAP_IPC_LOCK ) ) { kuid_t euid = current_euid ( ) ; err = - EPERM ; if ( ! uid_eq ( euid , shp -> shm_perm . uid ) && ! uid_eq ( euid , shp -> shm_perm . cuid ) ) goto out_unlock0 ; if ( cmd == SHM_LOCK && ! rlimit ( RLIMIT_MEMLOCK ) ) goto out_unlock0 ; } shm_file",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ; if ( shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if (\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ; if ( shp -> shm_file == NULL ||\n"
 },
 {
  "id": 209,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; } <vul-start> while ( offset < end_offset ) <vul-end> offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ; <vul-start> return offset ; <vul-end> }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> while ( offset > 0 && offset <vul-start> < end_offset ) { <vul-start> hf_keybuffer ) ; }\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> < end_offset ) { <vul-start> hf_keybuffer ) ; if ( offset < 0 ) return offset ; }\n"
 },
 {
  "id": 210,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void macvlan_common_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <vul-start> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <vul-end> dev -> netdev_ops = & macvlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> header_ops = & macvlan_hard_header_ops , dev -> ethtool_ops = & macvlan_ethtool_ops ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <vul-end> ; dev ->\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <vul-end> ; dev ->\n"
 },
 {
  "id": 211,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int wanxl_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { const size_t size = sizeof ( sync_serial_settings ) ; sync_serial_settings line ; port_t * port = dev_to_port ( dev ) ; if ( cmd != SIOCWANDEV ) return hdlc_ioctl ( dev , ifr , cmd ) ; switch ( ifr -> ifr_settings . type ) { case IF_GET_IFACE : ifr -> ifr_settings . type = IF_IFACE_SYNC_SERIAL ; if ( ifr -> ifr_settings . size < size ) { ifr -> ifr_settings . size = size ; return - ENOBUFS ; <vul-start> } <vul-end> line . clock_type = get_status ( port ) -> clocking ; line . clock_rate = 0 ; line . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & line , size ) ) return - EFAULT ; return 0 ; case IF_IFACE_SYNC_SERIAL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( dev -> flags & IFF_UP ) return - EBUSY ; if ( copy_from_user ( & line , ifr -> ifr_settings . ifs_ifsu . sync , size ) ) return - EFAULT ; if ( line . clock_type != CLOCK_EXT && line . clock_type != CLOCK_TXFROMRX ) return - EINVAL ; if ( line . loopback != 0 ) return - EINVAL ; get_status ( port ) -> clocking = line . clock_type ; return 0 ; default : return hdlc_ioctl ( dev , ifr , cmd ) ; } }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ENOBUFS ; } memset ( & line , 0 , sizeof ( line ) ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ENOBUFS ; } else if ( ifr -> ifr_settings. size > size ) return - EINVAL ;\n"
 },
 {
  "id": 212,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int mp_join_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_join * mpj = ( const struct mp_join * ) opt ; <vul-start> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <vul-end> ! ( opt_len == 16 && ( flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) && <vul-start> ! ( opt_len == 24 && flags & TH_ACK ) ) <vul-end> return 0 ; if ( opt_len != 24 ) { if ( mpj -> sub_b & MP_JOIN_B ) ND_PRINT ( ( ndo , \" backup\" ) ) ; ND_PRINT ( ( ndo , \" id %u\" , mpj -> addr_id ) ) ; } switch ( opt_len ) { case 12 : ND_PRINT ( ( ndo , \" token 0x%x\" \" nonce 0x%x\" , EXTRACT_32BITS ( mpj -> u . syn . token ) , EXTRACT_32BITS ( mpj -> u . syn . nonce ) ) ) ; break ; case 16 : ND_PRINT ( ( ndo , \" hmac 0x%\" PRIx64 \" nonce 0x%x\" , EXTRACT_64BITS ( mpj -> u . synack . mac ) , EXTRACT_32BITS ( mpj -> u . synack . nonce ) ) ) ; break ; case 24 : { size_t i ; ND_PRINT ( ( ndo , \" hmac 0x\" ) ) ; for ( i = 0 ; i < sizeof ( mpj -> u . ack . mac ) ; ++ i ) ND_PRINT ( ( ndo , \"%02x\" , mpj",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> == 12 && ( <vul-start> & TH_SYN ) ) <vul-start> == 24 && ( <vul-start> flags & TH_ACK )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> == 12 && ( <vul-start> flags & TH_SYN ) <vul-start> == 16 && ( <vul-start> flags & TH_ACK )\n"
 },
 {
  "id": 213,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void ndpi_search_oracle ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int16_t dport = 0 , sport = 0 ; NDPI_LOG_DBG ( ndpi_struct , \"search ORACLE\\\\n\" ) ; if ( packet -> tcp != NULL ) { sport = ntohs ( packet -> tcp -> source ) , dport = ntohs ( packet -> tcp -> dest ) ; NDPI_LOG_DBG2 ( ndpi_struct , \"calculating ORACLE over tcp\\\\n\" ) ; if ( ( dport == 1521 || sport == 1521 ) <vul-start> && ( ( ( packet -> payload [ 0 ] == 0x07 ) && ( packet -> payload [ 1 ] == 0xff ) && ( packet -> payload [ 2 ] == 0x00 ) ) <vul-end> || ( ( packet -> payload_packet_len >= 232 ) && ( ( packet -> payload [ 0 ] == 0x00 ) || ( packet -> payload [ 0 ] == 0x01 ) ) && ( packet -> payload [ 1 ] != 0x00 ) && ( packet -> payload [ 2 ] == 0x00 ) && ( packet -> payload [ 3 ] == 0x00 ) ) ) ) { NDPI_LOG_INFO ( ndpi_struct , \"found oracle\\\\n\" ) ; ndpi_int_oracle_add_connection ( ndpi_struct , flow ) ; } else if ( packet -> payload_packet_len == 213 && packet -> payload [ 0 ] == 0x00 && packet -> payload [ 1 ] == 0xd5 && packet -> payload [ 2 ] == 0x00 && packet -> payload [ 3 ] == 0x00 ) { NDPI_LOG_INFO (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( packet -> payload_packet_len >= 3 && packet ->\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 1521 ) && ( ( ( packet -> payload_packet_len >= 232 ) && ( ( packet -> payload [ 0 ] == 0x00 ) || ( packet -> payload [ 0 ] == 0x01 ) ) && <vul-start> ] == 0xff <vul-end> ) && ( <vul-start> 2 ] == 0x00 ) ) || ( ( packet -> payload_packet_len >= 213 ) && ( ( packet -> payload [ 0 ] == 0x00 && packet -> payload [ 1 ] == 0xd5 ) && ( packet -> payload [ 2 ] == 0x00 && packet -> payload [ 3 ] ==\n"
 },
 {
  "id": 214,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , \".\" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , \"-c\" ) || ! strcmp ( arg , \"-cfg\" ) ) { the_cfg = argv [ i +",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , \"Input url %s is too long, truncating to %d chars.\\\\n\" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { <vul-start> url_arg ) ; } <vul-start> ! e ) { strncpy <vul-end> ( the_url , <vul-start> ( sess ) , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <vul-end> gf_dm_sess_del ( sess <vul-start> str ) { strncpy <vul-end> ( the_url , <vul-start> , \"MP4Client \" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <vul-end> ; gf_term_connect (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr, \"Error: argument is too long\\\\n\" ) ; return 1 ; } <vul-start> ) ) { if ( strlen ( the_url ) >= sizeof ( the_url ) ) { fprintf ( stderr, \"Error: argument is too long\\\\n\" ) ; return 1 ; }\n"
 },
 {
  "id": 215,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int X509_verify ( X509 * a , EVP_PKEY * r ) <vul-start> { <vul-end> return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> r ) { if ( a == NULL ) return 0 ;\n"
 },
 {
  "id": 216,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 PHP_FUNCTION ( radius_get_vendor_attr ) { <vul-start> int res ; <vul-end> <vul-start> const void * data ; <vul-end> int len ; <vul-start> u_int32_t vendor ; <vul-end> <vul-start> if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s\" , & data , & len ) == FAILURE ) { <vul-end> return ; } <vul-start> res = rad_get_vendor_attr ( & vendor , & data , ( size_t * ) & len ) ; <vul-end> if ( res == - 1 ) { RETURN_FALSE ; } else { array_init ( return_value ) ; <vul-start> add_assoc_long ( return_value , \"attr\" , res ) ; <vul-end> add_assoc_long ( return_value , \"vendor\" , vendor ) ; <vul-start> add_assoc_stringl ( return_value , \"data\" , ( char * ) data , len , 1 ) ; <vul-end> return ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> radius_get_vendor_attr ) { <vul-end> const void * <vul-start> void * data , * raw <vul-start> ; u_int32_t vendor ; unsigned char type ; size_t data_len <vul-start> \"s\" , & raw <vul-end> , & len <vul-start> return ; } if ( <vul-end> rad_get_vendor_attr ( & <vul-start> vendor , & type , & data , & data_len , raw , len ) <vul-end> == - 1 <vul-start> , \"attr\" , type <vul-end> ) ; add_assoc_long <vul-start> ) data , data_len <vul-end> , 1 )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> radius_get_vendor_attr ) { size_t <vul-end> res ; const <vul-start> void * data, * vendor_data <vul-start> ; u_int32_t vendor ; zval dval ; dval = * data <vul-start> ) TSRMLS_CC, \"s\", & data, & len ) ; if ( dval == NULL ) { RETURN_FALSE ; } else if ( sscanf ( dval, \"%lu\", & vendor_data )!= 1 ) { RETURN_FALSE ; } <vul-end> if ( vendor <vul-start> vendor, & vendor_data <vul-end>, ( size_t <vul-start> ) & len )!= 1 <vul-start> return_value ) ; add_assoc_size ( return_value, \"vendor\", vendor_data <vul-start> vendor ) ; add_assoc_string <vul-end> ( return_value, <vul-start> ) data, len, 1 ) ; } else { array_init ( return_value ) ; add_assoc_long ( return_value, \"attr\", res <vul-end> ) ; return\n"
 },
 {
  "id": 217,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void sas_resume_port ( struct asd_sas_phy * phy ) { struct domain_device * dev ; struct asd_sas_port * port = phy -> port ; struct sas_ha_struct * sas_ha = phy -> ha ; struct sas_internal * si = to_sas_internal ( sas_ha -> core . shost -> transportt ) ; if ( si -> dft -> lldd_port_formed ) si -> dft -> lldd_port_formed ( phy ) ; if ( port -> suspended ) port -> suspended = 0 ; else { return ; } list_for_each_entry ( dev , & port -> dev_list , dev_list_node ) { int i , rc ; rc = sas_notify_lldd_dev_found ( dev ) ; if ( rc ) { <vul-start> sas_unregister_dev ( port , dev ) ; <vul-end> continue ; } if ( dev -> dev_type == SAS_EDGE_EXPANDER_DEVICE || dev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) { dev -> ex_dev . ex_change_count = - 1 ; for ( i = 0 ; i < dev -> ex_dev . num_phys ; i ++ ) { struct ex_phy * phy = & dev -> ex_dev . ex_phy [ i ] ; phy -> phy_change_count = - 1 ; } } } sas_discover_event ( port , DISCE_RESUME ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> port , dev ) ; sas_destruct_devices ( port\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> port, dev ) ; sas_destruct_devices ( port\n"
 },
 {
  "id": 218,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int key_update ( key_ref_t key_ref , const void * payload , size_t plen ) { struct key_preparsed_payload prep ; struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; key_check ( key ) ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) return ret ; if ( ! key -> type -> update ) return - EOPNOTSUPP ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = key -> type -> def_datalen ; prep . expiry = TIME_T_MAX ; if ( key -> type -> preparse ) { ret = key -> type -> preparse ( & prep ) ; if ( ret < 0 ) goto error ; } down_write ( & key -> sem ) ; ret = key -> type -> update ( key , & prep ) ; if ( ret == 0 ) <vul-start> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <vul-end> up_write ( & key -> sem ) ; error : if ( key -> type -> preparse ) key -> type -> free_preparse ( & prep ) ; return ret ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> == 0 ) mark_key_instantiated ( key , 0 <vul-end> ) ; up_write\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> == 0 ) mark_key_instantiated ( key, 0 <vul-end> ) ; up_write\n"
 },
 {
  "id": 219,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void rd_pick_partition ( VP9_COMP * cpi , const TileInfo * const tile , <vul-end> TOKENEXTRA * * tp , int mi_row , <vul-start> int mi_col , BLOCK_SIZE bsize , int * rate , <vul-end> int64_t * dist , int do_recon , int64_t best_rd ) { VP9_COMMON * const cm = & cpi -> common ; <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; const int mi_step = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; TOKENEXTRA * tp_orig = * tp ; <vul-start> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <vul-end> int i , pl ; BLOCK_SIZE subsize ; <vul-start> int this_rate , sum_rate = 0 , best_rate = INT_MAX ; <vul-end> int64_t this_dist , sum_dist = 0 , best_dist = INT64_MAX ; int64_t sum_rd = 0 ; int do_split = bsize >= BLOCK_8X8 ; int do_rect = 1 ; const int force_horz_split = ( mi_row + mi_step >= cm -> mi_rows ) ; const int force_vert_split = ( mi_col + mi_step >= cm -> mi_cols ) ; const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; <vul-start> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; <vul-end> int partition_horz_allowed = ! force_vert_split && yss <= xss && bsize",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cpi , ThreadData * td , TileDataEnc * tile_data <vul-end> , TOKENEXTRA * <vul-start> int mi_row , int mi_col , <vul-end> BLOCK_SIZE bsize , <vul-start> BLOCK_SIZE bsize , RD_COST * rd_cost , int64_t best_rd , PC_TREE * pc_tree <vul-end> ) { VP9_COMMON <vul-start> -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; <vul-start> x = & td <vul-end> -> mb ; <vul-start> * ctx = & pc_tree -> none <vul-end> ; int i <vul-start> BLOCK_SIZE subsize ; RD_COST this_rdc , sum_rdc , best_rdc <vul-end> ; int do_split <vul-start> . subsampling_y ; BLOCK_SIZE min_size = x -> min_partition_size ; BLOCK_SIZE max_size = x -> max_partition_size ; # if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ; int none_complexity = 0 ; # endif <vul-start> * tp_orig ; <vul-end> assert ( num_8x8_blocks_wide_lookup <vul-start> [ bsize ] ) ; vp9_rd_cost_init ( & this_rdc ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize <vul-start> bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) <vul-end> x -> mb_energy <vul-start> bsize ) ; if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) { int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size <vul-end> ) ; } <vul-start> ( bsize <= max_size && bsize >= min_size <vul-end> ) ; partition_horz_allowed <vul-start> ( bsize <= max_size && bsize > min_size <vul-end> ) || force_horz_split <vul-start> ( bsize <= max_size && bsize > min_size <vul-end> ) || force_vert_split <vul-start> &= bsize > min_size <vul-end> ; } if <vul-start> } save_context ( x <vul-end> , mi_row , <vul-start> bsize ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } # endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c ; MOTION_DIRECTION this_mv ; MOTION_DIRECTION right_mv ; MOTION_DIRECTION bottom_mv ; this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ; if ( c != mb_col_end - 1 ) { right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ; none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ; } if ( r != mb_row_end - 1 ) { bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ; none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ; } } } if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) { partition_none_allowed <vul-end> = 0 ; <vul-start> = 0 ; } } # endif <vul-end> if ( partition_none_allowed <vul-start> ( cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , ctx , best_rdc . rdcost ) ; if ( this_rdc . rate <vul-end> != INT_MAX ) <vul-start> bsize ) ; this_rdc . rate += cpi <vul-end> -> partition_cost [ <vul-start> PARTITION_NONE ] ; this_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , this_rdc . rate , this_rdc . dist ) ; } if ( this_rdc . rdcost < best_rdc . rdcost <vul-end> ) { int64_t <vul-start> ) { int64_t dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ; int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ; best_rdc = this_rdc <vul-end> ; if ( <vul-start> >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; dist_breakout_thr <vul-end> >>= 8 - <vul-start> ] ) ; rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; if ( ! x -> e_mbd . lossless && ( ctx -> skippable && best_rdc . dist < dist_breakout_thr && best_rdc . rate < rate_breakout_thr ) ) { do_split = 0 ; do_rect = 0 ; } # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && do_split != 0 && cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; int skip = 1 ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c <vul-end> ; if ( <vul-start> if ( ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_MOTION_ZERO_MASK ) || ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_ERROR_SMALL_MASK ) ) { skip = 0 ; break ; } } if ( skip == 0 ) { break ; } } if ( skip ) { if ( src_diff_var == UINT_MAX ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } if ( src_diff_var < 8 <vul-end> ) { do_split <vul-start> } } } # endif } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { i = 4 ; if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , pc_tree -> leaf_split [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rate == INT_MAX ) sum_rdc . rdcost = INT64_MAX ; } else { <vul-end> for ( i <vul-start> < 4 && sum_rdc . rdcost < best_rdc . rdcost <vul-end> ; ++ i <vul-start> ) continue ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> split [ i ] -> index = i <vul-end> ; rd_pick_partition ( <vul-start> ( cpi , td , tile_data <vul-end> , tp , <vul-start> subsize , & this_rdc , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <vul-end> == INT_MAX ) <vul-start> INT_MAX ) { sum_rdc . rdcost <vul-end> = INT64_MAX ; <vul-start> = INT64_MAX ; break ; <vul-start> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } } if ( sum_rdc . rdcost < best_rdc . rdcost <vul-end> && i == <vul-start> bsize ) ; sum_rdc . rate += cpi <vul-end> -> partition_cost [ <vul-start> PARTITION_SPLIT ] ; sum_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <vul-end> ; } } <vul-start> } restore_context ( x <vul-end> , mi_row , <vul-start> ( partition_horz_allowed && ( do_rect || vp9_active_h_edge ( cpi , mi_row , mi_step ) ) <vul-end> ) { subsize <vul-start> , PARTITION_HORZ ) <vul-end> ; if ( <vul-start> && partition_none_allowed ) pc_tree -> horizontal [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> horizontal [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <vul-end> && mi_row + <vul-start> cm -> mi_rows && bsize > BLOCK_8X8 ) { PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; <vul-end> update_state ( cpi <vul-start> ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) <vul-end> ; if ( <vul-start> && partition_none_allowed ) pc_tree -> horizontal [ 1 ] . <vul-end> pred_interp_filter = ctx <vul-start> ( cpi , tile_data , x <vul-end> , mi_row + <vul-start> mi_col , & this_rdc , subsize , & pc_tree -> horizontal [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <vul-end> == INT_MAX ) <vul-start> INT_MAX ) { sum_rdc . rdcost <vul-end> = INT64_MAX ; <vul-start> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && ( do_rect || vp9_active_v_edge ( cpi , mi_col , mi_step ) ) ) { subsize <vul-end> = get_subsize ( <vul-start> , PARTITION_VERT ) <vul-end> ; if ( <vul-start> && partition_none_allowed ) pc_tree -> vertical [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , & pc_tree -> vertical [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <vul-end> && mi_col + <vul-start> cm -> mi_cols && bsize > BLOCK_8X8 <vul-start> ( cpi , td , & pc_tree -> vertical [ 0 ] , mi_row , mi_col , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , & pc_tree -> vertical [ 0 ] ) <vul-end> ; if ( <vul-start> && partition_none_allowed ) pc_tree -> vertical [ 1 ] . <vul-end> pred_interp_filter = ctx <vul-start> ( cpi , tile_data , x <vul-end> , mi_row , <vul-start> mi_step , & this_rdc , subsize , & pc_tree -> vertical [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <vul-end> == INT_MAX ) <vul-start> INT_MAX ) { sum_rdc . rdcost <vul-end> = INT64_MAX ; <vul-start> } else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd ; * rd_cost = best_rdc ; if ( best_rdc . rate <vul-end> < INT_MAX && <vul-start> < INT_MAX && best_rdc . dist <vul-end> < INT64_MAX && <vul-start> < INT64_MAX && pc_tree -> index != 3 <vul-end> ) { int <vul-start> BLOCK_64X64 ) ; encode_sb ( cpi , td , tile_info , tp <vul-end> , mi_row , <vul-start> , output_enabled , bsize , pc_tree <vul-end> ) ; } <vul-start> ; assert ( best_rdc . rate <vul-end> < INT_MAX ) <vul-start> ; assert ( best_rdc . dist <vul-end> < INT64_MAX )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, ThreadData * td, TileDataEnc * tile_data <vul-end>, TOKENEXTRA * <vul-start> BLOCK_SIZE bsize, RD_COST * rd_cost, <vul-end> int do_recon, <vul-start> -> common ; TileInfo * const tile_info = & tile_data -> tile_info <vul-end> ; MACROBLOCKD * <vul-start> * ctx = & td -> mb ; <vul-start> * tp_orig = & tile_data -> none <vul-end> ; int i <vul-start> BLOCK_SIZE subsize ; RD_COST this_rdc, sum_rdc, best_rdc <vul-end> ; int do_split <vul-start> force_vert_split ; } <vul-end> assert ( num_8x8_blocks_wide_lookup <vul-start> ] ) ; vp9_setup_src_planes ( x, x -> Source, mi_row, mi_col ) ; source_variancey = get_sby_perpixel_variance ( cpi, x, bsize, & this_rdc, & sum_rdc ) ; if ( best_rdc. rdc_cost <vul-end> < cpi -> <vul-start> < cpi -> sf. min_split_var_thresh ) { vp9_split = 0 ; do_rect = 0 ; } else { vp9_setup_src_planes ( x, x -> Source, mi_row, mi_col ) ; sum_rdc. rdcost = vp9_block_energy ( cpi, x, mi_row, mi_col ) ; x -> mb_energy = vp9_block_energy ( cpi, x, mi_row, mi_col ) ; } } if (! x -> in_active_map ) { do_split = 0 ; do_rect = 0 ; } if ( cpi -> sf. <vul-end> auto_min_max_partition_size ) { <vul-start> ( bsize <= x -> <vul-end> max_partition_size && bsize <vul-start> 0, best_rate <vul-end> = 0 ; <vul-start> ( bsize <= x -> <vul-end> max_partition_size && bsize <vul-start> -> rddiv, sum_rdc. rdcost <vul-end> ) || force_horz_split <vul-start> &= ( bsize > x -> <vul-end> min_partition_size ) || <vul-start>"
 },
 {
  "id": 220,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void * etm_setup_aux ( int event_cpu , void * * pages , int nr_pages , bool overwrite ) { int cpu ; cpumask_t * mask ; struct coresight_device * sink ; struct etm_event_data * event_data = NULL ; event_data = alloc_event_data ( event_cpu ) ; if ( ! event_data ) return NULL ; sink = coresight_get_enabled_sink ( true ) ; if ( ! sink ) goto err ; INIT_WORK ( & event_data -> work , free_event_data ) ; mask = & event_data -> mask ; for_each_cpu ( cpu , mask ) { struct coresight_device * csdev ; csdev = per_cpu ( csdev_src , cpu ) ; if ( ! csdev ) goto err ; event_data -> path [ cpu ] = coresight_build_path ( csdev , sink ) ; if ( IS_ERR ( event_data -> path [ cpu ] ) ) goto err ; } if ( ! sink_ops ( sink ) -> alloc_buffer ) goto err ; <vul-start> event_data -> snk_config = <vul-end> sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ; if ( ! event_data -> snk_config ) goto err ; out : return event_data ; err : etm_free_aux ( event_data ) ; event_data = NULL ; goto out ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> goto err ; cpu = cpumask_first ( mask ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> goto err ; if ( cpumask_equal ( & event_data -> cpu_set, cpu ) ) goto err ;\n"
 },
 {
  "id": 221,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static pdf_creator_t * new_creator ( int * n_elements ) { pdf_creator_t * daddy ; static const pdf_creator_t creator_template [ ] = { { \"Title\" , \"\" } , { \"Author\" , \"\" } , { \"Subject\" , \"\" } , { \"Keywords\" , \"\" } , { \"Creator\" , \"\" } , { \"Producer\" , \"\" } , { \"CreationDate\" , \"\" } , { \"ModDate\" , \"\" } , { \"Trapped\" , \"\" } , } ; <vul-start> daddy = malloc ( sizeof ( creator_template ) ) ; <vul-end> memcpy ( daddy , creator_template , sizeof ( creator_template ) ) ; if ( n_elements ) * n_elements = sizeof ( creator_template ) / sizeof ( creator_template [ 0 ] ) ; return daddy ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ; daddy = safe_calloc <vul-end> ( sizeof (\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; daddy = safe_calloc <vul-end> ( sizeof (\n"
 },
 {
  "id": 222,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static grub_err_t find_file ( const char * currpath , grub_fshelp_node_t currroot , grub_fshelp_node_t * currfound , struct grub_fshelp_find_file_closure * c ) { <vul-start> # ifndef _MSC_VER <vul-end> <vul-start> char fpath [ grub_strlen ( currpath ) + 1 ] ; <vul-end> # else char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ; <vul-start> # endif <vul-end> char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , grub_strlen ( currpath ) + 1 ) ; while ( * name == '/' ) name ++ ; if ( ! * name ) { <vul-start> * currfound = currnode ; <vul-end> return 0 ; } for ( ; ; ) { int found ; struct find_file_closure cc ; next = grub_strchr ( name , '/' ) ; if ( next ) { while ( * next == '/' ) * ( next ++ ) = '\\\\0' ; } if ( type != GRUB_FSHELP_DIR ) { free_node ( currnode , c ) ; <vul-start> return grub_error ( GRUB_ERR_BAD_FILE_TYPE , \"not a directory\" ) ; <vul-end> } cc . name = name ; cc . type = & type ; cc . oldnode = & oldnode ; cc . currnode = & currnode ; found = c -> iterate_dir ( currnode , iterate , & cc ) ; if ( ! found ) { <vul-start> if ( grub_errno ) <vul-end> <vul-start> return grub_errno ; <vul-end> break ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> c ) { char * fpath = grub_malloc ( <vul-end> grub_strlen ( currpath <vul-start> ) + 1 ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <vul-end> grub_strlen ( currpath <vul-start> 1 ) ; <vul-end> while ( * <vul-start> currfound = currnode ; free ( fpath ) <vul-start> c ) ; free ( fpath ) ; <vul-start> ( grub_errno ) { free ( fpath ) ; <vul-start> return grub_errno ; } <vul-start> c ) ; free ( fpath ) ; <vul-start> oldnode , c ) ; free ( fpath <vul-start> c ) ; free ( fpath ) ; <vul-start> = type ; free ( fpath ) ; <vul-start> next ; } free ( fpath ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> c ) { char * fpath = grub_malloc ( <vul-end> grub_strlen ( currpath <vul-start> ) + 1 ) ; if (! fpath ) { return GRUB_ERR_MEMORY ; } <vul-end> char * name <vul-start> name ) { free_node ( currnode, c ) ; <vul-start> return grub_errno ; } <vul-start> 1 ) ; if (! fpath ) { free_node ( currnode, c ) ; return GRUB_ERR_MEMORY ; } <vul-start> name ) { free_node ( currnode, c ) ; <vul-start> return grub_errno ; } <vul-start> found ) { free_node ( currnode, c ) ; <vul-start> ( grub_errno ) { <vul-start> return grub_errno ; } <vul-start> next ; } free_node ( oldnode, c ) ; <vul-start> c ) ; free_node ( currnode, c ) ; <vul-start> = type ; free_node ( currnode, c ) ; <vul-start> next ; } free_node ( oldnode, c ) ;\n"
 },
 {
  "id": 223,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static struct prog_entry * predicate_parse ( const char * str , int nr_parens , int nr_preds , parse_pred_fn parse_pred , void * data , struct filter_parse_error * pe ) { struct prog_entry * prog_stack ; struct prog_entry * prog ; const char * ptr = str ; char * inverts = NULL ; int * op_stack ; int * top ; int invert = 0 ; int ret = - ENOMEM ; int len ; int N = 0 ; int i ; nr_preds += 2 ; op_stack = kmalloc_array ( nr_parens , sizeof ( * op_stack ) , GFP_KERNEL ) ; if ( ! op_stack ) return ERR_PTR ( - ENOMEM ) ; prog_stack = kcalloc ( nr_preds , sizeof ( * prog_stack ) , GFP_KERNEL ) ; if ( ! prog_stack ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } inverts = kmalloc_array ( nr_preds , sizeof ( * inverts ) , GFP_KERNEL ) ; if ( ! inverts ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } top = op_stack ; prog = prog_stack ; * top = 0 ; while ( * ptr ) { const char * next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case '(' : if ( top - op_stack > nr_parens ) <vul-start> return ERR_PTR ( - EINVAL ) ; <vul-end> * ( ++ top ) = invert ; continue ; case '!' : if ( ! is_not (",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> > nr_parens ) { ret = - EINVAL ; goto out_free ; } <vul-end> * ( ++\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> > nr_parens ) { ret = <vul-end> ERR_PTR ( - <vul-start> EINVAL ) ; goto out_free ; }\n"
 },
 {
  "id": 224,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 int wwunpack ( uint8_t * exe , uint32_t exesz , uint8_t * wwsect , struct cli_exe_section * sects , uint16_t scount , uint32_t pe , int desc ) { uint8_t * structs = wwsect + 0x2a1 , * compd , * ccur , * unpd , * ucur , bc ; uint32_t src , srcend , szd , bt , bits ; int error = 0 , i ; cli_dbgmsg ( \"in wwunpack\\\\n\" ) ; while ( 1 ) { if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , structs , 17 ) ) { cli_dbgmsg ( \"WWPack: Array of structs out of section\\\\n\" ) ; break ; } src = sects [ scount ] . rva - cli_readint32 ( structs ) ; structs += 8 ; szd = cli_readint32 ( structs ) * 4 ; structs += 4 ; srcend = cli_readint32 ( structs ) ; structs += 4 ; unpd = ucur = exe + src + srcend + 4 - szd ; if ( ! szd || ! CLI_ISCONTAINED ( exe , exesz , unpd , szd ) ) { cli_dbgmsg ( \"WWPack: Compressed data out of file\\\\n\" ) ; break ; } cli_dbgmsg ( \"WWP: src: %x, szd: %x, srcend: %x - %x\\\\n\" , src , szd , srcend , srcend + 4 - szd ) ; if ( ! ( compd = cli_malloc ( szd ) ) ) { cli_dbgmsg ( \"WWPack: Unable to allocate memory for compd\\\\n\" ) ; break ; } memcpy ( compd , unpd , szd ) ; memset ( unpd",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> 8 ) ; if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) { cli_dbgmsg ( \"WWPack: unpack memory address out of bounds.\\\\n\" ) ; return CL_EFORMAT ; }\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> 8 ) ; if (! CLI_ISCONTAINED ( exe, exesz, pe + 0x28, & exe [ pe + 0x50 ], sizeof ( uint32_t ) ) ) { cli_dbgmsg ( \"WWPack: exe contains invalid entries\\\\n\" ) ; break ; }\n"
 },
 {
  "id": 225,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int __ext4_expand_extra_isize ( struct inode * inode , unsigned int new_extra_isize , struct ext4_iloc * iloc , handle_t * handle , int * no_expand ) { struct ext4_inode * raw_inode ; struct ext4_xattr_ibody_header * header ; <vul-start> int error ; <vul-end> raw_inode = ext4_raw_inode ( iloc ) ; header = IHDR ( inode , raw_inode ) ; if ( ! ext4_test_inode_state ( inode , EXT4_STATE_XATTR ) || header -> h_magic != cpu_to_le32 ( EXT4_XATTR_MAGIC ) ) { memset ( ( void * ) raw_inode + EXT4_GOOD_OLD_INODE_SIZE + EXT4_I ( inode ) -> i_extra_isize , 0 , new_extra_isize - EXT4_I ( inode ) -> i_extra_isize ) ; EXT4_I ( inode ) -> i_extra_isize = new_extra_isize ; return 0 ; } error = ext4_expand_extra_isize_ea ( inode , new_extra_isize , raw_inode , handle ) ; if ( error ) { * no_expand = 1 ; } return error ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> * header ; unsigned int inode_size = EXT4_INODE_SIZE ( inode -> i_sb ) ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; int error ; if ( ( EXT4_GOOD_OLD_INODE_SIZE + ei -> i_extra_isize > inode_size ) || ( ei -> i_extra_isize & 3 ) ) { EXT4_ERROR_INODE ( inode , \"bad extra_isize %u (inode size %u)\" , ei -> i_extra_isize , EXT4_INODE_SIZE ( inode -> i_sb ) ) ; return - EFSCORRUPTED ; } if ( ( new_extra_isize < ei -> i_extra_isize ) || ( new_extra_isize < 4 ) || ( new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE ) ) return - EINVAL <vul-end> ; raw_inode =\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; int error ; if ( new_extra_isize < EXT4_I ( inode ) -> i_extra_isize ) return 0\n"
 },
 {
  "id": 226,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static int mov_write_audio_tag ( AVFormatContext * s , AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track ) { int64_t pos = avio_tell ( pb ) ; int version = 0 ; uint32_t tag = track -> tag ; if ( track -> mode == MODE_MOV ) { <vul-start> if ( track -> timescale > UINT16_MAX ) { <vul-end> if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( \"lpcm\" ) ; version = 2 ; } else if ( track -> audio_vbr || mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 ) { version = 1 ; } } avio_wb32 ( pb , 0 ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ffio_wfourcc ( pb , \"enca\" ) ; } else { avio_wl32 ( pb , tag ) ; } avio_wb32 ( pb , 0 ) ; avio_wb16 ( pb , 0 ) ; avio_wb16 ( pb , 1 ) ; avio_wb16 ( pb , version ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0 ) ; if ( version == 2 ) { avio_wb16 ( pb , 3 ) ; avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , 0xfffe ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0x00010000 ) ; avio_wb32 ( pb , 72 ) ;",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> timescale > UINT16_MAX || ! track -> par -> channels\n"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> { if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( \"lpcm\" ) ; else if ( <vul-start> track -> timescale == UINT16_MAX ) { version = 2 ; } else <vul-end> if ( track\n"
 },
 {
  "id": 227,
  "question": "CWE-552 Code Input Vulnerable Code Is: CWE-552 static long _syscall ( long num , long arg1 , long arg2 , long arg3 , long arg4 , long arg5 , long arg6 ) { long ret = - 1 ; oe_errno = 0 ; switch ( num ) { # if defined ( OE_SYS_creat ) case OE_SYS_creat : { const char * pathname = ( const char * ) arg1 ; oe_mode_t mode = ( oe_mode_t ) arg2 ; int flags = ( OE_O_CREAT | OE_O_WRONLY | OE_O_TRUNC ) ; ret = oe_open ( pathname , flags , mode ) ; if ( oe_errno == OE_ENOENT ) { oe_errno = OE_ENOSYS ; goto done ; } goto done ; } # endif # if defined ( OE_SYS_open ) case OE_SYS_open : { const char * pathname = ( const char * ) arg1 ; int flags = ( int ) arg2 ; uint32_t mode = ( uint32_t ) arg3 ; ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ; goto done ; } # endif case OE_SYS_openat : { int dirfd = ( int ) arg1 ; const char * pathname = ( const char * ) arg2 ; int flags = ( int ) arg3 ; uint32_t mode = ( uint32_t ) arg4 ; if ( dirfd != OE_AT_FDCWD ) { oe_errno = OE_EBADF ; goto done ; } ret = oe_open ( pathname , flags , mode ) ; if ( ret < 0 && oe_errno == OE_ENOENT ) goto done ; goto done ; }",
  "golden_answers": [
   "CWE-552 Fixed Code Lines are: <vul-start> ) arg4 ; <vul-end> struct oe_sockaddr * <vul-start> * dest_add = ( <vul-end> struct oe_sockaddr *\n"
  ],
  "generated_answer": "CWE-552 Fixed Code Lines are: <vul-start> ( const struct oe_sockaddr_storage <vul-end> * ) arg5 <vul-start> * ) arg5 ; const struct oe_sockaddr_storage * dest_add = ( const struct oe_sockaddr_storage <vul-end> * ) arg6\n"
 },
 {
  "id": 228,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * delete_policy_2_svc ( dpol_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , <vul-end> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> name ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , NULL , NULL ) ) { log_unauth ( \"kadm5_delete_policy\" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_DELETE ; } else { ret . code = kadm5_delete_policy ( ( void * ) handle , arg -> name ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_delete_policy\" , ( ( prime_arg == NULL ) ? \"(null)\" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; }",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <vul-end> free_server_handle ( handle\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> ) ; } exit_func : gss_release_buffer ( & minor_stat, & client_name ) ; gss_release_buffer ( & minor_stat, & service_name ) ; <vul-end> free_server_handle ( handle\n"
 },
 {
  "id": 229,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void ikev2_parent_outI1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( \"ikev2 parent outI1: calculated ke+nonce, sending I1\" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , \"%s: Request was disconnected from state\" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_outI1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_cur_state ( ) ; reset_globals ( ) ; <vul-start> passert ( GLOBALS_ARE_RESET ( ) ) ; <vul-end> }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> }    \n"
 },
 {
  "id": 230,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static struct block_device * ext3_blkdev_get ( dev_t dev , struct super_block * sb ) { struct block_device * bdev ; char b [ BDEVNAME_SIZE ] ; bdev = blkdev_get_by_dev ( dev , FMODE_READ | FMODE_WRITE | FMODE_EXCL , sb ) ; if ( IS_ERR ( bdev ) ) goto fail ; return bdev ; fail : <vul-start> ext3_msg ( sb , \"error: failed to open journal device %s: %ld\" , <vul-end> __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ; return NULL ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( sb , KERN_ERR ,\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( sb, KERN_ERR,\n"
 },
 {
  "id": 231,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int mk_request_error ( int http_status , struct client_session * cs , struct session_request * sr ) { int ret , fd ; mk_ptr_t message , * page = 0 ; struct error_page * entry ; struct mk_list * head ; struct file_info finfo ; mk_header_set_http_status ( sr , http_status ) ; if ( http_status != MK_CLIENT_LENGTH_REQUIRED && http_status != MK_CLIENT_BAD_REQUEST && http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE ) { mk_list_foreach ( head , & sr -> host_conf -> error_pages ) { entry = mk_list_entry ( head , struct error_page , _head ) ; if ( entry -> status != http_status ) { continue ; } ret = mk_file_get_info ( entry -> real_path , & finfo ) ; if ( ret == - 1 ) { break ; } fd = open ( entry -> real_path , config -> open_flags ) ; if ( fd == - 1 ) { break ; } sr -> fd_file = fd ; <vul-start> sr -> bytes_to_send = finfo . size ; <vul-end> sr -> headers . content_length = finfo . size ; sr -> headers . real_length = finfo . size ; memcpy ( & sr -> file_info , & finfo , sizeof ( struct file_info ) ) ; mk_header_send ( cs -> socket , cs , sr ) ; return mk_http_send_file ( cs , sr ) ; } } mk_ptr_reset ( & message ) ; switch ( http_status ) { case MK_CLIENT_BAD_REQUEST : page = mk_request_set_default_page ( \"Bad Request\" , sr -> uri , sr -> host_conf -> host_signature ) ; break ; case MK_CLIENT_FORBIDDEN : page = mk_request_set_default_page ( \"Forbidden\"",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; sr -> fd_is_fdt = MK_FALSE ; sr ->\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; sr -> file_info = ( struct file_info * ) malloc ( sizeof ( struct file_info ) ) ; if ( sr -> file_info == NULL ) { close ( fd ) ; break ; } sr ->\n"
 },
 {
  "id": 232,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_type = SADB_X_SPDFLUSH ; hdr -> sadb_msg_seq = c -> seq ; hdr -> sadb_msg_pid = c -> portid ; hdr -> sadb_msg_version = PF_KEY_V2 ; hdr -> sadb_msg_errno = ( uint8_t ) 0 ; <vul-start> hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; <vul-end> pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; return 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( sizeof ( * hdr <vul-end> ) / sizeof\n"
 },
 {
  "id": 233,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void uwbd_stop ( struct uwb_rc * rc ) <vul-start> { <vul-end> kthread_stop ( rc -> uwbd . task ) ; uwbd_flush ( rc ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> rc ) { if ( rc -> uwbd . task )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> rc ) { if ( rc -> uwbd. task )\n"
 },
 {
  "id": 234,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int sgi_clock_set ( clockid_t clockid , struct timespec * tp ) { u64 nsec ; <vul-start> u64 rem ; <vul-end> nsec = rtc_time ( ) * sgi_clock_period ; <vul-start> sgi_clock_offset . tv_sec = tp -> tv_sec - div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <vul-end> if ( rem <= tp -> tv_nsec ) sgi_clock_offset . tv_nsec = tp -> tv_sec - rem ; else { sgi_clock_offset . tv_nsec = tp -> tv_sec + NSEC_PER_SEC - rem ; sgi_clock_offset . tv_sec -- ; } return 0 ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> u64 nsec ; u32 <vul-end> rem ; nsec <vul-start> -> tv_sec - div_u64_rem <vul-end> ( nsec ,\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ; u64 rem ; int ret <vul-start> * sgi_clock_period ; ret = sgi_clock_set_impl ( clockid, tp ) ; if ( ret ) return ret <vul-end> ; if (\n"
 },
 {
  "id": 235,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int check_best_zero_mv ( const VP9_COMP * cpi , const uint8_t mode_context [ MAX_REF_FRAMES ] , int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] , <vul-start> int disable_inter_mode_mask , int this_mode , int ref_frame , <vul-end> int second_ref_frame ) { if ( ! ( disable_inter_mode_mask & ( 1 << INTER_OFFSET ( ZEROMV ) ) ) && ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frame ] . as_int == 0 && ( second_ref_frame == NONE || <vul-start> frame_mv [ this_mode ] [ second_ref_frame ] . as_int == 0 ) ) { <vul-end> <vul-start> int rfc = mode_context [ ref_frame ] ; <vul-end> int c1 = cost_mv_ref ( cpi , NEARMV , rfc ) ; int c2 = cost_mv_ref ( cpi , NEARESTMV , rfc ) ; int c3 = cost_mv_ref ( cpi , ZEROMV , rfc ) ; if ( this_mode == NEARMV ) { if ( c1 > c3 ) return 0 ; } else if ( this_mode == NEARESTMV ) { if ( c2 > c3 ) return 0 ; } else { assert ( this_mode == ZEROMV ) ; <vul-start> if ( second_ref_frame == NONE ) { <vul-end> <vul-start> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ] . as_int == 0 ) || <vul-end> <vul-start> ( c3 >= c1 && frame_mv [ NEARMV ] [ ref_frame ] . as_int == 0 ) ) <vul-end> return 0 ; } else { <vul-start> if ( ( c3 >= c2 && frame_mv [ NEARESTMV ] [ ref_frame ]",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> MAX_REF_FRAMES ] , int this_mode , const MV_REFERENCE_FRAME ref_frames [ 2 ] ) { if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == ZEROMV ) && frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && ( ref_frames [ 1 ] <vul-end> == NONE || <vul-start> this_mode ] [ ref_frames [ 1 ] <vul-end> ] . as_int <vul-start> = mode_context [ ref_frames [ 0 ] <vul-end> ] ; int <vul-start> ; if ( ref_frames [ 1 ] <vul-end> == NONE ) <vul-start> NEARESTMV ] [ ref_frames [ 0 ] <vul-end> ] . as_int <vul-start> NEARMV ] [ ref_frames [ 0 ] <vul-end> ] . as_int <vul-start> NEARESTMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARESTMV ] [ ref_frames [ 1 ] <vul-end> ] . as_int <vul-start> NEARMV ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 1 ] <vul-end> ] . as_int\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> disable_inter_mode_mask, int <vul-end> this_mode, int <vul-start> this_mode, int <vul-end> ref_frame, int <vul-start> == NONE || ( <vul-start> == 0 ) && ( mode_context [ ref_frame ] & 1 ) == 0 ) <vul-start> ) ) { const <vul-start> ; if ( ( this_mode == NEARMV ) && ( <vul-start> == NONE ) ) <vul-start> if ( ( this_mode == NEAREMV ) && ( <vul-start> == 0 ) || ( this_mode == ZEROMV ) && ( <vul-end> frame_mv [ NEARESTMV <vul-start> == 0 ) ) <vul-start> if ( ( this_mode == NEAREMV ) && ( <vul-start> == NONE ) )\n"
 },
 {
  "id": 236,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int MSG_ReadBits ( msg_t * msg , int bits ) { int value ; int get ; qboolean sgn ; int i , nbits ; <vul-start> value = 0 ; <vul-end> if ( bits < 0 ) { bits = - bits ; sgn = qtrue ; } else { sgn = qfalse ; } <vul-start> if ( msg -> oob ) { <vul-end> if ( bits == 8 ) { value = msg -> data [ msg -> readcount ] ; msg -> readcount += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp ; CopyLittleShort ( & temp , & msg -> data [ msg -> readcount ] ) ; value = temp ; msg -> readcount += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & value , & msg -> data [ msg -> readcount ] ) ; msg -> readcount += 4 ; msg -> bit += 32 ; } else Com_Error ( ERR_DROP , \"can\\'t read %d bits\" , bits ) ; } else { nbits = 0 ; if ( bits & 7 ) { <vul-start> nbits = bits & 7 ; <vul-end> for ( i = 0 ; i < nbits ; i ++ ) { value |= ( Huff_getBit ( msg -> data , & msg -> bit ) << i ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , nbits ; if ( msg -> readcount > msg -> cursize ) { return 0 ; } <vul-start> oob ) { if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <vul-start> & 7 ; if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <vul-start> msg -> bit , msg -> cursize << 3 <vul-start> ) ) ; if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, nbits ; int bit ; <vul-start> qfalse ; } bit = msg -> bit ; <vul-start> & 7 ; if ( bit > 0 && msg -> bit + nbits > msg -> len ) { value |= ( 1 << ( bits - nbits ) - 1 ) ; } else { <vul-start> bit ) ; } <vul-start> msg -> readcount += 1 ; msg -> bit += 1 <vul-end> ; } if\n"
 },
 {
  "id": 237,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 <vul-start> dictionary * iniparser_load ( const char * ininame ) <vul-end> { FILE * in ; char line [ ASCIILINESZ + 1 ] ; char section [ ASCIILINESZ + 1 ] ; char key [ ASCIILINESZ + 1 ] ; char tmp [ ( ASCIILINESZ * 2 ) + 1 ] ; char val [ ASCIILINESZ + 1 ] ; int last = 0 ; int len ; int lineno = 0 ; int errs = 0 ; dictionary * dict ; if ( ( in = fopen ( ininame , \"r\" ) ) == NULL ) { fprintf ( stderr , \"iniparser: cannot open %s\\\\n\" , ininame ) ; return NULL ; } dict = dictionary_new ( 0 ) ; if ( ! dict ) { fclose ( in ) ; return NULL ; } memset ( line , 0 , ASCIILINESZ ) ; memset ( section , 0 , ASCIILINESZ ) ; memset ( key , 0 , ASCIILINESZ ) ; memset ( val , 0 , ASCIILINESZ ) ; last = 0 ; while ( fgets ( line + last , ASCIILINESZ - last , in ) != NULL ) { lineno ++ ; len = ( int ) strlen ( line ) - 1 ; if ( len == 0 ) continue ; if ( line [ len ] != '\\\\n' && ! feof ( in ) ) { fprintf ( stderr , \"iniparser: input line too long in %s (%d)\\\\n\" , ininame , lineno ) ; dictionary_del ( dict ) ; fclose ( in ) ; return NULL ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> char * ininame , load_options options <vul-start> case LINE_ERROR : if ( options & HIDE_ERRORED_LINE_CONTENT ) { <vul-start> ( stderr , \"iniparser: syntax error in %s (%d)\\\\n\" , ininame , lineno ) ; } else { fprintf ( stderr , <vul-start> line ) ; }\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> char * ininame, const char * * section_name <vul-start> case LINE_ERROR : if ( section_name ) * section_name = '\\\\0' ; <vul-start> ( stderr, \"iniparser: syntax error in %s (%d):\\\\n\" <vul-end>, ininame, <vul-start> ( stderr, \"-> %s:%s\\\\n\", line, section_name? section_name : \"\" <vul-end> ) ; errs\n"
 },
 {
  "id": 238,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int calc_iframe_target_size_one_pass_cbr ( const VP9_COMP * cpi ) { <vul-start> const RATE_CONTROL * rc = & cpi -> rc ; <vul-end> int target ; if ( cpi -> common . current_video_frame == 0 ) { <vul-start> target = ( ( cpi -> oxcf . starting_buffer_level / 2 ) > INT_MAX ) <vul-end> <vul-start> ? INT_MAX : ( int ) ( cpi -> oxcf . starting_buffer_level / 2 ) ; <vul-end> } else { const int initial_boost = 32 ; <vul-start> int kf_boost = MAX ( initial_boost , ( int ) ( 2 * cpi -> output_framerate - 16 ) ) ; <vul-end> <vul-start> if ( rc -> frames_since_key < cpi -> output_framerate / 2 ) { <vul-end> kf_boost = ( int ) ( kf_boost * rc -> frames_since_key / <vul-start> ( cpi -> output_framerate / 2 ) ) ; <vul-end> } <vul-start> target = ( ( 16 + kf_boost ) * rc -> av_per_frame_bandwidth ) >> 4 ; <vul-end> } return vp9_rc_clamp_iframe_target_size ( cpi , target ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> cpi -> rc ; const VP9EncoderConfig * oxcf = & cpi -> oxcf ; const SVC * const svc = & cpi -> svc <vul-start> = ( ( rc -> <vul-end> starting_buffer_level / 2 <vul-start> int ) ( rc -> starting_buffer_level / 2 ) ; } else { int kf_boost = 32 ; double framerate = cpi -> framerate ; if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ; const LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; framerate = lc -> framerate ; } <vul-end> kf_boost = MAX <vul-start> = MAX ( kf_boost , ( int ) ( 2 * framerate <vul-end> - 16 ) <vul-start> -> frames_since_key < framerate <vul-end> / 2 ) <vul-start> frames_since_key / ( framerate <vul-end> / 2 ) <vul-start> * rc -> avg_frame_bandwidth <vul-end> ) >> 4\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) { const RATE_CONTROL_t <vul-end> * rc = <vul-start> / 2 ) + 1 ) / 2 <vul-end> ; } else <vul-start> int kf_boost = MIN <vul-end> ( initial_boost, <vul-start> ( initial_boost, <vul-end> 2 * cpi <vul-start> cpi -> output_framerate <vul-end> ) ; if <vul-start> / 2 ) kf_boost <vul-end> = ( int <vul-start> -> frames_since_key < ( cpi -> oxcf. key_depth * 2 ) ) { kf_boost <vul-end> = ( int <vul-start> / 2 ) ; } target = ( int ) ( ( 16 + kf_boost ) * rc -> avg_frame_bandwidth <vul-end> ) >> 4\n"
 },
 {
  "id": 239,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void enable_nmi_window ( struct kvm_vcpu * vcpu ) { struct vcpu_svm * svm = to_svm ( vcpu ) ; if ( ( svm -> vcpu . arch . hflags & ( HF_NMI_MASK | HF_IRET_MASK ) ) == HF_NMI_MASK ) return ; svm -> nmi_singlestep = true ; svm -> vmcb -> save . rflags |= ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <vul-start> update_db_bp_intercept ( vcpu ) ; <vul-end> }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> X86_EFLAGS_RF ) ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> X86_EFLAGS_RF ) ; <vul-end> }    \n"
 },
 {
  "id": 240,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void finish_object ( struct object * obj , <vul-start> struct strbuf * path , const char * name , <vul-end> void * cb_data ) { struct rev_list_info * info = cb_data ; if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( \"missing blob object \\'%s\\'\" , oid_to_hex ( & obj -> oid ) ) ; if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * obj , <vul-end> const char *\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * obj, <vul-end> const char *\n"
 },
 {
  "id": 241,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , \"(pad1)\" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , \"(padn: trunc)\" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , \"(padn)\" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , \"(refresh: trunc)\" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_PRINT ( ( ndo , \"(refresh: %u)\" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , \"(altcoa: trunc)\" ) ) ; goto trunc ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;\n"
 },
 {
  "id": 242,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int copy_to_user_tmpl ( struct xfrm_policy * xp , struct sk_buff * skb ) { struct xfrm_user_tmpl vec [ XFRM_MAX_DEPTH ] ; int i ; if ( xp -> xfrm_nr == 0 ) return 0 ; for ( i = 0 ; i < xp -> xfrm_nr ; i ++ ) { struct xfrm_user_tmpl * up = & vec [ i ] ; struct xfrm_tmpl * kp = & xp -> xfrm_vec [ i ] ; <vul-start> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <vul-end> up -> family = kp -> encap_family ; memcpy ( & up -> saddr , & kp -> saddr , sizeof ( up -> saddr ) ) ; up -> reqid = kp -> reqid ; up -> mode = kp -> mode ; up -> share = kp -> share ; up -> optional = kp -> optional ; up -> aalgos = kp -> aalgos ; up -> ealgos = kp -> ealgos ; up -> calgos = kp -> calgos ; } return nla_put ( skb , XFRMA_TMPL , sizeof ( struct xfrm_user_tmpl ) * xp -> xfrm_nr , vec ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> i ] ; memset ( up , 0 , sizeof ( * up ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> i ] ; memset ( up, 0, sizeof ( * up ) ) ;\n"
 },
 {
  "id": 243,
  "question": "CWE-522 Code Input Vulnerable Code Is: CWE-522 static void credential_write_item ( FILE * fp , const char * key , const char * value ) { if ( ! value ) return ; <vul-start> fprintf ( fp , \"%s=%s\\\\n\" , key , value ) ; <vul-end> }",
  "golden_answers": [
   "CWE-522 Fixed Code Lines are: <vul-start> ) return ; if ( strchr ( value , '\\\\n' ) ) die ( \"credential value for %s contains newline\" , key ) ;\n"
  ],
  "generated_answer": "CWE-522 Fixed Code Lines are: <vul-start> ) return ; fputc ('', fp ) ; fputs ( <vul-end> key, value <vul-start> key, value, fp\n"
 },
 {
  "id": 244,
  "question": "CWE-77 Code Input Vulnerable Code Is: CWE-77 static int parse_token ( char * * name , char * * value , char * * cp ) { char * end ; if ( ! name || ! value || ! cp ) return - BLKID_ERR_PARAM ; if ( ! ( * value = strchr ( * cp , '=' ) ) ) return 0 ; * * value = '\\\\0' ; * name = strip_line ( * cp ) ; * value = skip_over_blank ( * value + 1 ) ; if ( * * value == \\'\"\\' ) { <vul-start> end = strchr ( * value + 1 , \\'\"\\' ) ; <vul-end> if ( ! end ) { DBG ( READ , ul_debug ( \"unbalanced quotes at: %s\" , * value ) ) ; * cp = * value ; return - BLKID_ERR_CACHE ; } ( * value ) ++ ; * end = '\\\\0' ; <vul-start> end ++ ; <vul-end> } else { end = skip_over_word ( * value ) ; if ( * end ) { * end = '\\\\0' ; end ++ ; } } * cp = end ; return 1 ; }",
  "golden_answers": [
   "CWE-77 Fixed Code Lines are: <vul-start> \\'\"\\' ) { char * p = end = <vul-end> * value + <vul-start> value + 1 ; while ( * p ) { if ( * p == '\\\\\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \\'\"\\' ) break ; } p ++ ; end ++ ; } if ( * end != \\'\"\\' <vul-end> ) { DBG <vul-start> '\\\\0' ; end = ++ p <vul-end> ; } else\n"
  ],
  "generated_answer": "CWE-77 Fixed Code Lines are: <vul-start> { end = safe_strchr <vul-end> ( * value <vul-start> ; end ++ ; } else if ( * * value == \\'\"\\' ) { end = safe_strchr ( * value + 1, \\'\"\\' ) ; if (! end ) { DBG ( READ, ul_debug ( \"unbalanced quotes at: %s\", * value ) ) ; * cp = * value ; return - BLKID_ERR_CACHE ; } ( * value ) ++\n"
 },
 {
  "id": 245,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static const char * parse_string ( cJSON * item , const char * str ) <vul-end> { <vul-start> const char * ptr = str + 1 ; <vul-end> char * ptr2 ; char * out ; int len = 0 ; unsigned uc , uc2 ; if ( * str != \\'\\\\\"\\' ) { <vul-start> ep = str ; <vul-end> <vul-start> return 0 ; <vul-end> } <vul-start> while ( * ptr != \\'\\\\\"\\' && * ptr && ++ len ) <vul-end> <vul-start> if ( * ptr ++ == '\\\\\\\\' ) <vul-end> <vul-start> ptr ++ ; <vul-end> <vul-start> if ( ! ( out = ( char * ) cJSON_malloc ( len + 1 ) ) ) <vul-end> return 0 ; ptr = str + 1 ; ptr2 = out ; <vul-start> while ( * ptr != \\'\\\\\"\\' && * ptr ) { <vul-end> if ( * ptr != '\\\\\\\\' ) * ptr2 ++ = * ptr ++ ; else { ptr ++ ; switch ( * ptr ) { case 'b' : * ptr2 ++ = '\\\\b' ; break ; case 'f' : * ptr2 ++ = '\\\\f' ; break ; case 'n' : * ptr2 ++ = '\\\\n' ; break ; case 'r' : * ptr2 ++ = '\\\\r' ; break ; case 't' : * ptr2 ++ = '\\\\t' ; break ; case 'u' : <vul-start> sscanf ( ptr + 1 , \"%4x\" , & uc ) ; <vul-end> <vul-start> ptr += 4 ; <vul-end> if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) <vul-start> break",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> char * str , <vul-end> const char * <vul-start> const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * <vul-end> out ; int <vul-start> \\'\\\\\"\\' ) { * <vul-start> = str ; return 0 ; <vul-end> } while ( <vul-start> while ( * end_ptr <vul-end> != \\'\\\\\"\\' && <vul-start> \\'\\\\\"\\' && * end_ptr <vul-end> && ++ len <vul-start> ++ len ) if ( * end_ptr <vul-end> ++ == '\\\\\\\\' <vul-start> == '\\\\\\\\' ) end_ptr ++ ; out = ( char * ) cJSON_malloc ( len + 1 ) <vul-end> ; if ( <vul-start> if ( ! out ) return 0 ; item -> valuestring <vul-end> = out ; <vul-start> = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) <vul-end> { if ( <vul-start> case 'u' : uc = parse_hex4 ( ptr + 1 ) ; <vul-end> ptr += 4 <vul-start> += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } <vul-start> == 0 ) { * ep = str ; return 0 ; } <vul-end> if ( uc <vul-start> <= 0xDBFF ) { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } <vul-end> if ( ptr <vul-start> != 'u' ) { * ep = str ; return 0 ; } uc2 = parse_hex4 <vul-end> ( ptr + <vul-start> ptr + 3 ) ; <vul-end> ptr += 6 <vul-start> > 0xDFFF ) { * ep = str ; return 0 ; } <vul-end> uc = 0x10000 <vul-start> uc = 0x10000 + ( <vul-end> ( ( uc <vul-start> & 0x3FF ) ) <vul-start> < 0x80 ) len = 1 ; <vul-end> else if ( <vul-start> break ; } ptr ++ <vul-end> ; } } <vul-start> == \\'\\\\\"\\' ) ptr ++ <vul-end> ; return ptr\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> char * str, const char * * ptr <vul-start> const char * ptr2 <vul-end> ; char * <vul-start> \\'\\\\\"\\' ) { * <vul-start> = str ; goto parse_string_end ; } while ( * ptr == \\'\\\\\"\\' ) { if ( len > 1 ) { len = 2 ; * ptr = '\\\\0' ; } else { ptr ++ ; } } <vul-end> } while ( <vul-start> while ( * ptr <vul-end>!= \\'\\\\\"\\' && <vul-start>!= '\\\\\\\\' ) { if ( * ptr == '\\\\\\\\' ) break ; if ( len == 1 ) break ; <vul-start> ptr ++ ; } <vul-end> ptr2 = out <vul-start> ; while ( ptr < * ptr && <vul-start>!= \\'\\\\\"\\' && * ptr ) { if ( len == 1 ) { len = 1 ; * ptr2 ++ = * ptr ; break ; } if ( * ptr == \\'\\\\\"\\' ) { if ( len == 2 ) { len = 3 ; * ptr2 ++ = * ptr ; break ; } } else { if ( * ptr == '\\\\\\\\' ) { * ptr2 ++ = * ptr ; } else { if ( * ptr == '\\\\0' ) { * ptr2 ++ = * ptr ; break ; } } ptr ++ ; len -- ; if ( len == 0 ) { len = 4 ; if ( ( uc < 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) break ; if ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 ) break ; if ( * ptr2 <vul-end> < 0x10000 || <vul-start> < 0x10000 ) { * ptr2 ++ = ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF ) ; } ptr2 += len ; switch ( len ) { case 4 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; * -- ptr2 += len ; break ; case 2 : * -- ptr2 = ( ( uc | 0x80 ) & 0xBF ) ; * ptr2 += len ; break ; default : * ptr2 ++ = * ptr ; break ; } } * ptr2 = 0 ; <vul-end> item -> valuestring <vul-start> = 0 ; parse_string_end : <vul-end> item -> type\n"
 },
 {
  "id": 246,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_diamond_search_sadx4 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , int * num00 , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { int i , j , step ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * best_address ; int tot_steps ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int best_site = 0 ; int last_site = 0 ; int ref_row ; int ref_col ; int this_row_offset ; int this_col_offset ; search_site * ss ; unsigned char * check_here ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; ref_row = ref_mv -> as_mv . row ; ref_col = ref_mv -> as_mv . col ; *",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> in_what , in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> check_here , in_what_stride <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> in_what, in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> check_here, in_what_stride <vul-end> ) ; if\n"
 },
 {
  "id": 247,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; struct bpf_reg_state * regs = state -> regs , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u32 dst = insn -> dst_reg , src = insn -> src_reg ; <vul-start> u8 opcode = BPF_OP ( insn -> code ) ; <vul-end> dst_reg = & regs [ dst ] ; if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { verbose ( env , \"R%d 32-bit pointer arithmetic prohibited\\\\n\" , dst ) ; return - EACCES ; } switch ( ptr_reg -> type ) { case PTR_TO_MAP_VALUE_OR_NULL : verbose ( env , \"R%d pointer arithmetic on %s prohibited, null-check it first\\\\n\" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case CONST_PTR_TO_MAP : case PTR_TO_PACKET_END : case PTR_TO_SOCKET",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> -> code ) ; int ret <vul-start> case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , \"R%d tried to add from different maps or paths\\\\n\" , dst ) ; return ret ; } <vul-start> case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , \"R%d tried to sub from different maps or paths\\\\n\" , dst ) ; return ret ; }\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> code ) ; if (! check_reg_sane_offset ( env, off_reg, ptr_reg -> type ) ||! check_reg_sane_offset ( env, ptr_reg, ptr_reg -> type ) ) return - EINVAL ; <vul-start> case BPF_ADD : case BPF_SUB : <vul-start> off + smin_val >= ( s64 ) ( s32 ) ( <vul-end> ptr_reg -> off <vul-start> off + smin_val )\n"
 },
 {
  "id": 248,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) <vul-end> { <vul-start> int ret ; <vul-end> ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , <vul-start> indx , data , size , 100 ) ; <vul-end> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , \"%s returned %d\\\\n\" , __func__ , ret ) ; <vul-start> return ret ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> __u16 size , const <vul-start> data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <vul-end> ; ret = <vul-start> , indx , buf <vul-end> , size , <vul-start> ret ) ; kfree ( buf ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * pegasus, u8 * buf <vul-end>, __u16 size <vul-start> data ) { u8 * buf ; int ret ; buf = kmalloc ( size, GFP_NOIO ) ; if (! buf ) return - ENOMEM <vul-end> ; ret = <vul-start>, indx, buf <vul-end>, size, <vul-start> ret ) ; else if ( ret <= size ) memcpy ( buf, data, ret ) ; kfree ( buf ) ;\n"
 },
 {
  "id": 249,
  "question": "CWE-763 Code Input Vulnerable Code Is: CWE-763 static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ; markold ( g , g -> allgc , g -> reallyold ) ; markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; <vul-start> psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; <vul-end> sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }",
  "golden_answers": [
   "CWE-763 Fixed Code Lines are: <vul-start> L ) ; g -> gcstate = GCSswpallgc ;\n"
  ],
  "generated_answer": "CWE-763 Fixed Code Lines are: <vul-start> L ) ; if ( g -> gcstate!= GCSpropagate ) { lua_error ( L, 1, \"Too many garbage objects\\\\n\" ) ; finishgencycle ( L, g ) ; return ; }\n"
 },
 {
  "id": 250,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 <vul-start> static unsigned int stack_maxrandom_size ( void ) <vul-end> { <vul-start> unsigned int max = 0 ; <vul-end> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <vul-start> max = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; <vul-end> } return max ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start>   static unsigned long <vul-end> stack_maxrandom_size ( void <vul-start> ) { unsigned long <vul-end> max = 0 <vul-start> ( ( - 1UL <vul-end> ) & STACK_RND_MASK\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> int stack_maxrandom_size ( struct net * net <vul-end> ) { unsigned <vul-start> { unsigned int random_size = 0 ; if (! net_rand_state ) { int i ; for ( i = 0 ; i < NR_CURSEG_NODES ; i ++ ) { if ( i == ( net -> random_node [ i ]. s_addr ) || i == ( net -> random_node [ i ]. s_addr ) ) random_size = ( ( net -> random_node [ i ]. s_addr <vul-end> & STACK_RND_MASK ) <vul-start> & STACK_RND_MASK ) + 1 ; } else { random_size = ( ( - 1U ) & STACK_RND_MASK ) << PAGE_SHIFT ; } } return random_size <vul-end> ; }  \n"
 },
 {
  "id": 251,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_yv12_copy_frame_c ( const YV12_BUFFER_CONFIG * src_ybc , YV12_BUFFER_CONFIG * dst_ybc ) { int row ; const uint8_t * src = src_ybc -> y_buffer ; uint8_t * dst = dst_ybc -> y_buffer ; # if 0 assert ( src_ybc -> y_width == dst_ybc -> y_width ) ; assert ( src_ybc -> y_height == dst_ybc -> y_height ) ; # endif <vul-start> for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { <vul-end> <vul-start> vpx_memcpy ( dst , src , src_ybc -> y_width ) ; <vul-end> src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <vul-start> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <vul-end> src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { <vul-start> vpx_memcpy ( dst , src , src_ybc -> uv_width ) ; <vul-end> src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { assert ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ; <vul-start> row ) { memcpy_short_addr <vul-end> ( dst , <vul-start> row ) { memcpy_short_addr <vul-end> ( dst , <vul-start> row ) { memcpy_short_addr <vul-end> ( dst , <vul-start> dst_ybc ) ; return ; } else { assert ( ! ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ) ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy ( dst , src , src_ybc -> y_width ) ; src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { const uint16_t * src16 = CONVERT_TO_SHORTPTR ( src ) ; uint16_t * dst16 = CONVERT_TO_SHORTPTR ( dst ) ; <vul-start> row ) { memcpy ( dst16, src16, src_ybc -> y_width * sizeof ( uint16_t ) ) ; src += src_ybc -> y_stride ; dst += src_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst16 <vul-end>, src, <vul-start> row ) { memcpy <vul-end> ( dst, <vul-start> row ) { memcpy <vul-end> ( dst, <vul-start> dst_ybc ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { dst16 += src_ybc -> uv_stride * sizeof ( uint16_t ) ; src += src_ybc -> uv_stride ; dst16 += dst_ybc -> uv_stride ; } } # endif\n"
 },
 {
  "id": 252,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int http_read_header ( URLContext * h , int * new_location ) { HTTPContext * s = h -> priv_data ; char line [ MAX_URL_SIZE ] ; int err = 0 ; <vul-start> s -> chunksize = - 1 ; <vul-end> for ( ; ; ) { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; av_log ( h , AV_LOG_TRACE , \"header=\\'%s\\'\\\\n\" , line ) ; err = process_line ( h , line , s -> line_count , new_location ) ; if ( err < 0 ) return err ; if ( err == 0 ) break ; s -> line_count ++ ; } if ( s -> seekable == - 1 && s -> is_mediagateway && s -> filesize == 2000000000 ) h -> is_streamed = 1 ; cookie_string ( s -> cookie_dict , & s -> cookies ) ; av_dict_free ( & s -> cookie_dict ) ; return err ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> chunksize = UINT64_MAX <vul-end> ; for (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; int chunksize = s -> chunksize ; if ( chunksize < 0 ) <vul-start> -> chunksize = chunksize <vul-end> ; for (\n"
 },
 {
  "id": 253,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t ctrl_set_roi_map ( vpx_codec_alg_priv_t * ctx , <vul-start> int ctr_id , va_list args ) { <vul-end> return VPX_CODEC_INVALID_PARAM ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * ctx , <vul-end> va_list args ) <vul-start> args ) { ( void ) ctx ; ( void ) args ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * ctx, <vul-end> va_list args )\n"
 },
 {
  "id": 254,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , \"no magic-number found!\" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"%3s \" , tok2str ( juniper_direction_values , \"---\" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , \"\\\\n\\\\tJuniper PCAP Flags [%s]\" , bittok2str ( jnx_flag_values , \"none\" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jnx_ext_len ; if ( ndo -> ndo_vflag > 1 )",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> -> header_len ; ND_TCHECK ( p [ 0 ] ) ; <vul-start> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; <vul-start> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -> header_len ; ND_TCHECK2 ( p [ 0 ], l2info -> length ) ; <vul-start> ; } } ND_TCHECK2 ( p [ 0 ], l2info -> caplen ) ;\n"
 },
 {
  "id": 255,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static TX_MODE read_tx_mode ( vp9_reader * r ) { <vul-end> <vul-start> TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ; <vul-end> if ( tx_mode == ALLOW_32X32 ) <vul-start> tx_mode += vp9_read_bit ( r ) ; <vul-end> return tx_mode ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> TX_MODE read_tx_mode ( vpx_reader <vul-end> * r ) <vul-start> TX_MODE tx_mode = vpx_read_literal <vul-end> ( r , <vul-start> ) tx_mode += vpx_read_bit <vul-end> ( r )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> TX_MODE read_tx_mode ( vpx_reader <vul-end> * r ) <vul-start> TX_MODE tx_mode = vpx_read_literal <vul-end> ( r, <vul-start> ) tx_mode += vpx_read_bit <vul-end> ( r )\n"
 },
 {
  "id": 256,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int decode_slice_header ( H264Context * h , H264Context * h0 ) { unsigned int first_mb_in_slice ; unsigned int pps_id ; int ret ; unsigned int slice_type , tmp , i , j ; int last_pic_structure , last_pic_droppable ; int must_reinit ; int needs_reinit = 0 ; int field_pic_flag , bottom_field_flag ; h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab ; h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab ; first_mb_in_slice = get_ue_golomb_long ( & h -> gb ) ; if ( first_mb_in_slice == 0 ) { if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) { field_end ( h , 1 ) ; } h0 -> current_slice = 0 ; if ( ! h0 -> first_field ) { if ( h -> cur_pic_ptr && ! h -> droppable ) { ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ; } h -> cur_pic_ptr = NULL ; } } slice_type = get_ue_golomb_31 ( & h -> gb ) ; if ( slice_type > 9 ) { av_log ( h -> avctx , AV_LOG_ERROR , \"slice type too large (%d) at %d %d\\\\n\" , slice_type , h -> mb_x , h -> mb_y ) ; return AVERROR_INVALIDDATA ; } if ( slice_type > 4 ) { slice_type -= 5 ; h -> slice_type_fixed = 1 ; } else h -> slice_type_fixed = 0 ; slice_type = golomb_to_pict_type [ slice_type ] ; h -> slice_type = slice_type ; h -> slice_type_nos = slice_type & 3 ; h -> pict_type =",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; if ( <vul-end> h0 -> cur_pic_ptr <vul-start> { if ( <vul-end> last_pic_structure != PICT_FRAME <vul-start> { if ( <vul-end> last_pic_structure != PICT_FRAME\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> (! last_pic_droppable <vul-end> ) { ff_thread_report_progress <vul-start> if (! last_pic_droppable <vul-end> ) { ff_thread_report_progress <vul-start> ) ; } if ( h -> context_initialized && h -> pict_type == PICT_FRAME && h -> mb_width!= h -> cur_pic_ptr -> mb_width || h -> mb_height!= h -> cur_pic_ptr -> mb_height ) { h -> context_initialized = 0 ; }\n"
 },
 {
  "id": 257,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int cmd_info ( void * data , const char * input ) { RCore * core = ( RCore * ) data ; bool newline = r_config_get_i ( core -> config , \"scr.interactive\" ) ; RBinObject * o = r_bin_cur_object ( core -> bin ) ; RCoreFile * cf = core -> file ; int i , va = core -> io -> va || core -> io -> debug ; int mode = 0 ; int is_array = 0 ; Sdb * db ; for ( i = 0 ; input [ i ] && input [ i ] != ' ' ; i ++ ) ; if ( i > 0 ) { switch ( input [ i - 1 ] ) { case '*' : mode = R_CORE_BIN_RADARE ; break ; case 'j' : mode = R_CORE_BIN_JSON ; break ; case 'q' : mode = R_CORE_BIN_SIMPLE ; break ; } } if ( mode == R_CORE_BIN_JSON ) { if ( strlen ( input + 1 ) > 1 ) { is_array = 1 ; } } if ( is_array ) { r_cons_printf ( \"{\" ) ; } if ( ! * input ) { cmd_info_bin ( core , va , mode ) ; } if ( ! strcmp ( input , \"*\" ) ) { input = \"I*\" ; } RBinObject * obj = r_bin_cur_object ( core -> bin ) ; while ( * input ) { switch ( * input ) { case 'b' : { ut64 baddr = r_config_get_i ( core -> config , \"bin.baddr\" ) ; if (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> case 'l' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <vul-start> 0 ) ; } <vul-start> case 'i' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <vul-start> 0 ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> case 'l' : { if ( obj ) { <vul-start> ; break ; } <vul-start> } } } }\n"
 },
 {
  "id": 258,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int read_inter_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <vul-start> int mi_row , int mi_col , vp9_reader * r ) { <vul-end> struct segmentation * const seg = & cm -> seg ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-start> const BLOCK_SIZE bsize = mbmi -> sb_type ; <vul-end> int predicted_segment_id , segment_id ; if ( ! seg -> enabled ) return 0 ; <vul-start> predicted_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , <vul-end> bsize , mi_row , mi_col ) ; <vul-start> if ( ! seg -> update_map ) <vul-end> return predicted_segment_id ; <vul-start> if ( seg -> temporal_update ) { <vul-end> <vul-start> const vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; <vul-end> <vul-start> mbmi -> seg_id_predicted = vp9_read ( r , pred_prob ) ; <vul-end> segment_id = mbmi -> seg_id_predicted ? predicted_segment_id : read_segment_id ( r , seg ) ; } else { segment_id = read_segment_id ( r , seg ) ; } <vul-start> set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ; <vul-end> return segment_id ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int mi_col , vpx_reader <vul-end> * r ) <vul-start> -> mbmi ; int predicted_segment_id , segment_id ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) <vul-end> ; if ( <vul-start> ; predicted_segment_id = <vul-end> cm -> last_frame_seg_map <vul-start> cm -> last_frame_seg_map ? dec_get_segment_id ( cm , cm -> last_frame_seg_map , mi_offset , x_mis , y_mis ) : 0 <vul-end> ; if ( <vul-start> -> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <vul-start> return predicted_segment_id ; } <vul-start> ) { const vpx_prob <vul-end> pred_prob = vp9_get_pred_prob_seg_id <vul-start> -> seg_id_predicted = vpx_read <vul-end> ( r , <vul-start> ( cm , mi_offset , x_mis , y_mis <vul-end> , segment_id )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int mi_col, vpx_reader <vul-end> * r ) <vul-start> mbmi ; const BLOCK_SIZE <vul-end> bsize = mbmi <vul-start> ; predicted_segment_id = get_segment_id <vul-end> ( cm, <vul-start> cm -> last_frame_seg_map <vul-end>, mi_row, <vul-start> ; if ( seg -> update_map ) { if ( xd -> seg. enabled && xd -> mi [ 0 ] -> sb_type == BLOCK_8X8 ) { if ( xd -> seg. enabled && xd -> mi [ 1 ] -> sb_type == BLOCK_8X8 ) { const BLOCK_SIZE type = mbmi -> sb_type ; int predicted_segment_id = vp9_get_segment_id ( cm, cm -> last_frame_seg_map, bsize, mi_row, mi_col ) ; } else { predicted_segment_id = vp9_get_segment_id ( cm, cm -> last_frame_seg_map, <vul-end> mi_row, mi_col <vul-start> return predicted_segment_id ; } } <vul-start> ) { const vpx_prob <vul-end> pred_prob = vp9_get_pred_prob_seg_id <vul-start> -> seg_id_predicted = vpx_read <vul-end> ( r, <vul-start> ) ; } if ( mbmi -> seg_id_predicted ) { segment_id = mbmi -> seg_id_predicted ; } else { segment_id = read_segment_id ( r, seg ) ; } set_segment_id <vul-end> ( cm, <vul-start> ( cm, <vul-end> mi_row, mi_col\n"
 },
 {
  "id": 259,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static void audit_log_execve_info ( struct audit_context * context , struct audit_buffer * * ab ) { <vul-start> int i , len ; <vul-end> size_t len_sent = 0 ; <vul-start> const char __user * p ; <vul-end> char * buf ; p = ( const char __user * ) current -> mm -> arg_start ; <vul-start> audit_log_format ( * ab , \"argc=%d\" , context -> execve . argc ) ; <vul-end> <vul-start> buf = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; <vul-end> <vul-start> if ( ! buf ) { <vul-end> audit_panic ( \"out of memory for argv string\" ) ; return ; } <vul-start> for ( i = 0 ; i < context -> execve . argc ; i ++ ) { <vul-end> len = audit_log_single_execve_arg ( context , ab , i , & len_sent , p , buf ) ; if ( len <= 0 ) break ; p += len ; } kfree ( buf ) ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ab ) { long len_max ; long len_rem ; long len_full ; long len_buf ; long len_abuf ; long len_tmp ; bool require_data ; bool encode ; unsigned int iter ; unsigned int arg ; char * buf_head ; char * buf <vul-end> ; const char <vul-start> char __user * <vul-end> p = ( <vul-start> -> arg_start ; char abuf [ 96 ] ; WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ; len_max = MAX_EXECVE_AUDIT_LEN ; buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; if ( ! buf_head ) { audit_panic ( \"out of memory for argv string\" ) ; return ; } buf = buf_head ; <vul-start> argc ) ; len_rem = len_max ; len_buf = 0 ; len_full = 0 ; require_data = true ; encode = false ; iter = 0 ; arg = 0 ; do { if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ; if ( require_data ) { if ( buf != buf_head ) { memmove ( buf_head , buf , len_buf ) ; buf = buf_head ; } len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ; if ( len_tmp == - EFAULT ) { send_sig ( SIGKILL , current , 0 ) ; goto out ; } else if ( len_tmp == ( len_max - len_buf ) ) { require_data = true ; encode = true ; len_full = len_full * 2 ; p += len_tmp ; } else { require_data = false ; if ( ! encode ) encode = audit_string_contains_control ( buf , len_tmp ) ; if ( len_full < len_max ) len_full = ( encode ? len_tmp * 2 : len_tmp ) ; p += len_tmp + 1 ; } len_buf += len_tmp ; buf_head [ len_buf ] = '\\\\0' ; len_abuf = ( encode ? len_buf * 2 : len_buf + 2 ) ; } if ( len_buf > 0 ) { if ( ( sizeof ( abuf ) + 8 ) > len_rem ) { len_rem = len_max ; audit_log_end ( * ab ) ; * ab = audit_log_start ( context , GFP_KERNEL , AUDIT_EXECVE <vul-end> ) ; if <vul-start> if ( ! * ab ) goto out ; } len_tmp = 0 ; if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) { if ( iter == 0 ) { len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , \" a%d_len=%lu\" , arg , len_full ) ; } len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , \" a%d[%d]=\" , arg , iter ++ ) ; } else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , \" a%d=\" , arg ) ; WARN_ON ( len_tmp >= sizeof ( abuf ) ) ; abuf [ sizeof ( abuf ) - 1 ] = '\\\\0' ; audit_log_format ( * ab , \"%s\" , abuf ) ; len_rem -= len_tmp ; len_tmp = len_buf ; if ( encode ) { if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ; audit_log_n_hex ( * ab , buf , len_tmp ) ; len_rem -= len_tmp * 2 ; len_abuf -= len_tmp * 2 ; } else { if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ; audit_log_n_string ( * ab , buf , len_tmp ) ; len_rem -= len_tmp + 2 ; len_abuf -= len_tmp ; } len_buf -= len_tmp ; buf += len_tmp ; } if ( ( len_buf == 0 ) && ! require_data ) { arg ++ ; iter = 0 ; len_full = 0 ; require_data = true ; encode = false ; } } while ( arg <vul-end> < context -> <vul-start> execve . argc ) ; out : kfree ( buf_head <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ab ) { <vul-end> const char __user <vul-start> const char __user buf [ MAX_EXECVE_AUDIT_LEN + 1 ] ; int i <vul-end> ; char * <vul-start> const char __user * p <vul-end> ; p = <vul-start> -> arg_start ; if (! context -> execve. argc ) return ; buf = kzalloc ( <vul-end> context -> execve <vul-start> argc ) ; for ( i = 0 ; i < <vul-end> context -> execve <vul-start> execve. argc ; i ++ ) { if (! access_ok ( VERIFY_READ, buf, i * sizeof ( * buf ) ) ) break ; buf += i ; } <vul-end> if (! <vul-start> if (! buf ) <vul-end> audit_panic ( \"out of memory for argv string\" <vul-start> return ; } <vul-end> }    \n"
 },
 {
  "id": 260,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; <vul-start> if ( shdr -> sh_size < 1 ) { <vul-end> return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning: Cannot allocate memory (Check Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info , 0",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> sh_size < 1 || shdr -> sh_size > SIZE_MAX\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> sh_size < 1 || shdr -> sh_size > SIZE_MAX\n"
 },
 {
  "id": 261,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 jpc_ms_t * jpc_getms ( jas_stream_t * in , jpc_cstate_t * cstate ) { jpc_ms_t * ms ; jpc_mstabent_t * mstabent ; jas_stream_t * tmpstream ; if ( ! ( ms = jpc_ms_create ( 0 ) ) ) { return 0 ; } if ( jpc_getuint16 ( in , & ms -> id ) || ms -> id < JPC_MS_MIN || ms -> id > JPC_MS_MAX ) { jpc_ms_destroy ( ms ) ; return 0 ; } mstabent = jpc_mstab_lookup ( ms -> id ) ; ms -> ops = & mstabent -> ops ; if ( JPC_MS_HASPARMS ( ms -> id ) ) { if ( jpc_getuint16 ( in , & ms -> len ) || ms -> len < 3 ) { jpc_ms_destroy ( ms ) ; return 0 ; } ms -> len -= 2 ; if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { jpc_ms_destroy ( ms ) ; return 0 ; } if ( jas_stream_copy ( tmpstream , in , ms -> len ) || jas_stream_seek ( tmpstream , 0 , SEEK_SET ) < 0 ) { jas_stream_close ( tmpstream ) ; jpc_ms_destroy ( ms ) ; return 0 ; } if ( ( * ms -> ops -> getparms ) ( ms , cstate , tmpstream ) ) { ms -> ops = 0 ; jpc_ms_destroy ( ms ) ; jas_stream_close ( tmpstream ) ; return 0 ; } if ( jas_getdbglevel ( ) > 0 ) { jpc_ms_dump ( ms , stderr ) ; } <vul-start> if ( JAS_CAST ( ulong , jas_stream_tell",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ( JAS_CAST ( jas_ulong <vul-end> , jas_stream_tell (\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> } if ( JAS_CAST ( jas_ulong <vul-end>, jas_stream_tell (\n"
 },
 {
  "id": 262,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int ospf6_decode_v3 ( netdissect_options * ndo , register const struct ospf6hdr * op , register const u_char * dataend ) { register const rtrid_t * ap ; register const struct lsr6 * lsrp ; register const struct lsa6_hdr * lshp ; register const struct lsa6 * lsap ; register int i ; switch ( op -> ospf6_type ) { case OSPF_TYPE_HELLO : { <vul-start> register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; <vul-end> ND_PRINT ( ( ndo , \"\\\\n\\\\tOptions [%s]\" , bittok2str ( ospf6_option_values , \"none\" , EXTRACT_32BITS ( & hellop -> hello_options ) ) ) ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\" , EXTRACT_16BITS ( & hellop -> hello_helloint ) , EXTRACT_16BITS ( & hellop -> hello_deadint ) , ipaddr_string ( ndo , & hellop -> hello_ifid ) , hellop -> hello_priority ) ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr ) != 0 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t Designated Router %s\" , ipaddr_string ( ndo , & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_bdr ) != 0 ) ND_PRINT ( ( ndo , \", Backup Designated Router %s\" , ipaddr_string ( ndo , & hellop -> hello_bdr ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_PRINT (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> OSPF6HDR_LEN ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr )!= 0 ) { ND_PRINT ( ( ndo, \"\\\\n\\\\t Dynamic Dynamic Router %s\", ipaddr_string ( ndo, & hellop -> hello_dr ) ) ) ; }\n"
 },
 {
  "id": 263,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 void free_pipe_info ( struct pipe_inode_info * pipe ) { <vul-start> int i ; <vul-end> for ( i = 0 ; i < pipe -> buffers ; i ++ ) { struct pipe_buffer * buf = pipe -> bufs + i ; if ( buf -> ops ) buf -> ops -> release ( pipe , buf ) ; } if ( pipe -> tmp_page ) __free_page ( pipe -> tmp_page ) ; kfree ( pipe -> bufs ) ; kfree ( pipe ) ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> { int i ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user )\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> pipe ) { unsigned\n"
 },
 {
  "id": 264,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 int main ( int argc , char * * argv ) { int fd = xopen ( \"/dev/null\" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( \"Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]\" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , ' ' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , ' ' ) [ 0 ] = '\\\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( \"CCpp.conf\" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , \"MakeCompatCore\" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , \"SaveBinaryImage\" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , \"VerboseLog\" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> , fsuid , <vul-end> NULL ) ;\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> pid ) ; if ( rootdir == NULL ) { error_msg_and_die ( \"Root directory cannot be empty\" ) ; goto create_user_core ; }\n"
 },
 {
  "id": 265,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 <vul-start> double GetGPMFSampleRate ( size_t handle , uint32_t fourcc , uint32_t flags ) <vul-end> { mp4object * mp4 = ( mp4object * ) handle ; if ( mp4 == NULL ) return 0.0 ; GPMF_stream metadata_stream , * ms = & metadata_stream ; uint32_t teststart = 0 ; uint32_t testend = mp4 -> indexcount ; <vul-start> double rate = 0.0 ; <vul-end> if ( mp4 -> indexcount < 1 ) return 0.0 ; <vul-start> if ( mp4 -> indexcount > 3 ) <vul-end> { teststart ++ ; <vul-start> testend -- ; <vul-end> <vul-start> } <vul-end> <vul-start> uint32_t * payload = GetPayload ( handle , NULL , teststart ) ; <vul-end> <vul-start> uint32_t payloadsize = GetPayloadSize ( handle , teststart ) ; <vul-end> int32_t ret = GPMF_Init ( ms , payload , payloadsize ) ; <vul-start> if ( ret != GPMF_OK ) <vul-end> goto cleanup ; { uint32_t startsamples = 0 ; uint32_t endsamples = 0 ; uint32_t missing_samples = 0 ; while ( ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) <vul-start> { <vul-end> missing_samples = 1 ; teststart ++ ; <vul-start> payload = GetPayload ( handle , payload , teststart ) ; <vul-end> <vul-start> payloadsize = GetPayloadSize ( handle , teststart ) ; <vul-end> <vul-start> ret = GPMF_Init ( ms , payload , payloadsize ) ; <vul-end> } if ( missing_samples ) { teststart ++ ; payload = GetPayload ( handle , payload , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ;",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> , uint32_t flags , double * firstsampletime , double * lastsampletime <vul-start> rate = 0.0 ; uint32_t * payload ; uint32_t payloadsize ; int32_t ret <vul-start> return 0.0 ; payload = GetPayload ( handle , NULL , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; { uint64_t minimumtimestamp = 0 ; uint64_t starttimestamp = 0 ; uint64_t endtimestamp = 0 ; uint32_t startsamples = 0 ; uint32_t endsamples = 0 ; double intercept = 0.0 ; while ( teststart < <vul-end> mp4 -> indexcount <vul-start> mp4 -> indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) <vul-end> ) { teststart <vul-start> teststart ++ ; payload = GetPayload ( handle , payload , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } if ( ret == GPMF_OK && payload ) { uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) startsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) - samples ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) starttimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & find_stream ) ) ; if ( starttimestamp ) { GPMF_stream any_stream ; GPMF_Init ( & any_stream , payload , payloadsize ) ; minimumtimestamp = starttimestamp ; while ( GPMF_OK == GPMF_FindNext ( & any_stream , GPMF_KEY_TIME_STAMP , GPMF_RECURSE_LEVELS ) ) { uint64_t timestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & any_stream ) ) ; if ( timestamp < minimumtimestamp ) minimumtimestamp = timestamp ; } } testend = mp4 -> indexcount ; do { <vul-start> testend -- ; <vul-end> payload = GetPayload <vul-start> ( handle , payload , testend ) ; <vul-end> payloadsize = GetPayloadSize <vul-start> ( handle , testend ) ; <vul-end> ret = GPMF_Init <vul-start> payloadsize ) ; } while ( testend > 0 <vul-end> && GPMF_OK != <vul-start> GPMF_RECURSE_LEVELS ) ) ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) endsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) ; else { uint32_t i ; for ( i = teststart ; i <= testend ; i ++ ) { <vul-end> payload = GetPayload <vul-start> , payload , i <vul-end> ) ; payloadsize <vul-start> ( handle , i ) ; if ( GPMF_OK == <vul-end> GPMF_Init ( ms <vul-start> , payloadsize ) ) if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) endsamples += GPMF_PayloadSampleCount ( ms ) ; } } if ( starttimestamp != 0 <vul-end> ) { uint32_t <vul-start> ) { uint32_t last_samples = GPMF_PayloadSampleCount ( ms ) ; uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples ; double time_stamp_scale = 1000000000.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) endtimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData <vul-end> ( & find_stream <vul-start> ( & find_stream ) ) ; if ( endtimestamp ) { double approxrate = 0.0 ; if ( endsamples > startsamples ) approxrate <vul-end> = ( double <vul-start> indexcount ) ; if ( approxrate == 0.0 ) approxrate <vul-end> = ( double <vul-start> indexcount ) ; while ( time_stamp_scale >= 1 ) { rate = ( double ) ( totaltimestamped_samples ) / ( ( double ) ( endtimestamp - starttimestamp ) / time_stamp_scale ) ; if ( rate * 0.9 < approxrate && approxrate < rate * 1.1 ) break ; time_stamp_scale *= 0.1 ; } if ( time_stamp_scale < 1.0 ) rate = 0.0 ; intercept = ( ( ( double ) minimumtimestamp - ( double ) starttimestamp ) / time_stamp_scale ) * rate ; } } if ( rate == 0.0 ) { if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) ) { if ( endsamples > startsamples ) rate = ( double ) ( endsamples - startsamples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) <vul-end> mp4 -> indexcount <vul-start> mp4 -> indexcount ) ; if ( rate == 0.0 ) rate = ( double ) ( samples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) mp4 -> indexcount ) ; double in , out ; if ( GPMF_OK == GetPayloadTime ( handle , teststart , & in , & out ) ) intercept = ( double ) - in * rate ; } else { uint32_t payloadpos = 0 , payloadcount = 0 ; double slope , top = 0.0 , bot = 0.0 , meanX = 0 , meanY = 0 ; uint32_t * repeatarray = malloc ( mp4 -> indexcount <vul-start> teststart ; payloadpos <= testend ; payloadpos ++ ) { payload = GetPayload ( handle , payload , payloadpos ) ; payloadsize = GetPayloadSize ( handle , payloadpos ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) { GPMF_stream find_stream2 ; GPMF_CopyState ( ms , & find_stream2 ) ; payloadcount ++ <vul-end> ; if ( <vul-start> == GPMF_FindNext ( & find_stream2 <vul-end> , fourcc , <vul-start> , fourcc , <vul-end> GPMF_CURRENT_LEVEL ) ) <vul-start> repeatarray ) { double <vul-end> in , out <vul-start> ) samples ; if ( GPMF_OK == <vul-start> & out ) ) <vul-end> meanX += out <vul-start> uint32_t repeat = GPMF_PayloadSampleCount <vul-end> ( ms ) <vul-start> repeatarray ) { double <vul-end> in , out <vul-start> ) samples ; if ( GPMF_OK == <vul-start> & out ) ) <vul-end> meanX += out <vul-start> } } } else { <vul-end> repeatarray [ payloadpos <vul-start> [ payloadpos ] = 0 ; } } if ( repeatarray ) { meanY /= ( double ) payloadcount ; meanX /= ( double ) payloadcount ; for ( payloadpos = teststart ; payloadpos <= testend ; payloadpos ++ ) { double in , out ; if ( repeatarray [ payloadpos ] && GPMF_OK == GetPayloadTime ( handle , payloadpos , & in , & out ) ) { top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] <vul-start> meanX ) ; } <vul-start> / bot ; rate = slope ; intercept = meanY - slope * meanX ; <vul-start> # if 0 printf ( \"%c%c%c%c start offset = %f (%.3fms) rate = %f\\\\n\" <vul-end> , PRINTF_4CC ( <vul-start> intercept / slope , rate ) ; printf ( \"%c%c%c%c first sample at time %.3fms\\\\n\" , PRINTF_4CC ( fourcc ) , - 1000.0 * intercept / slope ) ; # endif <vul-end> } else { <vul-start> repeatarray ) ; } } if ( firstsampletime && lastsampletime ) { uint32_t endpayload = mp4 -> indexcount ; do { endpayload -- ; payload = GetPayload ( handle , payload , endpayload ) ; payloadsize = GetPayloadSize ( handle , endpayload ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } while ( endpayload > 0 && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) ; if ( endpayload > 0 && ret == GPMF_OK ) { uint32_t totalsamples = endsamples - startsamples ; float timo = 0.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_OFFSET , GPMF_CURRENT_LEVEL ) ) GPMF_FormattedData ( & find_stream , & timo , 4 , 0 , 1 ) ; double first , last ; first = - intercept / rate - timo ; last = first + ( double ) totalsamples / rate ; if ( firstsampletime ) * firstsampletime = first ; if ( lastsampletime ) * lastsampletime = last ; } <vul-end> } } } <vul-start> ( payload ) <vul-end> FreePayload ( payload <vul-start> = NULL ; <vul-end> return rate ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>, uint32_t fourcc <vul-end> ) { mp4object <vul-start> -> indexcount ; int32_t rate = 0.0 ; uint32_t * payload = NULL ; uint32_t payloadsize = 0 ; <vul-start> > 3 ) <vul-end> teststart ++ ; <vul-start> testend -- ; <vul-end> payload = GetPayload <vul-start> teststart ) ; <vul-end> payloadsize = GetPayloadSize <vul-start> indexsize ) ; if ( payloadsize < ( testend - teststart ) ) { if ( ret!= GPMF_OK ) goto cleanup ; <vul-start> teststart ++ ; payloadsize = GetPayloadSize ( handle, teststart ) ; <vul-start> ) samples ; } if ( payloadsize < ( testend - teststart + 1 ) ) { rate = 0.0 ; break ; } <vul-start> ) samples ; payloadsize = GetPayloadSize ( handle, teststart ) ; <vul-start> indexcount ) ; if ( payloadsize < ( testend - teststart + 1 ) ) { rate = 0.0 ; break ; } <vul-start> } } } if ( repeatarray ) { meanY /= ( double ) payloadcount ; meanX /= ( double ) payloadcount ; for ( payloadpos = teststart ; payloadpos < testend ; payloadpos ++ ) { <vul-start> ) ; top += ( ( double ) out - teststart ) * ( ( double ) repeatarray [ payloadpos ] - testY ) ; bot += ( ( double ) out - teststart ) ; } slope = top / bot ; # if 0 <vul-end> if ( ret <vul-start> if ( ret == GPMF_OK ) { <vul-end> goto cleanup ; <vul-start> goto cleanup ; } # endif <vul-start> indexcount ) ; if ( rate < 0.0 ) rate = 0.0 ; <vul-start> repeatarray ) ; <vul-end> free ( repeatarray <vul-start> repeatarray ) ; <vul-end> } }  \n"
 },
 {
  "id": 266,
  "question": "CWE-129 Code Input Vulnerable Code Is: CWE-129 int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { <vul-start> if ( * ( unsigned char * ) data > 1 ) <vul-end> return - ENOTSUPP ; return 1 ; }",
  "golden_answers": [
   "CWE-129 Fixed Code Lines are: <vul-start> { if ( datalen != 1 ) return - EINVAL ; if (\n"
  ],
  "generated_answer": "CWE-129 Fixed Code Lines are: <vul-start> { if ( datalen!= 1 &&\n"
 },
 {
  "id": 267,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void snd_timer_user_ccallback ( struct snd_timer_instance * timeri , int event , struct timespec * tstamp , unsigned long resolution ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread r1 ; unsigned long flags ; if ( event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE ) tu -> tstamp = * tstamp ; if ( ( tu -> filter & ( 1 << event ) ) == 0 || ! tu -> tread ) return ; <vul-start> r1 . event = event ; <vul-end> r1 . tstamp = * tstamp ; r1 . val = resolution ; spin_lock_irqsave ( & tu -> qlock , flags ) ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; spin_unlock_irqrestore ( & tu -> qlock , flags ) ; kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; wake_up ( & tu -> qchange_sleep ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ) return ; memset ( & r1 , 0 , sizeof ( r1 ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) return ; memset ( & r1, 0, sizeof ( r1 ) ) ;\n"
 },
 {
  "id": 268,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || <vul-start> ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit ) { <vul-end> duprintf ( \"Bad offset %p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking: element %p size %u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows must be unconditional and \" \"use the STANDARD target with \" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n"
 },
 {
  "id": 269,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static void * zend_mm_realloc_heap ( zend_mm_heap * heap , void * ptr , size_t size , size_t copy_size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC ) { size_t page_offset ; size_t old_size ; size_t new_size ; void * ret ; # if ZEND_DEBUG size_t real_size ; zend_mm_debug_info * dbg ; # endif page_offset = ZEND_MM_ALIGNED_OFFSET ( ptr , ZEND_MM_CHUNK_SIZE ) ; if ( UNEXPECTED ( page_offset == 0 ) ) { if ( UNEXPECTED ( ptr == NULL ) ) { return zend_mm_alloc_heap ( heap , size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; } old_size = zend_mm_get_huge_block_size ( heap , ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # if ZEND_DEBUG real_size = size ; size = ZEND_MM_ALIGNED_SIZE ( size ) + ZEND_MM_ALIGNED_SIZE ( sizeof ( zend_mm_debug_info ) ) ; # endif if ( size > ZEND_MM_MAX_LARGE_SIZE ) { # if ZEND_DEBUG size = real_size ; # endif # ifdef ZEND_WIN32 new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , MAX ( REAL_PAGE_SIZE , ZEND_MM_CHUNK_SIZE ) ) ; # else new_size = ZEND_MM_ALIGNED_SIZE_EX ( size , REAL_PAGE_SIZE ) ; # endif if ( new_size == old_size ) { # if ZEND_DEBUG zend_mm_change_huge_block_size ( heap , ptr , new_size , real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # else zend_mm_change_huge_block_size ( heap , ptr , new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC ) ; # endif return ptr ; } else if ( new_size < old_size ) { if ( zend_mm_chunk_truncate ( heap , ptr , old_size , new_size ) ) { # if ZEND_MM_STAT || ZEND_MM_LIMIT heap -> real_size -= old_size - new_size ; # endif # if ZEND_MM_STAT heap -> size -= old_size - new_size ; # endif # if ZEND_DEBUG zend_mm_change_huge_block_size (",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> { int old_bin_num <vul-end> = ZEND_MM_SRUN_BIN_NUM ( <vul-start> old_bin_num ] ; if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <vul-start> return ptr ; }\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> { int old_bin_num ; size_t <vul-end> bin_num ; old_bin_num <vul-start> old_bin_num ] ; if ( UNEXPECTED ( old_bin_num >= size ) ) { break ; } <vul-start> ; # endif ZEND_MM_CHECK ( ZEND_MM_ALIGNED_OFFSET ( page_offset, ZEND_MM_PAGE_SIZE ) == 0, \"zend_mm_heap corrupted\" ) ; <vul-start> ; # endif ZEND_MM_CHECK ( ZEND_MM_ALIGNED_OFFSET ( page_offset, ZEND_MM_PAGE_SIZE ) == 0, \"zend_mm_heap corrupted\" ) ;\n"
 },
 {
  "id": 270,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void jpc_qmfb_split_col ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE ] ; jpc_fix_t * buf = splitbuf ; register jpc_fix_t * srcptr ; register jpc_fix_t * dstptr ; register int n ; register int m ; <vul-start> int hstartcol ; <vul-end> if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) { <vul-start> hstartcol = ( numrows + 1 - parity ) >> 1 ; <vul-end> <vul-start> m = numrows - hstartcol ; <vul-end> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { * dstptr = * srcptr ; ++ dstptr ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; srcptr += stride << 1 ; } <vul-start> dstptr = & a [ hstartcol * stride ] ; <vul-end> srcptr = buf ; n = m ; while ( n -- > 0 ) { * dstptr = * srcptr",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> m ; int hstartrow <vul-end> ; if ( <vul-start> 2 ) { hstartrow <vul-end> = ( numrows <vul-start> = numrows - hstartrow <vul-end> ; n = <vul-start> & a [ hstartrow <vul-end> * stride ]\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; int hstartcol ; int minstride = JAS_CEILDIVPOW2 ( numrows, 2 ) <vul-start> 2 ) { minstride = JAS_CEILDIVPOW2 ( numrows, 2 ) ; if ( minstride > bufsize - hstartcol ) { if (! ( buf = jas_alloc2 ( bufsize, sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } <vul-start> = numrows - minstride <vul-end> ; n = <vul-start> & a [ minstride <vul-end> * stride ]\n"
 },
 {
  "id": 271,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int em_ret_far ( struct x86_emulate_ctxt * ctxt ) { int rc ; <vul-start> unsigned long cs ; <vul-end> int cpl = ctxt -> ops -> cpl ( ctxt ) ; <vul-start> rc = emulate_pop ( ctxt , & ctxt -> _eip , ctxt -> op_bytes ) ; <vul-end> if ( rc != X86EMUL_CONTINUE ) <vul-start> return rc ; <vul-end> if ( ctxt -> op_bytes == 4 ) ctxt -> _eip = ( u32 ) ctxt -> _eip ; rc = emulate_pop ( ctxt , & cs , ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; if ( ctxt -> mode >= X86EMUL_MODE_PROT16 && ( cs & 3 ) > cpl ) return X86EMUL_UNHANDLEABLE ; <vul-start> rc = load_segment_descriptor ( ctxt , ( u16 ) cs , VCPU_SREG_CS ) ; <vul-end> return rc ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ; unsigned long eip , cs ; u16 old_cs <vul-end> ; int cpl <vul-start> ctxt ) ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; <vul-start> ctxt , & eip <vul-end> , ctxt -> <vul-start> ) return rc <vul-end> ; rc = <vul-start> ; rc = __load_segment_descriptor <vul-end> ( ctxt , <vul-start> cs , VCPU_SREG_CS , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <vul-end> return rc ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> unsigned long cs ; unsigned long eip <vul-start> ctxt ) ; if (! ( ctxt -> op_bytes & X86EMUL_CONTINUE ) ) return X86EMUL_UNHANDLEABLE ; <vul-start> ) return rc <vul-end> ; rc = <vul-start> return X86EMUL_UNHANDLEABLE ; eip = ( u32 ) ctxt -> _eip ; rc = assign_eip_near ( ctxt, eip ) ; if ( rc!= X86EMUL_CONTINUE ) return rc ;\n"
 },
 {
  "id": 272,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void uwbd_start ( struct uwb_rc * rc ) { <vul-start> rc -> uwbd . task = kthread_run ( uwbd , rc , \"uwbd\" ) ; <vul-end> <vul-start> if ( rc -> uwbd . task == NULL ) <vul-end> printk ( KERN_ERR \"UWB: Cannot start management daemon; \" \"UWB won\\'t work\\\\n\" ) ; <vul-start> else <vul-end> rc -> uwbd . pid = rc -> uwbd . task -> pid ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> rc ) { struct task_struct * <vul-end> task = kthread_run <vul-start> ; if ( IS_ERR ( task ) ) { <vul-start> uwbd . task = NULL ; <vul-end> printk ( KERN_ERR <vul-start> \"UWB won\\'t work\\\\n\" ) ; } else { rc -> uwbd . task = task ; <vul-end> rc -> uwbd <vul-start> pid ; } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> rc ) { struct uwbd_task * task = NULL ; <vul-start> \"uwbd\" ) ; spin_lock_irq ( & rc -> uwbd. task_lock ) ; <vul-start> \"UWB: Cannot start management daemon; \" \"UWB won\\'t work\\\\n\" ) ; } else { <vul-end> task = rc <vul-start> -> pid ; uwbd_start_io ( rc ) ; } spin_unlock_irq ( & rc -> uwbd. task_lock ) ;\n"
 },
 {
  "id": 273,
  "question": "CWE-674 Code Input Vulnerable Code Is: CWE-674 static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , RE_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = \"Deleting\" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 6 : <vul-start> # line 96 \"re_grammar.y\" <vul-end> { yr_free ( ( ( * yyvaluep ) . class_vector ) ) ; } <vul-start> # line 1045 \"re_grammar.c\" <vul-end> break ; case 26 : <vul-start> # line 97 \"re_grammar.y\" <vul-end> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1051 \"re_grammar.c\" break ; case 27 : <vul-start> # line 98 \"re_grammar.y\" <vul-end> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1057 \"re_grammar.c\" break ; case 28 : <vul-start> # line 99 \"re_grammar.y\" <vul-end> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1063 \"re_grammar.c\" break ; case 29 : <vul-start> # line 100 \"re_grammar.y\" <vul-end> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1069 \"re_grammar.c\" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }",
  "golden_answers": [
   "CWE-674 Fixed Code Lines are: <vul-start> : # line 104 <vul-end> \"re_grammar.y\" { yr_free <vul-start> } # line 1053 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 105 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 106 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1065 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 107 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1071 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 108 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1077 <vul-end> \"re_grammar.c\" break ;\n"
  ],
  "generated_answer": "CWE-674 Fixed Code Lines are: <vul-start> : # line 101 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1060 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 102 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1060 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 103 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1060 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 104 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1060 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 107 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1060 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 106 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1060 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 105 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1060 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 105 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1060 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 105 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep ). re_node ) ) ; } # line 1060 <vul-end> \"re_grammar.c\" break ; <vul-start> : # line 105 \"re_grammar.y\" { yr_re_node_destroy ( ( ( * yyvaluep )"
 },
 {
  "id": 274,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int pptp_bind ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; int error = 0 ; <vul-start> lock_sock ( sk ) ; <vul-end> opt -> src_addr = sp -> sa_addr . pptp ; if ( add_chan ( po ) ) error = - EBUSY ; release_sock ( sk ) ; return error ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> = 0 ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> = 0 ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;\n"
 },
 {
  "id": 275,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * setv4key_principal_2_svc ( setv4key_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , <vul-end> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_SETKEY , arg -> princ , NULL ) ) { ret . code = kadm5_setv4key_principal ( ( void * ) handle , arg -> princ , arg -> keyblock ) ; } else { log_unauth ( \"kadm5_setv4key_principal\" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_SETKEY ; } if ( ret . code != KADM5_AUTH_SETKEY ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( \"kadm5_setv4key_principal\" ,",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
 },
 {
  "id": 276,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int psf_close ( SF_PRIVATE * psf ) { uint32_t k ; int error = 0 ; if ( psf -> codec_close ) { error = psf -> codec_close ( psf ) ; psf -> codec_close = NULL ; } ; if ( psf -> container_close ) error = psf -> container_close ( psf ) ; error = psf_fclose ( psf ) ; <vul-start> psf_close_rsrc ( psf ) ; <vul-end> free ( psf -> container_data ) ; free ( psf -> codec_data ) ; free ( psf -> interleave ) ; free ( psf -> dither ) ; free ( psf -> peak_info ) ; free ( psf -> broadcast_16k ) ; free ( psf -> loop_info ) ; free ( psf -> instrument ) ; free ( psf -> cues ) ; free ( psf -> channel_map ) ; free ( psf -> format_desc ) ; free ( psf -> strings . storage ) ; if ( psf -> wchunks . chunks ) for ( k = 0 ; k < psf -> wchunks . used ; k ++ ) free ( psf -> wchunks . chunks [ k ] . data ) ; free ( psf -> rchunks . chunks ) ; free ( psf -> wchunks . chunks ) ; free ( psf -> iterator ) ; free ( psf -> cart_16k ) ; memset ( psf , 0 , sizeof ( SF_PRIVATE ) ) ; free ( psf ) ; return error ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> psf_close_rsrc ( psf ) ; free ( psf -> header . ptr\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> psf ) ; if ( psf -> rsrc_chunk_free ) psf_rsrc_chunk_free ( psf ) ;\n"
 },
 {
  "id": 277,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int http_connect ( http_subtransport * t ) { int error ; char * proxy_url ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , \"git_stream\" ) ; if ( git_stream_supports_proxy ( t -> io ) && ! git_remote__get_http_proxy ( t -> owner -> owner , ! ! t -> connection_data . use_ssl , & proxy_url ) ) { error = git_stream_set_proxy ( t -> io , proxy_url ) ; git__free ( proxy_url ) ; if ( error < 0 ) return error ; } error = git_stream_connect ( t -> io ) ; # if defined ( GIT_OPENSSL ) || defined ( GIT_SECURE_TRANSPORT ) || defined ( GIT_CURL ) if ( ( ! error ||",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ; int is_valid = ( error == GIT_OK ) <vul-start> giterr_clear ( ) <vul-end> ; error =\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> * cert ; <vul-end> if ( ( <vul-start> giterr_clear ( ) <vul-end> ; error =\n"
 },
 {
  "id": 278,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 struct _mdi * _WM_ParseNewHmp ( uint8_t * hmp_data , uint32_t hmp_size ) { uint8_t is_hmp2 = 0 ; uint32_t zero_cnt = 0 ; uint32_t i = 0 ; uint32_t hmp_file_length = 0 ; uint32_t hmp_chunks = 0 ; uint32_t hmp_divisions = 0 ; uint32_t hmp_unknown = 0 ; uint32_t hmp_bpm = 0 ; uint32_t hmp_song_time = 0 ; struct _mdi * hmp_mdi ; uint8_t * * hmp_chunk ; uint32_t * chunk_length ; uint32_t * chunk_ofs ; uint32_t * chunk_delta ; uint8_t * chunk_end ; uint32_t chunk_num = 0 ; uint32_t hmp_track = 0 ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t end_of_chunks = 0 ; uint32_t var_len_shift = 0 ; float tempo_f = 500000.0 ; float samples_per_delta_f = 0.0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; if ( memcmp ( hmp_data , \"HMIMIDIP\" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , NULL , 0 ) ; return NULL ; } hmp_data += 8 ; hmp_size -= 8 ; if ( ! memcmp ( hmp_data , \"013195\" , 6 ) ) { hmp_data += 6 ; hmp_size -= 6 ; is_hmp2 = 1 ; } if ( is_hmp2 ) { zero_cnt = 18 ; } else { zero_cnt = 24 ; } for ( i = 0 ; i < zero_cnt ; i ++ ) { if ( hmp_data [ i ] != 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , NULL , 0 ) ; return NULL ; } } hmp_data += zero_cnt ;",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ] + chunk_length [ i ] ; chunk_length [ i ] -= chunk_ofs <vul-start> += 3 ; chunk_length [ i ] -= 3 ; <vul-start> hmp_mdi , hmp_chunk [ i ] , chunk_length <vul-start> ] = 1 ; chunk_length [ i ] -= 3 <vul-start> += setup_ret ; chunk_length [ i ] -= setup_ret ; <vul-start> ; if ( chunk_length [ i ] && <vul-start> { do { if ( ! chunk_length [ i ] ) break ; <vul-start> ] ++ ; chunk_length [ i ] -- ; <vul-start> ) ; } if ( ! chunk_length [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , \"file too short\" , 0 ) ; goto _hmp_end ; } <vul-start> i ] ++ ; chunk_length [ i ] --\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ] ; } hmp_chunk [ i ] += chunk_length [ i ] ; hmp_chunk [ i ] -= chunk_length [ i ] ; <vul-start> ] ; } hmp_chunk [ i ] += chunk_length [ i ] ;\n"
 },
 {
  "id": 279,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static fp_info * fp_set_per_packet_inf_from_conv ( umts_fp_conversation_info_t * p_conv_data , tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree _U_ ) { fp_info * fpi ; guint8 tfi , c_t ; int offset = 0 , i = 0 , j = 0 , num_tbs , chan , tb_size , tb_bit_off ; gboolean is_control_frame ; umts_mac_info * macinf ; rlc_info * rlcinf ; guint8 fake_lchid = 0 ; gint * cur_val = NULL ; fpi = wmem_new0 ( wmem_file_scope ( ) , fp_info ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 , fpi ) ; fpi -> iface_type = p_conv_data -> iface_type ; fpi -> division = p_conv_data -> division ; fpi -> release = 7 ; fpi -> release_year = 2006 ; fpi -> release_month = 12 ; fpi -> channel = p_conv_data -> channel ; fpi -> dch_crc_present = p_conv_data -> dch_crc_present ; fpi -> link_type = FP_Link_Ethernet ; # if 0 if ( ! pinfo -> fd -> flags . visited && p_conv_data -> reset_frag ) { fpi -> reset_frag = p_conv_data -> reset_frag ; p_conv_data -> reset_frag = FALSE ; } # endif fpi -> srcport = pinfo -> srcport ; fpi -> destport = pinfo -> destport ; fpi -> com_context_id = p_conv_data -> com_context_id ; if ( pinfo -> link_dir == P2P_DIR_UL ) { fpi -> is_uplink = TRUE ; } else { fpi -> is_uplink = FALSE ; } is_control_frame = tvb_get_guint8 ( tvb , offset ) & 0x01 ; switch ( fpi -> channel ) { case CHANNEL_HSDSCH : fpi ->",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; c_t = ( <vul-start> , 4 ) + 1 ) % 0xf <vul-start> ] = c_t <vul-end> ; macinf -> <vul-start> lchId_type_table [ c_t <vul-end> ] ; rlcinf <vul-start> lchId_rlc_map [ c_t <vul-end> ] ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = TRUE ; if ( j + chan >= MAX_MAC_FRAMES ) { wmem_set_error_string ( pinfo, \"invalid frame size\" ) ; return NULL ; } <vul-start> 1 ] ; if ( j + chan >= MAX_MAC_FRAMES ) { wmem_set_error_string ( pinfo, \"invalid frame size\" ) ; return NULL ; }\n"
 },
 {
  "id": 280,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ECDSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int sig_len , EC_KEY * eckey ) { ECDSA_SIG * s ; <vul-start> int ret = - 1 ; <vul-end> s = ECDSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ; <vul-start> if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ; <vul-end> ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ; err : <vul-start> ECDSA_SIG_free ( s ) ; <vul-end> return ( ret ) ; }",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <vul-start> s , & p <vul-end> , sig_len ) <vul-start> == NULL ) goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <vul-start> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int der_len = - 1 ; <vul-start> s, & p <vul-end>, sig_len ) <vul-start> == NULL ) goto err ; der_len = i2d_ECDSA_SIG ( s, & der ) ; if ( der_len!= sig_len || memcmp ( sigbuf, der, der_len ) ) <vul-start> ; err : if ( der_len > 0 ) { OPENSSL_cleanse ( der, der_len ) ; OPENSSL_free ( der ) ; }\n"
 },
 {
  "id": 281,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 static void sctp_v6_get_dst ( struct sctp_transport * t , union sctp_addr * saddr , struct flowi * fl , struct sock * sk ) { struct sctp_association * asoc = t -> asoc ; struct dst_entry * dst = NULL ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sctp_bind_addr * bp ; <vul-start> struct sctp_sockaddr_entry * laddr ; <vul-end> union sctp_addr * baddr = NULL ; union sctp_addr * daddr = & t -> ipaddr ; union sctp_addr dst_saddr ; <vul-start> __u8 matchlen = 0 ; <vul-end> __u8 bmatchlen ; sctp_scope_t scope ; memset ( fl6 , 0 , sizeof ( struct flowi6 ) ) ; fl6 -> daddr = daddr -> v6 . sin6_addr ; fl6 -> fl6_dport = daddr -> v6 . sin6_port ; fl6 -> flowi6_proto = IPPROTO_SCTP ; if ( ipv6_addr_type ( & daddr -> v6 . sin6_addr ) & IPV6_ADDR_LINKLOCAL ) fl6 -> flowi6_oif = daddr -> v6 . sin6_scope_id ; pr_debug ( \"%s: dst=%pI6 \" , __func__ , & fl6 -> daddr ) ; if ( asoc ) fl6 -> fl6_sport = htons ( asoc -> base . bind_addr . port ) ; if ( saddr ) { fl6 -> saddr = saddr -> v6 . sin6_addr ; fl6 -> fl6_sport = saddr -> v6 . sin6_port ; pr_debug ( \"src=%pI6 - \" , & fl6 -> saddr ) ; } <vul-start> dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; <vul-end> if ( ! asoc || saddr ) goto out ; bp = & asoc -> base .",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> bp ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct <vul-start> sctp_addr dst_saddr ; struct in6_addr * final_p , final ; <vul-start> ) ; } final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <vul-start> , fl6 , final_p <vul-end> , false ) <vul-start> . sin6_port ; final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <vul-start> , fl6 , final_p <vul-end> , false )\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> bp ; struct ip6_dst_entry * laddr, * dst_entry <vul-end> ; __u8 matchlen <vul-start> sctp_addr dst_saddr ; bool use_dst ; <vul-start> ) ; } dst_entry = sctp_dst_lookup_flow ( sk, fl6, NULL, false ) ; if (! dst_entry ) { if ( use_dst ) dst = sctp_dst_lookup_flow ( sk, fl6, NULL, false ) ; else dst = NULL ; } <vul-start>. sin6_port ; if (! dst_entry ) { sctp_dst_release ( dst ) ; dst = NULL ; goto out ; } <vul-start>, fl6, use_dst <vul-end>, false )\n"
 },
 {
  "id": 282,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 extern int onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , OnigCompileInfo * ci , OnigErrorInfo * einfo ) { int r ; UChar * cpat , * cpat_end ; if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; if ( ci -> pattern_enc != ci -> target_enc ) { <vul-start> r = conv_encoding ( ci -> pattern_enc , ci -> target_enc , pattern , pattern_end , <vul-end> & cpat , & cpat_end ) ; if ( r != 0 ) return r ; } else { cpat = ( UChar * ) pattern ; cpat_end = ( UChar * ) pattern_end ; } * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; if ( IS_NULL ( * reg ) ) { r = ONIGERR_MEMORY ; goto err2 ; } r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , ci -> syntax ) ; if ( r != 0 ) goto err ; r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; if ( r != 0 ) { err : onig_free ( * reg ) ; * reg = NULL ; } err2 : if ( cpat != pattern ) xfree ( cpat ) ; return r ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <vul-end> ; } else\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> { r = onig_conv_encoding <vul-end> ( ci ->\n"
 },
 {
  "id": 283,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static char * get_header ( FILE * fp ) { <vul-start> long start ; <vul-end> <vul-start> char * header ; <vul-end> header = calloc ( 1 , 1024 ) ; <vul-start> start = ftell ( fp ) ; <vul-end> fseek ( fp , 0 , SEEK_SET ) ; SAFE_E ( fread ( header , 1 , 1023 , fp ) , 1023 , \"Failed to load PDF header.\\\\n\" ) ; fseek ( fp , start , SEEK_SET ) ; return header ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> fp ) { <vul-end> char * header <vul-start> char * header = safe_calloc ( <vul-end> 1024 ) ; <vul-start> 1024 ) ; long\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> fp ) { size_t <vul-end> start ; char <vul-start> char * header ; if (! fp ) return NULL <vul-start> 1024 ) ; if (! header ) return NULL ;\n"
 },
 {
  "id": 284,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , \"\\\\122\\\\314\" , 2",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> rows * MagickMax ( number_planes_filled , 4 ) <vul-end> * sizeof ( <vul-start> -> rows * MagickMax ( number_planes_filled , 4 ) <vul-end> ; pixels =\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> \"MemoryAllocationFailed\" ) ; if ( pixel_info_length > ( size_t ) GetVirtualMemorySize ( pixel_info ) ) ThrowReaderException ( ResourceLimitError, \"MemoryAllocationFailed\" ) ; <vul-start> \"MemoryAllocationFailed\" ) ; if ( pixel_info_length > ( size_t ) GetVirtualMemorySize ( pixel_info ) ) ThrowReaderException ( ResourceLimitError, \"MemoryAllocationFailed\" ) ;\n"
 },
 {
  "id": 285,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * ikev1_id_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep _U_ , uint32_t phase , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { # define USE_IPSECDOI_IN_PHASE1 1 const struct ikev1_pl_id * p ; struct ikev1_pl_id id ; static const char * idtypestr [ ] = { \"IPv4\" , \"IPv4net\" , \"IPv6\" , \"IPv6net\" , } ; static const char * ipsecidtypestr [ ] = { NULL , \"IPv4\" , \"FQDN\" , \"user FQDN\" , \"IPv4net\" , \"IPv6\" , \"IPv6net\" , \"IPv4range\" , \"IPv6range\" , \"ASN1 DN\" , \"ASN1 GN\" , \"keyid\" , } ; int len ; const u_char * data ; ND_PRINT ( ( ndo , \"%s:\" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; p = ( const struct ikev1_pl_id * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; if ( sizeof ( * p ) < item_len ) { data = ( const u_char * ) ( p + 1 ) ; len = item_len - sizeof ( * p ) ; } else { data = NULL ; len = 0 ; } # if 0 ND_PRINT ( ( ndo , \" [phase=%d doi=%d proto=%d]\" , phase , doi , proto ) ) ; # endif switch ( phase ) { # ifndef USE_IPSECDOI_IN_PHASE1 case 1 : # endif default : ND_PRINT ( ( ndo , \" idtype=%s\" , STR_OR_ID ( id . d .",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( len < 32 ) ND_PRINT ( ( ndo , \" len=%d [bad: < 32]\" <vul-end> , len )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( len < sizeof ( struct ikev1_pl_id ) ) ND_PRINT ( ( ndo, \" len=%d [bad: < %u]\", len, ( unsigned int ) <vul-end> data [ len <vul-start> [ len ] <vul-end> ) ) ;\n"
 },
 {
  "id": 286,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 CURLcode Curl_close ( struct Curl_easy * data ) { struct Curl_multi * m ; if ( ! data ) return CURLE_OK ; Curl_expire_clear ( data ) ; m = data -> multi ; if ( m ) curl_multi_remove_handle ( data -> multi , data ) ; <vul-start> if ( data -> multi_easy ) <vul-end> <vul-start> curl_multi_cleanup ( data -> multi_easy ) ; <vul-end> Curl_llist_destroy ( & data -> state . timeoutlist , NULL ) ; data -> magic = 0 ; if ( data -> state . rangestringalloc ) free ( data -> state . range ) ; Curl_free_request_state ( data ) ; Curl_ssl_close_all ( data ) ; Curl_safefree ( data -> state . first_host ) ; Curl_safefree ( data -> state . scratch ) ; Curl_ssl_free_certinfo ( data ) ; free ( data -> req . newurl ) ; data -> req . newurl = NULL ; if ( data -> change . referer_alloc ) { Curl_safefree ( data -> change . referer ) ; data -> change . referer_alloc = FALSE ; } data -> change . referer = NULL ; Curl_up_free ( data ) ; Curl_safefree ( data -> state . buffer ) ; Curl_safefree ( data -> state . headerbuff ) ; Curl_safefree ( data -> state . ulbuf ) ; Curl_flush_cookies ( data , 1 ) ; Curl_digest_cleanup ( data ) ; Curl_safefree ( data -> info . contenttype ) ; Curl_safefree ( data -> info . wouldredirect ) ; Curl_resolver_cleanup ( data -> state . resolver ) ; Curl_http2_cleanup_dependencies ( data ) ; Curl_convert_close ( data ) ; if",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> -> multi_easy ) { <vul-start> multi_easy ) ; data -> multi_easy = NULL ; }\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> -> multi_easy ) { if ( data -> multi_easy -> count > 0 ) curl_easy_cleanup ( data -> multi_easy ) ; else <vul-start> multi_easy ) ; }\n"
 },
 {
  "id": 287,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int search_old_relocation ( struct reloc_struct_t * reloc_table , ut32 addr_to_patch , int n_reloc ) { int i ; for ( i = 0 ; i < n_reloc ; i ++ ) { if ( addr_to_patch == reloc_table [ i ] . data_offset ) { return i ; } } return - 1 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: \n"
 },
 {
  "id": 288,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int inet6_csk_xmit ( struct sock * sk , struct sk_buff * skb , struct flowi * fl_unused ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 fl6 ; struct dst_entry * dst ; int res ; dst = inet6_csk_route_socket ( sk , & fl6 ) ; if ( IS_ERR ( dst ) ) { sk -> sk_err_soft = - PTR_ERR ( dst ) ; sk -> sk_route_caps = 0 ; kfree_skb ( skb ) ; return PTR_ERR ( dst ) ; } rcu_read_lock ( ) ; skb_dst_set_noref ( skb , dst ) ; fl6 . daddr = sk -> sk_v6_daddr ; <vul-start> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <vul-end> rcu_read_unlock ( ) ; return res ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> & fl6 , rcu_dereference ( <vul-start> np -> opt )\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> & fl6, rcu_dereference ( <vul-start> np -> opt ), <vul-end> np -> tclass\n"
 },
 {
  "id": 289,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static struct clock_source * dce120_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( * clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <vul-start> BREAK_TO_DEBUGGER ( ) ; <vul-end> return NULL ; }",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> base ; } kfree ( clk_src ) ;\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> base ; } kfree ( clk_src ) ;\n"
 },
 {
  "id": 290,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_build_intra_predictors_mbuv_s_c ( MACROBLOCKD * x , unsigned char * uabove_row , unsigned char * vabove_row , unsigned char * uleft , unsigned char * vleft , int left_stride , unsigned char * upred_ptr , unsigned char * vpred_ptr , int pred_stride ) { unsigned char uleft_col [ 8 ] ; unsigned char utop_left = uabove_row [ - 1 ] ; unsigned char vleft_col [ 8 ] ; unsigned char vtop_left = vabove_row [ - 1 ] ; int i , j ; for ( i = 0 ; i < 8 ; i ++ ) { uleft_col [ i ] = uleft [ i * left_stride ] ; vleft_col [ i ] = vleft [ i * left_stride ] ; } switch ( x -> mode_info_context -> mbmi . uv_mode ) { case DC_PRED : { int expected_udc ; int expected_vdc ; int shift ; int Uaverage = 0 ; int Vaverage = 0 ; if ( x -> up_available ) { for ( i = 0 ; i < 8 ; i ++ ) { Uaverage += uabove_row [ i ] ; Vaverage += vabove_row [ i ] ; } } if ( x -> left_available ) { for ( i = 0 ; i < 8 ; i ++ ) { Uaverage += uleft_col [ i ] ; Vaverage += vleft_col [ i ] ; } } if ( ! x -> up_available && ! x -> left_available ) { expected_udc = 128 ; expected_vdc = 128 ; } else { shift = 2 + x -> up_available + x -> left_available",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memset <vul-end> ( upred_ptr , <vul-start> 8 ) ; memset <vul-end> ( vpred_ptr , <vul-start> ++ ) { memcpy <vul-end> ( upred_ptr , <vul-start> 8 ) ; memcpy <vul-end> ( vpred_ptr , <vul-start> ++ ) { memset <vul-end> ( upred_ptr , <vul-start> 8 ) ; memset <vul-end> ( vpred_ptr ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memcpy <vul-end> ( upred_ptr, <vul-start> 8 ) ; memcpy <vul-end> ( vpred_ptr, <vul-start> ++ ) { memcpy <vul-end> ( upred_ptr, <vul-start> 8 ) ; memcpy <vul-end> ( vpred_ptr, <vul-start> ++ ) { memcpy <vul-end> ( upred_ptr, <vul-start> 8 ) ; memcpy <vul-end> ( vpred_ptr,\n"
 },
 {
  "id": 291,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 BOOL rdp_decrypt ( rdpRdp * rdp , STREAM * s , int length , UINT16 securityFlags ) { BYTE cmac [ 8 ] ; BYTE wmac [ 8 ] ; if ( rdp -> settings -> EncryptionMethods == ENCRYPTION_METHOD_FIPS ) { UINT16 len ; BYTE version , pad ; BYTE * sig ; if ( stream_get_left ( s ) < 12 ) return FALSE ; stream_read_UINT16 ( s , len ) ; stream_read_BYTE ( s , version ) ; stream_read_BYTE ( s , pad ) ; sig = s -> p ; stream_seek ( s , 8 ) ; length -= 12 ; if ( ! security_fips_decrypt ( s -> p , length , rdp ) ) { printf ( \"FATAL: cannot decrypt\\\\n\" ) ; return FALSE ; } if ( ! security_fips_check_signature ( s -> p , length - pad , sig , rdp ) ) { printf ( \"FATAL: invalid packet signature\\\\n\" ) ; return FALSE ; } s -> size -= pad ; return TRUE ; } if ( stream_get_left ( s ) < 8 ) return FALSE ; stream_read ( s , wmac , sizeof ( wmac ) ) ; length -= sizeof ( wmac ) ; <vul-start> security_decrypt ( s -> p , length , rdp ) ; <vul-end> if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ; else security_mac_signature ( rdp , s -> p , length , cmac ) ; if ( memcmp ( wmac , cmac , sizeof ( wmac ) ) != 0 )",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> wmac ) ; if ( ! <vul-start> , rdp ) ) return FALSE\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> wmac ) ; if ( length < sizeof ( cmac ) ) { printf ( \"FATAL: packet signature\\\\n\" ) ; return FALSE ; }\n"
 },
 {
  "id": 292,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int acm_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_country_functional_desc * cfd = NULL ; unsigned char * buffer = intf -> altsetting -> extra ; int buflen = intf -> altsetting -> extralen ; struct usb_interface * control_interface ; struct usb_interface * data_interface ; struct usb_endpoint_descriptor * epctrl = NULL ; struct usb_endpoint_descriptor * epread = NULL ; struct usb_endpoint_descriptor * epwrite = NULL ; struct usb_device * usb_dev = interface_to_usbdev ( intf ) ; struct acm * acm ; int minor ; int ctrlsize , readsize ; u8 * buf ; u8 ac_management_function = 0 ; u8 call_management_function = 0 ; int call_interface_num = - 1 ; int data_interface_num = - 1 ; unsigned long quirks ; int num_rx_buf ; int i ; unsigned int elength = 0 ; int combined_interfaces = 0 ; struct device * tty_dev ; int rv = - ENOMEM ; quirks = ( unsigned long ) id -> driver_info ; if ( quirks == IGNORE_DEVICE ) return - ENODEV ; num_rx_buf = ( quirks == SINGLE_RX_URB ) ? 1 : ACM_NR ; if ( quirks == NO_UNION_NORMAL ) { data_interface = usb_ifnum_to_if ( usb_dev , 1 ) ; <vul-start> control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; <vul-end> goto skip_normal_probe ; } if ( ! buffer ) { dev_err ( & intf -> dev , \"Weird descriptor references\\\\n\" ) ; return - EINVAL ; } if ( ! buflen ) { if ( intf -> cur_altsetting -> endpoint && intf -> cur_altsetting",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> , 0 ) ; if ( ! data_interface || ! control_interface ) return - ENODEV\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> 0 ) ; if ( data_interface < 0 || control_interface < 0 ) { dev_err ( & intf -> dev, \"Invalid data interface\\\\n\" ) ; return - EINVAL ; }\n"
 },
 {
  "id": 293,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( \"section len: %u properties %u\\\\n\" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh .",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( \"CDF_VECTOR with nelements == 0\\\\n\" ) ) ; goto out ; } <vul-start> j < nelements && i < sh . sh_properties ; <vul-end> j ++ ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; o = 1 <vul-end> ; } else <vul-start> ; o = 1 <vul-end> ; } else\n"
 },
 {
  "id": 294,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> static int <vul-end> <vul-start> rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , u_int indent ) <vul-end> { const rpki_rtr_pdu * pdu_header ; u_int pdu_type , pdu_len , hexdump ; const u_char * msg ; <vul-start> pdu_header = ( const rpki_rtr_pdu * ) tptr ; <vul-end> pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; <vul-start> ND_TCHECK2 ( * tptr , pdu_len ) ; <vul-end> hexdump = FALSE ; ND_PRINT ( ( ndo , \"%sRPKI-RTRv%u, %s PDU (%u), length: %u\" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , \"Unknown\" , pdu_type ) , <vul-start> pdu_type , pdu_len ) ) ; <vul-end> switch ( pdu_type ) { case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : <vul-start> case RPKI_RTR_END_OF_DATA_PDU : <vul-end> msg = ( const u_char * ) ( pdu_header + 1 ) ; ND_PRINT ( ( ndo , \"%sSession ID: 0x%04x, Serial: %u\" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) , EXTRACT_32BITS ( msg ) ) ) ; break ; case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : <vul-start> break ; <vul-end> <vul-start> case RPKI_RTR_CACHE_RESPONSE_PDU : <vul-end> ND_PRINT ( ( ndo , \"%sSession ID: 0x%04x\" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ; break ; case RPKI_RTR_IPV4_PREFIX_PDU : { const rpki_rtr_pdu_ipv4_prefix * pdu ; <vul-start> pdu = ( const rpki_rtr_pdu_ipv4_prefix * ) tptr ; <vul-end> ND_PRINT ( ( ndo , \"%sIPv4 Prefix %s/%u-%u, origin-as %u, flags 0x%02x\" , indent_string ( indent + 2 ) ,",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start>     static u_int <vul-end> rpki_rtr_pdu_print ( netdissect_options <vul-start> * tptr , const u_int len , const u_char recurse , const <vul-start> * msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , \"%sRPKI-RTRv%u (unknown)\" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , \"(%u bytes is too few to decode)\" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <vul-start> length ) ; <vul-end> hexdump = FALSE <vul-start> pdu_len ) ) ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <vul-start> case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <vul-start> case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <vul-start> case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <vul-start> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <vul-start> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <vul-start> , error_code ; tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <vul-start> encapsulated_pdu_length ) ; tlen += 4 <vul-end> ; error_code = <vul-start> ) ) ; <vul-end> if ( encapsulated_pdu_length <vul-start> if ( encapsulated_pdu_length ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <vul-end> { ND_PRINT ( <vul-start> ) ) ; <vul-end> rpki_rtr_pdu_print ( ndo <vul-start> ndo , tptr + tlen , encapsulated_pdu_length , 0 <vul-start> + 2 ) ; } tlen <vul-end> += encapsulated_pdu_length ; <vul-start> += encapsulated_pdu_length ; } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <vul-end> ; text_length = <vul-start> ; text_length = <vul-end> EXTRACT_32BITS ( tptr <vul-start> EXTRACT_32BITS ( tptr + tlen ) ; tlen <vul-end> += 4 ; <vul-start> += 4 ; if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , \"%sError text: \" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <vul-end> ND_TCHECK2 ( * <vul-start> * tptr , pdu_len ) ; <vul-end> hexdump = TRUE <vul-start> ; } return pdu_len ; invalid : ND_PRINT ( ( ndo , \"%s\" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <vul-end> ; trunc : <vul-start> ; trunc : ND_PRINT ( ( ndo , \"\\\\n\\\\t%s\" , tstr ) ) ; return len <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> int rpki_rtr_pdu_print ( u_int pdu_len, u_int session_id <vul-end>, u_int indent <vul-start> * tptr, u_int length ) { <vul-end> const rpki_rtr_pdu * <vul-start> * msg ; u_int pdu_len ; <vul-start> length ) ; <vul-end> hexdump = FALSE <vul-start> case RPKI_RTR_SERIAL_QUERY_PDU : msg = ( const u_char * ) ( pdu_header + 1 ) ; ND_TCHECK_32BITS ( pdu_header -> length ) ; <vul-start> case RPKI_RTR_CACHE_RESET_PDU : ND_TCHECK_16BITS ( pdu_header -> u. session_id ) ; <vul-start> case RPKI_RTR_CACHE_RESPONSE_PDU : ND_TCHECK_16BITS ( pdu_header -> u. session_id ) ; <vul-start> += encapsulated_pdu_length ; text_length = pdu_len ; if ( tlen > 0 ) { <vul-start> -= encapsulated_pdu_length ; if ( pdu_len < 4 ) { if (! hexdump ) { ND_PRINT ( ( ndo, \"%sError text: \", indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo, tptr, 4, ndo -> ndo_snapend ) ) goto trunc ; } } else { <vul-start> ) ) ; } <vul-start> ) ; } if ( session_id == 0 ) { ND_TCHECK_16BITS ( pdu_header -> u. session_id ) ; } <vul-start> ) ; } if (! hexdump ) { ND_PRINT ( ( ndo, \"%sError text: \", indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo, tptr, text_length, ndo -> ndo_snapend ) ) goto trunc ; } } <vul-start> ) ; } if ( pdu_len > 0 ) { <vul-start> ; trunc : if (! hexdump ) { ND_PRINT ( ( ndo, \"%sError text: \", indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo, tptr, pdu_"
 },
 {
  "id": 295,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int jpc_pi_nextrpcl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; uint_fast32_t trx0 ; uint_fast32_t try0 ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { <vul-start> xstep = picomp -> hsamp * ( 1 << ( pirlvl -> prcwidthexpn + <vul-end> picomp -> numrlvls - rlvlno - 1 ) ) ; <vul-start> ystep = picomp -> vsamp * ( 1 << ( pirlvl -> prcheightexpn + <vul-end> picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pchg -> rlvlnoend && pi",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <vul-start> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <vul-end> ( pirlvl -> <vul-start> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <vul-end> ( pirlvl -> <vul-start> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << rpx ) <vul-start> x % ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << rpx ) <vul-start> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << rpy ) <vul-start> y % ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << rpy )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <vul-start> hsamp * ( JAS_CAST ( uint_fast32_t, 1 ) <vul-end> << ( pirlvl <vul-start> vsamp * ( JAS_CAST ( uint_fast32_t, 1 ) <vul-end> << ( pirlvl <vul-start> ) % ( JAS_CAST ( uint_fast32_t, 1 ) <vul-end> << rpx ) <vul-start> ||! ( JAS_CAST ( uint_fast32_t, 1 ) <vul-end> << rpy )\n"
 },
 {
  "id": 296,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void l2tp_packet_print ( const struct l2tp_packet_t * pack , void ( * print ) ( const char * fmt , ... ) ) { const struct l2tp_attr_t * attr ; const struct l2tp_dict_value_t * val ; <vul-start> if ( pack -> hdr . ver == 2 ) { <vul-end> print ( \"[L2TP tid=%u sid=%u\" , ntohs ( pack -> hdr . tid ) , ntohs ( pack -> hdr . sid ) ) ; log_ppp_debug ( \" Ns=%u Nr=%u\" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <vul-start> } else { <vul-end> print ( \"[L2TP cid=%u\" , pack -> hdr . cid ) ; <vul-start> log_ppp_debug ( \" Ns=%u Nr=%u\" , ntohs ( pack -> hdr . Ns ) , ntohs ( pack -> hdr . Nr ) ) ; <vul-end> } list_for_each_entry ( attr , & pack -> attrs , entry ) { print ( \" <%s\" , attr -> attr -> name ) ; val = l2tp_dict_find_value ( attr -> attr , attr -> val ) ; if ( val ) print ( \" %s\" , val -> name ) ; else if ( attr -> H ) print ( \" (hidden, %hu bytes)\" , attr -> length ) ; else { switch ( attr -> attr -> type ) { case ATTR_TYPE_INT16 : print ( \" %i\" , attr -> val . int16 ) ; break ; case ATTR_TYPE_INT32 : print ( \" %i\" , attr -> val . int32 ) ; break ; case ATTR_TYPE_STRING : print ( \"",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * val ; switch ( pack -> hdr . flags & L2TP_VER_MASK ) { case 2 : <vul-end> print ( \"[L2TP tid=%u sid=%u\" <vul-start> ) ) ; break ; case 3 : <vul-end> print ( \"[L2TP cid=%u\" <vul-start> Nr ) ) ; break ; default : print ( \"[L2TP unknown version]\\\\n\" ) ; return\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * val ; print ( \"[L2TP %u]\", pack -> hdr. cid ) ; <vul-start> ) ) ; print ( \" Ns=%u Nr=%u\", ntohs ( pack -> hdr. Ns ), ntohs ( pack -> hdr. Nr ) ) ; <vul-start> ; log_ppp_debug ( \" Ns=%u Nr=%u\" <vul-end>, ntohs ( <vul-start> ) ) ; print ( \" />\" ) ;\n"
 },
 {
  "id": 297,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone_prinicipal = FALSE ; krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( \"Principal does not belong",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <vul-end> st = krb5_add_ber_mem_ldap_mod <vul-start> , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <vul-end> if ( !\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context, & subtreelist, & ntrees ) ; if ( st ) goto cleanup ; } if ( <vul-start>, bersecretkey ) ) == 0\n"
 },
 {
  "id": 298,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void usage ( void ) { PRINT_VERSION ; <vul-start> puts ( \"Copyright (c) 2011, Oracle and/or its affiliates. \" <vul-end> \"All rights reserved.\\\\n\" ) ; puts ( \"Enable or disable plugins.\" ) ; printf ( \"\\\\nUsage: %s [options] <plugin> ENABLE|DISABLE\\\\n\\\\nOptions:\\\\n\" , my_progname ) ; my_print_help ( my_long_options ) ; puts ( \"\\\\n\" ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; puts ( \"Copyright (c) 2011, 2015, Oracle and/or its affiliates. \" <vul-end> \"All rights reserved.\\\\n\" ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; puts ( \"Copyright (c) 2011, Oracle and/or its affiliates. \" <vul-end> \"All rights reserved.\\\\n\" ) ;\n"
 },
 {
  "id": 299,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static char * pool_strdup ( const char * s ) { <vul-start> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <vul-end> <vul-start> strcpy ( r , s ) ; <vul-end> return r ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> s ) { size_t len = strlen ( s ) + 1 ; <vul-start> = pool_alloc ( len ) ; memcpy <vul-end> ( r , <vul-start> r , s , len\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> s ) { size_t slen = <vul-end> strlen ( s <vul-start> ) + 1 ; char * r = pool_alloc ( slen <vul-start> ; strcpy ( r, s ) ; r [ slen - 1 ] = 0 <vul-end> ; return r\n"
 },
 {
  "id": 300,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static void Process_ipfix_template_add ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { input_translation_t * translation_table ; ipfix_template_record_t * ipfix_template_record ; ipfix_template_elements_std_t * NextElement ; int i ; while ( size_left ) { uint32_t table_id , count , size_required ; uint32_t num_extensions = 0 ; <vul-start> if ( size_left && size_left < 4 ) { <vul-end> LogError ( \"Process_ipfix [%u] Template size error at %s line %u\" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; table_id = ntohs ( ipfix_template_record -> TemplateID ) ; count = ntohs ( ipfix_template_record -> FieldCount ) ; dbg_printf ( \"\\\\n[%u] Template ID: %u\\\\n\" , exporter -> info . id , table_id ) ; dbg_printf ( \"FieldCount: %u buffersize: %u\\\\n\" , count , size_left ) ; memset ( ( void * ) cache . common_extensions , 0 , ( Max_num_extensions + 1 ) * sizeof ( uint32_t ) ) ; memset ( ( void * ) cache . lookup_info , 0 , 65536 * sizeof ( struct element_param_s ) ) ; for ( i = 1 ; ipfix_element_map [ i ] . id != 0 ; i ++ ) { uint32_t Type = ipfix_element_map [ i ] . id ; if ( ipfix_element_map [ i ] . id == ipfix_element_map [ i - 1 ] . id ) continue ; cache . lookup_info [ Type ] . index = i ; } cache . input_order",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ; if ( <vul-end> size_left < 4\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> size_left < 4 ||! SizeOfTemplateData"
 },
 {
  "id": 301,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> char ) ( existing & ~ mask <vul-end> ) | ( <vul-start> ) | ( col & mask <vul-end> ) << bitIdx\n"
 },
 {
  "id": 302,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , <vul-start> OPJ_UINT32 * p_data_written , <vul-end> const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; OPJ_UNUSED ( p_manager ) ; <vul-start> opj_write_bytes ( p_data , J2K_MS_SOT , <vul-end> 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; # ifdef USE_JPWL assert ( 0 && \"TODO\" ) ; # endif * p_data_written = 12 ; return OPJ_TRUE ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 <vul-start> p_manager ) ; if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not enough bytes in output buffer to write SOT marker\\\\n\" ) ; return OPJ_FALSE ; }\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> * p_data, const <vul-start> p_manager ) ; if ( p_data_written < 2 * sizeof ( OPJ_BYTE ) ) { return OPJ_FALSE ; }\n"
 },
 {
  "id": 303,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void tokenize_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; VP9_COMP * cpi = args -> cpi ; <vul-start> MACROBLOCKD * xd = args -> xd ; <vul-end> TOKENEXTRA * * tp = args -> tp ; uint8_t token_cache [ 32 * 32 ] ; <vul-start> struct macroblock_plane * p = & cpi -> mb . plane [ plane ] ; <vul-end> struct macroblockd_plane * pd = & xd -> plane [ plane ] ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; int pt ; int c ; TOKENEXTRA * t = * tp ; int eob = p -> eobs [ block ] ; const PLANE_TYPE type = pd -> plane_type ; <vul-start> const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; <vul-end> const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ; vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = <vul-start> cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ; <vul-end> unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = <vul-start> cpi -> common . counts . eob_branch [ tx_size",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> cpi ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd <vul-end> ; TOKENEXTRA * <vul-start> p = & x -> <vul-end> plane [ plane <vul-start> plane_type ; const tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = td -> rd_counts . coef_counts [ tx_size ] [ type ] [ ref ] ; vpx_prob <vul-end> ( * const <vul-start> common . fc -> <vul-end> coef_probs [ tx_size <vul-start> COEFF_CONTEXTS ] = td -> counts -> <vul-end> eob_branch [ tx_size <vul-start> tx_size ) ; int16_t token ; EXTRABIT extra ; <vul-start> ] ; } vp9_get_token_extra ( v , & token , & extra ) ; <vul-start> pt ] , <vul-end> extra , ( <vul-start> ( uint8_t ) <vul-end> token , ( <vul-start> = vp9_pt_energy_class [ <vul-end> token ] ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> cpi ; ThreadData * td = args -> td ; MACROBLOCK * x = & td -> mb ; <vul-start> struct macroblock_plane * const <vul-start> plane_type ; const PLANE_TYPE_EXT * const plane_ext = pd -> plane_ext ; const <vul-start> UNCONSTRAINED_NODES ] = td -> <vul-end> coef_probs [ tx_size <vul-start> COEFF_CONTEXTS ] = td -> <vul-end> eob_branch [ tx_size <vul-start> COEFF_CONTEXTS ] = td -> <vul-end> eob_branch [ tx_size <vul-start> ( uint8_t ) td -> <vul-end> token, ( <vul-start> ] ] = vp9_get_energy_class ( mbmi -> segment_id <vul-end>, token_cache, <vul-start> = vp9_pt_energy_class [ mbmi -> <vul-end> token ] ;\n"
 },
 {
  "id": 304,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int kvm_vm_ioctl_set_pit ( struct kvm * kvm , struct kvm_pit_state * ps ) <vul-start> { <vul-end> mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; memcpy ( & kvm -> arch . vpit -> pit_state , ps , sizeof ( struct kvm_pit_state ) ) ; <vul-start> kvm_pit_load_count ( kvm , 0 , ps -> channels [ 0 ] . count , 0 ) ; <vul-end> mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ps ) { int i ; <vul-start> ) ) ; for ( i = 0 ; i < 3 ; i ++ ) <vul-start> ( kvm , i <vul-end> , ps -> <vul-start> -> channels [ i <vul-end> ] . count\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ps ) { if (! ps ) return - EINVAL ; <vul-start> ) ) ; mutex_lock ( & kvm -> arch. vpit -> pit_state. lock ) ; <vul-start> count, 0 ) ; mutex_unlock ( & kvm -> arch. vpit -> pit_state. lock\n"
 },
 {
  "id": 305,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void sink ( int argc , char * * argv , const char * src ) { static BUF buffer ; struct stat stb ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerr ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; char * * patterns = NULL ; size_t n , npatterns = 0 ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( \"Unexpected off_t/time_t size\" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( \"ambiguous target\" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , \"\" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode )",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> = 0 ; ( void ) <vul-end> utimes ( vect <vul-start> ] , tv <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if (! pflag && <vul-start>!= '\\\\n' ) { <vul-start> 1 ) ; } <vul-start>!= '\\\\0' ) { <vul-start> 1 ) ; }\n"
 },
 {
  "id": 306,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <vul-start> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <vul-end> restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m ,",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> exit ; } m -> msg_namelen = 0 ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> exit ; } m -> msg_namelen = 0 ;\n"
 },
 {
  "id": 307,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = \"Getting sb failed\" ; struct inode * inode ; struct path path ; uid_t check_ruid ; int rc ; sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ; if ( rc ) { err = \"Error parsing options\" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , flags , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } rc = bdi_setup_and_register ( & sbi -> bdi , \"ecryptfs\" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = \"Reading sb failed\" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , \"kern_path() failed\\\\n\" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR \"Mount on filesystem",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( \"eCryptfs: maximum fs stacking depth exceeded\\\\n\" ) ; goto out_free ; }\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path. dentry -> d_inode -> i_sb -> s_stack_depth ;\n"
 },
 {
  "id": 308,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void do_ssh2_kex ( void ) { char * myproposal [ PROPOSAL_MAX ] = { KEX_SERVER } ; struct kex * kex ; int r ; myproposal [ PROPOSAL_KEX_ALGS ] = compat_kex_proposal ( options . kex_algorithms ) ; myproposal [ PROPOSAL_ENC_ALGS_CTOS ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_ENC_ALGS_STOC ] = compat_cipher_proposal ( options . ciphers ) ; myproposal [ PROPOSAL_MAC_ALGS_CTOS ] = myproposal [ PROPOSAL_MAC_ALGS_STOC ] = options . macs ; if ( options . compression == COMP_NONE ) { myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = \"none\" ; <vul-start> } else if ( options . compression == COMP_DELAYED ) { <vul-end> myproposal [ PROPOSAL_COMP_ALGS_CTOS ] = myproposal [ PROPOSAL_COMP_ALGS_STOC ] = \"none,zlib@openssh.com\" ; } if ( options . rekey_limit || options . rekey_interval ) packet_set_rekey_limits ( options . rekey_limit , ( time_t ) options . rekey_interval ) ; myproposal [ PROPOSAL_SERVER_HOST_KEY_ALGS ] = compat_pkalg_proposal ( list_hostkey_types ( ) ) ; if ( ( r = kex_setup ( active_state , myproposal ) ) != 0 ) fatal ( \"kex_setup: %s\" , ssh_err ( r ) ) ; kex = active_state -> kex ; # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> \"none\" ; } <vul-end> if ( options\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> options. compression!= COMP_NONE <vul-end> ) { myproposal\n"
 },
 {
  "id": 309,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 void ip4_datagram_release_cb ( struct sock * sk ) { const struct inet_sock * inet = inet_sk ( sk ) ; const struct ip_options_rcu * inet_opt ; __be32 daddr = inet -> inet_daddr ; <vul-start> struct flowi4 fl4 ; <vul-end> struct rtable * rt ; <vul-start> if ( ! __sk_dst_get ( sk ) || __sk_dst_check ( sk , 0 ) ) <vul-end> return ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rt = ip_route_output_ports ( sock_net ( sk ) , & fl4 , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; <vul-start> if ( ! IS_ERR ( rt ) ) <vul-end> <vul-start> __sk_dst_set ( sk , & rt -> dst ) ; <vul-end> rcu_read_unlock ( ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> inet_daddr ; struct dst_entry * dst ; struct <vul-start> * rt ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; <vul-start> if ( ! dst || ! dst -> obsolete || dst -> ops -> check ( dst <vul-end> , 0 ) <vul-start> 0 ) ) { rcu_read_unlock ( ) ; return ; } <vul-end> inet_opt = rcu_dereference <vul-start> sk_bound_dev_if ) ; dst = <vul-end> ! IS_ERR ( <vul-start> ( rt ) ? <vul-end> & rt -> <vul-start> & rt -> dst : NULL ; sk_dst_set ( sk ,\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> inet_daddr ; struct ip_options_rcu * inet_opt ; struct <vul-start> * rt ; struct ip_options_rcu * inet_dst ; <vul-start> sk_bound_dev_if ) ; inet_dst = rcu_dereference ( inet -> inet_dst ) ; <vul-start> rt ) ) { rcu_assign_pointer ( inet_dst -> ops -> family, & inet_opt -> opt. faddr ) ; inet_dst = & rt -> dst ; } <vul-end> rcu_read_unlock ( )\n"
 },
 {
  "id": 310,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 struct snd_seq_client_port * snd_seq_create_port ( struct snd_seq_client * client , int port ) { unsigned long flags ; struct snd_seq_client_port * new_port , * p ; int num = - 1 ; if ( snd_BUG_ON ( ! client ) ) return NULL ; if ( client -> num_ports >= SNDRV_SEQ_MAX_PORTS ) { pr_warn ( \"ALSA: seq: too many ports for client %d\\\\n\" , client -> number ) ; return NULL ; } new_port = kzalloc ( sizeof ( * new_port ) , GFP_KERNEL ) ; if ( ! new_port ) return NULL ; new_port -> addr . client = client -> number ; new_port -> addr . port = - 1 ; new_port -> owner = THIS_MODULE ; sprintf ( new_port -> name , \"port-%d\" , num ) ; snd_use_lock_init ( & new_port -> use_lock ) ; port_subs_info_init ( & new_port -> c_src ) ; port_subs_info_init ( & new_port -> c_dest ) ; <vul-start> num = port >= 0 ? port : 0 ; <vul-end> mutex_lock ( & client -> ports_mutex ) ; write_lock_irqsave ( & client -> ports_lock , flags ) ; list_for_each_entry ( p , & client -> ports_list_head , list ) { if ( p -> addr . port > num ) break ; if ( port < 0 ) num = p -> addr . port + 1 ; } list_add_tail ( & new_port -> list , & p -> list ) ; client -> num_ports ++ ; new_port -> addr . port = num ; <vul-start> write_unlock_irqrestore ( & client -> ports_lock , flags ) ; <vul-end> <vul-start> mutex_unlock (",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <vul-start> = num ; sprintf ( new_port -> name , \"port-%d\" , num ) ; <vul-start> client -> ports_mutex <vul-end> ) ; return\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> c_dest ) ; new_port -> disconnected = false ; <vul-start> = num ; new_port -> disconnected = false ; <vul-start> flags ) ; <vul-end> sprintf ( new_port\n"
 },
 {
  "id": 311,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int get_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) { <vul-start> return usb_control_msg ( dev -> udev , usb_rcvctrlpipe ( dev -> udev , 0 ) , <vul-end> RTL8150_REQ_GET_REGS , RTL8150_REQT_READ , <vul-start> indx , 0 , data , size , 500 ) ; <vul-end> <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> data ) { void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <vul-end> usb_control_msg ( dev <vul-start> , 0 , buf <vul-end> , size , <vul-start> 500 ) ; if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> data ) { int ret ; ret = <vul-end> usb_control_msg ( dev <vul-start>, indx, 0, & data [ indx ] <vul-end>, size, <vul-start> 500 ) ; if ( ret < size ) { kfree ( data ) ; return ret ; } return 0 ;\n"
 },
 {
  "id": 312,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 LIBXSMM_API_INTERN void libxsmm_sparse_csc_reader ( libxsmm_generated_code * io_generated_code , const char * i_csc_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csc_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_column_idx_id = NULL ; unsigned int l_i = 0 ; l_csc_file_handle = fopen ( i_csc_file_in , \"r\" ) ; if ( l_csc_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csc_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <vul-start> if ( sscanf ( l_line , \"%u %u %u\" , o_row_count , o_column_count , o_element_count ) == 3 ) { <vul-end> * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_column_idx = ( unsigned int * ) malloc ( sizeof (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <vul-end> { * o_row_idx <vul-start> return ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start>, o_element_count ) && 0!= * o_row_count && 0!= * o_column_count && 0!= * o_element_count ) <vul-end> { * o_row_idx <vul-start> return ; } LIBXSMM_ASSERT ( 0!= l_row && 0!= l_column ) ;\n"
 },
 {
  "id": 313,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int cipso_v4_sock_setattr ( struct sock * sk , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) { int ret_val = - EPERM ; unsigned char * buf = NULL ; u32 buf_len ; u32 opt_len ; <vul-start> struct ip_options * opt = NULL ; <vul-end> struct inet_sock * sk_inet ; struct inet_connection_sock * sk_conn ; if ( sk == NULL ) return 0 ; buf_len = CIPSO_V4_OPT_LEN_MAX ; buf = kmalloc ( buf_len , GFP_ATOMIC ) ; if ( buf == NULL ) { ret_val = - ENOMEM ; goto socket_setattr_failure ; } ret_val = cipso_v4_genopt ( buf , buf_len , doi_def , secattr ) ; if ( ret_val < 0 ) goto socket_setattr_failure ; buf_len = ret_val ; opt_len = ( buf_len + 3 ) & ~ 3 ; opt = kzalloc ( sizeof ( * opt ) + opt_len , GFP_ATOMIC ) ; if ( opt == NULL ) { ret_val = - ENOMEM ; goto socket_setattr_failure ; } <vul-start> memcpy ( opt -> __data , buf , buf_len ) ; <vul-end> <vul-start> opt -> optlen = opt_len ; <vul-end> <vul-start> opt -> cipso = sizeof ( struct iphdr ) ; <vul-end> kfree ( buf ) ; buf = NULL ; sk_inet = inet_sk ( sk ) ; <vul-start> if ( sk_inet -> is_icsk ) { <vul-end> sk_conn = inet_csk ( sk ) ; <vul-start> if ( sk_inet -> opt ) <vul-end> <vul-start> sk_conn -> icsk_ext_hdr_len -= sk_inet -> opt -> optlen ; <vul-end> <vul-start> sk_conn -> icsk_ext_hdr_len += opt -> optlen ; <vul-end> sk_conn -> icsk_sync_mss ( sk",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> opt_len ; struct ip_options_rcu * old , <vul-end> * opt = <vul-start> ( opt -> opt . <vul-start> ; opt -> opt . <vul-start> ; opt -> opt . <vul-start> sk ) ; old = rcu_dereference_protected ( sk_inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <vul-start> ; if ( old <vul-end> ) sk_conn -> <vul-start> -> icsk_ext_hdr_len -= old -> opt . <vul-end> optlen ; sk_conn <vul-start> += opt -> opt . <vul-start> ) ; } rcu_assign_pointer ( sk_inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <vul-end> ) ; return\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> opt_len ; struct ip_options_rcu <vul-end> * opt = <vul-start> ( opt -> opt. <vul-start> ; opt -> opt. <vul-start> ; opt -> opt. <vul-start> ( sk_inet -> opt. <vul-start> ) if ( rcu_dereference_protected ( sk_inet -> opt. <vul-start> sk_inet -> opt. <vul-end> optlen ) sk_conn <vul-start> -> icsk_ext_hdr_len -= opt -> opt. <vul-end> optlen ; sk_conn <vul-start> += opt -> opt.\n"
 },
 {
  "id": 314,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int decode_bit_string ( const u8 * inbuf , size_t inlen , void * outbuf , size_t outlen , int invert ) { const u8 * in = inbuf ; u8 * out = ( u8 * ) outbuf ; <vul-start> int zero_bits = * in & 0x07 ; <vul-end> <vul-start> size_t octets_left = inlen - 1 ; <vul-end> <vul-start> int i , count = 0 ; <vul-end> memset ( outbuf , 0 , outlen ) ; in ++ ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 ) - zero_bits ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> outbuf ; int i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <vul-start> & 0x07 ; <vul-end> octets_left = inlen <vul-start> - 1 ; in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <vul-end> ) - zero_bits\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> outbuf ; int i, count = 0 ; memset ( outbuf, 0, outlen ) ; const <vul-start> & 0x07 ; if ( octets_left < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <vul-start> - 1 ; <vul-end> if ( outlen\n"
 },
 {
  "id": 315,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static ssize_t aio_run_iocb ( struct kiocb * req , unsigned opcode , char __user * buf , size_t len , bool compat ) { struct file * file = req -> ki_filp ; ssize_t ret ; unsigned long nr_segs ; int rw ; fmode_t mode ; aio_rw_op * rw_op ; rw_iter_op * iter_op ; struct iovec inline_vecs [ UIO_FASTIOV ] , * iovec = inline_vecs ; struct iov_iter iter ; switch ( opcode ) { case IOCB_CMD_PREAD : case IOCB_CMD_PREADV : mode = FMODE_READ ; rw = READ ; rw_op = file -> f_op -> aio_read ; iter_op = file -> f_op -> read_iter ; goto rw_common ; case IOCB_CMD_PWRITE : case IOCB_CMD_PWRITEV : mode = FMODE_WRITE ; rw = WRITE ; rw_op = file -> f_op -> aio_write ; iter_op = file -> f_op -> write_iter ; goto rw_common ; rw_common : if ( unlikely ( ! ( file -> f_mode & mode ) ) ) return - EBADF ; if ( ! rw_op && ! iter_op ) return - EINVAL ; if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , <vul-start> & len , & iovec , compat ) ; <vul-end> else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , <vul-start> len , iovec ) ; <vul-end> if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ; if ( ret < 0 ) { if ( iovec != inline_vecs ) kfree ( iovec",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> iovec , compat , & iter <vul-start> len , iovec , & iter <vul-start> iter_op ) { ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iter . iov , iter . <vul-end> nr_segs , req\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> nr_sec, compat, 1 <vul-start> len, iovec, 1\n"
 },
 {
  "id": 316,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int key_verify ( pam_handle_t * pamh , int flags , PKCS11_KEY * authkey ) { int ok = 0 ; unsigned char challenge [ 30 ] ; <vul-start> unsigned char signature [ 256 ] ; <vul-end> <vul-start> unsigned int siglen = sizeof signature ; <vul-end> const EVP_MD * md = EVP_sha1 ( ) ; EVP_MD_CTX * md_ctx = EVP_MD_CTX_new ( ) ; EVP_PKEY * privkey = PKCS11_get_private_key ( authkey ) ; EVP_PKEY * pubkey = PKCS11_get_public_key ( authkey ) ; <vul-start> if ( 1 != randomize ( pamh , challenge , sizeof challenge ) ) { <vul-end> goto err ; } if ( NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md || ! EVP_SignInit ( md_ctx , md ) || ! EVP_SignUpdate ( md_ctx , challenge , sizeof challenge ) || ! EVP_SignFinal ( md_ctx , signature , & siglen , privkey ) || ! EVP_MD_CTX_reset ( md_ctx ) || ! EVP_VerifyInit ( md_ctx , md ) || ! EVP_VerifyUpdate ( md_ctx , challenge , sizeof challenge ) || 1 != EVP_VerifyFinal ( md_ctx , signature , siglen , pubkey ) ) { pam_syslog ( pamh , LOG_DEBUG , \"Error verifying key: %s\\\\n\" , ERR_reason_error_string ( ERR_get_error ( ) ) ) ; prompt ( flags , pamh , PAM_ERROR_MSG , NULL , _ ( \"Error verifying key\" ) ) ; goto err ; } ok = 1 ; <vul-start> err : <vul-end> if ( NULL != pubkey ) EVP_PKEY_free ( pubkey ) ; if ( NULL != privkey ) EVP_PKEY_free ( privkey ) ; if ( NULL",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; unsigned char * signature = NULL <vul-end> ; unsigned int <vul-start> unsigned int siglen <vul-end> ; const EVP_MD <vul-start> ; if ( NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <vul-start> ; err : free ( signature ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> char signature [ 1024 <vul-end> ] ; unsigned <vul-start> siglen = sizeof signature ; const EVP_MD * md = EVP_sha1 ( ) ; EVP_PKEY * privkey = PKCS11_get_private_key ( authkey ) ; const EVP_PKEY * pubkey = PKCS11_get_public_key ( authkey ) ; if ( NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md ||! EVP_SignInit ( md_ctx, md ) ||! EVP_SignUpdate ( md_ctx, challenge, sizeof challenge ) ||! EVP_VerifyInit ( md_ctx, md ) ||! EVP_VerifyUpdate ( md_ctx, signature, siglen, privkey ) ) { pam_syslog ( pamh, LOG_DEBUG, \"Error verifying key: %s\\\\n\", ERR_reason_error_string ( ERR_get_error ( ) ) ) ; prompt ( flags, pamh, PAM_ERROR_MSG, NULL, _ ( \"Error verifying key\" ) ) ; goto err ; } ok = 1 ; err : if ( NULL!= pubkey ) EVP_PKEY_free ( pubkey ) ; if ( NULL!= privkey ) EVP_PKEY_free ( privkey ) ; if ( NULL!= <vul-start> ; if ( <vul-end> NULL!= md_ctx\n"
 },
 {
  "id": 317,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( \"Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\\\\n\" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , \"ipmi_si.%d\" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( \"ipmi_si\" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( \"Unable to allocate platform device\\\\n\" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ;",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ; out_err : if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; }\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; out_err : if ( init_name )\n"
 },
 {
  "id": 318,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void encode_loopfilter ( struct loopfilter * lf , <vul-start> struct vp9_write_bit_buffer * wb ) { <vul-end> int i ; <vul-start> vp9_wb_write_literal ( wb , lf -> filter_level , 6 ) ; <vul-end> <vul-start> vp9_wb_write_literal ( wb , lf -> sharpness_level , 3 ) ; <vul-end> <vul-start> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_enabled ) ; <vul-end> if ( lf -> mode_ref_delta_enabled ) { <vul-start> vp9_wb_write_bit ( wb , lf -> mode_ref_delta_update ) ; <vul-end> if ( lf -> mode_ref_delta_update ) { for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) { const int delta = lf -> ref_deltas [ i ] ; const int changed = delta != lf -> last_ref_deltas [ i ] ; <vul-start> vp9_wb_write_bit ( wb , changed ) ; <vul-end> if ( changed ) { lf -> last_ref_deltas [ i ] = delta ; <vul-start> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <vul-end> <vul-start> vp9_wb_write_bit ( wb , delta < 0 ) ; <vul-end> } } for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) { const int delta = lf -> mode_deltas [ i ] ; const int changed = delta != lf -> last_mode_deltas [ i ] ; <vul-start> vp9_wb_write_bit ( wb , changed ) ; <vul-end> if ( changed ) { lf -> last_mode_deltas [ i ] = delta ; <vul-start> vp9_wb_write_literal ( wb , abs ( delta ) & 0x3F , 6 ) ; <vul-end> <vul-start> vp9_wb_write_bit ( wb , delta < 0 ) ; <vul-end> } } } } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> lf , struct vpx_write_bit_buffer <vul-end> * wb ) <vul-start> int i ; vpx_wb_write_literal <vul-end> ( wb , <vul-start> 6 ) ; vpx_wb_write_literal <vul-end> ( wb , <vul-start> 3 ) ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> mode_ref_delta_enabled ) { vpx_wb_write_bit <vul-end> ( wb , <vul-start> i ] ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> = delta ; vpx_wb_write_literal <vul-end> ( wb , <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> i ] ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> = delta ; vpx_wb_write_literal <vul-end> ( wb , <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> lf, struct vpx_write_bit_buffer <vul-end> * wb ) <vul-start> int i ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> 6 ) ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> 3 ) ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> mode_ref_delta_enabled ) { vpx_wb_write_bit <vul-end> ( wb, <vul-start> i ] ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> i ] ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> = delta ; vpx_wb_write_literal <vul-end> ( wb, <vul-start> 6 ) ; vpx_wb_write_bit <vul-end> ( wb,\n"
 },
 {
  "id": 319,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 void pdf_get_version ( FILE * fp , pdf_t * pdf ) { <vul-start> char * header , * c ; <vul-end> <vul-start> header = get_header ( fp ) ; <vul-end> if ( ( c = strstr ( header , \"%PDF-\" ) ) && <vul-start> ( c + strlen ( \"%PDF-M.m\" ) + 2 ) ) <vul-end> { pdf -> pdf_major_version = atoi ( c + strlen ( \"%PDF-\" ) ) ; pdf -> pdf_minor_version = atoi ( c + strlen ( \"%PDF-M.\" ) ) ; } free ( header ) ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> char * header <vul-end> = get_header ( <vul-start> ( fp ) ; const char * c <vul-start> ) && ( ( c + 6 ) [ 0 ] == '.' ) && isdigit ( ( c + 5 ) [ 0 ] ) && isdigit ( ( c + 7 ) [ 0 ] <vul-end> ) ) {\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> pdf ) { int major_version ; int minor_version ; <vul-start> * c ; if (! ( <vul-start> ( fp ) ) ) return ; major_version = get_major_version ( c, & minor_version ) ; if ( ( c = strstr ( header, \"%PDF-\" ) ) && ( c + strlen ( \"%PDF-M.m\" ) + 2 ) ) { pdf -> pdf_major_version = atoi ( c + strlen ( \"%PDF-\" ) ) ; pdf -> pdf_minor_version = atoi ( c + strlen ( \"%PDF-M.\" ) ) ; } else { major_version = 0 ; minor_version = <vul-end> atoi ( c <vul-start> + 2 ) ; } if ( ( c = strstr ( header, \"Version=\" ) ) && ( c + strlen ( c + strlen ( \"%PDF-M.m\" ) + 2 ) )\n"
 },
 {
  "id": 320,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int dccp_v6_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; <vul-start> struct in6_addr * saddr = NULL , * final_p , final ; <vul-end> struct flowi6 fl6 ; struct dst_entry * dst ; int addr_type ; int err ; dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; IP6_ECN_flow_init ( fl6 . flowlabel ) ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { struct ip6_flowlabel * flowlabel ; flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; fl6_sock_release ( flowlabel ) ; } } if ( ipv6_addr_any ( & usin -> sin6_addr ) ) usin -> sin6_addr . s6_addr [ 15 ] = 1 ; addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type & IPV6_ADDR_MULTICAST ) return - ENETUNREACH ; if ( addr_type & IPV6_ADDR_LINKLOCAL ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> final_p , final ; struct ipv6_txoptions * opt <vul-start> ) ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <vul-start> & fl6 , <vul-end> opt , & <vul-start> ; if ( opt <vul-end> ) icsk -> <vul-start> -> icsk_ext_hdr_len = <vul-end> opt -> opt_flen <vul-start> -> opt_flen + <vul-end> opt -> opt_nflen <vul-start> opt -> opt_nflen <vul-end> ; inet ->\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> final_p, final ; struct ipv6_txoptions * opt <vul-start> ) ) ; opt = rcu_dereference_protected ( np -> opt, sock_owned_by_user ( sk ) ) ; <vul-start> & fl6, opt <vul-end>, & final <vul-start> ; if ( opt <vul-end>!= NULL ) <vul-start> -> icsk_ext_hdr_len = <vul-end> opt -> opt_flen <vul-start> -> opt_flen + <vul-end> opt -> opt_nflen <vul-start> opt -> opt_nflen <vul-end> ; inet ->\n"
 },
 {
  "id": 321,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void mpls_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const u_char * p ; uint32_t label_entry ; uint16_t label_stack_depth = 0 ; enum mpls_packet_type pt = PT_UNKNOWN ; p = bp ; ND_PRINT ( ( ndo , \"MPLS\" ) ) ; do { ND_TCHECK2 ( * p , sizeof ( label_entry ) ) ; if ( length < sizeof ( label_entry ) ) { ND_PRINT ( ( ndo , \"[|MPLS], length %u\" , length ) ) ; return ; } label_entry = EXTRACT_32BITS ( p ) ; ND_PRINT ( ( ndo , \"%s(label %u\" , ( label_stack_depth && ndo -> ndo_vflag ) ? \"\\\\n\\\\t\" : \" \" , MPLS_LABEL ( label_entry ) ) ) ; label_stack_depth ++ ; if ( ndo -> ndo_vflag && MPLS_LABEL ( label_entry ) < sizeof ( mpls_labelname ) / sizeof ( mpls_labelname [ 0 ] ) ) ND_PRINT ( ( ndo , \" (%s)\" , mpls_labelname [ MPLS_LABEL ( label_entry ) ] ) ) ; ND_PRINT ( ( ndo , \", exp %u\" , MPLS_EXP ( label_entry ) ) ) ; if ( MPLS_STACK ( label_entry ) ) ND_PRINT ( ( ndo , \", [S]\" ) ) ; ND_PRINT ( ( ndo , \", ttl %u)\" , MPLS_TTL ( label_entry ) ) ) ; p += sizeof ( label_entry ) ; length -= sizeof ( label_entry ) ; } while ( ! MPLS_STACK ( label_entry ) ) ; switch ( MPLS_LABEL ( label_entry ) ) { case 0 : case 3 : pt = PT_IPV4 ; break ; case 2 : pt =",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> p , length <vul-end> ) ; break\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> p, length <vul-end> ) ; break\n"
 },
 {
  "id": 322,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 BOOL SQLWriteFileDSN ( LPCSTR pszFileName , LPCSTR pszAppName , LPCSTR pszKeyName , LPCSTR pszString ) { HINI hIni ; char szFileName [ ODBC_FILENAME_MAX + 1 ] ; if ( pszFileName [ 0 ] == '/' ) { <vul-start> strncpy ( szFileName , sizeof ( szFileName ) - 5 , pszFileName ) ; <vul-end> } else { char szPath [ ODBC_FILENAME_MAX + 1 ] ; * szPath = '\\\\0' ; _odbcinst_FileINI ( szPath ) ; snprintf ( szFileName , sizeof ( szFileName ) - 5 , \"%s/%s\" , szPath , pszFileName ) ; } if ( strlen ( szFileName ) < 4 || strcmp ( szFileName + strlen ( szFileName ) - 4 , \".dsn\" ) ) { strcat ( szFileName , \".dsn\" ) ; } # ifdef __OS2__ if ( iniOpen ( & hIni , szFileName , \"#;\" , '[' , ']' , '=' , TRUE , 0L ) != INI_SUCCESS ) # else if ( iniOpen ( & hIni , szFileName , \"#;\" , '[' , ']' , '=' , TRUE ) != INI_SUCCESS ) # endif { inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_INVALID_PATH , \"\" ) ; return FALSE ; } if ( pszString == NULL && pszKeyName == NULL ) { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) == INI_SUCCESS ) { iniObjectDelete ( hIni ) ; } } else if ( pszString == NULL ) { if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , \"\" ) == INI_SUCCESS ) { iniPropertyDelete",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( szFileName , pszFileName , <vul-start> ) - 5 <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> '/' ) { memcpy <vul-end> ( szFileName,\n"
 },
 {
  "id": 323,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int requireDirective ( MaState * state , cchar * key , cchar * value ) { char * age , * type , * rest , * option , * ovalue , * tok ; int domains ; if ( ! maTokenize ( state , value , \"%S ?*\" , & type , & rest ) ) { return MPR_ERR_BAD_SYNTAX ; } if ( scaselesscmp ( type , \"ability\" ) == 0 ) { httpSetAuthRequiredAbilities ( state -> auth , rest ) ; } else if ( scaselesscmp ( type , \"group\" ) == 0 || scaselesscmp ( type , \"role\" ) == 0 ) { httpSetAuthRequiredAbilities ( state -> auth , rest ) ; } else if ( scaselesscmp ( type , \"secure\" ) == 0 ) { domains = 0 ; age = 0 ; for ( option = stok ( sclone ( rest ) , \" \\\\t\" , & tok ) ; option ; option = stok ( 0 , \" \\\\t\" , & tok ) ) { <vul-start> option = stok ( option , \" =\\\\t,\" , & ovalue ) ; <vul-end> ovalue = strim ( ovalue , \"\\\\\"\\'\" , MPR_TRIM_BOTH ) ; if ( smatch ( option , \"age\" ) ) { age = sfmt ( \"%lld\" , ( int64 ) httpGetTicks ( ovalue ) ) ; } else if ( smatch ( option , \"domains\" ) ) { domains = 1 ; } } if ( age ) { if ( domains ) { age = sjoin ( \"-1\" , age , NULL ) ; } } addCondition",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option ,\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option,\n"
 },
 {
  "id": 324,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) { <vul-start> u_char * b , * s , * t , c ; <vul-end> int i , proto ; const void * se ; if ( length <= 0 ) return ; <vul-start> b = ( uint8_t * ) malloc ( length ) ; <vul-end> if ( b == NULL ) return ; <vul-start> for ( s = ( u_char * ) p , t = b , i = length ; i > 0 ; i -- ) { <vul-end> c = * s ++ ; if ( c == 0x7d ) { <vul-start> if ( i > 1 ) { <vul-end> i -- ; <vul-start> c = * s ++ ^ 0x20 ; <vul-end> } else continue ; } * t ++ = c ; } se = ndo -> ndo_snapend ; ndo -> ndo_snapend = t ; length = t - b ; if ( length < 1 ) goto trunc ; proto = * b ; switch ( proto ) { case PPP_IP : ip_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; case PPP_IPV6 : ip6_print ( ndo , b + 1 , length - 1 ) ; goto cleanup ; default : break ; } if ( length < 2 ) goto trunc ; proto = EXTRACT_16BITS ( b ) ; switch ( proto ) { case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ; proto",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> b , * <vul-end> t , c <vul-start> t , c ; const u_char * s <vul-start> b = ( u_char <vul-end> * ) malloc <vul-start> ( s = <vul-end> p , t <vul-start> i > 0 && ND_TTEST ( * s ) <vul-start> if ( i <= 1 || ! ND_TTEST ( * s ) ) break ; <vul-end> i -- ; <vul-start> ++ ^ 0x20 <vul-end> ; } *\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> length ) { int proto ; const void * se ; u_char * b = NULL, * s = NULL, * t = NULL <vul-end> ; if ( <vul-start> ) return ; if ( length > MAX_RW_COUNT ) { ND_PRINT ( ( ndo, \"[|ppp]\" ) ) ; return ; } for ( <vul-end> s = ( <vul-start> = b, length - 1, & b, & i ) { switch ( i ) { case 0x7d : <vul-end> c = * <vul-start> s ++ ^ 0x20 ; break ; case 0x7d : c = * s ++ ; break ; case 0x20 : c = * s ++ ; break ; default : ND_PRINT ( ( ndo, \"[|ppp]\" ) ) ; break ; } } * t ++ = c ; } se = ndo -> ndo_snapend ; ndo -> ndo_snapend = t ; length = t - b ; if ( length < 1 ) goto trunc ; proto = * b ; switch ( proto ) { case PPP_IP : ip_print ( ndo, b + 1, length - 1 ) ; goto trunc ; case PPP_IPV6 : ip6_print ( ndo, b + 1, length - 1 ) ; goto trunc ; } if ( length < 4 ) goto trunc ; proto = * b ; switch ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 2 ) goto trunc ; for ( i = length ; i > 0 ; i -- ) { c = * s ++ ; if ( c == 0x7d ) { if ( i > 1 ) { <vul-end> c = * <vul-start> s ++ ^ 0x20 ; break ; } else continue ; } * t ++ = c ; } se = ndo -> ndo_snapend ; ndo -> ndo_snapend = t ; length = t - b ; if ( length < 1 ) goto trunc ; length = t - b ; if ( length < 2 ) goto trunc ; for ( i = length ; i > 0 ; i -- ) { if ( i > 1 ) { <vul-end> c = * <vul-start> ^ 0x20 ; break ; } else { <vul-end> continue ; }\n"
 },
 {
  "id": 325,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void ih264d_rest_of_residual_cav_chroma_dc_block ( UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD16 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <vul-start> WORD16 i2_level_arr [ 4 ] ; <vul-end> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 16 ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <vul-end> ] ; tu_sblk4x4_coeff_data_t\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <vul-end> ] ; tu_sblk4x4_coeff_data_t\n"
 },
 {
  "id": 326,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct packet_offload * ptype ; __be16 type = skb -> protocol ; struct list_head * head = & offload_base ; int same_flow ; enum gro_result ret ; int grow ; if ( ! ( skb -> dev -> features & NETIF_F_GRO ) ) goto normal ; if ( skb_is_gso ( skb ) || skb_has_frag_list ( skb ) || skb -> csum_bad ) goto normal ; gro_list_prepare ( napi , skb ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( ptype , head , list ) { if ( ptype -> type != type || ! ptype -> callbacks . gro_receive ) continue ; skb_set_network_header ( skb , skb_gro_offset ( skb ) ) ; skb_reset_mac_len ( skb ) ; NAPI_GRO_CB ( skb ) -> same_flow = 0 ; NAPI_GRO_CB ( skb ) -> flush = 0 ; NAPI_GRO_CB ( skb ) -> free = 0 ; <vul-start> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <vul-end> NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ; switch ( skb -> ip_summed ) { case CHECKSUM_COMPLETE : NAPI_GRO_CB ( skb ) -> csum = skb -> csum ; NAPI_GRO_CB ( skb ) -> csum_valid = 1 ; NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; break ; case CHECKSUM_UNNECESSARY : NAPI_GRO_CB ( skb ) -> csum_cnt = skb -> csum_level + 1 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; break ; default : NAPI_GRO_CB ( skb ) -> csum_cnt =",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> skb ) -> encap_mark <vul-end> = 0 ;\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> skb ) -> encap_mark <vul-end> = 0 ;\n"
 },
 {
  "id": 327,
  "question": "CWE-674 Code Input Vulnerable Code Is: CWE-674 static int renameTableSelectCb ( Walker * pWalker , Select * pSelect ) { int i ; RenameCtx * p = pWalker -> u . pRename ; <vul-start> SrcList * pSrc = pSelect -> pSrc ; <vul-end> if ( pSrc == 0 ) { assert ( pWalker -> pParse -> db -> mallocFailed ) ; return WRC_Abort ; } for ( i = 0 ; i < pSrc -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pSrc -> a [ i ] ; if ( pItem -> pTab == p -> pTab ) { renameTokenFind ( pWalker -> pParse , p , pItem -> zName ) ; } } renameWalkWith ( pWalker , pSelect ) ; return WRC_Continue ; }",
  "golden_answers": [
   "CWE-674 Fixed Code Lines are: <vul-start> pSelect -> pSrc ; if ( pSelect -> selFlags & SF_View ) return WRC_Prune\n"
  ],
  "generated_answer": "CWE-674 Fixed Code Lines are: <vul-start>. pRename ; if ( p -> selFlags & SF_View ) return WRC_Prune ;\n"
 },
 {
  "id": 328,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void cJSON_AddItemToObject ( cJSON * object , const char * string , cJSON * item ) { if ( ! item ) return ; if ( item -> string ) cJSON_free ( item -> string ) ; item -> string = cJSON_strdup ( string ) ; cJSON_AddItemToArray ( object , item ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: \n"
 },
 {
  "id": 329,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( addr & ( shmlba - 1 ) ) { <vul-start> if ( shmflg & SHM_RND ) <vul-end> addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR (",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> { if ( ( <vul-start> shmflg & SHM_RND ) && addr >= shmlba\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> { if ( ( shmflg & SHM_RND ) && addr >= shmlba <vul-end> ) addr &=\n"
 },
 {
  "id": 330,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 void perf_pmu_migrate_context ( struct pmu * pmu , int src_cpu , int dst_cpu ) { struct perf_event_context * src_ctx ; struct perf_event_context * dst_ctx ; struct perf_event * event , * tmp ; LIST_HEAD ( events ) ; src_ctx = & per_cpu_ptr ( pmu -> pmu_cpu_context , src_cpu ) -> ctx ; dst_ctx = & per_cpu_ptr ( pmu -> pmu_cpu_context , dst_cpu ) -> ctx ; <vul-start> mutex_lock ( & src_ctx -> mutex ) ; <vul-end> list_for_each_entry_safe ( event , tmp , & src_ctx -> event_list , event_entry ) { perf_remove_from_context ( event , false ) ; unaccount_event_cpu ( event , src_cpu ) ; put_ctx ( src_ctx ) ; list_add ( & event -> migrate_entry , & events ) ; } <vul-start> mutex_unlock ( & src_ctx -> mutex ) ; <vul-end> synchronize_rcu ( ) ; mutex_lock ( & dst_ctx -> mutex ) ; list_for_each_entry_safe ( event , tmp , & events , migrate_entry ) { list_del ( & event -> migrate_entry ) ; if ( event -> state >= PERF_EVENT_STATE_OFF ) event -> state = PERF_EVENT_STATE_INACTIVE ; account_event_cpu ( event , dst_cpu ) ; perf_install_in_context ( dst_ctx , event , dst_cpu ) ; get_ctx ( dst_ctx ) ; } mutex_unlock ( & dst_ctx -> mutex ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> -> ctx ; mutex_lock_double ( & src_ctx -> mutex , & dst_ctx <vul-end> -> mutex ) <vul-start> ) ; } synchronize_rcu ( <vul-end> ) ; list_for_each_entry_safe <vul-start> mutex ) ; mutex_unlock ( & src_ctx -> mutex ) ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> -> ctx ; mutex_lock_nested <vul-end> ( & src_ctx <vul-start> src_ctx -> mutex, SINGLE_DEPTH_NESTING <vul-start> ) ; } mutex_unlock_nested ( & src_ctx -> mutex, SINGLE_DEPTH_NESTING ) ; <vul-start> mutex ) ; mutex_unlock_nested ( & dst_ctx -> mutex, SINGLE_DEPTH_NESTING ) ;\n"
 },
 {
  "id": 331,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 struct bpf_prog * bpf_prog_get ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_prog * prog ; prog = __bpf_prog_get ( f ) ; if ( IS_ERR ( prog ) ) return prog ; <vul-start> atomic_inc ( & prog -> aux -> refcnt ) ; <vul-end> fdput ( f ) ; return prog ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> return prog ; prog = bpf_prog_inc ( prog <vul-end> ) ; fdput\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> return prog ; if ( prog -> aux )\n"
 },
 {
  "id": 332,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static INLINE void write_buffer_8x8 ( int16_t * output , __m128i * res , int stride ) { <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 0 * stride ) , res [ 0 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 1 * stride ) , res [ 1 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 2 * stride ) , res [ 2 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 3 * stride ) , res [ 3 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 4 * stride ) , res [ 4 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 5 * stride ) , res [ 5 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 6 * stride ) , res [ 6 ] ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 7 * stride ) , res [ 7 ] ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> void write_buffer_8x8 ( tran_low_t <vul-end> * output , <vul-start> stride ) { store_output ( & res [ 0 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 1 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 2 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 3 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 4 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 5 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 6 ] , <vul-end> ( output + <vul-start> * stride ) ) ; store_output ( & res [ 7 ] , <vul-end> ( output + <vul-start> * stride ) <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void write_buffer_8x8 ( tran_low_t <vul-end> * output, <vul-start> stride ) { memcpy <vul-end> ( output + <vul-start> output + 0, res [ 0 ] ) ; memcpy <vul-end> ( output + <vul-start> output + 1, res [ 1 ] ) ; memcpy <vul-end> ( output + <vul-start> output + 2, res [ 2 ] ) ; memcpy <vul-end> ( output + <vul-start> output + 3, res [ 3 ] ) ; memcpy <vul-end> ( output + <vul-start> output + 4, res [ 4 ] ) ; memcpy <vul-end> ( output + <vul-start> output + 5, res [ 5 ] ) ; memcpy <vul-end> ( output + <vul-start> output + 6, res [ 6 ] ) ; memcpy <vul-end> ( output + <vul-start> output + 7, res [ 7 ] ) ; _mm_store_si128 ( ( __m128i * ) ( output + 8 * stride, res [ 8 ] ) ; _mm_store_si128 ( ( __m128i * ) ( output + 9\n"
 },
 {
  "id": 333,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 long follow_hugetlb_page ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * * pages , struct vm_area_struct * * vmas , unsigned long * position , unsigned long * nr_pages , long i , unsigned int flags , int * nonblocking ) { unsigned long pfn_offset ; unsigned long vaddr = * position ; unsigned long remainder = * nr_pages ; struct hstate * h = hstate_vma ( vma ) ; int err = - EFAULT ; while ( vaddr < vma -> vm_end && remainder ) { pte_t * pte ; spinlock_t * ptl = NULL ; int absent ; struct page * page ; if ( fatal_signal_pending ( current ) ) { remainder = 0 ; break ; } pte = huge_pte_offset ( mm , vaddr & huge_page_mask ( h ) , huge_page_size ( h ) ) ; if ( pte ) ptl = huge_pte_lock ( h , mm , pte ) ; absent = ! pte || huge_pte_none ( huge_ptep_get ( pte ) ) ; if ( absent && ( flags & FOLL_DUMP ) && ! hugetlbfs_pagecache_present ( h , vma , vaddr ) ) { if ( pte ) spin_unlock ( ptl ) ; remainder = 0 ; break ; } if ( absent || is_swap_pte ( huge_ptep_get ( pte ) ) || ( ( flags & FOLL_WRITE ) && ! huge_pte_write ( huge_ptep_get ( pte ) ) ) ) { vm_fault_t ret ; unsigned int fault_flags = 0 ; if ( pte ) spin_unlock ( ptl ) ; if ( flags & FOLL_WRITE ) fault_flags |=",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; if ( unlikely (! try_get_page ( page ) ) ) { err = - ENOMEM ; break ; } <vul-end> if ( pages\n"
 },
 {
  "id": 334,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int dex_loadcode ( RBinFile * arch , RBinDexObj * bin ) { struct r_bin_t * rbin = arch -> rbin ; int i ; int * methods = NULL ; int sym_count = 0 ; if ( ! bin || bin -> methods_list ) { return false ; } bin -> code_from = UT64_MAX ; bin -> code_to = 0 ; bin -> methods_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> methods_list ) { return false ; } bin -> imports_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> imports_list ) { r_list_free ( bin -> methods_list ) ; return false ; } bin -> classes_list = r_list_newf ( ( RListFree ) __r_bin_class_free ) ; if ( ! bin -> classes_list ) { r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; return false ; } if ( bin -> header . method_size > bin -> size ) { bin -> header . method_size = 0 ; return false ; } bin -> header . method_size = R_MIN ( bin -> header . method_size , bin -> size ) ; bin -> header . class_size = R_MIN ( bin -> header . class_size , bin -> size ) ; bin -> header . strings_size = R_MIN ( bin -> header . strings_size , bin -> size ) ; if ( bin -> header . strings_size > bin -> size ) { eprintf ( \"Invalid strings size\\\\n\" ) ; return false ; } if ( bin ->",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> header . types_size <vul-end> ) { continue\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> continue ; } int method_size = R_MIN ( bin -> header. method_size, bin -> size ) ; int method_to = R_MIN ( bin -> header. method_size, bin -> size ) ; int import_count = 0 ; int sym_count = 0 ; if ( method_name && * method_name ) { int i, j ; for ( i = 0 ; i < i ; j ++ ) { if ( bin -> methods [ j ]. type == DEX_CLASS_ID_INTERNAL &&! bin -> methods [ j ]. bind ) { method_size = j + 1 ; import_count ++ ; } } if ( method_size > method_size ) { r_list_free ( bin -> methods_list ) ; return false ; } <vul-start>. class_id > method_size <vul-end> - 1 ) <vul-start> { continue ; } <vul-start>. method_offset + method_size <vul-end> ; sym_count =\n"
 },
 {
  "id": 335,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int rpc_pack ( rpc_pkg * pkg , void * * data , uint32_t * size ) { static void * send_buf ; static size_t send_buf_size ; <vul-start> uint32_t pkg_size = RPC_PKG_HEAD_SIZE + pkg -> ext_size + pkg -> body_size ; <vul-end> if ( send_buf_size < pkg_size ) { if ( send_buf ) free ( send_buf ) ; send_buf_size = pkg_size * 2 ; send_buf = malloc ( send_buf_size ) ; <vul-start> assert ( send_buf != NULL ) ; <vul-end> } memcpy ( send_buf , pkg , RPC_PKG_HEAD_SIZE ) ; if ( pkg -> ext_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE , pkg -> ext , pkg -> ext_size ) ; if ( pkg -> body_size ) memcpy ( send_buf + RPC_PKG_HEAD_SIZE + pkg -> ext_size , pkg -> body , pkg -> body_size ) ; pkg = send_buf ; pkg -> magic = htole32 ( RPC_PKG_MAGIC ) ; pkg -> command = htole32 ( pkg -> command ) ; pkg -> pkg_type = htole16 ( pkg -> pkg_type ) ; pkg -> result = htole32 ( pkg -> result ) ; pkg -> sequence = htole32 ( pkg -> sequence ) ; pkg -> req_id = htole64 ( pkg -> req_id ) ; pkg -> body_size = htole32 ( pkg -> body_size ) ; pkg -> ext_size = htole16 ( pkg -> ext_size ) ; pkg -> crc32 = 0 ; pkg -> crc32 = htole32 ( generate_crc32c ( send_buf , pkg_size ) ) ; * data = send_buf ; * size = pkg_size ; return 0 ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ; uint32_t pkg_size ; if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) { return - 1 ; } pkg_size <vul-start> send_buf_size ) ; if ( send_buf == NULL ) { return - 1 ; } <vul-end> } memcpy (\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> uint32_t pkg_size = rpc_pkg_get_head_size ( pkg ) + rpc_pkg_get_ext_size ( pkg ) + rpc_pkg_get_body_size ( pkg ) <vul-end> ; if ( <vul-start> send_buf_size ) ; if ( send_buf == NULL ) { return - 1 ; }\n"
 },
 {
  "id": 336,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 BOOL update_recv ( rdpUpdate * update , wStream * s ) { BOOL rc = FALSE ; UINT16 updateType ; rdpContext * context = update -> context ; if ( Stream_GetRemainingLength ( s ) < 2 ) { WLog_ERR ( TAG , \"Stream_GetRemainingLength(s) < 2\" ) ; return FALSE ; } Stream_Read_UINT16 ( s , updateType ) ; WLog_Print ( update -> log , WLOG_TRACE , \"%s Update Data PDU\" , UPDATE_TYPE_STRINGS [ updateType ] ) ; if ( ! update_begin_paint ( update ) ) goto fail ; switch ( updateType ) { case UPDATE_TYPE_ORDERS : rc = update_recv_orders ( update , s ) ; break ; case UPDATE_TYPE_BITMAP : { BITMAP_UPDATE * bitmap_update = update_read_bitmap_update ( update , s ) ; if ( ! bitmap_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> BitmapUpdate , context , bitmap_update ) ; free_bitmap_update ( update -> context , bitmap_update ) ; } break ; case UPDATE_TYPE_PALETTE : { PALETTE_UPDATE * palette_update = update_read_palette ( update , s ) ; if ( ! palette_update ) { WLog_ERR ( TAG , \"UPDATE_TYPE_PALETTE - update_read_palette() failed\" ) ; goto fail ; } rc = IFCALLRESULT ( FALSE , update -> Palette , context , palette_update ) ; free_palette_update ( context , palette_update ) ; } break ; case UPDATE_TYPE_SYNCHRONIZE : <vul-start> update_read_synchronize ( update , s ) ; <vul-end> rc = IFCALLRESULT ( TRUE , update -> Synchronize , context ) ; break ; default : break ; } fail : if (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> case UPDATE_TYPE_SYNCHRONIZE : if ( ! <vul-start> , s ) ) goto fail\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> case UPDATE_TYPE_SYNCHRONIZE : if (! <vul-start>, s ) ) goto fail\n"
 },
 {
  "id": 337,
  "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 static struct svc_serv * nfs_callback_create_svc ( int minorversion ) { struct nfs_callback_data * cb_info = & nfs_callback_info [ minorversion ] ; struct svc_serv * serv ; struct svc_serv_ops * sv_ops ; if ( cb_info -> serv ) { svc_get ( cb_info -> serv ) ; return cb_info -> serv ; } switch ( minorversion ) { case 0 : sv_ops = nfs4_cb_sv_ops [ 0 ] ; break ; default : sv_ops = nfs4_cb_sv_ops [ 1 ] ; } if ( sv_ops == NULL ) return ERR_PTR ( - ENOTSUPP ) ; if ( cb_info -> users ) printk ( KERN_WARNING \"nfs_callback_create_svc: no kthread, %d users??\\\\n\" , cb_info -> users ) ; <vul-start> serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; <vul-end> if ( ! serv ) { printk ( KERN_ERR \"nfs_callback_create_svc: create service failed\\\\n\" ) ; return ERR_PTR ( - ENOMEM ) ; } cb_info -> serv = serv ; serv -> sv_maxconn = 1024 ; dprintk ( \"nfs_callback_create_svc: service created\\\\n\" ) ; return serv ; }",
  "golden_answers": [
   "CWE-404 Fixed Code Lines are: <vul-start> ; serv = svc_create_pooled <vul-end> ( & nfs4_callback_program\n"
  ],
  "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> users ) ; if ( cb_info -> user ) printk ( KERN_WARNING \"nfs_callback_create_svc: no kthread, %d user??\\\\n\", cb_info -> user ) ;\n"
 },
 {
  "id": 338,
  "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 static int ext4_xattr_block_set ( handle_t * handle , struct inode * inode , struct ext4_xattr_info * i , struct ext4_xattr_block_find * bs ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; struct ext4_xattr_search * s = & bs -> s ; <vul-start> struct mb_cache_entry * ce = NULL ; <vul-end> int error = 0 ; <vul-start> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <vul-end> # define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ; if ( s -> base ) { <vul-start> ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev , <vul-end> bs -> bh -> b_blocknr ) ; BUFFER_TRACE ( bs -> bh , \"get_write_access\" ) ; error = ext4_journal_get_write_access ( handle , bs -> bh ) ; if ( error ) goto cleanup ; lock_buffer ( bs -> bh ) ; if ( header ( s -> base ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <vul-start> if ( ce ) { <vul-end> mb_cache_entry_free ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , \"modifying in-place\" ) ; error = ext4_xattr_set_entry ( i , s ) ; if ( ! error ) { if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; ext4_xattr_cache_insert ( ext4_mb_cache , bs -> bh ) ; }",
  "golden_answers": [
   "CWE-19 Fixed Code Lines are: <vul-start> s ; struct mb2_cache_entry <vul-end> * ce = <vul-start> 0 ; struct mb2_cache <vul-end> * ext4_mb_cache = <vul-start> base ) { <vul-end> BUFFER_TRACE ( bs <vul-start> ) ) { __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <vul-end> ea_bdebug ( bs <vul-start> bh ) ; <vul-end> ea_bdebug ( bs <vul-start> new_bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <vul-start> cleanup_dquot ; } mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <vul-end> ce ) ; <vul-start> ( ce ) mb2_cache_entry_put ( ext4_mb_cache , <vul-end> ce ) ;\n"
  ],
  "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> s ; struct mb2_cache_entry <vul-end> * ce = <vul-start> 0 ; struct mb2_cache <vul-end> * ext4_mb_cache = <vul-start> base ) { <vul-end> BUFFER_TRACE ( bs <vul-start> ) ) { <vul-end> ea_bdebug ( bs <vul-start> cleanup_dquot ; } mb2_cache_entry_delete_block ( ext4_mb_cache, ce ) ; <vul-end> ea_bdebug ( bs\n"
 },
 {
  "id": 339,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version !=",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <vul-end> == SSL3_MT_CLIENT_HELLO )\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> == SSL3_RT_HANDSHAKE && SSL_get_protocol ( p ) <vul-end> == SSL3_MT_CLIENT_HELLO )\n"
 },
 {
  "id": 340,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int decode_rt_routing_info ( netdissect_options * ndo , const u_char * pptr , char * buf , u_int buflen ) { uint8_t route_target [ 8 ] ; u_int plen ; <vul-start> ND_TCHECK ( pptr [ 0 ] ) ; <vul-end> plen = pptr [ 0 ] ; if ( 0 == plen ) { snprintf ( buf , buflen , \"default route target\" ) ; return 1 ; } if ( 32 > plen ) return - 1 ; <vul-start> plen -= 32 ; <vul-end> if ( 64 < plen ) return - 1 ; memset ( & route_target , 0 , sizeof ( route_target ) ) ; <vul-start> ND_TCHECK2 ( pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <vul-end> <vul-start> memcpy ( & route_target , & pptr [ 1 ] , ( plen + 7 ) / 8 ) ; <vul-end> if ( plen % 8 ) { ( ( u_char * ) & route_target ) [ ( plen + 7 ) / 8 - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , buflen , \"origin AS: %s, route target %s\" , <vul-start> as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + 1 ) ) , <vul-end> bgp_vpn_rd_print ( ndo , ( u_char * ) & route_target ) ) ; return 5 + ( plen + 7 ) / 8 ; trunc : return - 2 ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> u_int plen ; char asbuf [ sizeof ( astostr ) ] ; <vul-start> - 1 ; ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <vul-start> ( pptr [ 5 <vul-end> ] , ( <vul-start> & pptr [ 5 <vul-end> ] , ( <vul-start> , \"origin AS: %s, route target %s\" , asbuf <vul-end> , bgp_vpn_rd_print (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> u_int plen ; if (! pptr [ 0 ] ||! buflen ) return - 1 ; <vul-start> - 1 ; if ( plen < 32 ) return - 1 ; <vul-start> ) ) ; if (! plen ) return - 1 ; <vul-start> / 8 ) ) ; if (! plen ) return - 1 <vul-start>, EXTRACT_32BITS ( pptr <vul-end> ) ),\n"
 },
 {
  "id": 341,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 <vul-start> static void consume_one_event ( unsigned cpu , <vul-end> struct evtchn_fifo_control_block * control_block , <vul-start> unsigned priority , unsigned long * ready , <vul-end> bool drop ) { struct evtchn_fifo_queue * q = & per_cpu ( cpu_queue , cpu ) ; uint32_t head ; evtchn_port_t port ; event_word_t * word ; head = q -> head [ priority ] ; if ( head == 0 ) { virt_rmb ( ) ; head = control_block -> head [ priority ] ; } port = head ; word = event_word_from_port ( port ) ; head = clear_linked ( word ) ; if ( head == 0 ) clear_bit ( priority , ready ) ; if ( evtchn_fifo_is_pending ( port ) && ! evtchn_fifo_is_masked ( port ) ) { <vul-start> if ( unlikely ( drop ) ) <vul-end> pr_warn ( \"Dropping pending event for port %u\\\\n\" , port ) ; else <vul-start> handle_irq_for_port ( port ) ; <vul-end> } q -> head [ priority ] = head ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <vul-start> long * ready <vul-end> ) { struct <vul-start> ( unlikely ( ! ctrl <vul-end> ) ) pr_warn <vul-start> handle_irq_for_port ( port , ctrl\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> void consume_one_event ( struct evtchn_loop_ctrl * ctrl, <vul-start> long * ready <vul-end> ) { struct <vul-start> ) ) { struct evtchn_loop_ctrl * ctrl = & per_cpu ( ctrl, cpu ) ; <vul-start> ) ; else handle_irq_for_port_with_ctrl <vul-end> ( port )\n"
 },
 {
  "id": 342,
  "question": "CWE-347 Code Input Vulnerable Code Is: CWE-347 <vul-start> void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) { <vul-end> PointZZ_p R0 , R1 , tmp ; mpz_inits ( R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; mpz_init_set ( R0 . x , point -> x ) ; mpz_init_set ( R0 . y , point -> y ) ; pointZZ_pDouble ( & R1 , point , curve ) ; int dbits = mpz_sizeinbase ( scalar , 2 ) , i ; for ( i = dbits - 2 ; i >= 0 ; i -- ) { if ( mpz_tstbit ( scalar , i ) ) { mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pAdd ( & R0 , & R1 , & tmp , curve ) ; mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pDouble ( & R1 , & tmp , curve ) ; } else { mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pAdd ( & R1 , & R0 , & tmp , curve ) ; mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pDouble ( & R0 , & tmp , curve ) ; } }",
  "golden_answers": [
   "CWE-347 Fixed Code Lines are: <vul-start> curve ) { if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }\n"
  ],
  "generated_answer": "CWE-347 Fixed Code Lines are: <vul-start> curve ) { if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }\n"
 },
 {
  "id": 343,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; <vul-start> cstate = 0 ; <vul-end> if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { <vul-start> return - 1 ; <vul-end> } <vul-start> if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || <vul-end> ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( \"all tiles are outside the image area\\\\n\" ) ; return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> uint_fast8_t tmp ; siz -> comps = 0 ; <vul-start> ) ) { goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( \"reference grid cannot have zero area\\\\n\" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( \"tile cannot have zero area\\\\n\" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( \"number of components not in permissible range\\\\n\" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( \"XOsiz not in permissible range\\\\n\" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( \"YOsiz not in permissible range\\\\n\" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( \"XTOsiz not in permissible range\\\\n\" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( \"YTOsiz not in permissible range\\\\n\" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( \"invalid XRsiz value %d\\\\n\" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( \"invalid YRsiz value %d\\\\n\" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <vul-start> 1 ; } <vul-end>      \n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> uint_fast8_t tmp ; jas_matind_t tmp_x ; jas_matind_t tmp_y ; <vul-start> ) ) { goto error <vul-end> ; } if <vul-start> siz -> height ) { goto error ; } if ( siz -> tilewidth == 0 || siz -> tileheight == 0 || siz -> tilexoff > 255 || siz -> tileheight == 0\n"
 },
 {
  "id": 344,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 gstrings_ret * get_strings_2_svc ( gstrings_arg * arg , struct svc_req * rqstp ) { static gstrings_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , <vul-end> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gstrings_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( \"kadm5_get_strings\" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_strings ( ( void * ) handle , arg -> princ , & ret . strings , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle ->",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : <vul-start> service_name ) ; <vul-end> free_server_handle ( handle\n"
 },
 {
  "id": 345,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int rpc_type_of_NPNVariable ( int variable ) { int type ; switch ( variable ) { case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : <vul-start> case NPNVSupportsWindowless : <vul-end> type = RPC_TYPE_BOOLEAN ; break ; case NPNVToolkit : case NPNVnetscapeWindow : type = RPC_TYPE_UINT32 ; break ; case NPNVWindowNPObject : case NPNVPluginElementNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling :\n"
 },
 {
  "id": 346,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 struct sctp_chunk * sctp_inq_pop ( struct sctp_inq * queue ) { struct sctp_chunk * chunk ; sctp_chunkhdr_t * ch = NULL ; if ( ( chunk = queue -> in_progress ) ) { if ( chunk -> singleton || chunk -> end_of_packet || chunk -> pdiscard ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } else { ch = ( sctp_chunkhdr_t * ) chunk -> chunk_end ; skb_pull ( chunk -> skb , chunk -> chunk_end - chunk -> skb -> data ) ; <vul-start> if ( skb_headlen ( chunk -> skb ) < sizeof ( sctp_chunkhdr_t ) ) { <vul-end> sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; } } } if ( ! chunk ) { struct list_head * entry ; if ( list_empty ( & queue -> in_chunk_list ) ) return NULL ; entry = queue -> in_chunk_list . next ; chunk = queue -> in_progress = list_entry ( entry , struct sctp_chunk , list ) ; list_del_init ( entry ) ; chunk -> singleton = 1 ; ch = ( sctp_chunkhdr_t * ) chunk -> skb -> data ; chunk -> data_accepted = 0 ; } chunk -> chunk_hdr = ch ; chunk -> chunk_end = ( ( __u8 * ) ch ) + WORD_ROUND ( ntohs ( ch -> length ) ) ; if ( unlikely ( skb_is_nonlinear ( chunk -> skb ) ) ) { if ( chunk -> chunk_end > skb_tail_pointer ( chunk -> skb ) ) chunk -> chunk_end = skb_tail_pointer ( chunk -> skb",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> data ) ; <vul-end> } } if <vul-start> chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <vul-start> ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( \"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\\\n\" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <vul-end> chunk ; }\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ; if ( skb_mac_header_len <vul-end> ( chunk -> <vul-start> ) ) { sctp_chunk_free ( chunk ) ; chunk = queue -> in_progress = NULL ; return NULL ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( \"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\\\n\", chunk, sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ), ntohs ( chunk -> chunk_hdr -> length ), chunk -> skb -> len ) ; <vul-start> ) ) { <vul-end> chunk = queue\n"
 },
 {
  "id": 347,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , \"sorbo\" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( \"Inet check by %s %d\\\\n\" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; <vul-start> last_id = ntohs ( * pid ) ; <vul-end> if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( \"Got packet %d %d\" , last_id , plen ) ; if ( is_dup (",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> - 2 ; if ( plen < 0 ) return 0 ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> - 2 ; if ( plen < 2 ) return 1 ;\n"
 },
 {
  "id": 348,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int squidclamav_check_preview_handler ( char * preview_data , int preview_data_len , ci_request_t * req ) { ci_headers_list_t * req_header ; struct http_info httpinf ; av_req_data_t * data = ci_service_data ( req ) ; char * clientip ; struct hostent * clientname ; unsigned long ip ; char * username ; char * content_type ; ci_off_t content_length ; char * chain_ret = NULL ; char * ret = NULL ; int chkipdone = 0 ; ci_debug_printf ( 1 , \"DEBUG squidclamav_check_preview_handler: processing preview header.\\\\n\" ) ; if ( preview_data_len ) ci_debug_printf ( 1 , \"DEBUG squidclamav_check_preview_handler: preview data size is %d\\\\n\" , preview_data_len ) ; if ( ( req_header = ci_http_request_headers ( req ) ) == NULL ) { ci_debug_printf ( 0 , \"ERROR squidclamav_check_preview_handler: bad http header, aborting.\\\\n\" ) ; return CI_ERROR ; } if ( ( username = ci_headers_value ( req -> request_header , \"X-Authenticated-User\" ) ) != NULL ) { ci_debug_printf ( 2 , \"DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\\\\n\" , username ) ; if ( simple_pattern_compare ( username , TRUSTUSER ) == 1 ) { ci_debug_printf ( 1 , \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTUSER match) for user: %s\\\\n\" , username ) ; return CI_MOD_ALLOW204 ; } } else { username = ( char * ) malloc ( sizeof ( char ) * 2 ) ; strcpy ( username , \"-\" ) ; } if ( ( clientip = ci_headers_value ( req -> request_header , \"X-Client-IP\" ) ) != NULL ) { ci_debug_printf ( 2 , \"DEBUG squidclamav_check_preview_handler: X-Client-IP: %s\\\\n\" , clientip ) ; ip = inet_addr ( clientip ) ; chkipdone =",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 1 ) { char * rbuff = NULL ; <vul-start> method ) ; rbuff = replace ( httpinf . url , \"%\" , \"%25\" ) ; <vul-start> , \"%s %s %s %s\\\\n\" , rbuff <vul-end> , clientip , <vul-start> fflush ( sgfpw ) ; xfree ( rbuff\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 1 ) { if ( simple_pattern_compare ( httpinf. url, ABORT ) == 1 ) { ci_debug_printf ( 1, \"DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\\\\n\", httpinf. url ) ; if ( logredir ) ci_debug_printf ( 0, \"INFO Chained program redirection received: %s\\\\n\", httpinf. url ) ; return CI_MOD_ALLOW204 ; } } else { <vul-start> method ) ; } <vul-start> ( sgfpw ) ; if ( simple_pattern_compare ( httpinf. url, ABORT ) == 1 ) { ci_debug_printf ( 1, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\\\n\", squidguard ) ; ci_debug_printf ( 2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\\\n\", httpinf. url, clientip, username, httpinf. method ) ; fprintf ( sgfpw, \"%s %s %s %s %s\\\\n\", httpinf. url, clientip, username, httpinf. method ) ; fflush ( sgfpw ) ; } else { ci_debug_printf ( 2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\\\n\", httpinf. url, clientip, username, httpinf. method ) ; }\n"
 },
 {
  "id": 349,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void r_bin_dwarf_dump_debug_info ( FILE * f , const RBinDwarfDebugInfo * inf ) { size_t i , j , k ; RBinDwarfDIE * dies ; RBinDwarfAttrValue * values ; if ( ! inf || ! f ) { return ; } for ( i = 0 ; i < inf -> length ; i ++ ) { fprintf ( f , \" Compilation Unit @ offset 0x%\" PFMT64x \":\\\\n\" , inf -> comp_units [ i ] . offset ) ; fprintf ( f , \" Length: 0x%x\\\\n\" , inf -> comp_units [ i ] . hdr . length ) ; fprintf ( f , \" Version: %d\\\\n\" , inf -> comp_units [ i ] . hdr . version ) ; fprintf ( f , \" Abbrev Offset: 0x%x\\\\n\" , inf -> comp_units [ i ] . hdr . abbrev_offset ) ; fprintf ( f , \" Pointer Size: %d\\\\n\" , inf -> comp_units [ i ] . hdr . pointer_size ) ; dies = inf -> comp_units [ i ] . dies ; for ( j = 0 ; j < inf -> comp_units [ i ] . length ; j ++ ) { fprintf ( f , \" Abbrev Number: %\" PFMT64u \" \" , dies [ j ] . abbrev_code ) ; if ( dies [ j ] . tag && dies [ j ] . tag <= DW_TAG_volatile_type && dwarf_tag_name_encodings [ dies [ j ] . tag ] ) { fprintf ( f , \"(%s)\\\\n\" , dwarf_tag_name_encodings [ dies [ j ] . tag ] ) ; } else { fprintf (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> . name ) { continue ; } <vul-end> if ( values\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ]. name ||! values [ k ]. name\n"
 },
 {
  "id": 350,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int irda_recvmsg_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied = 0 ; int target , err ; long timeo ; IRDA_DEBUG ( 3 , \"%s()\\\\n\" , __func__ ) ; if ( ( err = sock_error ( sk ) ) < 0 ) return err ; if ( sock -> flags & __SO_ACCEPTCON ) return - EINVAL ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; err = 0 ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , noblock ) ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> do { int chunk ; struct sk_buff * skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( skb == NULL ) { DEFINE_WAIT ( wait ) ; err = 0 ; if ( copied >= target ) break ; prepare_to_wait_exclusive ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; err = sock_error ( sk ) ; if ( err ) ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) ; else if ( noblock ) err = - EAGAIN ; else if ( signal_pending ( current ) ) err = sock_intr_errno ( timeo ) ; else if ( sk -> sk_state != TCP_ESTABLISHED ) err = -",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> noblock ) ; <vul-end> do { int\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> noblock ) ; <vul-end> do { int\n"
 },
 {
  "id": 351,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 static unsigned int do_encrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , <vul-start> encT ) ; <vul-end> # elif defined ( USE_ARM_ASM ) <vul-start> return _gcry_aes_arm_encrypt_block ( ctx -> keyschenc , bx , ax , ctx -> rounds , encT ) ; <vul-end> # else return do_encrypt_fn ( ctx , bx , ax ) ; # endif }",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> -> rounds , enc_tables . T <vul-end> ) ; # <vul-start> -> rounds , enc_tables . T <vul-end> ) ; #\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> -> rounds, ctx -> tfm. T <vul-end> ) ; # <vul-start> -> rounds, ctx -> tfm.\n"
 },
 {
  "id": 352,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 PHP_FUNCTION ( imagecrop ) { zval * IM ; gdImagePtr im ; gdImagePtr im_crop ; gdRect rect ; zval * z_rect ; zval * * tmp ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"ra\" , & IM , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , \"Image\" , le_gd ) ; if ( zend_hash_find ( HASH_OF ( z_rect ) , \"x\" , sizeof ( \"x\" ) , ( void * * ) & tmp ) != FAILURE ) { <vul-start> rect . x = Z_LVAL_PP ( tmp ) ; <vul-end> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Missing x position\" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , \"y\" , sizeof ( \"x\" ) , ( void * * ) & tmp ) != FAILURE ) { <vul-start> rect . y = Z_LVAL_PP ( tmp ) ; <vul-end> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Missing y position\" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , \"width\" , sizeof ( \"width\" ) , ( void * * ) & tmp ) != FAILURE ) { <vul-start> rect . width = Z_LVAL_PP ( tmp ) ; <vul-end> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Missing width\" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , \"height\" , sizeof ( \"height\" ) , ( void * * ) & tmp ) != FAILURE )",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <vul-start> . x = Z_LVAL ( lval ) ; } else { rect . x = <vul-start> tmp ) ; } <vul-start> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <vul-start> . y = Z_LVAL ( lval ) ; } else { rect . y = <vul-start> tmp ) ; } <vul-start> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <vul-start> . width = Z_LVAL ( lval ) ; } else { rect . width = <vul-start> tmp ) ; } <vul-start> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <vul-start> . height = Z_LVAL ( lval ) ; } else { rect . height = <vul-start> tmp ) ; }\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start>. x = Z_LVAL <vul-end> ( tmp ) <vul-start>. y = Z_LVAL <vul-end> ( tmp ) <vul-start>. width = Z_LVAL <vul-end> ( tmp ) <vul-start>. height = Z_LVAL <vul-end> ( tmp )\n"
 },
 {
  "id": 353,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { PicContext * s = avctx -> priv_data ; AVFrame * frame = data ; uint32_t * palette ; int bits_per_plane , bpp , etype , esize , npal , pos_after_pal ; int i , x , y , plane , tmp , ret , val ; bytestream2_init ( & s -> g , avpkt -> data , avpkt -> size ) ; if ( bytestream2_get_bytes_left ( & s -> g ) < 11 ) return AVERROR_INVALIDDATA ; if ( bytestream2_get_le16u ( & s -> g ) != 0x1234 ) return AVERROR_INVALIDDATA ; s -> width = bytestream2_get_le16u ( & s -> g ) ; s -> height = bytestream2_get_le16u ( & s -> g ) ; bytestream2_skip ( & s -> g , 4 ) ; tmp = bytestream2_get_byteu ( & s -> g ) ; bits_per_plane = tmp & 0xF ; s -> nb_planes = ( tmp >> 4 ) + 1 ; bpp = bits_per_plane * s -> nb_planes ; if ( bits_per_plane > 8 || bpp < 1 || bpp > 32 ) { avpriv_request_sample ( avctx , \"Unsupported bit depth\" ) ; return AVERROR_PATCHWELCOME ; } if ( bytestream2_peek_byte ( & s -> g ) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8 ) { bytestream2_skip ( & s -> g , 2 ) ; etype = bytestream2_get_le16 ( & s -> g ) ; esize = bytestream2_get_le16 ( & s -> g )",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> avctx -> width || <vul-end> s -> height\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; if ( avctx -> pix_fmt == AV_PIX_FMT_PAL16 && s -> width > 255 && s -> height > 255 ) { avpriv_request_sample ( avctx, \"Invalid image size\" ) ; return AVERROR_PATCHWELCOME ; } if (\n"
 },
 {
  "id": 354,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 ssize_t socket_write_and_transfer_fd ( const socket_t * socket , const void * buf , size_t count , int fd ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; if ( fd == INVALID_FD ) return socket_write ( socket , buf , count ) ; struct msghdr msg ; struct iovec iov ; char control_buf [ CMSG_SPACE ( sizeof ( int ) ) ] ; iov . iov_base = ( void * ) buf ; iov . iov_len = count ; msg . msg_iov = & iov ; msg . msg_iovlen = 1 ; msg . msg_control = control_buf ; msg . msg_controllen = sizeof ( control_buf ) ; msg . msg_name = NULL ; msg . msg_namelen = 0 ; struct cmsghdr * header = CMSG_FIRSTHDR ( & msg ) ; header -> cmsg_level = SOL_SOCKET ; header -> cmsg_type = SCM_RIGHTS ; header -> cmsg_len = CMSG_LEN ( sizeof ( int ) ) ; * ( int * ) CMSG_DATA ( header ) = fd ; <vul-start> ssize_t ret = sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ; <vul-end> close ( fd ) ; return ret ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ssize_t ret = TEMP_FAILURE_RETRY ( <vul-start> msg , MSG_DONTWAIT )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ssize_t ret = TEMP_FAILURE_RETRY ( <vul-start>, MSG_DONTWAIT ) )\n"
 },
 {
  "id": 355,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int sock_send_all ( int sock_fd , const uint8_t * buf , int len ) { int s = len ; int ret ; while ( s ) { <vul-start> do ret = send ( sock_fd , buf , s , 0 ) ; <vul-end> while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( \"sock fd:%d send errno:%d, ret:%d\" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; s -= ret ; } return len ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> do ret = TEMP_FAILURE_RETRY ( <vul-start> s , 0 )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> do ret = TEMP_FAILURE_RETRY ( <vul-start> s, 0 )\n"
 },
 {
  "id": 356,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void isakmp_rfc3948_print ( netdissect_options * ndo , const u_char * bp , u_int length , const u_char * bp2 ) { <vul-start> if ( length == 1 && bp [ 0 ] == 0xff ) { <vul-end> ND_PRINT ( ( ndo , \"isakmp-nat-keep-alive\" ) ) ; return ; } if ( length < 4 ) { goto trunc ; <vul-start> } <vul-end> if ( bp [ 0 ] == 0 && bp [ 1 ] == 0 && bp [ 2 ] == 0 && bp [ 3 ] == 0 ) { ND_PRINT ( ( ndo , \"NONESP-encap: \" ) ) ; isakmp_print ( ndo , bp + 4 , length - 4 , bp2 ) ; return ; } { int nh , enh , padlen ; int advance ; ND_PRINT ( ( ndo , \"UDP-encap: \" ) ) ; advance = esp_print ( ndo , bp , length , bp2 , & enh , & padlen ) ; if ( advance <= 0 ) return ; bp += advance ; length -= advance + padlen ; nh = enh & 0xff ; ip_print_inner ( ndo , bp , length , nh , bp2 ) ; return ; } trunc : ND_PRINT ( ( ndo , \"[|isakmp]\" ) ) ; return ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> bp2 ) { ND_TCHECK ( bp [ 0 ] ) ; <vul-start> trunc ; } ND_TCHECK ( bp [ 3 ] ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> bp2 ) { int isakmp_tstr = <vul-end> bp [ 0 <vul-start> ] == 0xff ; <vul-end> if ( length <vul-start> trunc ; } if ( isakmp_tstr == 1 ) { ND_PRINT ( ( ndo, \"[|isakmp]\" ) ) ; return ; }\n"
 },
 {
  "id": 357,
  "question": "CWE-444 Code Input Vulnerable Code Is: CWE-444 static void add_header_value ( VALUE hh , const char * key , int klen , const char * val , int vlen ) { <vul-start> if ( sizeof ( content_type ) - 1 == klen && 0 == strncasecmp ( key , content_type , sizeof ( content_type ) - 1 ) ) { <vul-end> <vul-start> rb_hash_aset ( hh , content_type_val , rb_str_new ( val , vlen ) ) ; <vul-end> } else if ( sizeof ( content_length ) - 1 == klen && 0 == strncasecmp ( key , content_length , sizeof ( content_length ) - 1 ) ) { <vul-start> rb_hash_aset ( hh , content_length_val , rb_str_new ( val , vlen ) ) ; <vul-end> } else { char hkey [ 1024 ] ; char * k = hkey ; volatile VALUE sval = rb_str_new ( val , vlen ) ; <vul-start> strcpy ( hkey , \"HTTP_\" ) ; <vul-end> k = hkey + 5 ; if ( ( int ) ( sizeof ( hkey ) - 5 ) <= klen ) { klen = sizeof ( hkey ) - 6 ; } strncpy ( k , key , klen ) ; hkey [ klen + 5 ] = '\\\\0' ; for ( k = hkey + 5 ; '\\\\0' != * k ; k ++ ) { if ( '-' == * k ) { * k = '_' ; } else { * k = toupper ( * k ) ; } } <vul-start> rb_hash_aset ( hh , rb_str_new ( hkey , klen + 5 ) , sval ) ; <vul-end> <vul-start>",
  "golden_answers": [
   "CWE-444 Fixed Code Lines are: <vul-start> vlen ) { VALUE v ; <vul-start> ) ) { if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_type_val , Qnil ) ) ) { <vul-start> ) ) ; } else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , rb_str_new ( val , vlen ) ) ; rb_hash_aset ( hh , content_type_val , a ) ; } <vul-start> ) ) { if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_length_val , Qnil ) ) ) { <vul-start> ) ) ; } else { rb_raise ( rb_eArgError , \"Multiple Content-Length headers.\" ) ; } <vul-start> vlen ) ; volatile VALUE kval ; <vul-start> ; } } kval = <vul-end> rb_str_new ( hkey <vul-start> + 5 ) ; if ( Qnil == ( v = rb_hash_lookup2 ( hh , kval , Qnil ) ) ) { rb_hash_aset ( hh , kval <vul-start> ) ; } else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , sval ) ; rb_hash_aset ( hh , kval , a ) ; } }\n"
  ],
  "generated_answer": "CWE-444 Fixed Code Lines are: <vul-start> vlen ) { VALUE sval ; int ret ; <vul-start> ) ) { ret = <vul-start> ) ) { ret = <vul-start> vlen ) ; } else { char hkey [ 1024 ] ; char * k = hkey ; volatile VALUE sval ; if ( ( int ) ( sizeof ( hkey ) - 5 ) <= klen ) { klen = sizeof ( hkey ) - 6 ; } strncpy ( k, key, klen ) ; hkey [ klen + 5 ] = '\\\\0' ; for ( k = hkey + 5 ; '\\\\0'!= * k ) { if ( '-' == * k ) { * k = '_' ; } else { * k = toupper ( * k ) ; } } <vul-start> ; } } if ( ret == RTEST_OK ) { sval = rb_str_new ( val, vlen ) ; } <vul-start> sval ) ; if ( ret == RTEST_OK ) { rb_hash_aset ( hh, content_type_val, sval ) ; } else { rb_hash_aset ( hh, content_length_val, rb_str_new ( val, vlen ) ) ; }\n"
 },
 {
  "id": 358,
  "question": "CWE-908 Code Input Vulnerable Code Is: CWE-908 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <vul-start> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <vul-end> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; PixelPacket * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ;",
  "golden_answers": [
   "CWE-908 Fixed Code Lines are: <vul-start> , tag ) \\\\\\n{ <vul-end> if ( palette <vul-start> tag ) ; \\\\\\n} <vul-end> Image * image <vul-start> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;\n"
  ],
  "generated_answer": "CWE-908 Fixed Code Lines are: <vul-start>, tag ) \\\\\\n{ <vul-end> if ( palette <vul-start> tag ) ; \\\\\\n} <vul-end> Image * image <vul-start> goto NoMemory ; ( void ) memset ( BImgBuff, 0, ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;\n"
 },
 {
  "id": 359,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static ssize_t _archive_write_data ( struct archive * _a , const void * buff , size_t s ) { struct archive_write * a = ( struct archive_write * ) _a ; <vul-start> archive_check_magic ( & a -> archive , ARCHIVE_WRITE_MAGIC , <vul-end> <vul-start> ARCHIVE_STATE_DATA , \"archive_write_data\" ) ; <vul-end> archive_clear_error ( & a -> archive ) ; return ( ( a -> format_write_data ) ( a , buff , s ) ) ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> ) _a ; const size_t max_write = INT_MAX ; <vul-start> , \"archive_write_data\" ) ; if ( s > max_write ) s = max_write\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ) _a ; if (! a -> format_write_data ) { archive_set_error ( & a -> archive, ARCHIVE_STATE_ERROR, \"archive_write_data\" ) ; return - 1 ; } <vul-start>, \"archive_write_data\" ) <vul-end> ; return (\n"
 },
 {
  "id": 360,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( 0 == u2_width || 0 == u2_height ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_FRM_HDR_DECODE_ERR ; return e_error ; } if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; <vul-start> if ( 0 == ps_dec -> u4_frm_buf_stride ) <vul-end> { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( 0 == ps_dec -> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } <vul-start> else if ( ( u2_width > ps_dec -> u2_create_max_width ) <vul-end> <vul-start> || ( u2_height > ps_dec -> u2_create_max_height ) ) <vul-end> { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec ->",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> = u2_height ; } else { <vul-start> == ps_dec -> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } else if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error <vul-end> ; } else <vul-start> if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH <vul-end> ) || ( <vul-start> ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS <vul-end> ; } else <vul-start> ; return e_error ; } if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> = u2_height ; <vul-end> } else { <vul-start> if ( ( ( UWORD16 ) <vul-start> > ps_dec -> u2_create_max_height <vul-end> ) || ( <vul-start> || ( u2_width < ( UWORD16 ) <vul-end> ps_dec -> u2_create_max_width <vul-start> ps_dec -> u2_create_max_width <vul-end> ) { return <vul-start> } ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; } else { if ( 0 == ps_dec -> <vul-start> IMPEG2D_FRM_HDR_DECODE_ERR ; } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream, 4 ) ; ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream, 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; ps_dec -> u2_reinit_max_height = u2_height ; return IMPEG2D_FRM_HDR_DECODE_OK ; }\n"
 },
 {
  "id": 361,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int StreamTcpPacketStateSynSent ( ThreadVars * tv , Packet * p , StreamTcpThread * stt , TcpSession * ssn , PacketQueue * pq ) { if ( ssn == NULL ) return - 1 ; SCLogDebug ( \"ssn %p: pkt received: %s\" , ssn , PKT_IS_TOCLIENT ( p ) ? \"toclient\" : \"toserver\" ) ; <vul-start> if ( p -> tcph -> th_flags & TH_RST ) { <vul-end> if ( ! StreamTcpValidateRst ( ssn , p ) ) return - 1 ; if ( PKT_IS_TOSERVER ( p ) ) { if ( SEQ_EQ ( TCP_GET_SEQ ( p ) , ssn -> client . isn ) && SEQ_EQ ( TCP_GET_WINDOW ( p ) , 0 ) && SEQ_EQ ( TCP_GET_ACK ( p ) , ( ssn -> client . isn + 1 ) ) ) { SCLogDebug ( \"ssn->server.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\" ) ; ssn -> server . flags |= STREAMTCP_STREAM_FLAG_RST_RECV ; StreamTcpPacketSetState ( p , ssn , TCP_CLOSED ) ; SCLogDebug ( \"ssn %p: Reset received and state changed to \" \"TCP_CLOSED\" , ssn ) ; } } else { ssn -> client . flags |= STREAMTCP_STREAM_FLAG_RST_RECV ; SCLogDebug ( \"ssn->client.flags |= STREAMTCP_STREAM_FLAG_RST_RECV\" ) ; StreamTcpPacketSetState ( p , ssn , TCP_CLOSED ) ; SCLogDebug ( \"ssn %p: Reset received and state changed to \" \"TCP_CLOSED\" , ssn ) ; } } else if ( p -> tcph -> th_flags & TH_FIN ) { } else if ( ( p -> tcph -> th_flags & ( TH_SYN | TH_ACK ) ) == ( TH_SYN | TH_ACK ) ) { if ( ( ssn -> flags &",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; if ( StateSynSentValidateTimestamp ( ssn , p ) == false ) return - 1 ; if (\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if (! StreamTcpPacketIsConnected ( p ) ) return - 1 ; if (\n"
 },
 {
  "id": 362,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 static int pad_basic ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t pad = 0 ; <vul-start> int result = RLC_OK ; <vul-end> bn_t t ; RLC_TRY { bn_null ( t ) ; bn_new ( t ) ; switch ( operation ) { case RSA_ENC : case RSA_SIG : case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; bn_lsh ( m , m , m_len * 8 ) ; break ; case RSA_DEC : case RSA_VER : case RSA_VER_HASH : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; <vul-start> if ( ! bn_is_zero ( t ) ) { <vul-end> <vul-start> result = RLC_ERR ; <vul-end> } * p_len = 1 ; do { ( * p_len ) ++ ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad == 0 && m_len > 0 ) ; <vul-start> if ( pad != RSA_PAD ) { <vul-end> <vul-start> result = RLC_ERR ; <vul-end> } bn_mod_2b ( m , m , ( k_len - * p_len ) * 8 ) ; <vul-start> break ; <vul-end> } } RLC_CATCH_ANY { result = RLC_ERR ; } RLC_FINALLY { bn_free ( t ) ; } return result ; }",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> int result = RLC_ERR ; bn_t t ; RLC_TRY { bn_null ( t ) ; bn_new ( t ) ; switch ( operation ) { case RSA_ENC : case RSA_SIG : case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK <vul-end> ; break ; <vul-start> ; if ( <vul-end> bn_is_zero ( t <vul-start> ) ) { <vul-end> * p_len = <vul-start> if ( pad == <vul-end> RSA_PAD ) { <vul-start> { result = RLC_OK <vul-end> ; } bn_mod_2b <vul-start> 8 ) ; }\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> int result = RLC_ERR <vul-end> ; bn_t t <vul-start> ; if ( <vul-end> bn_is_zero ( t <vul-start> ) ) { <vul-end> * p_len = <vul-start> if ( pad == <vul-end> RSA_PAD ) { <vul-start> RSA_PAD ) { <vul-end> bn_mod_2b ( m <vul-start> 8 ) ; } else { result = RLC_OK ; }\n"
 },
 {
  "id": 363,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void usage_exit ( ) { <vul-end> fprintf ( stderr , \"Usage: %s <infile> <outfile>\\\\n\" , exec_name ) ; exit ( EXIT_FAILURE ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> void usage_exit ( void\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void usage_exit ( void\n"
 },
 {
  "id": 364,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void __xml_acl_post_process ( xmlNode * xml ) { xmlNode * cIter = __xml_first_child ( xml ) ; xml_private_t * p = xml -> _private ; if ( is_set ( p -> flags , xpf_created ) ) { xmlAttr * xIter = NULL ; <vul-start> for ( xIter = crm_first_attr ( xml ) ; xIter != NULL ; xIter = xIter -> next ) { <vul-end> const char * prop_name = ( const char * ) xIter -> name ; <vul-start> if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 ) { <vul-end> continue ; } else if ( __xml_acl_check ( xml , NULL , xpf_acl_write ) ) { crm_trace ( \"Creation of %s=%s is allowed\" , crm_element_name ( xml ) , ID ( xml ) ) ; break ; } else { <vul-start> char * path = xml_get_path ( xml ) ; <vul-end> crm_trace ( \"Cannot add new node %s at %s\" , crm_element_name ( xml ) , path ) ; if ( xml != xmlDocGetRootElement ( xml -> doc ) ) { xmlUnlinkNode ( xml ) ; xmlFreeNode ( xml ) ; } free ( path ) ; return ; } } <vul-start> } <vul-end> while ( cIter != NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; __xml_acl_post_process ( child ) ; } }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> = NULL ; char * path = xml_get_path ( xml ) ; <vul-start> ) == 0 && strstr ( path , \"/\" XML_CIB_TAG_ACLS \"/\" ) == NULL <vul-start> } else { <vul-end> crm_trace ( \"Cannot add new node %s at %s\" <vul-start> ; } } free ( path ) ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> = NULL ; char * path = xml_get_path ( xml ) ; <vul-start> ; if ( xIter == xml -> _private ) { continue ; } else if ( <vul-start>, XML_ATTR_ID )!= 0 ) { <vul-end> break ; } <vul-start> } else { <vul-end> crm_trace ( \"Cannot add new node %s at %s\" <vul-start> ; } } free ( path ) ;\n"
 },
 {
  "id": 365,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static rfbBool rfbSetClientColourMapBGR233 ( rfbClientPtr cl ) { <vul-start> char buf [ sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2 ] ; <vul-end> <vul-start> rfbSetColourMapEntriesMsg * scme = ( rfbSetColourMapEntriesMsg * ) buf ; <vul-end> <vul-start> uint16_t * rgb = ( uint16_t * ) ( & buf [ sz_rfbSetColourMapEntriesMsg ] ) ; <vul-end> int i , len ; int r , g , b ; if ( cl -> format . bitsPerPixel != 8 ) { rfbErr ( \"%s: client not 8 bits per pixel\\\\n\" , \"rfbSetClientColourMapBGR233\" ) ; rfbCloseClient ( cl ) ; return FALSE ; } scme -> type = rfbSetColourMapEntries ; scme -> firstColour = Swap16IfLE ( 0 ) ; scme -> nColours = Swap16IfLE ( 256 ) ; len = sz_rfbSetColourMapEntriesMsg ; i = 0 ; for ( b = 0 ; b < 4 ; b ++ ) { for ( g = 0 ; g < 8 ; g ++ ) { for ( r = 0 ; r < 8 ; r ++ ) { rgb [ i ++ ] = Swap16IfLE ( r * 65535 / 7 ) ; rgb [ i ++ ] = Swap16IfLE ( g * 65535 / 7 ) ; rgb [ i ++ ] = Swap16IfLE ( b * 65535 / 3 ) ; } } } len += 256 * 3 * 2 ; <vul-start> if ( rfbWriteExact ( cl , buf , len ) < 0 ) { <vul-end> rfbLogPerror ( \"rfbSetClientColourMapBGR233: write\" ) ; rfbCloseClient ( cl ) ; return FALSE ; } return TRUE ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> cl ) { union { char bytes <vul-end> [ sz_rfbSetColourMapEntriesMsg + <vul-start> ] ; rfbSetColourMapEntriesMsg msg ; } buf ; rfbSetColourMapEntriesMsg * scme = & buf . msg <vul-end> ; uint16_t * <vul-start> ( & buf . bytes <vul-start> cl , buf . bytes\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> cl ) { const <vul-start> 2 ] ; const <vul-start> ) buf ; const <vul-start> uint16_t * ) buf <vul-end> ; int i <vul-start> * 2 ; buf [ len ] = 0 ;\n"
 },
 {
  "id": 366,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = \"\" ; const char * link_section_name = \"\" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( ( int ) shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( \"Warning: Cannot allocate memory (Check Elf_(Verdef))\\\\n\" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , \"section_name\" , section_name , 0 ) ; sdb_num_set ( sdb , \"entries\" , shdr -> sh_info ,",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> + i ; size_t vstart_off = i ; <vul-start> < 1 || shdr -> sh_size - vstart_off < vdaux <vul-end> ) { sdb_free <vul-start> ; } vstart += vdaux ; vstart_off <vul-start> . vda_next ; vstart_off += aux . vda_next ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> char key [ 64 <vul-end> ] = { <vul-start> out_error ; } int vdaux = verdef -> vd_aux ; if ( vdaux < 1 || vstart + vdaux < vstart <vul-end> ) { sdb_free <vul-start> vdaux < vstart || vstart + vdaux < vstart <vul-start> out_error ; } int vdaux = verdef -> vd_aux ; if ( vdaux < 1 || vstart + vdaux < vstart <vul-end> ) { sdb_free <vul-start> out_error ; } vstart += vdaux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <vul-start> > end || vstart + vdaux < vstart <vul-end> ) { sdb_free\n"
 },
 {
  "id": 367,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 void flush_tlb_mm_range ( struct mm_struct * mm , unsigned long start , unsigned long end , unsigned long vmflag ) { unsigned long addr ; unsigned long base_pages_to_flush = TLB_FLUSH_ALL ; preempt_disable ( ) ; <vul-start> if ( current -> active_mm != mm ) <vul-end> <vul-start> goto out ; <vul-end> if ( ! current -> mm ) { leave_mm ( smp_processor_id ( ) ) ; <vul-start> goto out ; <vul-end> } if ( ( end != TLB_FLUSH_ALL ) && ! ( vmflag & VM_HUGETLB ) ) base_pages_to_flush = ( end - start ) >> PAGE_SHIFT ; if ( base_pages_to_flush > tlb_single_page_flush_ceiling ) { base_pages_to_flush = TLB_FLUSH_ALL ; count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ALL ) ; local_flush_tlb ( ) ; } else { for ( addr = start ; addr < end ; addr += PAGE_SIZE ) { count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ONE ) ; __flush_tlb_single ( addr ) ; } } trace_tlb_flush ( TLB_LOCAL_MM_SHOOTDOWN , base_pages_to_flush ) ; out : if ( base_pages_to_flush == TLB_FLUSH_ALL ) { start = 0UL ; end = TLB_FLUSH_ALL ; } if ( cpumask_any_but ( mm_cpumask ( mm ) , smp_processor_id ( ) ) < nr_cpu_ids ) flush_tlb_others ( mm_cpumask ( mm ) , mm , start , end ) ; preempt_enable ( ) ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> != mm ) { smp_mb ( ) ; <vul-start> goto out ; } <vul-start> ) ) ; smp_mb ( ) ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ; if (! mmget_still_valid ( mm ) ) goto out ; if ( <vul-start>!= mm ) { leave_mm ( smp_processor_id ( ) ) ; <vul-start> goto out ; } <vul-start> ) ; goto out <vul-end> ; } if\n"
 },
 {
  "id": 368,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , size_t count , loff_t * fpos ) { struct oz_pd * pd ; struct oz_elt_buf * eb ; struct oz_elt_info * ei ; struct oz_elt * elt ; struct oz_app_hdr * app_hdr ; struct oz_serial_ctx * ctx ; <vul-start> spin_lock_bh ( & g_cdev . lock ) ; <vul-end> pd = g_cdev . active_pd ; if ( pd ) oz_pd_get ( pd ) ; spin_unlock_bh ( & g_cdev . lock ) ; if ( pd == NULL ) return - ENXIO ; if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) return - EAGAIN ; eb = & pd -> elt_buff ; ei = oz_elt_info_alloc ( eb ) ; if ( ei == NULL ) { count = 0 ; goto out ; } elt = ( struct oz_elt * ) ei -> data ; app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; elt -> length = sizeof ( struct oz_app_hdr ) + count ; elt -> type = OZ_ELT_APP_DATA ; ei -> app_id = OZ_APPID_SERIAL ; ei -> length = elt -> length + sizeof ( struct oz_elt ) ; app_hdr -> app_id = OZ_APPID_SERIAL ; if ( copy_from_user ( app_hdr + 1 , buf , count ) ) goto out ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; if ( ctx ) { app_hdr -> elt_seq_num = ctx -> tx_seq_num",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * ctx ; if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * ctx ; if ( g_cdev. disconnected ) return - EBUSY ;\n"
 },
 {
  "id": 369,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int f_midi_set_alt ( struct usb_function * f , unsigned intf , unsigned alt ) { struct f_midi * midi = func_to_midi ( f ) ; unsigned i ; int err ; if ( intf != midi -> ms_id ) return 0 ; err = f_midi_start_ep ( midi , f , midi -> in_ep ) ; if ( err ) return err ; err = f_midi_start_ep ( midi , f , midi -> out_ep ) ; if ( err ) return err ; while ( kfifo_avail ( & midi -> in_req_fifo ) ) { struct usb_request * req = midi_alloc_ep_req ( midi -> in_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> length = 0 ; req -> complete = f_midi_complete ; kfifo_put ( & midi -> in_req_fifo , req ) ; } for ( i = 0 ; i < midi -> qlen && err == 0 ; i ++ ) { struct usb_request * req = midi_alloc_ep_req ( midi -> out_ep , midi -> buflen ) ; if ( req == NULL ) return - ENOMEM ; req -> complete = f_midi_complete ; err = usb_ep_queue ( midi -> out_ep , req , GFP_ATOMIC ) ; if ( err ) { ERROR ( midi , \"%s: couldn\\'t enqueue request: %d\\\\n\" , midi -> out_ep -> name , err ) ; <vul-start> free_ep_req ( midi -> out_ep , req ) ; <vul-end> return err ; } } return 0 ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> err ) ; if ( req -> buf != NULL )\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> err ) ; if ( req!= midi -> in_req ) <vul-start> free_ep_req ( midi -> in_ep, req ) ; free_ep_req ( midi\n"
 },
 {
  "id": 370,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void server_real_connect ( SERVER_REC * server , IPADDR * ip , const char * unix_socket ) { GIOChannel * handle ; IPADDR * own_ip = NULL ; const char * errmsg ; char * errmsg2 ; char ipaddr [ MAX_IP_LEN ] ; int port ; g_return_if_fail ( ip != NULL || unix_socket != NULL ) ; signal_emit ( \"server connecting\" , 2 , server , ip ) ; if ( server -> connrec -> no_connect ) return ; if ( ip != NULL ) { own_ip = ip == NULL ? NULL : ( IPADDR_IS_V6 ( ip ) ? server -> connrec -> own_ip6 : server -> connrec -> own_ip4 ) ; port = server -> connrec -> proxy != NULL ? server -> connrec -> proxy_port : server -> connrec -> port ; handle = server -> connrec -> use_ssl ? <vul-start> net_connect_ip_ssl ( ip , port , own_ip , server -> connrec -> ssl_cert , server -> connrec -> ssl_pkey , <vul-end> server -> connrec -> ssl_cafile , server -> connrec -> ssl_capath , server -> connrec -> ssl_verify ) : net_connect_ip ( ip , port , own_ip ) ; } else { handle = net_connect_unix ( unix_socket ) ; } if ( handle == NULL ) { errmsg = g_strerror ( errno ) ; errmsg2 = NULL ; if ( errno == EADDRNOTAVAIL ) { if ( own_ip != NULL ) { net_ip2host ( own_ip , ipaddr ) ; errmsg2 = g_strconcat ( errmsg , \": \" , ipaddr , NULL ) ; } server -> no_reconnect = TRUE ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> , port , server -> connrec -> address ,\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> use_ssl? net_connect_ip_ssl <vul-end> ( ip,\n"
 },
 {
  "id": 371,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int rc_pick_q_and_bounds_one_pass_cbr ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { const VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; int active_best_quality ; int active_worst_quality = calc_active_worst_quality_one_pass_cbr ( cpi ) ; int q ; <vul-start> if ( frame_is_intra_only ( cm ) ) { <vul-end> active_best_quality = rc -> best_quality ; if ( rc -> this_key_frame_forced ) { int qindex = rc -> last_boosted_qindex ; <vul-start> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <vul-end> int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , <vul-start> ( last_boosted_q * 0.75 ) ) ; <vul-end> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; } else if ( cm -> current_video_frame > 0 ) { double q_adj_factor = 1.0 ; double q_val ; <vul-start> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <vul-end> <vul-start> rc -> kf_boost , <vul-end> kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ; if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) { q_adj_factor -= 0.25 ; } <vul-start> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <vul-end> active_best_quality += vp9_compute_qdelta ( rc , q_val , <vul-start> q_val * q_adj_factor ) ; <vul-end> } } else if ( ! rc -> is_src_frame_alt_ref && ! cpi -> use_svc && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) { q",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int q ; int * rtc_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , rtc_minq ) ; <vul-start> vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <vul-start> * 0.75 ) , cm -> bit_depth <vul-start> ; active_best_quality = get_kf_active_quality ( rc , <vul-end> rc -> avg_frame_qindex <vul-start> KEY_FRAME ] , cm -> bit_depth <vul-end> ) ; if <vul-start> vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <vul-start> q_val * q_adj_factor , cm -> bit_depth <vul-start> } active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <vul-end> ) ; } <vul-start> ) active_best_quality = rtc_minq <vul-end> [ rc -> <vul-start> else active_best_quality = rtc_minq <vul-end> [ active_worst_quality ] <vul-start> ) active_best_quality = rtc_minq <vul-end> [ rc -> <vul-start> else active_best_quality = rtc_minq <vul-end> [ active_worst_quality ] <vul-start> rc -> this_key_frame_forced && <vul-end> ! ( cm <vul-start> 0 ) ) { int qdelta = 0 ; vpx_clear_system_state ( ) ; qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <vul-end> ; } #\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int q ; int * inter_minq ; <vul-start> vp9_convert_qindex_to_q ( qindex, cm -> bit_depth <vul-start> last_boosted_q * 0.75, cm -> bit_depth <vul-start> ; active_best_quality = get_kf_active_quality ( rc, <vul-end> rc -> avg_frame_qindex <vul-start> KEY_FRAME ], cm -> bit_depth, <vul-start> vp9_convert_qindex_to_q ( active_best_quality, cm -> bit_depth <vul-start> q_val * q_adj_factor, cm -> bit_depth <vul-start> vp9_convert_qindex_to_q ( qindex, cm -> bit_depth <vul-start> int delta_qindex = vp9_compute_qdelta ( rc, last_boosted_q, ( last_boosted_q * 0.75, cm -> bit_depth ) ) ; active_worst_quality = MIN <vul-end> ( qindex + <vul-start> ( qindex + delta_qindex, rc -> best_quality ) ; } else { active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ], rc -> kf_boost, kf_low, kf_high, kf_low_motion_minq, kf_high_motion_minq ) ; } <vul-end> active_best_quality = clamp <vul-start> ; active_best_quality = get_kf_active_quality ( rc, <vul-end> rc -> avg_frame_qindex <vul-start> KEY_FRAME ], cm -> bit_depth, <vul-start> active_best_quality ) ; <vul-end> } # if <vul-start> LIMIT_QRANGE_FOR_ALTREF_AND_KEY if ( is_two_pass_svc ( cpi ) && <vul-end> cm -> frame_type <vul-start> frame_type == KEY_FRAME ) { int q = <vul-end> rc -> last_boosted_qindex <vul-start> last_boosted_qindex ; double last_boosted_q = vp9_convert_qindex_to_q ( qindex, cm -> bit_depth ) ; int delta_qindex = vp9_compute_qdelta ( rc, last_boosted_q, ( last_boosted_q * 0"
 },
 {
  "id": 372,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ; <vul-start> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <vul-end> CORE_MMU_USER_PARAM_SIZE ) ; <vul-start> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <vul-end> return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <vul-start> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <vul-end> uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> uaddr_t a ; uaddr_t end_addr = 0 ; <vul-start> len , & end_addr <vul-end> ) ) return <vul-start> ( a = ROUNDDOWN ( uaddr , addr_incr ) <vul-end> ; a < <vul-start> ; a < end_addr <vul-end> ; a +=\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> a ; size_t addr_aligned = 0 ; size_t add_size = 0 ; if ( len > CORE_MMU_USER_PARAM_SIZE ) return TEE_ERROR_INVALID_PARAMETER ; if ( flags & TEE_MEMORY_ACCESS_NONSECURE ) return TEE_ERROR_SECURE ; if ( flags & TEE_MEMORY_ACCESS_SECURE ) return TEE_ERROR_SECURE ; if ( flags & TEE_MEMORY_ACCESS_READ ) return TEE_ERROR_ACCESS_DENIED ; if ( flags & TEE_MEMORY_ACCESS_NONSECURE ) return TEE_ERROR_ACCESS_DENIED ; if ( flags & TEE_MEMORY_ACCESS_SECURE ) return TEE_ERROR_ACCESS_DENIED ; if ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) { if (! tee_mmu_is_vbuf_inside_ta_private ( utc, ( void * ) uaddr, len ) ) return TEE_ERROR_ACCESS_DENIED ; addr_aligned = MIN ( CORE_MMU_USER_CODE_SIZE, CORE_MMU_USER_PARAM_SIZE ) ; add_size = ADD_OVERFLOW ( uaddr, len, & add_size ) ; if ( add_size > len ) return TEE_ERROR_ACCESS_DENIED ; } <vul-start>, & a ) ) return TEE_ERROR_ACCESS_DENIED ; for ( a = uaddr ; a < ( uaddr + len ) ; a += add_size\n"
 },
 {
  "id": 373,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_slice ( void * _o ) { slice_ty o = ( slice_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } switch ( o -> kind ) { case Slice_kind : result = PyType_GenericNew ( Slice_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Slice . lower ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lower , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Slice . upper ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_upper , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Slice . step ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_step , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ExtSlice_kind : result = PyType_GenericNew ( ExtSlice_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . ExtSlice . dims , ast2obj_slice ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_dims , value ) ==",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } switch\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } switch\n"
 },
 {
  "id": 374,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int em_call_far ( struct x86_emulate_ctxt * ctxt ) { u16 sel , old_cs ; ulong old_eip ; int rc ; <vul-start> old_cs = get_segment_selector ( ctxt , VCPU_SREG_CS ) ; <vul-end> old_eip = ctxt -> _eip ; memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; <vul-start> if ( load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ) <vul-end> return X86EMUL_CONTINUE ; <vul-start> ctxt -> _eip = 0 ; <vul-end> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; ctxt -> src . val = old_eip ; return em_push ( ctxt ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> int rc ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <vul-end> , VCPU_SREG_CS ) <vul-start> , VCPU_SREG_CS ) <vul-end> ; memcpy ( <vul-start> 2 ) ; rc = __load_segment_descriptor <vul-end> ( ctxt , <vul-start> sel , VCPU_SREG_CS , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <vul-end> ) return X86EMUL_CONTINUE <vul-start> return X86EMUL_CONTINUE ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( ctxt, VCPU_SREG_CS ) ; if (! is_guest_mode ( ctxt ) ) return X86EMUL_CONTINUE <vul-end> ; memcpy ( <vul-start>, sel, VCPU_SREG_EIP <vul-end> ) ) return <vul-start> ; ctxt -> <vul-end> src. val\n"
 },
 {
  "id": 375,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 BITMAP_UPDATE * update_read_bitmap_update ( rdpUpdate * update , wStream * s ) { UINT32 i ; BITMAP_UPDATE * bitmapUpdate = calloc ( 1 , sizeof ( BITMAP_UPDATE ) ) ; if ( ! bitmapUpdate ) goto fail ; if ( Stream_GetRemainingLength ( s ) < 2 ) goto fail ; Stream_Read_UINT16 ( s , bitmapUpdate -> number ) ; WLog_Print ( update -> log , WLOG_TRACE , \"BitmapUpdate: %\" PRIu32 \"\" , bitmapUpdate -> number ) ; if ( bitmapUpdate -> number > bitmapUpdate -> count ) { <vul-start> UINT16 count ; <vul-end> BITMAP_DATA * newdata ; count = bitmapUpdate -> number * 2 ; <vul-start> newdata = ( BITMAP_DATA * ) realloc ( bitmapUpdate -> rectangles , <vul-end> sizeof ( BITMAP_DATA ) * count ) ; if ( ! newdata ) goto fail ; bitmapUpdate -> rectangles = newdata ; ZeroMemory ( & bitmapUpdate -> rectangles [ bitmapUpdate -> count ] , sizeof ( BITMAP_DATA ) * ( count - bitmapUpdate -> count ) ) ; bitmapUpdate -> count = count ; } for ( i = 0 ; i < bitmapUpdate -> number ; i ++ ) { if ( ! update_read_bitmap_data ( update , s , & bitmapUpdate -> rectangles [ i ] ) ) goto fail ; } return bitmapUpdate ; fail : free_bitmap_update ( update -> context , bitmapUpdate ) ; return NULL ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> count ) { UINT32 <vul-end> count = bitmapUpdate <vul-start> * 2 ; BITMAP_DATA *\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> count ) { UINT32 <vul-end> count ; BITMAP_DATA <vul-start> * 2 ; if ( count > sizeof ( BITMAP_DATA ) * count ) goto fail ;\n"
 },
 {
  "id": 376,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 grub_err_t grub_disk_read ( grub_disk_t disk , grub_disk_addr_t sector , grub_off_t offset , grub_size_t size , void * buf ) { char * tmp_buf ; unsigned real_offset ; if ( grub_disk_adjust_range ( disk , & sector , & offset , size ) != GRUB_ERR_NONE ) { grub_error_push ( ) ; grub_dprintf ( \"disk\" , \"Read out of range: sector 0x%llx (%s).\\\\n\" , ( unsigned long long ) sector , grub_errmsg ) ; grub_error_pop ( ) ; return grub_errno ; } real_offset = offset ; tmp_buf = grub_malloc ( GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS ) ; if ( ! tmp_buf ) return grub_errno ; while ( size ) { char * data ; grub_disk_addr_t start_sector ; grub_size_t len ; grub_size_t pos ; start_sector = sector & ~ ( GRUB_DISK_CACHE_SIZE - 1 ) ; pos = ( sector - start_sector ) << GRUB_DISK_SECTOR_BITS ; len = ( ( GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS ) - pos - real_offset ) ; if ( len > size ) len = size ; data = grub_disk_cache_fetch ( disk -> dev -> id , disk -> id , start_sector ) ; if ( data ) { <vul-start> if ( buf ) <vul-end> <vul-start> grub_memcpy ( buf , data + pos + real_offset , len ) ; <vul-end> grub_disk_cache_unlock ( disk -> dev -> id , disk -> id , start_sector ) ; } else { if ( start_sector + GRUB_DISK_CACHE_SIZE > disk -> total_sectors || ( disk -> dev -> read ) ( disk , start_sector , GRUB_DISK_CACHE_SIZE , tmp_buf ) != GRUB_ERR_NONE ) { unsigned num ; char * p ; grub_errno = GRUB_ERR_NONE ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( buf ) { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <vul-start> len ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> data ) { size_t actual_size = size ; <vul-start>, data + actual_size <vul-end>, len )\n"
 },
 {
  "id": 377,
  "question": "CWE-287 Code Input Vulnerable Code Is: CWE-287 <vul-start> static void oidc_scrub_headers ( request_rec * r ) { <vul-end> oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ; if ( cfg -> scrub_request_headers != 0 ) { oidc_scrub_request_headers ( r , OIDC_DEFAULT_HEADER_PREFIX , oidc_cfg_dir_authn_header ( r ) ) ; if ( ( strstr ( cfg -> claim_prefix , OIDC_DEFAULT_HEADER_PREFIX ) != cfg -> claim_prefix ) ) { oidc_scrub_request_headers ( r , cfg -> claim_prefix , NULL ) ; } } }",
  "golden_answers": [
   "CWE-287 Fixed Code Lines are: <vul-start>       <vul-end> void oidc_scrub_headers (\n"
  ],
  "generated_answer": "CWE-287 Fixed Code Lines are: <vul-start> r ) { if ( r -> server -> authn_cookie!= 0 ) { oidc_scrub_request_headers ( r, oidc_cfg_dir_authn_header ( r ) ) ; }\n"
 },
 {
  "id": 378,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 TpktState CotpConnection_readToTpktBuffer ( CotpConnection * self ) { uint8_t * buffer = self -> readBuffer -> buffer ; int bufferSize = self -> readBuffer -> maxSize ; int bufPos = self -> readBuffer -> size ; assert ( bufferSize > 4 ) ; int readBytes ; if ( bufPos < 4 ) { readBytes = readFromSocket ( self , buffer + bufPos , 4 - bufPos ) ; if ( readBytes < 0 ) goto exit_closed ; if ( DEBUG_COTP ) { if ( readBytes > 0 ) printf ( \"TPKT: read %i bytes from socket\\\\n\" , readBytes ) ; } bufPos += readBytes ; if ( bufPos == 4 ) { if ( ( buffer [ 0 ] == 3 ) && ( buffer [ 1 ] == 0 ) ) { self -> packetSize = ( buffer [ 2 ] * 0x100 ) + buffer [ 3 ] ; if ( DEBUG_COTP ) printf ( \"TPKT: header complete (msg size = %i)\\\\n\" , self -> packetSize ) ; if ( self -> packetSize > bufferSize ) { if ( DEBUG_COTP ) printf ( \"TPKT: packet too large\\\\n\" ) ; goto exit_error ; } } else { if ( DEBUG_COTP ) printf ( \"TPKT: failed to decode TPKT header.\\\\n\" ) ; goto exit_error ; } } else goto exit_waiting ; } <vul-start> readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ; <vul-end> if ( readBytes < 0 ) goto exit_closed ; bufPos += readBytes ; if ( bufPos < self -> packetSize ) goto exit_waiting ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> exit_waiting ; } if ( self -> packetSize <= bufPos ) goto exit_error ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> exit_waiting ; } if ( bufPos + readBytes > self -> packetSize ) goto exit_closed ;\n"
 },
 {
  "id": 379,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { <vul-start> void * dllhandle ; <vul-end> if ( useSystemLib ) Com_Printf ( \"Trying to load \\\\\"%s\\\\\"...\\\\n\" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = \".\" ; Com_Printf ( \"Trying to load \\\\\"%s\\\\\" from \\\\\"%s\\\\\"...\\\\n\" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , \"%s%c%s\" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( \"fs_basepath\" ) ; if ( ! basePath || ! * basePath ) basePath = \".\" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( \"Trying to load \\\\\"%s\\\\\" from \\\\\"%s\\\\\"...\\\\n\" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , \"%s%c%s\" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( \"Loading \\\\\"%s\\\\\" failed\\\\n\" , name ) ; } } return dllhandle ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> * dllhandle ; if ( COM_CompareExtension ( name , \".pk3\" ) ) { Com_Printf ( \"Rejecting DLL named \\\\\"%s\\\\\"\" , name ) ; return NULL ; }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> void * dllhandle ; if (! COM_CompareExtension ( name, \".dll\" ) ) return NULL\n"
 },
 {
  "id": 380,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char charbuf [ 512 ] ; char htmlstring [ ] = \"<html>\" ; char framestring [ ] = \"</frameset></html>\" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( \"pixHtmlViewer\" ) ; if ( ! dirin ) return ERROR_INT ( \"dirin not defined\" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( \"dirout not defined\" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( \"rootname not defined\" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( \"thumbwidth too small; using min value\\\\n\" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( \"viewwidth too small; using min value\\\\n\" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , \"mkdir -p %s\" , dirout",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; snprintf ( charbuf , sizeof ( charbuf ) <vul-end> , \"%s/%s.html\" , <vul-start> charbuf ) ; snprintf ( charbuf , sizeof ( charbuf ) <vul-end> , \"%s/%s-links.html\" , <vul-start> factor ) ; snprintf ( charbuf , sizeof ( charbuf ) <vul-end> , \"%s_thumb_%03d\" ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; snprintf ( charbuf, sizeof ( charbuf ) <vul-end>, \"%s_thumb_%03d\", <vul-start> charbuf ) ; snprintf ( charbuf, sizeof ( charbuf ) <vul-end>, \"%s/%s-links.html\", <vul-start> factor ) ; snprintf ( charbuf, sizeof ( charbuf ) <vul-end>, \"%s_thumb_%03d\", <vul-start> charbuf ) ; snprintf ( charbuf, sizeof ( charbuf ) <vul-end>, \"%s/%s-links.html\",\n"
 },
 {
  "id": 381,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) { <vul-end> if ( svc_ctx == NULL ) return NULL ; <vul-start> return ( const SvcInternal * ) svc_ctx -> internal ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>   static const SvcInternal_t <vul-end> * get_const_svc_internal ( <vul-start> return ( const SvcInternal_t <vul-end> * ) svc_ctx\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static const SvcInternal_t <vul-end> * get_const_svc_internal ( <vul-start> return ( const SvcInternal_t <vul-end> * ) svc_ctx\n"
 },
 {
  "id": 382,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; <vul-start> if ( chunk_num > chm -> num_chunks ) return NULL ; <vul-end> if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( !",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> if ( chunk_num >= <vul-end> chm -> num_chunks\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> if ( chunk_num >= <vul-end> chm -> num_chunks\n"
 },
 {
  "id": 383,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , \"%d: Client using the %s protocol\\\\n\" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , \"%d: Realign input buffer\\\\n\" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , \"<%d Read binary protocol data:\" , c ->",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ! el ) { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == ' ' ) { ++ ptr ; } if ( strcmp ( ptr , \"get \" ) && strcmp ( ptr , \"gets \" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <vul-end> cont = el\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> (! el ||! c -> rcurr\n"
 },
 {
  "id": 384,
  "question": "CWE-667 Code Input Vulnerable Code Is: CWE-667 struct vm_area_struct * find_extend_vma ( struct mm_struct * mm , unsigned long addr ) { struct vm_area_struct * vma ; unsigned long start ; addr &= PAGE_MASK ; vma = find_vma ( mm , addr ) ; if ( ! vma ) return NULL ; if ( vma -> vm_start <= addr ) return vma ; if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) return NULL ; <vul-start> start = vma -> vm_start ; <vul-end> if ( expand_stack ( vma , addr ) ) return NULL ; if ( vma -> vm_flags & VM_LOCKED ) populate_vma_page_range ( vma , addr , start , NULL ) ; return vma ; }",
  "golden_answers": [
   "CWE-667 Fixed Code Lines are: <vul-start> return NULL ; if ( ! mmget_still_valid ( mm ) ) return NULL ;\n"
  ],
  "generated_answer": "CWE-667 Fixed Code Lines are: <vul-start> return NULL ; if (! ( vma -> vm_flags & VM_MAYWRITE ) ) return NULL ;\n"
 },
 {
  "id": 385,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int unix_attach_fds ( struct scm_cookie * scm , struct sk_buff * skb ) { int i ; unsigned char max_level = 0 ; int unix_sock_count = 0 ; if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) { struct sock * sk = unix_get_socket ( scm -> fp -> fp [ i ] ) ; if ( sk ) { unix_sock_count ++ ; max_level = max ( max_level , unix_sk ( sk ) -> recursion_level ) ; } } if ( unlikely ( max_level > MAX_RECURSION_LEVEL ) ) return - ETOOMANYREFS ; UNIXCB ( skb ) . fp = scm_fp_dup ( scm -> fp ) ; if ( ! UNIXCB ( skb ) . fp ) return - ENOMEM ; for ( i = scm -> fp -> count - 1 ; i >= 0 ; i -- ) <vul-start> unix_inflight ( scm -> fp -> fp [ i ] ) ; <vul-end> return max_level ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> -> fp -> user , scm -> fp ->\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> -> fp -> user, scm -> fp ->\n"
 },
 {
  "id": 386,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_arg ( PyObject * obj , arg_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier arg ; expr_ty annotation ; string type_comment ; int lineno ; int col_offset ; <vul-start> if ( _PyObject_HasAttrId ( obj , & PyId_arg ) ) { <vul-end> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ; if ( tmp == NULL ) goto failed ; <vul-start> res = obj2ast_identifier ( tmp , & arg , arena ) ; <vul-end> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"arg\\\\\" missing from arg\" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_annotation ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_annotation ) ; if ( tmp == NULL ) goto failed ; <vul-start> res = obj2ast_expr ( tmp , & annotation , arena ) ; <vul-end> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> annotation = NULL ; } if ( exists_not_none ( obj , & PyId_type_comment ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_comment ) ; if ( tmp == NULL ) goto failed ; <vul-start> res = obj2ast_string ( tmp , & type_comment , arena ) ; <vul-end> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { type_comment = NULL ; } if ( _PyObject_HasAttrId (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"arg\\\\\" missing from arg\" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; annotation = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & annotation <vul-end> , arena ) <vul-start> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"lineno\\\\\" missing from arg\" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & lineno <vul-end> , arena ) <vul-start> ) ; } if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"col_offset\\\\\" missing from arg\" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) <vul-end> ; } *\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj, <vul-start>, & arg <vul-end> ) ; if <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_annotation, & annotation ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"arg\\\\\" missing from arg\" ) ; return 1 ; } else { Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj, & PyId_type_comment, & type_comment ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"type_comment missing from arg\" ) ; return 1 ; } else { <vul-end> Py_CLEAR ( tmp <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_arg, & arg ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"arg\\\\\" missing from arg\" ) ; return 1 ; } else { <vul-end> type_comment = NULL <vul-start> goto failed ; int res ; <vul-start> tmp, & arg <vul-end>, arena ) <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_annotation, & annotation ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"annotation\\\\\" missing from arg\" ) ; return 1 ; } else { <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_type_comment, & annotation ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"type_comment missing from arg\" ) ; return 1 ; } else { <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_arg, & arg ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"arg\\\\\" missing from arg\" ) ; return 1 ; } else { <vul-start> ) ; } if ( lookup_attr_id ( obj,"
 },
 {
  "id": 387,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) { <vul-start> spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; <vul-end> flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <vul-start> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, flags ) ; fq -> flush_pending_idx ^= 1\n"
 },
 {
  "id": 388,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; <vul-start> int count , i ; <vul-end> count = be32_to_cpu ( aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED ) ; acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> * ace ; unsigned\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start>, i ; if ( be32_to_cpu ( aclp -> acl_cnt ) > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED ) ; if ( count < 0 ) { xfs_alert ( \"posix_acl_from_disk: count < 0\" ) ; return ERR_PTR ( - EINVAL ) ; }\n"
 },
 {
  "id": 389,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( \"Bad offset %p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking: element %p size %u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } if ( ! ip6_checkentry ( & e -> ipv6 ) ) return - EINVAL ; <vul-start> err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; <vul-end> if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> , e -> elems , e ->\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, e -> elems, e ->\n"
 },
 {
  "id": 390,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int main ( int argc , char * argv [ ] ) { FILE * iplist = NULL ; plist_t root_node = NULL ; char * plist_out = NULL ; uint32_t size = 0 ; int read_size = 0 ; char * plist_entire = NULL ; struct stat filestats ; options_t * options = parse_arguments ( argc , argv ) ; if ( ! options ) { print_usage ( argc , argv ) ; return 0 ; } iplist = fopen ( options -> in_file , \"rb\" ) ; if ( ! iplist ) { free ( options ) ; return 1 ; } <vul-start> stat ( options -> in_file , & filestats ) ; <vul-end> plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ; read_size = fread ( plist_entire , sizeof ( char ) , filestats . st_size , iplist ) ; fclose ( iplist ) ; if ( memcmp ( plist_entire , \"bplist00\" , 8 ) == 0 ) { plist_from_bin ( plist_entire , read_size , & root_node ) ; plist_to_xml ( root_node , & plist_out , & size ) ; } else { plist_from_xml ( plist_entire , read_size , & root_node ) ; plist_to_bin ( root_node , & plist_out , & size ) ; } plist_free ( root_node ) ; free ( plist_entire ) ; if ( plist_out ) { if ( options -> out_file != NULL ) { FILE * oplist = fopen ( options -> out_file , \"wb\" ) ; if ( ! oplist ) { free",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> filestats ) ; if ( filestats . st_size < 8 ) { printf ( \"ERROR: Input file is too small to contain valid plist data.\\\\n\" ) ; return - 1 ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 1 ; } if ( options -> in_file == NULL ) { print_usage ( argc, argv ) ; return 1 ; }\n"
 },
 {
  "id": 391,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 void gsm_xsmp_client_connect ( GsmXSMPClient * client , SmsConn conn , unsigned long * mask_ret , SmsCallbacks * callbacks_ret ) { client -> priv -> conn = conn ; <vul-start> if ( client -> priv -> protocol_timeout ) { <vul-end> g_source_remove ( client -> priv -> protocol_timeout ) ; client -> priv -> protocol_timeout = 0 ; } g_debug ( \"GsmXSMPClient: Initializing client %s\" , client -> priv -> description ) ; * mask_ret = 0 ; * mask_ret |= SmsRegisterClientProcMask ; callbacks_ret -> register_client . callback = register_client_callback ; callbacks_ret -> register_client . manager_data = client ; * mask_ret |= SmsInteractRequestProcMask ; callbacks_ret -> interact_request . callback = interact_request_callback ; callbacks_ret -> interact_request . manager_data = client ; * mask_ret |= SmsInteractDoneProcMask ; callbacks_ret -> interact_done . callback = interact_done_callback ; callbacks_ret -> interact_done . manager_data = client ; * mask_ret |= SmsSaveYourselfRequestProcMask ; callbacks_ret -> save_yourself_request . callback = save_yourself_request_callback ; callbacks_ret -> save_yourself_request . manager_data = client ; * mask_ret |= SmsSaveYourselfP2RequestProcMask ; callbacks_ret -> save_yourself_phase2_request . callback = save_yourself_phase2_request_callback ; callbacks_ret -> save_yourself_phase2_request . manager_data = client ; * mask_ret |= SmsSaveYourselfDoneProcMask ; callbacks_ret -> save_yourself_done . callback = save_yourself_done_callback ; callbacks_ret -> save_yourself_done . manager_data = client ; * mask_ret |= SmsCloseConnectionProcMask ; callbacks_ret -> close_connection . callback = close_connection_callback ; callbacks_ret -> close_connection . manager_data = client ; * mask_ret |= SmsSetPropertiesProcMask ; callbacks_ret -> set_properties . callback = set_properties_callback ; callbacks_ret -> set_properties . manager_data = client ; * mask_ret |= SmsDeletePropertiesProcMask ; callbacks_ret -> delete_properties . callback = delete_properties_callback ; callbacks_ret -> delete_properties . manager_data = client ;",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> = conn ; <vul-end> g_debug ( \"GsmXSMPClient: Initializing client %s\"\n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> = conn ; <vul-end> g_debug ( \"GsmXSMPClient: Initializing client %s\"\n"
 },
 {
  "id": 392,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 void luaT_getvarargs ( lua_State * L , CallInfo * ci , StkId where , int wanted ) { int i ; int nextra = ci -> u . l . nextraargs ; if ( wanted < 0 ) { wanted = nextra ; <vul-start> checkstackp ( L , nextra , where ) ; <vul-end> L -> top = where + nextra ; } for ( i = 0 ; i < wanted && i < nextra ; i ++ ) setobjs2s ( L , where + i , ci -> func - nextra + i ) ; for ( ; i < wanted ; i ++ ) setnilvalue ( s2v ( where + i ) ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> = nextra ; checkstackGCp <vul-end> ( L ,\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> = nextra ; luaD_checkstack <vul-end> ( L,\n"
 },
 {
  "id": 393,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int64_t rd_pick_intra_sub_8x8_y_mode ( VP9_COMP * cpi , MACROBLOCK * mb , int * rate , int * rate_y , int64_t * distortion , int64_t best_rd ) { int i , j ; const MACROBLOCKD * const xd = & mb -> e_mbd ; MODE_INFO * const mic = xd -> mi [ 0 ] ; <vul-start> const MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ; <vul-end> <vul-start> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; <vul-end> const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; int cost = 0 ; int64_t total_distortion = 0 ; int tot_rate_y = 0 ; int64_t total_rd = 0 ; ENTROPY_CONTEXT t_above [ 4 ] , t_left [ 4 ] ; <vul-start> const int * bmode_costs = mb -> mbmode_cost ; <vul-end> <vul-start> vpx_memcpy ( t_above , xd -> plane [ 0 ] . above_context , sizeof ( t_above ) ) ; <vul-end> <vul-start> vpx_memcpy ( t_left , xd -> plane [ 0 ] . left_context , sizeof ( t_left ) ) ; <vul-end> for ( idy = 0 ; idy < 2 ; idy += num_4x4_blocks_high ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_blocks_wide ) { <vul-start> MB_PREDICTION_MODE best_mode = DC_PRED ; <vul-end> int r = INT_MAX , ry = INT_MAX ; int64_t d =",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = xd -> above_mi <vul-end> ; const MODE_INFO <vul-start> = xd -> left_mi <vul-end> ; const BLOCK_SIZE <vul-start> * bmode_costs = cpi <vul-end> -> mbmode_cost ; <vul-start> -> mbmode_cost ; memcpy <vul-end> ( t_above , <vul-start> ) ) ; memcpy <vul-end> ( t_left , <vul-start> num_4x4_blocks_wide ) { PREDICTION_MODE <vul-end> best_mode = DC_PRED <vul-start> ) { const PREDICTION_MODE <vul-end> A = vp9_above_block_mode <vul-start> ) ; const PREDICTION_MODE <vul-end> L = vp9_left_block_mode <vul-start> ; bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ; } this_rd = rd_pick_intra4x4block ( cpi , mb , idy , idx <vul-end> , & best_mode\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> const MODE_INFO * above_mi = xd -> above_mi ; const MODE_INFO * left_mi = xd -> left_mi <vul-end> ; const BLOCK_SIZE <vul-start> 4 ] ; memcpy <vul-end> ( t_above, <vul-start> ) ) ; memcpy <vul-end> ( t_left, <vul-start> num_4x4_blocks_wide ) { PREDICTION_MODE <vul-end> best_mode = DC_PRED <vul-start> ) { const PREDICTION_MODE <vul-end> A = vp9_above_block_mode <vul-start> ) ; const PREDICTION_MODE <vul-end> L = vp9_left_block_mode <vul-start> L ] ; if ( A >= best_mode ) { * rate = INT_MAX ; * rate_y = INT_MAX ; return RDCOST ( mb -> rdmult, mb -> rddiv, cost, total_distortion ) ; } else { * rate = INT_MAX ; * rate_y = tot_rate_y ; * distortion = INT64_MAX ; }\n"
 },
 {
  "id": 394,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , \"%d: Client using the %s protocol\\\\n\" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , \"%d: Realign input buffer\\\\n\" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , \"<%d Read binary protocol data:\" , c ->",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> } if ( ptr - c -> rcurr > 100 || ( strncmp ( ptr , \"get \" , 4 ) && strncmp <vul-end> ( ptr , <vul-start> ptr , \"gets \" , 5 )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> } if ( ( c -> rbytes == 0 ) && <vul-start>, \"get \" ) ) { if ( settings. verbose ) { fprintf ( stderr, \"Connection is not closed\\\\n\" ) ; return - 1 ; } <vul-end> conn_set_state ( c\n"
 },
 {
  "id": 395,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int asf_build_simple_index ( AVFormatContext * s , int stream_index ) { ff_asf_guid g ; ASFContext * asf = s -> priv_data ; int64_t current_pos = avio_tell ( s -> pb ) ; int64_t ret ; if ( ( ret = avio_seek ( s -> pb , asf -> data_object_offset + asf -> data_object_size , SEEK_SET ) ) < 0 ) { return ret ; } if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; while ( ff_guidcmp ( & g , & ff_asf_simple_index_header ) ) { int64_t gsize = avio_rl64 ( s -> pb ) ; if ( gsize < 24 || avio_feof ( s -> pb ) ) { goto end ; } avio_skip ( s -> pb , gsize - 24 ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; } { int64_t itime , last_pos = - 1 ; int pct , ict ; int i ; int64_t av_unused gsize = avio_rl64 ( s -> pb ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; itime = avio_rl64 ( s -> pb ) ; pct = avio_rl32 ( s -> pb ) ; ict = avio_rl32 ( s -> pb ) ; av_log ( s , AV_LOG_DEBUG , \"itime:0x%\" PRIx64 \", pct:%d, ict:%d\\\\n\" , itime , pct , ict ) ; for ( i = 0 ; i < ict ;",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> 0 ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; }\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> int64_t index_pts = <vul-end> av_rescale ( itime <vul-start>, 10000 ) <vul-end> ; if (\n"
 },
 {
  "id": 396,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 <vul-start> static int udp_push_pending_frames ( struct sock * sk ) <vul-end> { struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct flowi4 * fl4 = & inet -> cork . fl . u . ip4 ; struct sk_buff * skb ; int err = 0 ; skb = ip_finish_skb ( sk , fl4 ) ; if ( ! skb ) goto out ; err = udp_send_skb ( skb , fl4 ) ; out : up -> len = 0 ; up -> pending = 0 ; return err ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start>       <vul-end> int udp_push_pending_frames (\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start>       <vul-end> int udp_push_pending_frames (\n"
 },
 {
  "id": 397,
  "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 void bpf_int_jit_compile ( struct bpf_prog * prog ) { struct bpf_binary_header * header = NULL ; int proglen , oldproglen = 0 ; struct jit_context ctx = { } ; u8 * image = NULL ; int * addrs ; int pass ; int i ; if ( ! bpf_jit_enable ) return ; if ( ! prog || ! prog -> len ) return ; addrs = kmalloc ( prog -> len * sizeof ( * addrs ) , GFP_KERNEL ) ; if ( ! addrs ) return ; for ( proglen = 0 , i = 0 ; i < prog -> len ; i ++ ) { proglen += 64 ; addrs [ i ] = proglen ; } ctx . cleanup_addr = proglen ; <vul-start> for ( pass = 0 ; pass < 10 ; pass ++ ) { <vul-end> proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ; if ( proglen <= 0 ) { image = NULL ; if ( header ) bpf_jit_binary_free ( header ) ; goto out ; } if ( image ) { if ( proglen != oldproglen ) { pr_err ( \"bpf_jit: proglen=%d != oldproglen=%d\\\\n\" , proglen , oldproglen ) ; goto out ; } break ; } if ( proglen == oldproglen ) { header = bpf_jit_binary_alloc ( proglen , & image , 1 , jit_fill_hole ) ; if ( ! header ) goto out ; } oldproglen = proglen ; } if ( bpf_jit_enable > 1 ) bpf_jit_dump ( prog -> len , proglen , 0 ,",
  "golden_answers": [
   "CWE-17 Fixed Code Lines are: <vul-start> pass < 10 || image\n"
  ],
  "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> = proglen ; ctx. jit_mm = NULL ;\n"
 },
 {
  "id": 398,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int vfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry , struct inode * * delegated_inode , unsigned int flags ) { int error ; bool is_dir = d_is_dir ( old_dentry ) ; const unsigned char * old_name ; struct inode * source = old_dentry -> d_inode ; struct inode * target = new_dentry -> d_inode ; bool new_is_dir = false ; unsigned max_links = new_dir -> i_sb -> s_max_links ; <vul-start> if ( source == target ) <vul-end> return 0 ; error = may_delete ( old_dir , old_dentry , is_dir ) ; if ( error ) return error ; if ( ! target ) { error = may_create ( new_dir , new_dentry ) ; } else { new_is_dir = d_is_dir ( new_dentry ) ; if ( ! ( flags & RENAME_EXCHANGE ) ) error = may_delete ( new_dir , new_dentry , is_dir ) ; else error = may_delete ( new_dir , new_dentry , new_is_dir ) ; } if ( error ) return error ; if ( ! old_dir -> i_op -> rename && ! old_dir -> i_op -> rename2 ) return - EPERM ; if ( flags && ! old_dir -> i_op -> rename2 ) return - EINVAL ; if ( new_dir != old_dir ) { if ( is_dir ) { error = inode_permission ( source , MAY_WRITE ) ; if ( error ) return error ; } if ( ( flags & RENAME_EXCHANGE ) && new_is_dir ) { error = inode_permission ( target , MAY_WRITE ) ; if ( error )",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ; if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <vul-end> ) return 0\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> -> s_max_links ; struct super_block * old_sb = old_dir -> i_sb ; struct super_block * new_sb = target -> i_sb ; <vul-start> source == target ||! new_sb ) return 0 ; if ( new_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE\n"
 },
 {
  "id": 399,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <vul-start> int length ; <vul-end> <vul-start> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <vul-end> in_uint8s ( s , length ) ; return s_check ( s ) ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> s ) { uint32 length ; struct stream packet = * s <vul-end> ; ber_parse_header ( <vul-start> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( \"mcs_parse_domain_params(), consume domain params from stream would overrun\" , & packet ) ; }\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> s ) { uint32 <vul-end> length ; ber_parse_header <vul-start>, & length ) ; if (! s_check ( s ) ) return FALSE ; if ( length > MCS_MAX_DOMAIN_PARAMS ) return FALSE <vul-end> ; in_uint8s (\n"
 },
 {
  "id": 400,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; <vul-start> size_t e ; <vul-end> if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { <vul-start> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <vul-end> c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } <vul-start> } <vul-end> }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ; size_t e ; mrb_value nil <vul-start> ) ) { <vul-end> mrb_gc_mark ( mrb <vul-start> ; } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; size_t e ; mrb_value t <vul-start> ) ) { t = mrb_basic_ptr ( v ) ; if ( t <vul-end> -> tt == <vul-start> ; } } else { mrb_gc_mark ( mrb, t ) ; }\n"
 },
 {
  "id": 401,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void __skb_tstamp_tx ( struct sk_buff * orig_skb , struct skb_shared_hwtstamps * hwtstamps , struct sock * sk , int tstype ) { struct sk_buff * skb ; <vul-start> bool tsonly ; <vul-end> if ( ! sk ) return ; tsonly = sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY ; if ( ! skb_may_tx_timestamp ( sk , tsonly ) ) return ; if ( tsonly ) { # ifdef CONFIG_INET if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) && sk -> sk_protocol == IPPROTO_TCP && <vul-start> sk -> sk_type == SOCK_STREAM ) <vul-end> skb = tcp_get_timestamping_opt_stats ( sk ) ; <vul-start> else <vul-end> # endif skb = alloc_skb ( 0 , GFP_ATOMIC ) ; } else { skb = skb_clone ( orig_skb , GFP_ATOMIC ) ; } if ( ! skb ) return ; if ( tsonly ) { skb_shinfo ( skb ) -> tx_flags = skb_shinfo ( orig_skb ) -> tx_flags ; skb_shinfo ( skb ) -> tskey = skb_shinfo ( orig_skb ) -> tskey ; } if ( hwtstamps ) * skb_hwtstamps ( skb ) = * hwtstamps ; else skb -> tstamp = ktime_get_real ( ) ; <vul-start> __skb_complete_tx_timestamp ( skb , sk , tstype ) ; <vul-end> }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; bool tsonly , opt_stats = false <vul-start> == SOCK_STREAM ) { <vul-start> sk ) ; opt_stats = true ; } <vul-start> sk , tstype , opt_stats\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; bool tsonly ; int opt_stats_size <vul-start> == SOCK_STREAM ) { opt_stats_size = sizeof ( struct sockaddr_storage ) + sizeof ( struct sockaddr_storage ) * sizeof ( u32 ) ; <vul-start> sk ) ; } else { opt_stats_size = sizeof ( struct sockaddr_storage ) ; } <vul-start> ( ) ; opt_stats_size /= sizeof ( u32 ) ; <vul-start> sk, tstype, opt_stats_size\n"
 },
 {
  "id": 402,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = \"PredictorEncodeTile\" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\" , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; if ( ( cc0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"PredictorEncodeTile\" , \"%s\" , \"(cc0%rowsize)!=0\" ) ; <vul-start> return 0 ; <vul-end> } while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> \"(cc0%rowsize)!=0\" ) ; _TIFFfree ( working_copy ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> \"(cc0%rowsize)!=0\" ) ; _TIFFfree ( working_copy ) ;\n"
 },
 {
  "id": 403,
  "question": "CWE-704 Code Input Vulnerable Code Is: CWE-704 static void merge_param ( HashTable * params , zval * zdata , zval * * * current_param , zval * * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , \"params = \" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , \"\\\\n\" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( \"value\" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , \"arguments\" , sizeof ( \"arguments\" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args",
  "golden_answers": [
   "CWE-704 Fixed Code Lines are: <vul-start> ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY\n"
  ],
  "generated_answer": "CWE-704 Fixed Code Lines are: <vul-start> { if ( SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( test_ptr ), ( void * ) & test_ptr ) ) { zval * tmp ; tmp = * test_ptr ; while ( <vul-start> IS_ARRAY ) { if ( Z_TYPE_PP ( test_ptr ) == IS_ARRAY && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( test_ptr ), & hkey. str, & hkey. len, & hkey. num, hkey. dup, NULL ) ) { zval * tmp ; tmp = * test_ptr ; add_assoc_zval_ex ( tmp, ZEND_STRS ( \"value\" ), * ptr ) ; } else if ( hkey. type == HASH_KEY_IS_STRING && SUCCESS == zend_hash_find ( Z_ARRVAL_PP ( ptr ), & hkey. str, & hkey. len, & hkey. num, hkey. dup, NULL ) ) { zval * arg ; tmp = * test_ptr ; add_assoc_zval_ex ( tmp, ZEND_STRS ( \"value\" ), * ptr ) ; array_init ( tmp ) ; } else if ( hkey. type == HASH_KEY_IS_LONG && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( ptr ), & hkey. str, & hkey. len, & hkey. num, hkey. dup, NULL ) ) { zval * tmp ; tmp = * test_ptr ; add_assoc_zval_ex ( tmp, ZEND_STRS ( \"value\" ), * ptr ) ; } else { zval * tmp ; tmp = * test_ptr ; add_assoc_zval_ex ( tmp, ZEND_STRS ( \"value\" ), * ptr ) ; } } } else if ( hkey. type == HASH_KEY_IS_LONG && SUCCESS == zend_hash_get_current_data ( Z_ARRVAL_PP ( ptr ), \"value\", sizeof ( \"value\" ), NULL ) ) { zval * arg ; arg = * test_ptr ; array_init ( arg ) ; } else if ( Z"
 },
 {
  "id": 404,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void lo_release ( struct gendisk * disk , fmode_t mode ) { <vul-start> struct loop_device * lo = disk -> private_data ; <vul-end> int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } <vul-start> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <vul-end> }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <vul-end> disk -> private_data <vul-start> disk -> private_data ) ; <vul-end> mutex_unlock ( & <vul-start> mutex_unlock ( & loop_index_mutex <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> mode ) { int err ; <vul-start> disk -> private_data <vul-end> ; if ( <vul-start> ) ; } mutex_unlock ( & lo -> lo_ctl_mutex ) ;\n"
 },
 {
  "id": 405,
  "question": "CWE-436 Code Input Vulnerable Code Is: CWE-436 bgp_attr_parse_ret_t bgp_attr_parse ( struct peer * peer , struct attr * attr , bgp_size_t size , struct bgp_nlri * mp_update , struct bgp_nlri * mp_withdraw ) { bgp_attr_parse_ret_t ret ; uint8_t flag = 0 ; uint8_t type = 0 ; bgp_size_t length ; uint8_t * startp , * endp ; uint8_t * attr_endp ; uint8_t seen [ BGP_ATTR_BITMAP_SIZE ] ; struct aspath * as4_path = NULL ; as_t as4_aggregator = 0 ; struct in_addr as4_aggregator_addr = { . s_addr = 0 } ; memset ( seen , 0 , BGP_ATTR_BITMAP_SIZE ) ; endp = BGP_INPUT_PNT ( peer ) + size ; while ( BGP_INPUT_PNT ( peer ) < endp ) { if ( endp - BGP_INPUT_PNT ( peer ) < BGP_ATTR_MIN_LEN ) { flog_warn ( EC_BGP_ATTRIBUTE_TOO_SMALL , \"%s: error BGP attribute length %lu is smaller than min len\" , peer -> host , ( unsigned long ) ( endp - stream_pnt ( BGP_INPUT ( peer ) ) ) ) ; bgp_notify_send ( peer , BGP_NOTIFY_UPDATE_ERR , BGP_NOTIFY_UPDATE_ATTR_LENG_ERR ) ; return BGP_ATTR_PARSE_ERROR ; } startp = BGP_INPUT_PNT ( peer ) ; flag = 0xF0 & stream_getc ( BGP_INPUT ( peer ) ) ; type = stream_getc ( BGP_INPUT ( peer ) ) ; if ( CHECK_FLAG ( flag , BGP_ATTR_FLAG_EXTLEN ) && ( ( endp - startp ) < ( BGP_ATTR_MIN_LEN + 1 ) ) ) { flog_warn ( EC_BGP_EXT_ATTRIBUTE_TOO_SMALL , \"%s: Extended length set, but just %lu bytes of attr header\" , peer -> host , ( unsigned long ) ( endp - stream_pnt ( BGP_INPUT ( peer ) ) ) ) ; bgp_notify_send (",
  "golden_answers": [
   "CWE-436 Fixed Code Lines are: <vul-start> ; # if ENABLE_BGP_VNC_ATTR <vul-end> case BGP_ATTR_VNC :\n"
  ],
  "generated_answer": "CWE-436 Fixed Code Lines are: <vul-start> ; break ; <vul-end> case BGP_ATTR_ENCAP :\n"
 },
 {
  "id": 406,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) { <vul-start> char buffer [ 80 ] ; <vul-end> int ret ; int i ; for ( i = 0 ; i < 79 ; i ++ ) { if ( _nskip > 0 ) { buffer [ i ] = * _skip ++ ; _nskip -- ; } else { if ( ! file_read ( buffer + i , 1 , _fin ) ) return - 1 ; } if ( buffer [ i ] == '\\\\n' ) break ; } if ( _nskip > 0 ) return - 1 ; if ( i == 79 ) { fprintf ( stderr , \"Error parsing header; not a YUV2MPEG2 file?\\\\n\" ) ; return - 1 ; } buffer [ i ] = '\\\\0' ; if ( memcmp ( buffer , \"YUV4MPEG\" , 8 ) ) { fprintf ( stderr , \"Incomplete magic for YUV4MPEG file.\\\\n\" ) ; return - 1 ; } if ( buffer [ 8 ] != '2' ) { fprintf ( stderr , \"Incorrect YUV input file version; YUV4MPEG2 required.\\\\n\" ) ; } ret = y4m_parse_tags ( _y4m , buffer + 5 ) ; if ( ret < 0 ) { fprintf ( stderr , \"Error parsing YUV4MPEG2 header.\\\\n\" ) ; return ret ; } if ( _y4m -> interlace == '?' ) { fprintf ( stderr , \"Warning: Input video interlacing format unknown; \" \"assuming progressive scan.\\\\n\" ) ; } else if ( _y4m -> interlace != 'p' ) {",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> [ 80 ] = { 0 } <vul-start> ; _y4m -> bps <vul-end> = 12 ; <vul-start> = 12 ; _y4m -> bit_depth = 8 ; <vul-start> -> chroma_type , \"420p10\" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 10 ; _y4m -> bps = 15 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 420p10 to 420jpeg\\\\n\" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , \"420p12\" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 12 ; _y4m -> bps = 18 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 420p12 to 420jpeg\\\\n\" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , <vul-start> ; _y4m -> bps <vul-end> = 16 ; <vul-start> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , \"422p10\" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 20 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 422p10 to 420jpeg\\\\n\" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , \"422p12\" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 24 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 422p12 to 420jpeg\\\\n\" ) ; return - 1 <vul-start> ; _y4m -> bps <vul-end> = 24 ; <vul-start> -> chroma_type , \"444p10\" <vul-end> ) == 0 <vul-start> = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 30 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; <vul-start> only_420 ) { <vul-end> fprintf ( stderr <vul-start> ( stderr , \"Unsupported conversion from 444p10 to 420jpeg\\\\n\" <vul-end> ) ; return <vul-start> 1 ; } } else if ( strcmp ( _y4m -> chroma_type , \"444p12\" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 36 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , \"Unsupported conversion from 444p12 to 420jpeg\\\\n\" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , \"444alpha\" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , \"mono\" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else { fprintf ( stderr , \"Unknown chroma sampling type: %s\\\\n\" , _y4m -> chroma_type ) ; return - 1 ; } <vul-start> dst_c_dec_v ) ; if ( _y4m -> bit_depth == 8 ) <vul-start> dst_buf_sz ) ; else _y4m -> dst_buf <vul-end> = ( unsigned <vul-start> ) malloc ( 2 * _y4m -> dst_buf_sz ) ; if ( <vul-start> _y4m -> aux_buf_sz > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> only_420 ) { int ret ; <vul-start> char buffer [ 64 <vul-end> ] ; int <vul-start> ; _y4m -> fmt_mb_type = VPX_IMG_FMT_I422 ; _y4m -> <vul-start> = 12 ; <vul-end> _y4m -> src_c_dec_h <vul-start> ; } else <vul-end> { _y4m -> <vul-start> = VPX_IMG_FMT_I422 ; <vul-end> _y4m -> dst_c_dec_h <vul-start> ; _y4m -> fmt_mb_type = VPX_IMG_FMT_I422 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type, \"420jpeg\" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 0 ; _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_422_420jpeg ; } else { _y4m -> src_c_dec_h = 4 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ; _y4m -> aux_buf_read_sz = 0 ; _y4m ->"
 },
 {
  "id": 407,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; int ret = 0 ; <vul-start> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <vul-end> return - ENOKEY ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer (",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_negative ( key <vul-end> ) ) return\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_negative ( key <vul-end> ) ) return\n"
 },
 {
  "id": 408,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 boolean proc_wizkit_line ( buf ) char * buf ; { <vul-start> struct obj * otmp = readobjnam ( buf , ( struct obj * ) 0 ) ; <vul-end> if ( otmp ) { if ( otmp != & zeroobj ) wizkit_addinv ( otmp ) ; } else { config_error_add ( \"Bad wizkit item: \\\\\"%.60s\\\\\"\" , buf ) ; return FALSE ; } return TRUE ; }",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> struct obj * otmp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\\\0' ;\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> buf ; { <vul-end> obj * otmp\n"
 },
 {
  "id": 409,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * inpic ) { KerndeintContext * kerndeint = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * outpic ; const uint8_t * prvp ; const uint8_t * prvpp ; const uint8_t * prvpn ; const uint8_t * prvppp ; const uint8_t * prvpnn ; const uint8_t * prvp4p ; const uint8_t * prvp4n ; const uint8_t * srcp ; const uint8_t * srcpp ; const uint8_t * srcpn ; const uint8_t * srcppp ; const uint8_t * srcpnn ; const uint8_t * srcp3p ; const uint8_t * srcp3n ; const uint8_t * srcp4p ; const uint8_t * srcp4n ; uint8_t * dstp , * dstp_saved ; const uint8_t * srcp_saved ; int src_linesize , psrc_linesize , dst_linesize , bwidth ; int x , y , plane , val , hi , lo , g , h , n = kerndeint -> frame ++ ; double valf ; const int thresh = kerndeint -> thresh ; const int order = kerndeint -> order ; const int map = kerndeint -> map ; const int sharp = kerndeint -> sharp ; const int twoway = kerndeint -> twoway ; const int is_packed_rgb = kerndeint -> is_packed_rgb ; outpic = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! outpic ) { av_frame_free ( & inpic ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( outpic , inpic ) ; outpic -> interlaced_frame = 0 ; <vul-start> for",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; <vul-end> plane < 4 <vul-start> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; if ( inpic -> data [ plane ] && inpic -> linesize [ plane ] ) { for ( y = 0 ; y < inlink -> h ; y ++ ) { if ( inlink -> format == AV_PIX_FMT_YUVA420P || inlink -> format == AV_PIX_FMT_YUV420P ) { if ( plane == 0 ) { if ( inlink -> interlaced_frame ) { outpic -> interlaced_frame = 1 ; } else { outpic -> interlaced_frame = 2 ; } } return AVERROR_INVALIDDATA ; } } for ( plane = 0 ; <vul-end> plane < 4\n"
 },
 {
  "id": 410,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int yr_re_match ( RE * re , const char * target ) { return yr_re_exec ( re -> code , ( uint8_t * ) target , strlen ( target ) , <vul-start> re -> flags | RE_FLAGS_SCAN , <vul-end> NULL , NULL ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> target ) , 0 ,\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -> flags | RE_FLAGS_SINGLE_THRE <vul-end>, NULL,\n"
 },
 {
  "id": 411,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * <vul-start> ikev1_attr_print ( netdissect_options * ndo , const u_char * p , const u_char * ep ) <vul-end> { int totlen ; uint32_t t ; <vul-start> if ( p [ 0 ] & 0x80 ) <vul-end> totlen = 4 ; <vul-start> else <vul-end> totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ; <vul-start> if ( ep < p + totlen ) { <vul-end> ND_PRINT ( ( ndo , \"[|attr]\" ) ) ; <vul-start> return ep + 1 ; <vul-end> <vul-start> } <vul-end> ND_PRINT ( ( ndo , \"(\" ) ) ; t = EXTRACT_16BITS ( & p [ 0 ] ) & 0x7fff ; ND_PRINT ( ( ndo , \"type=#%d \" , t ) ) ; if ( p [ 0 ] & 0x80 ) { ND_PRINT ( ( ndo , \"value=\" ) ) ; t = p [ 2 ] ; <vul-start> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <vul-end> } else { <vul-start> ND_PRINT ( ( ndo , \"len=%d value=\" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <vul-end> <vul-start> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <vul-end> } ND_PRINT ( ( ndo , \")\" ) ) ; <vul-start> return p + totlen ; <vul-end> <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> const u_char * ep2 <vul-end> ) { int <vul-start> uint32_t t ; ND_TCHECK ( p [ 0 ] ) ; <vul-start> 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <vul-start> ] ) ; } if ( ep2 <vul-end> < p + <vul-start> ) ; return ep2 <vul-end> + 1 ; <vul-start> 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <vul-start> 2 ] ; if ( ! <vul-start> , 2 ) ) { ND_PRINT ( ( ndo , \")\" ) ) ; goto trunc ; } <vul-end> } else { <vul-start> , \"len=%d value=\" , totlen - 4 ) ) ; if ( ! <vul-end> rawprint ( ndo <vul-start> 4 ] , totlen - 4 ) ) { <vul-end> ND_PRINT ( ( <vul-start> ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , \")\" ) ) ; <vul-start> + totlen ; trunc : return NULL ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> const u_char * ep2 <vul-end>, const u_char <vul-start> const u_char * ep2 <vul-end> ) { int <vul-start> uint32_t t ; ND_TCHECK ( p [ 0 ] ) ; <vul-start> 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <vul-start> ] ) ; } if ( ep2 <vul-end> < p + <vul-start> ) ; return ep2 <vul-end> + 1 ; <vul-start> 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <vul-start> 2 ] ; if (! <vul-start>, 2 ) ) { goto trunc ; } <vul-start> } else { if (! <vul-start> ) ) ; if (! <vul-start> + totlen ; trunc : return NULL ;\n"
 },
 {
  "id": 412,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int PredictorDecodeRow ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> decoderow != NULL ) ; assert ( sp -> decodepfunc != NULL ) ; if ( ( * sp -> decoderow ) ( tif , op0 , occ0 , s ) ) { <vul-start> ( * sp -> decodepfunc ) ( tif , op0 , occ0 ) ; <vul-end> <vul-start> return 1 ; <vul-end> } else return 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) ) { return <vul-start> occ0 ) ; <vul-end> } else return\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ) { if (! <vul-start>, occ0 ) ) return 0 ; else if (! s ) return 0 <vul-start> return 1 ; <vul-end> } else return\n"
 },
 {
  "id": 413,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ASN1_verify ( i2d_of_void * i2d , X509_ALGOR * a , ASN1_BIT_STRING * signature , char * data , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; const EVP_MD * type ; unsigned char * p , * buf_in = NULL ; int ret = - 1 , i , inl ; EVP_MD_CTX_init ( & ctx ) ; i = OBJ_obj2nid ( a -> algorithm ) ; type = EVP_get_digestbyname ( OBJ_nid2sn ( i ) ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } <vul-start> inl = i2d ( data , NULL ) ; <vul-end> buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } p = buf_in ; i2d ( data , & p ) ; ret = EVP_VerifyInit_ex ( & ctx , type , NULL ) && EVP_VerifyUpdate ( & ctx , ( unsigned char * ) buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_VerifyFinal ( & ctx , ( unsigned char * ) signature -> data , ( unsigned int ) signature -> length , pkey ) <= 0 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup (",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; }\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> err ; } if ( signature -> length!= 2 ) { ASN1err ( ASN1_F_ASN1_VERIFY, ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; }\n"
 },
 {
  "id": 414,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 key_ref_t keyring_search ( key_ref_t keyring , struct key_type * type , const char * description ) { struct keyring_search_context ctx = { . index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , <vul-start> . match_data . cmp = type -> match , <vul-end> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_DO_STATE_CHECK , } ; key_ref_t key ; <vul-start> int ret ; <vul-end> if ( ! ctx . match_data . cmp ) return ERR_PTR ( - ENOKEY ) ; if ( type -> match_preparse ) { ret = type -> match_preparse ( & ctx . match_data ) ; if ( ret < 0 ) return ERR_PTR ( ret ) ; } key = keyring_search_aux ( keyring , & ctx ) ; if ( type -> match_free ) type -> match_free ( & ctx . match_data ) ; return key ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> . cmp = key_default_cmp <vul-end> , . match_data <vul-start> ; int ret <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start>. match_data. key_type = type -> key_type,. match_data. <vul-start> int ret ; if (! type -> match_data. key_type ) { ret = key_permission ( type -> match_data. key, & ctx. match_data ) ; if ( ret < 0 ) return ERR_PTR ( ret ) ; }\n"
 },
 {
  "id": 415,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int ff_combine_frame ( ParseContext * pc , int next , const uint8_t * * buf , int * buf_size ) { if ( pc -> overread ) { av_dlog ( NULL , \"overread %d, state:%X next:%d index:%d o_index:%d\\\\n\" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , \"%X %X %X %X\\\\n\" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } for ( ; pc -> overread > 0 ; pc -> overread -- ) { pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ] ; } if ( ! * buf_size && next == END_NOT_FOUND ) { next = 0 ; } pc -> last_index = pc -> index ; if ( next == END_NOT_FOUND ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <vul-start> if ( ! new_buffer ) <vul-end> <vul-start> return AVERROR ( ENOMEM ) ; <vul-end> pc -> buffer = new_buffer ; memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ) ; pc -> index += * buf_size ; return - 1 ; } * buf_size = pc -> overread_index = pc -> index + next ; if ( pc -> index",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ! new_buffer ) { pc -> index = 0 ; <vul-start> ENOMEM ) ; } <vul-start> ! new_buffer ) { pc -> overread_index = pc -> index = 0 ; <vul-start> ENOMEM ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>! new_buffer ) { pc -> buffer = NULL ; <vul-start> ENOMEM ) ; }\n"
 },
 {
  "id": 416,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int fixup_bpf_calls ( struct bpf_verifier_env * env ) { struct bpf_prog * prog = env -> prog ; struct bpf_insn * insn = prog -> insnsi ; const struct bpf_func_proto * fn ; const int insn_cnt = prog -> len ; const struct bpf_map_ops * ops ; struct bpf_insn_aux_data * aux ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_prog * new_prog ; struct bpf_map * map_ptr ; int i , cnt , delta = 0 ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( insn -> code == ( BPF_ALU64 | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_DIV | BPF_X ) || insn -> code == ( BPF_ALU | BPF_MOD | BPF_X ) || insn -> code == ( BPF_ALU | BPF_DIV | BPF_X ) ) { bool is64 = BPF_CLASS ( insn -> code ) == BPF_ALU64 ; struct bpf_insn mask_and_div [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JNE , insn -> src_reg , 0 , 2 ) , BPF_ALU32_REG ( BPF_XOR , insn -> dst_reg , insn -> dst_reg ) , BPF_JMP_IMM ( BPF_JA , 0 , 0 , 1 ) , * insn , } ; struct bpf_insn mask_and_mod [ ] = { BPF_MOV32_REG ( insn -> src_reg , insn -> src_reg ) , BPF_JMP_IMM ( BPF_JEQ , insn -> src_reg , 0 , 1 ) , * insn , } ; struct bpf_insn * patchlet ; if ( insn -> code",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg <vul-end> ; aux = <vul-start> if ( ! aux -> alu_state <vul-end> ) continue ; <vul-start> ) continue ; isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf <vul-end> ; new_prog = <vul-start> } if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; <vul-end> aux = & <vul-start> ; if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( <vul-start> aux ) ) { verbose ( env , \"tail_call abusing map_ptr\\\\n\" ) ; return - EINVAL ; } <vul-end> map_ptr = BPF_MAP_PTR <vul-start> map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of <vul-end> ( map_ptr , <vul-start> ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; <vul-end> new_prog = bpf_patch_insn_data <vul-start> continue ; } if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , \"bpf verifier is misconfigured\\\\n\" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; }\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> continue ; } env -> cur_pc = insn -> dst_reg ; if (! bpf_verifier_is_valid_opcode ( insn ) ) return - EINVAL ; <vul-start> ; if ( bpf_map_ptr_is_unpriv <vul-end> ( aux ) <vul-start> ) goto patch_call_imm ; env -> cur_pc = aux -> map_state <vul-start> map_state ) ; cnt = ARRAY_SIZE ( aux -> map_state ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env, \"bpf verifier is misconfigured\\\\n\" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env, i + delta, insn_buf, cnt ) ; if (! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog -> insnsi + i + delta ; continue ; } if ( BPF_CLASS ( insn -> code ) == BPF_LD && ( BPF_MODE ( insn -> code ) == BPF_ABS || BPF_MODE ( insn -> code ) == BPF_IND ) ) { struct bpf_map * map = bpf_map_PTR ( aux -> map_state ) ; <vul-start> -> map_gen_lookup ) <vul-end> { verbose ( <vul-start>! __same_type ( map -> lookup_elem, ( void * ( * ) ( struct bpf_map * ) map -> ptrs [ 0 ] <vul-end> ) ) continue <vul-start> - ENOMEM ; <vul-end> delta += cnt\n"
 },
 {
  "id": 417,
  "question": "CWE-665 Code Input Vulnerable Code Is: CWE-665 void rfbSendServerCutText ( rfbScreenInfoPtr rfbScreen , char * str , int len ) { rfbClientPtr cl ; rfbServerCutTextMsg sct ; rfbClientIteratorPtr iterator ; <vul-start> iterator = rfbGetClientIterator ( rfbScreen ) ; <vul-end> while ( ( cl = rfbClientIteratorNext ( iterator ) ) != NULL ) { sct . type = rfbServerCutText ; sct . length = Swap32IfLE ( len ) ; LOCK ( cl -> sendMutex ) ; if ( rfbWriteExact ( cl , ( char * ) & sct , sz_rfbServerCutTextMsg ) < 0 ) { rfbLogPerror ( \"rfbSendServerCutText: write\" ) ; rfbCloseClient ( cl ) ; UNLOCK ( cl -> sendMutex ) ; continue ; } if ( rfbWriteExact ( cl , str , len ) < 0 ) { rfbLogPerror ( \"rfbSendServerCutText: write\" ) ; rfbCloseClient ( cl ) ; } UNLOCK ( cl -> sendMutex ) ; rfbStatRecordMessageSent ( cl , rfbServerCutText , sz_rfbServerCutTextMsg + len , sz_rfbServerCutTextMsg + len ) ; } rfbReleaseClientIterator ( iterator ) ; }",
  "golden_answers": [
   "CWE-665 Fixed Code Lines are: <vul-start> rfbClientIteratorPtr iterator ; memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ;\n"
  ],
  "generated_answer": "CWE-665 Fixed Code Lines are: <vul-start> rfbScreen ) ; if ( iterator == NULL ) { return ; }\n"
 },
 {
  "id": 418,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int read_filesystem_tables_4 ( ) { <vul-start> long long directory_table_end , table_start ; <vul-end> if ( read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 ) <vul-start> return FALSE ; <vul-end> if ( read_uids_guids ( & table_start ) == FALSE ) <vul-start> return FALSE ; <vul-end> if ( parse_exports_table ( & table_start ) == FALSE ) <vul-start> return FALSE ; <vul-end> <vul-start> if ( read_fragment_table ( & directory_table_end ) == FALSE ) <vul-end> return FALSE ; if ( read_inode_table ( sBlk . s . inode_table_start , sBlk . s . directory_table_start ) == FALSE ) <vul-start> return FALSE ; <vul-end> if ( read_directory_table ( sBlk . s . directory_table_start , directory_table_end ) == FALSE ) return FALSE ; if ( no_xattrs ) sBlk . s . xattr_id_table_start = SQUASHFS_INVALID_BLK ; return TRUE ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> { long long table_start ; if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) { ERROR ( \"read_filesystem_tables: xattr id table start too large in super block\\\\n\" ) ; goto corrupted ; } <vul-end> if ( read_xattrs_from_disk <vul-start> == 0 ) goto corrupted ; } else table_start = sBlk . s . bytes_used ; if ( sBlk . s . id_table_start >= table_start ) { ERROR ( \"read_filesystem_tables: id table start too large in super block\\\\n\" ) ; goto corrupted ; } if ( sBlk . s . no_ids == 0 ) { ERROR ( \"read_filesystem_tables: Bad id count in super block\\\\n\" ) ; goto corrupted ; } if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) { ERROR ( \"read_filesystem_tables: Bad id count in super block\\\\n\" ) ; goto corrupted ; } if ( read_id_table <vul-end> ( & table_start <vul-start> == FALSE ) goto corrupted ; if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . lookup_table_start >= table_start ) { ERROR ( \"read_filesystem_tables: lookup table start too large in super block\\\\n\" ) ; goto corrupted ; } <vul-end> if ( parse_exports_table <vul-start> == FALSE ) goto corrupted ; } if ( sBlk . s . fragments != 0 ) { if ( sBlk . s . fragment_table_start >= table_start ) { ERROR ( \"read_filesystem_tables: fragment table start too large in super block\\\\n\" ) ; goto corrupted ; } if ( sBlk . s . fragments > sBlk . s . inodes ) { ERROR ( \"read_filesystem_tables: Bad fragment count in super block\\\\n\" ) ; goto corrupted ; } <vul-end> if ( read_fragment_table <vul-start> read_fragment_table ( & table_start ) == FALSE ) goto corrupted ; } else { if ( sBlk . s . fragment_table_start != table_start ) { ERROR ( \"read_filesystem_tables: fragment table start invalid in super block\\\\n\" ) ; goto corrupted ; } } if ( sBlk . s . directory_table_start >= table_start ) { ERROR ( \"read_filesystem_tables: directory table start too large in super block\\\\n\" ) ; goto corrupted ; } if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ; if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) { ERROR ( \"read_filesystem_tables: inode table start too large in super block\\\\n\" ) ; goto corrupted ; } <vul-end> if ( read_inode_table <vul-start> == FALSE ) goto corrupted <vul-end> ; if ( <vul-start> return TRUE ; corrupted : ERROR ( \"File system corruption detected\\\\n\" ) ; return FALSE ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( ) { int directory_table_start, table_start ; struct super_block * sb = NULL <vul-end> ; if ( <vul-start> == 0 ) { return FALSE ; } <vul-end> if ( read_uids_guids <vul-start> == FALSE ) { return FALSE ; } <vul-end> if ( parse_exports_table <vul-start> == FALSE ) { return FALSE ; } <vul-end> if ( read_fragment_table <vul-start> read_fragment_table ( & sb ) == FALSE ) { return FALSE ; } <vul-end> if ( read_inode_table <vul-start> == FALSE ) { return FALSE ; } <vul-end> if ( read_directory_table <vul-start> == FALSE ) { return FALSE ; } <vul-end> if ( no_xattrs <vul-start> TRUE ; } if ( sb_read_directory_table ( & sBlk. s. directory_table_end, sBlk. s. directory_table_start ) == FALSE ) { return FALSE ; } return TRUE ; }\n"
 },
 {
  "id": 419,
  "question": "CWE-732 Code Input Vulnerable Code Is: CWE-732 static struct env * <vul-start> createenv ( const struct rule * rule ) <vul-end> { struct env * env ; u_int i ; env = malloc ( sizeof ( * env ) ) ; if ( ! env ) err ( 1 , NULL ) ; RB_INIT ( & env -> root ) ; <vul-start> env -> count = 0 ; <vul-end> if ( rule -> options & KEEPENV ) { extern char * * environ ; for ( i = 0 ; environ [ i ] != NULL ; i ++ ) { struct envnode * node ; const char * e , * eq ; size_t len ; char keybuf [ 1024 ] ; e = environ [ i ] ; if ( ( eq = strchr ( e , '=' ) ) == NULL || eq == e ) continue ; len = eq - e ; if ( len > sizeof ( keybuf ) - 1 ) continue ; memcpy ( keybuf , e , len ) ; keybuf [ len ] = '\\\\0' ; node = createnode ( keybuf , eq + 1 ) ; if ( RB_INSERT ( envtree , & env -> root , node ) ) { freenode ( node ) ; } else { env -> count ++ ; } } <vul-start> } <vul-end> return env ; }",
  "golden_answers": [
   "CWE-732 Fixed Code Lines are: <vul-start> rule * rule , const struct passwd * mypw , const struct passwd * targpw <vul-start> count = 0 ; addnode ( env , \"DOAS_USER\" , mypw -> pw_name ) <vul-start> } } } else { static const char * copyset [ ] = { \"DISPLAY\" , \"TERM\" , NULL } ; addnode ( env , \"HOME\" , targpw -> pw_dir ) ; addnode ( env , \"LOGNAME\" , targpw -> pw_name ) ; addnode ( env , \"PATH\" , getenv ( \"PATH\" ) ) ; addnode ( env , \"SHELL\" , targpw -> pw_shell ) ; addnode ( env , \"USER\" , targpw -> pw_name ) ; fillenv ( env , copyset ) ; }\n"
  ],
  "generated_answer": "CWE-732 Fixed Code Lines are: <vul-start> rule * rule, const struct passwd * mypw, const struct passwd * targpw ) { struct env * env ; u_int i ; if ( rule -> options & KEEPENV ) { extern char * * environ ; if ( mypw && ( rule -> options & KEEPENV ) ) rule -> options |= KEEPENV ; } env = malloc ( sizeof ( * env ) ) ; if (! env ) err ( 1, NULL ) ; RB_INIT ( & env -> count = 0 ; env -> root. val = NULL ; env -> root. type = KEEP_ENV ; env -> root. envid = 0 ; env -> root. envname = NULL ; env -> root. envvalue = NULL ; env -> root. type = KEEP_ENV ; if ( mypw && ( rule -> options & KEEPENV ) ) rule -> options |= KEEPENV ; if ( rule -> options & KEEPENV ) { extern char * * <vul-end> environ ; for <vul-start> ; } } if ( env -> count > 0 ) free ( env -> environ [ 0 ] ) ;\n"
 },
 {
  "id": 420,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 BOOL rdp_read_share_control_header ( wStream * s , UINT16 * length , UINT16 * type , UINT16 * channel_id ) { <vul-start> if ( Stream_GetRemainingLength ( s ) < 2 ) <vul-end> return FALSE ; <vul-start> Stream_Read_UINT16 ( s , * length ) ; <vul-end> <vul-start> if ( * length == 0x8000 ) <vul-end> { <vul-start> rdp_read_flow_control_pdu ( s , type ) ; <vul-end> * channel_id = 0 ; * length = 8 ; return TRUE ; } <vul-start> if ( ( ( size_t ) * length - 2 ) > Stream_GetRemainingLength ( s ) ) <vul-end> return FALSE ; Stream_Read_UINT16 ( s , * type ) ; * type &= 0x0F ; <vul-start> if ( * length > 4 ) <vul-end> Stream_Read_UINT16 ( s , * channel_id ) ; else * channel_id = 0 ; return TRUE ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> channel_id ) { UINT16 len ; <vul-start> ( s , len ) ; * length = len <vul-end> ; if ( <vul-start> ; if ( len <vul-end> == 0x8000 ) <vul-start> 0x8000 ) { if ( ! <vul-start> , type ) ) return FALSE <vul-start> if ( ( len < 4 ) || ( ( len <vul-end> - 2 ) <vul-start> Stream_GetRemainingLength ( s ) <vul-start> ; if ( len <vul-end> > 4 )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> channel_id ) { UINT16 remaining_length = Stream_GetRemainingLength ( s ) ; if ( remaining_length < 2 ) { <vul-end> return FALSE ; <vul-start> return FALSE ; } if ( remaining_length == 0 ) { return FALSE ; } <vul-start> ; if ( remaining_length <vul-end> == 0x8000 ) <vul-start> 0x8000 ) { if (! <vul-start>, type ) ) return FALSE <vul-start> } if ( remaining_length - 2 <vul-end> > Stream_GetRemainingLength ( <vul-start> &= 0x0F ; remaining_length -= 2 ;\n"
 },
 {
  "id": 421,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; tnl_hlen = skb_tnl_header_len ( skb ) ; <vul-start> if ( skb_headroom",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> ; if ( skb -> mac_header <vul-end> < ( tnl_hlen\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ; if ( skb_mac_header <vul-end> ( skb ) <vul-start> skb ) < skb -> head +\n"
 },
 {
  "id": 422,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int tap_if_up ( const char * devname , const bt_bdaddr_t * addr ) { struct ifreq ifr ; int sk , err ; sk = socket ( AF_INET , SOCK_DGRAM , 0 ) ; if ( sk < 0 ) return - 1 ; memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IFNAMSIZ - 1 ) ; <vul-start> err = ioctl ( sk , SIOCGIFHWADDR , & ifr ) ; <vul-end> if ( err < 0 ) { BTIF_TRACE_ERROR ( \"Could not get network hardware for interface:%s, errno:%s\" , devname , strerror ( errno ) ) ; close ( sk ) ; return - 1 ; } strncpy ( ifr . ifr_name , devname , IFNAMSIZ - 1 ) ; memcpy ( ifr . ifr_hwaddr . sa_data , addr -> address , 6 ) ; if ( ifr . ifr_hwaddr . sa_data [ 0 ] & 0x01 ) { BTIF_TRACE_WARNING ( \"Not a unicast MAC address, force multicast bit flipping\" ) ; ifr . ifr_hwaddr . sa_data [ 0 ] &= ~ 0x01 ; } <vul-start> err = ioctl ( sk , SIOCSIFHWADDR , ( caddr_t ) & ifr ) ; <vul-end> if ( err < 0 ) { BTIF_TRACE_ERROR ( \"Could not set bt address for interface:%s, errno:%s\" , devname , strerror ( errno ) ) ; close ( sk ) ; return - 1 ; } memset ( & ifr , 0 , sizeof ( ifr ) ) ; strncpy ( ifr . ifr_name , devname , IF_NAMESIZE -",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ; err = TEMP_FAILURE_RETRY ( <vul-start> , & ifr ) <vul-start> } err = TEMP_FAILURE_RETRY ( <vul-start> ) & ifr ) <vul-start> ; err = TEMP_FAILURE_RETRY ( <vul-start> & ifr ) )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ; err = TEMP_FAILURE_RETRY ( <vul-start>, & ifr ) <vul-start> } err = TEMP_FAILURE_RETRY ( <vul-start> ) & ifr )\n"
 },
 {
  "id": 423,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int get_down2_steps ( int in_length , int out_length ) { <vul-end> int steps = 0 ; int proj_in_length ; while ( ( proj_in_length = get_down2_length ( in_length , 1 ) ) >= out_length ) { ++ steps ; in_length = proj_in_length ; } return steps ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>       static\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>       static\n"
 },
 {
  "id": 424,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static __u8 * ch_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <vul-start> if ( * rsize >= 17 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { <vul-end> hid_info ( hdev , \"fixing up Cherry Cymotion report descriptor\\\\n\" ) ; rdesc [ 11 ] = rdesc [ 16 ] = 0xff ; rdesc [ 12 ] = rdesc [ 17 ] = 0x03 ; } return rdesc ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * rsize >= 18 <vul-end> && rdesc [\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * rsize >= 19 <vul-end> && rdesc [\n"
 },
 {
  "id": 425,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void parse_hid_report_descriptor ( struct gtco * device , char * report , int length ) { struct device * ddev = & device -> intf -> dev ; int x , i = 0 ; __u8 prefix ; __u8 size ; __u8 tag ; __u8 type ; __u8 data = 0 ; __u16 data16 = 0 ; __u32 data32 = 0 ; int inputnum = 0 ; __u32 usage = 0 ; __u32 globalval [ TAG_GLOB_MAX ] ; __u32 oldval [ TAG_GLOB_MAX ] ; char maintype = 'x' ; char globtype [ 12 ] ; int indent = 0 ; char indentstr [ 10 ] = \"\" ; dev_dbg ( ddev , \"======>>>>>>PARSE<<<<<<======\\\\n\" ) ; while ( i < length ) { <vul-start> prefix = report [ i ] ; <vul-end> i ++ ; size = PREF_SIZE ( prefix ) ; switch ( size ) { case 1 : data = report [ i ] ; break ; case 2 : data16 = get_unaligned_le16 ( & report [ i ] ) ; break ; <vul-start> case 3 : <vul-end> size = 4 ; data32 = get_unaligned_le32 ( & report [ i ] ) ; break ; } i += size ; tag = PREF_TAG ( prefix ) ; type = PREF_TYPE ( prefix ) ; switch ( type ) { case TYPE_MAIN : strcpy ( globtype , \"\" ) ; switch ( tag ) { case TAG_MAIN_INPUT : maintype = 'I' ; if ( data == 2 ) strcpy ( globtype , \"Variable\" ) ; else if ( data == 3 ) strcpy (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> report [ i ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , \"Not enough data (need %d, have %d)\\\\n\" , i + size , length ) ; break ; } <vul-end> switch ( size <vul-start> break ; case 4 : <vul-end> data32 = get_unaligned_le32\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> length ) { if ( i + size > length ) break ; <vul-start> case 3 : if ( i + 4 > length ) break ;\n"
 },
 {
  "id": 426,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <vul-start> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <vul-end> { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , \"Composite Document File V2 Document\" ) == - 1 ) return - 1 ; if ( file_printf ( ms , \", %s Endian\" , si . si_byte_order == 0xfffe ? \"Little\" : \"Big\" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , \", Os: Windows, Version %d.%d\" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , \", Os: MacOS, Version %d.%d\" , ( uint32_t ) si . si_os_version >> 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , \", Os %d, Version: %d.%d\" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; } <vul-start> str = cdf_clsid_to_mime ( clsid",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> sst , const cdf_directory_t * root_storage <vul-end> ) { cdf_summary_info_header_t <vul-start> break ; } if ( root_storage ) { <vul-start> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <vul-end> , clsid2desc ) <vul-start> - 2 ; } <vul-start> , count , root_storage <vul-end> ) ; free\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> sst, const cdf_directory_t * root_storage <vul-end> ) { cdf_summary_info_header_t <vul-start> break ; } if ( root_storage ) { str = cdf_clsid_to_mime ( root_storage -> d_storage_uuid, clsid2desc ) ; if ( str ) if ( file_printf ( ms, \", %s\", str ) == - 1 ) return - 2 ; } else { <vul-start> 2 ; } }\n"
 },
 {
  "id": 427,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 node * PyParser_ParseStringObject ( const char * s , PyObject * filename , grammar * g , int start , perrdetail * err_ret , int * flags ) { struct tok_state * tok ; int exec_input = start == file_input ; if ( initerr ( err_ret , filename ) < 0 ) return NULL ; if ( * flags & PyPARSE_IGNORE_COOKIE ) tok = PyTokenizer_FromUTF8 ( s , exec_input ) ; else tok = PyTokenizer_FromString ( s , exec_input ) ; if ( tok == NULL ) { err_ret -> error = PyErr_Occurred ( ) ? E_DECODE : E_NOMEM ; return NULL ; } <vul-start> # ifndef PGEN <vul-end> Py_INCREF ( err_ret -> filename ) ; tok -> filename = err_ret -> filename ; # endif return parsetok ( tok , g , start , err_ret , flags ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> NULL ; } if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> NULL ; } if ( * flags & PyPARSE_ASYNC_ALWAYS ) tok -> async_always = 1 ;\n"
 },
 {
  "id": 428,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void set_segment_id ( VP9_COMMON * cm , BLOCK_SIZE bsize , <vul-end> int mi_row , int mi_col , int segment_id ) { <vul-start> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; <vul-end> const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; const int bh = num_8x8_blocks_high_lookup [ bsize ] ; const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ; int x , y ; assert ( segment_id >= 0 && segment_id < MAX_SEGMENTS ) ; <vul-start> for ( y = 0 ; y < ymis ; y ++ ) <vul-end> <vul-start> for ( x = 0 ; x < xmis ; x ++ ) <vul-end> <vul-start> cm -> last_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cm , int mi_offset , int x_mis , int y_mis <vul-end> , int segment_id <vul-start> segment_id ) { <vul-end> int x , <vul-start> ; y < y_mis <vul-end> ; y ++ <vul-start> ; x < x_mis <vul-end> ; x ++ <vul-start> ) cm -> current_frame_seg_map <vul-end> [ mi_offset +\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void set_segment_id ( const VP9_COMMON * const <vul-end> cm, BLOCK_SIZE <vul-start> { const int segment_id = get_segment_id ( cm, mi_row, mi_col ) ; const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; const int bh = num_8x8_blocks_high_lookup [ bsize ] ; const int xmis = MIN ( cm -> mi_cols - mi_col, bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row, bh ) ; const int xmis = MIN ( cm -> mi_cols - mi_col, bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row, bh ) ; const int xmis = MIN ( cm -> mi_cols - mi_col, bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row, bh ) ; const int <vul-start> MAX_SEGMENTS ) ; set_segment_id_internal ( cm, segment_id, mi_row, mi_col, xmis ) ; <vul-start> y ++ ) { <vul-start> x ++ ) { <vul-start> = segment_id ; set_segment_id_internal ( cm, segment_id, y, x ) ; } }\n"
 },
 {
  "id": 429,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; <vul-start> if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <vul-end> atomic_inc ( & key -> user -> nikeys ) ; <vul-start> key -> reject_error = - error ; <vul-end> smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ; if ( keyring && link_ret == 0 ) __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key -> state == KEY_IS_UNINSTANTIATED <vul-end> ) { atomic_inc <vul-start> nikeys ) ; mark_key_instantiated ( key , - error <vul-end> ) ; now\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key -> state == KEY_IS_UNINSTANTIATED <vul-end> ) { atomic_inc <vul-start> nikeys ) ; mark_key_instantiated ( key, 0 <vul-end> ) ; now\n"
 },
 {
  "id": 430,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int cdf_unpack_summary_info ( const cdf_stream_t * sst , const cdf_header_t * h , cdf_summary_info_header_t * ssi , cdf_property_info_t * * info , size_t * count ) { <vul-start> size_t i , maxcount ; <vul-end> const cdf_summary_info_header_t * si = CAST ( const cdf_summary_info_header_t * , sst -> sst_tab ) ; const cdf_section_declaration_t * sd = CAST ( const cdf_section_declaration_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + CDF_SECTION_DECLARATION_OFFSET ) ) ; if ( cdf_check_stream_offset ( sst , h , si , sizeof ( * si ) , __LINE__ ) == - 1 || cdf_check_stream_offset ( sst , h , sd , sizeof ( * sd ) , __LINE__ ) == - 1 ) return - 1 ; ssi -> si_byte_order = CDF_TOLE2 ( si -> si_byte_order ) ; ssi -> si_os_version = CDF_TOLE2 ( si -> si_os_version ) ; ssi -> si_os = CDF_TOLE2 ( si -> si_os ) ; ssi -> si_class = si -> si_class ; cdf_swap_class ( & ssi -> si_class ) ; <vul-start> ssi -> si_count = CDF_TOLE2 ( si -> si_count ) ; <vul-end> * count = 0 ; maxcount = 0 ; * info = NULL ; <vul-start> for ( i = 0 ; i < CDF_TOLE4 ( si -> si_count ) ; i ++ ) { <vul-end> if ( i >= CDF_LOOP_LIMIT ) { DPRINTF ( ( \"Unpack summary info loop limit\" ) ) ; errno = EFTYPE ; return - 1 ; } if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( sd -> sd_offset ) ,",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ) { size_t <vul-end> maxcount ; const <vul-start> -> si_count = CDF_TOLE4 <vul-end> ( si -> <vul-start> = NULL ; if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( <vul-end> sd -> sd_offset <vul-start> - 1 ) <vul-end> return - 1 <vul-start> - 1 ; <vul-end> return 0 ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> i, maxcount, count_left <vul-start> si_class ) ; count_left = CDF_TOLE4 ( si -> si_count ) ; if ( count_left < CDF_LOOP_LIMIT ) { DPRINTF ( ( \"Unpack summary info loop limit\" ) ) ; errno = EFTYPE ; return - 1 ; } <vul-start> ; i < count_left <vul-end> ; i ++ <vul-start> ++ ) { if ( i >= count_left ) { DPRINTF ( ( \"Unpack summary info loop limit\" ) ) ; errno = EFTYPE ; return - 1 ; } <vul-start> - 1 ) <vul-end> return - 1 <vul-start> - 1 ; <vul-end> } return 0\n"
 },
 {
  "id": 431,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static inline void header_put_byte ( SF_PRIVATE * psf , char x ) <vul-start> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 1 ) <vul-end> <vul-start> psf -> header [ psf -> headindex ++ ] = x ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> x ) { <vul-end> psf -> header <vul-start> psf -> header . ptr [ <vul-end> psf -> header <vul-start> psf -> header . indx <vul-end> ++ ] =\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> x ) { <vul-end> psf -> header <vul-start> psf -> header. ptr [ <vul-end> psf -> header <vul-start> psf -> header. indx <vul-end> ++ ] =\n"
 },
 {
  "id": 432,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static char * cJSON_strdup ( const char * str ) { size_t len ; char * copy ; len = strlen ( str ) + 1 ; if ( ! ( copy = ( char * ) cJSON_malloc ( len ) ) ) return 0 ; memcpy ( copy , str , len ) ; return copy ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: \n"
 },
 {
  "id": 433,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int calc_partial_ssl_err ( YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * dest ) { int i , j ; int Total = 0 ; int srcoffset , dstoffset ; unsigned char * src = source -> y_buffer ; unsigned char * dst = dest -> y_buffer ; int linestocopy ; linestocopy = ( source -> y_height >> 4 ) / PARTIAL_FRAME_FRACTION ; linestocopy = linestocopy ? linestocopy << 4 : 16 ; srcoffset = source -> y_stride * ( ( dest -> y_height >> 5 ) * 16 ) ; dstoffset = dest -> y_stride * ( ( dest -> y_height >> 5 ) * 16 ) ; src += srcoffset ; dst += dstoffset ; for ( i = 0 ; i < linestocopy ; i += 16 ) { for ( j = 0 ; j < source -> y_width ; j += 16 ) { unsigned int sse ; <vul-start> Total += vp8_mse16x16 ( src + j , source -> y_stride , <vul-end> dst + j , dest -> y_stride , & sse ) ; } src += 16 * source -> y_stride ; dst += 16 * dest -> y_stride ; } return Total ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; Total += vpx_mse16x16 <vul-end> ( src +\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; Total += vpx_mse16x16 <vul-end> ( src +\n"
 },
 {
  "id": 434,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int nfs4_do_close ( struct path * path , struct nfs4_state * state , int wait ) { struct nfs_server * server = NFS_SERVER ( state -> inode ) ; struct nfs4_closedata * calldata ; struct nfs4_state_owner * sp = state -> owner ; struct rpc_task * task ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_CLOSE ] , . rpc_cred = state -> owner -> so_cred , } ; struct rpc_task_setup task_setup_data = { . rpc_client = server -> client , . rpc_message = & msg , . callback_ops = & nfs4_close_ops , . workqueue = nfsiod_workqueue , . flags = RPC_TASK_ASYNC , } ; int status = - ENOMEM ; calldata = kmalloc ( sizeof ( * calldata ) , GFP_KERNEL ) ; if ( calldata == NULL ) goto out ; calldata -> inode = state -> inode ; calldata -> state = state ; calldata -> arg . fh = NFS_FH ( state -> inode ) ; calldata -> arg . stateid = & state -> open_stateid ; calldata -> arg . seqid = nfs_alloc_seqid ( & state -> owner -> so_seqid ) ; if ( calldata -> arg . seqid == NULL ) goto out_free_calldata ; <vul-start> calldata -> arg . open_flags = 0 ; <vul-end> calldata -> arg . bitmask = server -> attr_bitmask ; calldata -> res . fattr = & calldata -> fattr ; calldata -> res . seqid = calldata -> arg . seqid ; calldata -> res . server = server ; calldata -> path . mnt = mntget ( path ->",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> -> arg . fmode <vul-end> = 0 ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> -> arg. <vul-end> bitmask = server\n"
 },
 {
  "id": 435,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int flush_completed_IO ( struct inode * inode ) { <vul-start> ext4_io_end_t * io ; <vul-end> int ret = 0 ; int ret2 = 0 ; <vul-start> if ( list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) <vul-end> return ret ; dump_completed_IO ( inode ) ; <vul-start> while ( ! list_empty ( & EXT4_I ( inode ) -> i_completed_io_list ) ) { <vul-end> <vul-start> io = list_entry ( EXT4_I ( inode ) -> i_completed_io_list . next , <vul-end> ext4_io_end_t , list ) ; <vul-start> ret = ext4_end_io_nolock ( io ) ; <vul-end> if ( ret < 0 ) ret2 = ret ; else list_del_init ( & io -> list ) ; } <vul-start> return ( ret2 < 0 ) ? ret2 : 0 ; <vul-end> }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ext4_io_end_t * io ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags <vul-start> list_empty ( & ei <vul-end> -> i_completed_io_list ) <vul-start> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <vul-start> list_empty ( & ei <vul-end> -> i_completed_io_list ) <vul-start> = list_entry ( ei <vul-end> -> i_completed_io_list . <vul-start> list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <vul-start> ext4_end_io_nolock ( io ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags <vul-start> ) ; } spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> inode ) { struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags ; int ret <vul-end> = 0 ; <vul-start> = 0 ; unsigned long flags_end = 0 ; <vul-start> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock, flags_end ) ; <vul-start> ) ) { ext4_io_end_t * io ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock, flags_end ) ; <vul-start> list ) ; if ( io ) { <vul-start> ) ; } } spin_unlock_irqrestore ( & ei -> i_completed_io_lock, flags_end ) ;\n"
 },
 {
  "id": 436,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 int __usb_get_extra_descriptor ( char * buffer , unsigned size , <vul-start> unsigned char type , void * * ptr ) <vul-end> { struct usb_descriptor_header * header ; while ( size >= sizeof ( struct usb_descriptor_header ) ) { header = ( struct usb_descriptor_header * ) buffer ; <vul-start> if ( header -> bLength < 2 ) { <vul-end> printk ( KERN_ERR \"%s: bogus descriptor, type %d length %d\\\\n\" , usbcore_name , header -> bDescriptorType , header -> bLength ) ; return - 1 ; } <vul-start> if ( header -> bDescriptorType == type ) { <vul-end> * ptr = header ; return 0 ; } buffer += header -> bLength ; size -= header -> bLength ; } return - 1 ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> * * ptr , size_t minsize <vul-start> bLength < 2 || header -> bLength > size <vul-start> bDescriptorType == type && header -> bLength >= minsize\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> unsigned char type <vul-end> ) { struct <vul-start> -> bLength < sizeof ( struct usb_descriptor_header ) <vul-end> ) { printk <vul-start> 1 ; } switch ( type ) { case USB_DT_STRING : if ( header -> bLength < 2 || header -> bLength > size ) return - EINVAL ; break ; case USB_DT_VIDEO : if ( header -> bLength < 4 ) return - EINVAL ; break ; default : printk ( KERN_ERR \"%s: invalid descriptor type %d\\\\n\", usbcore_name, header -> bDescriptorType ) ; return - EINVAL ; }\n"
 },
 {
  "id": 437,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( \"Usage: %s mj2filename output_location\\\\n\" , argv [ 0 ] ) ; printf ( \"Example: %s foreman.mj2 output/foreman\\\\n\" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , \"rb\" ) ; if ( ! file ) { fprintf ( stderr , \"failed to open %s for reading\\\\n\" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> file ) ; { int num = snprintf <vul-end> ( outfilename , <vul-start> ( outfilename , sizeof ( outfilename ) , <vul-start> 2 ] , snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , \"maximum length of output prefix exceeded\\\\n\" ) ; free ( frame_codestream ) ; return 1 ; } } <vul-end> outfile = fopen <vul-start> \"failed to open %s for writing\\\\n\" , outfilename ) ; free ( frame_codestream\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, \"%s_%05d.j2k\", exec_name <vul-end>, snum ) <vul-start> ( stderr, \"Failed to open %s for writing\\\\n\" <vul-end>, outfilename )\n"
 },
 {
  "id": 438,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_setup_in_frame_q_adj ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; struct segmentation * const seg = & cm -> seg ; <vul-start> vp9_clear_system_state ( ) ; <vul-end> if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { int segment ; <vul-start> vpx_memset ( cpi -> segmentation_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; <vul-end> vpx_memset ( cpi -> complexity_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ; for ( segment = 1 ; segment < 2 ; segment ++ ) { const int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , <vul-start> in_frame_q_adj_ratio [ segment ] ) ; <vul-end> vp9_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ; vp9_set_segdata ( seg , segment , SEG_LVL_ALT_Q , qindex_delta ) ; } } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> seg ; vpx_clear_system_state <vul-end> ( ) ; <vul-start> int segment ; const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ; memset ( cpi -> segmentation_map , DEFAULT_AQ2_SEG , cm -> mi_rows * cm -> mi_cols ) ; vp9_clearall_segfeatures ( seg ) ; if ( cpi -> rc . sb64_target_rate < 256 ) { vp9_disable_segmentation ( seg ) ; return ; } vp9_enable_segmentation ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , DEFAULT_AQ2_SEG , SEG_LVL_ALT_Q ) ; for ( segment = 0 ; segment < AQ_C_SEGMENTS ; ++ segment ) { int qindex_delta ; if ( segment == DEFAULT_AQ2_SEG ) continue ; <vul-end> qindex_delta = vp9_compute_qdelta_by_rate <vul-start> -> base_qindex , aq_c_q_adj_factor [ aq_strength ] [ segment ] , cm -> bit_depth ) ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( ( cm -> base_qindex + qindex_delta ) > 0 ) { <vul-end> vp9_enable_segfeature ( seg <vul-start> } } } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> seg ; int segment_adj_ratio [ MAX_VP9_SEGMENTATION_SIZE ] ; memset ( cpi -> common. seg. base, 0, sizeof ( seg -> base ) ) ; seg -> abs_delta = SEGMENT_DELTADATA ; if ( seg -> is_key_frame ) { if ( cpi -> rc. is_src_frame_alt_ref ) return ; segment_adj_ratio [ segment ] = in_frame_q_adj_ratio [ segment ] ; } else if ( seg -> is_key_frame ) { if ( seg -> seg. base. segment_type == KEY_FRAME ) { seg -> seg. base. segment_type = KEY_FRAME ; seg -> seg. base. segment_size = sizeof ( seg -> base. segment_size ) ; seg -> seg. base. segment_size = segment_adj_ratio [ segment ] ; } } <vul-start> -> base_qindex, segment_adj_ratio <vul-end> ) ; vp9_enable_segfeature <vul-start> ; } } vp9_clear_system_state ( ) ; seg -> is_key_frame = 0 ;\n"
 },
 {
  "id": 439,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) { int name_end = - 1 ; int j = * idx ; int ptr_count = 0 ; # define GET32 ( x ) do { if ( j + 4 > length ) goto err ; memcpy ( & t32_ , packet + j , 4 ) ; j += 4 ; x = ntohl ( t32_ ) ; } while ( 0 ) # define GET16 ( x ) do { if ( j + 2 > length ) goto err ; memcpy ( & t_ , packet + j , 2 ) ; j += 2 ; x = ntohs ( t_ ) ; } while ( 0 ) # define GET8 ( x ) do { if ( j >= length ) goto err ; x = packet [ j ++ ] ; } while ( 0 ) char * cp = name_out ; const char * const end = name_out + name_out_len ; for ( ; ; ) { u8 label_len ; <vul-start> if ( j >= length ) return - 1 ; <vul-end> GET8 ( label_len ) ; if ( ! label_len ) break ; if ( label_len & 0xc0 ) { u8 ptr_low ; GET8 ( ptr_low ) ; if ( name_end < 0 ) name_end = j ; j = ( ( ( int ) label_len & 0x3f ) << 8 ) + ptr_low ; if ( j < 0 || j >= length )",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> u8 label_len ; <vul-end> GET8 ( label_len <vul-start> - 1 ; if ( j + label_len > length ) return - 1 ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> u8 label_len ; int label_len_left = length - j - 1 ; if ( label_len_left < 0 ) goto err <vul-end> ; GET8 ( <vul-start> - 1 ; if (! label_len_left ) goto err ; <vul-start> + j, label_len_left <vul-end> ) ; cp\n"
 },
 {
  "id": 440,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void beep_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { <vul-start> if ( l_strnstart ( \"MSG\" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP MSG\" ) ) ; <vul-start> else if ( l_strnstart ( \"RPY \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP RPY\" ) ) ; <vul-start> else if ( l_strnstart ( \"ERR \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP ERR\" ) ) ; <vul-start> else if ( l_strnstart ( \"ANS \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP ANS\" ) ) ; <vul-start> else if ( l_strnstart ( \"NUL \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP NUL\" ) ) ; <vul-start> else if ( l_strnstart ( \"SEQ \" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP SEQ\" ) ) ; <vul-start> else if ( l_strnstart ( \"END\" , 4 , ( const char * ) bp , length ) ) <vul-end> ND_PRINT ( ( ndo , \" BEEP END\" ) ) ; else ND_PRINT ( ( ndo , \" BEEP (payload or undecoded)\" ) ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo , <vul-start> ( l_strnstart ( ndo ,\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> { if ( l_strnstart <vul-end> ( \"MSG\", <vul-start> ) ) ; } <vul-start> else if ( l_strnstart <vul-end> ( \"RPY \", <vul-start> ) ) ; } <vul-start> else if ( l_strnstart <vul-end> ( \"ERR \", <vul-start> ) ) ; } <vul-start> else if ( l_strnstart <vul-end> ( \"ANS \", <vul-start> ) ) ; } <vul-start> else if ( l_strnstart <vul-end> ( \"NUL \", <vul-start> ) ) ; } <vul-end> else if ( <vul-start> ) ) ; } if ( l_strnstart <vul-end> ( \"SEQ \", <vul-start> ) ) ; } if ( l_strnstart <vul-end> ( \"END\", <vul-start> ) ) ; else ND_PRINT ( ( ndo, \" BEEP END\" ) ) ;\n"
 },
 {
  "id": 441,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 opj_image_t * tgatoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f ; opj_image_t * image ; unsigned int image_width , image_height , pixel_bit_depth ; unsigned int x , y ; int flip_image = 0 ; opj_image_cmptparm_t cmptparm [ 4 ] ; int numcomps ; OPJ_COLOR_SPACE color_space ; OPJ_BOOL mono ; OPJ_BOOL save_alpha ; int subsampling_dx , subsampling_dy ; int i ; f = fopen ( filename , \"rb\" ) ; if ( ! f ) { fprintf ( stderr , \"Failed to open %s for reading !!\\\\n\" , filename ) ; return 0 ; } if ( ! tga_readheader ( f , & pixel_bit_depth , & image_width , & image_height , & flip_image ) ) { fclose ( f ) ; return NULL ; } if ( ! ( ( pixel_bit_depth == 24 ) || ( pixel_bit_depth == 32 ) ) ) { fclose ( f ) ; return NULL ; } memset ( & cmptparm [ 0 ] , 0 , 4 * sizeof ( opj_image_cmptparm_t ) ) ; mono = ( pixel_bit_depth == 8 ) || ( pixel_bit_depth == 16 ) ; save_alpha = ( pixel_bit_depth == 16 ) || ( pixel_bit_depth == 32 ) ; if ( mono ) { color_space = OPJ_CLRSPC_GRAY ; numcomps = save_alpha ? 2 : 1 ; } else { numcomps = save_alpha ? 4 : 3 ; color_space = OPJ_CLRSPC_SRGB ; } <vul-start> subsampling_dx = parameters -> subsampling_dx ; <vul-end> subsampling_dy = parameters -> subsampling_dy ; for ( i = 0 ; i < numcomps ; i ++ ) {",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> OPJ_CLRSPC_SRGB ; } if ( numcomps < 1 || numcomps > 256 ) { fclose ( f ) ; return NULL ; }\n"
 },
 {
  "id": 442,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int init_types ( void ) { static int initialized ; if ( initialized ) return 1 ; if ( add_ast_fields ( ) < 0 ) return 0 ; mod_type = make_type ( \"mod\" , & AST_type , NULL , 0 ) ; if ( ! mod_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ; <vul-start> Module_type = make_type ( \"Module\" , mod_type , Module_fields , 1 ) ; <vul-end> <vul-start> if ( ! Module_type ) return 0 ; <vul-end> <vul-start> Interactive_type = make_type ( \"Interactive\" , mod_type , Interactive_fields , <vul-end> 1 ) ; <vul-start> if ( ! Interactive_type ) return 0 ; <vul-end> <vul-start> Expression_type = make_type ( \"Expression\" , mod_type , Expression_fields , 1 ) ; <vul-end> if ( ! Expression_type ) return 0 ; Suite_type = make_type ( \"Suite\" , mod_type , Suite_fields , 1 ) ; if ( ! Suite_type ) return 0 ; stmt_type = make_type ( \"stmt\" , & AST_type , NULL , 0 ) ; if ( ! stmt_type ) return 0 ; if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ; FunctionDef_type = make_type ( \"FunctionDef\" , stmt_type , FunctionDef_fields , <vul-start> 5 ) ; <vul-end> <vul-start> if ( ! FunctionDef_type ) return 0 ; <vul-end> AsyncFunctionDef_type = make_type ( \"AsyncFunctionDef\" , stmt_type , <vul-start> AsyncFunctionDef_fields , 5 ) ; <vul-end> <vul-start> if ( ! AsyncFunctionDef_type ) return 0 ; <vul-end> <vul-start> ClassDef_type = make_type ( \"ClassDef\" , stmt_type , ClassDef_fields , 5 ) ; <vul-end> <vul-start> if (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , Module_fields , 2 ) ; if ( ! Module_type ) return 0 ; Interactive_type = make_type ( \"Interactive\" , mod_type , Interactive_fields , <vul-start> if ( ! Interactive_type ) return 0 ; Expression_type = make_type ( \"Expression\" <vul-end> , mod_type , <vul-start> , mod_type , Expression_fields , <vul-end> 1 ) ; <vul-start> if ( ! Expression_type ) return 0 ; FunctionType_type = make_type ( \"FunctionType\" <vul-end> , mod_type , <vul-start> , mod_type , FunctionType_fields , 2 ) ; if ( ! FunctionType_type <vul-end> ) return 0 <vul-start> , FunctionDef_fields , 6 ) ; if ( ! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( \"AsyncFunctionDef\" , stmt_type , AsyncFunctionDef_fields , 6 ) ; if ( ! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( \"ClassDef\" , stmt_type , ClassDef_fields , <vul-start> if ( ! ClassDef_type ) return 0 ; Return_type = make_type ( \"Return\" <vul-end> , stmt_type , <vul-start> , stmt_type , Return_fields , 1 ) ; if ( ! Return_type ) return 0 ; Delete_type = make_type ( \"Delete\" , stmt_type , Delete_fields , 1 ) ; if ( ! Delete_type ) return 0 ; Assign_type = make_type ( \"Assign\" , stmt_type , Assign_fields , 3 ) ; if ( ! Assign_type ) return 0 ; AugAssign_type = make_type ( \"AugAssign\" , stmt_type , AugAssign_fields , 3 ) ; if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( \"AnnAssign\" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( \"For\" , stmt_type , For_fields <vul-end> , 5 ) <vul-start> if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( \"AsyncFor\" <vul-end> , stmt_type , <vul-start> , stmt_type , AsyncFor_fields <vul-end> , 5 ) <vul-start> if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( \"While\" <vul-end> , stmt_type , <vul-start> , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( \"If\" <vul-end> , stmt_type , <vul-start> , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( \"With\" <vul-end> , stmt_type , <vul-start> , stmt_type , With_fields , 3 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( \"AsyncWith\" <vul-end> , stmt_type , <vul-start> , stmt_type , AsyncWith_fields , 3 <vul-end> ) ; if <vul-start> , arg_fields , 3 <vul-end> ) ; if <vul-start> return 0 ; type_ignore_type = make_type ( \"type_ignore\" , & AST_type , NULL , 0 ) ; if ( ! type_ignore_type ) return 0 ; if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ; TypeIgnore_type = make_type ( \"TypeIgnore\" , type_ignore_type , TypeIgnore_fields , 1 ) ; if ( ! TypeIgnore_type ) return 0 ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> return 0 ; AST_type <vul-end> = make_type ( <vul-start> = make_type ( \"AST_type\" <vul-end>, mod_type, <vul-start> if (! AST_type <vul-end> ) return 0 <vul-start> return 0 ; <vul-end> FunctionDef_type = make_type <vul-start> = make_type ( \"AST_type\" <vul-end>, mod_type, <vul-start> if (! FunctionDef_type <vul-end> ) return 0 <vul-start> ; FunctionDef_type = make_type ( \"AST_type\", mod_type, FunctionDef_fields, 1 ) ; if (! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( \"AsyncFunctionDef\", stmt_type, AsyncFunctionDef_fields, 1 ) ; if (! AsyncFunctionDef_type ) return 0 ; ClassDef_type = <vul-start> = make_type ( \"AST_type\", stmt_type, ClassDef_fields, 5 ) ; if (! ClassDef_type ) return 0 ; Return_type = make_type ( \"Return\", stmt_type, Return_fields, 1 ) ; if (! Return_type ) return 0 ; Interactive_type = make_type ( \"Interactive\", mod_type, Interactive_fields, 1 ) ; if (! Interactive_type ) return 0 ; Expression_type = make_type ( \"Expression\", mod_type, Expression_fields, 1 ) ; if (! Expression_type ) return 0 ; Suite_type = make_type ( \"Suite\", mod_type, Suite_fields, 1 ) ; if (! Suite_type ) return 0 ; stmt_type = make_type ( \"stmt\", & AST_type, NULL, 0 ) ; if (! stmt_type ) return 0 ; if (! stmt_type ) return 0 ; FunctionDef_type = make_type ( \"FunctionDef\", stmt_type, FunctionDef_fields, 1 ) ; if (! FunctionDef_type ) return 0 ; FunctionDef_type = make_type ( \"FunctionDef\", stmt_type, FunctionDef_fields, 1 ) ; if (! FunctionDef_type ) return 0 ; FunctionDef_type = make_type ( \"AsyncDef\", stmt_type, AsyncFunctionDef_fields, 5 ) ; if ("
 },
 {
  "id": 443,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 static int crypto_report_comp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_comp rcomp ; <vul-start> snprintf ( rcomp . type , CRYPTO_MAX_ALG_NAME , \"%s\" , \"compression\" ) ; <vul-end> if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> crypto_report_comp rcomp ; strncpy <vul-end> ( rcomp . <vul-start> . type , \"compression\" , sizeof ( rcomp . type ) <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> crypto_report_comp rcomp ; strncpy <vul-end> ( rcomp. <vul-start>. type, \"compression\", sizeof ( rcomp. type ) <vul-end> ) ; if\n"
 },
 {
  "id": 444,
  "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 static void cp2112_gpio_set ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <vul-start> unsigned long flags ; <vul-end> int ret ; <vul-start> spin_lock_irqsave ( & dev -> lock , flags ) ; <vul-end> buf [ 0 ] = CP2112_GPIO_SET ; buf [ 1 ] = value ? 0xff : 0 ; buf [ 2 ] = 1 << offset ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_SET , buf , CP2112_GPIO_SET_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) hid_err ( hdev , \"error setting GPIO values: %d\\\\n\" , ret ) ; <vul-start> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <vul-end> }",
  "golden_answers": [
   "CWE-404 Fixed Code Lines are: <vul-start> -> in_out_buffer ; <vul-end> int ret ; <vul-start> int ret ; mutex_lock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; buf <vul-start> ret ) ; mutex_unlock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> -> in_out_buffer ; <vul-end> int ret ; <vul-start> int ret ; mutex_lock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; buf <vul-start> ret ) ; mutex_unlock <vul-end> ( & dev <vul-start> dev -> lock <vul-end> ) ; }\n"
 },
 {
  "id": 445,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int evaluate_inter_mode_rd ( int mdcounts [ 4 ] , RATE_DISTORTION * rd , int * disable_skip , VP8_COMP * cpi , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; int distortion ; vp8_build_inter16x16_predictors_mby ( & x -> e_mbd , x -> e_mbd . predictor , 16 ) ; if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { x -> skip = 1 ; } else if ( x -> encode_breakout ) { unsigned int sse ; unsigned int var ; unsigned int threshold = ( xd -> block [ 0 ] . dequant [ 1 ] * xd -> block [ 0 ] . dequant [ 1 ] >> 4 ) ; if ( threshold < x -> encode_breakout ) threshold = x -> encode_breakout ; <vul-start> var = vp8_variance16x16 <vul-end> ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; if ( sse < threshold ) { unsigned int q2dc = xd -> block [ 24 ] . dequant [ 0 ] ; if ( ( sse - var < q2dc * q2dc >> 4 ) || ( sse / 2 > var && sse - var < 64 ) ) { unsigned int sse2 = VP8_UVSSE ( x ) ; if ( sse2 * 2 < threshold ) { x",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; var = vpx_variance16x16 <vul-end> ( * (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> encode_breakout ; sse = vpx_variance16x16 ( * ( b -> base_src ), b -> src_stride, x -> e_mbd. predictor, 16, & sse ) ; if ( sse < threshold ) { x -> skip = 1 ; return RDCOST ( x -> rdmult, x -> rddiv, rd -> rate2, rd -> distortion2 ) ; } else { if ( sse > 64 ) { x -> skip = 1 ; return RDCOST ( x -> rdmult, x -> rddiv, rd -> rate2, rd -> distortion2 ) ; } } } xd -> rate2 += vp8_cost_mv_ref ( this_mode, mdcounts ) ; macro_block_yrd ( x, & rd -> rate_y, & distortion ) ; rd -> rate2 += rd -> rate_y ; rd -> distortion2 += distortion ; rd_inter16x16_uv ( cpi, x, & rd -> distortion_uv, & cpi -> common. full_pixel ) ; rd -> rate2 += rd -> distortion_uv ; rd -> distortion2 += distortion ; rd_inter16x16_uv ( cpi, x, & rd -> rate_uv, & xd -> distortion2 ) ; } } x -> rate2 += vp8_cost_mv_ref ( this_mode, mdcounts ) ; if ( * disable_skip ) { * disable_skip = 1 ; return RDCOST ( x -> rdmult, x -> rddiv, rd -> rate2, rd -> distortion2 ) ; } } } x -> rate2 += vp8_cost_mv_ref ( this_mode, mdcounts ) ; if ( x -> encode_breakout ) { x -> skip = 1 ; return RDCOST ( x -> rdmult, x -> rddiv, rd -> rate2, rd -> distortion2 ) ; } else { x -> skip = 1 ; <vul-end> return INT_MAX ;\n"
 },
 {
  "id": 446,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , \"ptr\" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , \"byte\" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"word\" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"dword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"qword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , \"oword\" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <vul-start> = temp ; } <vul-start> += temp ; if ( reg_index < 2 ) { <vul-start> = X86R_UNDEFINED ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> X86R_UNDEFINED ) { if ( reg_index >= 64 ) { return nextpos ; } <vul-start> = temp ; reg_index ++ <vul-end> ; } else <vul-start> } else { if ( reg_index >= 64 ) { return nextpos ; } <vul-start> += temp ; if ( reg_index >= 64 ) { return nextpos ; } <vul-start> X86R_UNDEFINED ) { if ( reg_index >= 64 ) { return nextpos ; } <vul-start> = temp ; reg_index ++ ; } <vul-end> } temp =\n"
 },
 {
  "id": 447,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 <vul-start> int mongo_env_read_socket ( mongo * conn , void * buf , int len ) { <vul-end> char * cbuf = buf ; while ( len ) { <vul-start> int sent = recv ( conn -> sock , cbuf , len , 0 ) ; <vul-end> if ( sent == 0 || sent == - 1 ) { __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * buf , size_t <vul-end> len ) { <vul-start> len ) { size_t <vul-end> sent = recv\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * buf, size_t <vul-end> len ) { <vul-start> len ) { size_t <vul-end> sent = recv\n"
 },
 {
  "id": 448,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void update_logging ( ) { bool should_log = module_started && ( logging_enabled_via_api || stack_config -> get_btsnoop_turned_on ( ) ) ; if ( should_log == is_logging ) return ; is_logging = should_log ; if ( should_log ) { btsnoop_net_open ( ) ; const char * log_path = stack_config -> get_btsnoop_log_path ( ) ; if ( stack_config -> get_btsnoop_should_save_last ( ) ) { char last_log_path [ PATH_MAX ] ; snprintf ( last_log_path , PATH_MAX , \"%s.%llu\" , log_path , btsnoop_timestamp ( ) ) ; if ( ! rename ( log_path , last_log_path ) && errno != ENOENT ) LOG_ERROR ( \"%s unable to rename \\'%s\\' to \\'%s\\': %s\" , __func__ , log_path , last_log_path , strerror ( errno ) ) ; } <vul-start> logfile_fd = open ( log_path , O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH ) ; <vul-end> if ( logfile_fd == INVALID_FD ) { LOG_ERROR ( \"%s unable to open \\'%s\\': %s\" , __func__ , log_path , strerror ( errno ) ) ; is_logging = false ; return ; } <vul-start> write ( logfile_fd , \"btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea\" , 16 ) ; <vul-end> } else { if ( logfile_fd != INVALID_FD ) close ( logfile_fd ) ; logfile_fd = INVALID_FD ; btsnoop_net_close ( ) ; } }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> } logfile_fd = TEMP_FAILURE_RETRY ( <vul-start> S_IWGRP | S_IROTH ) <vul-start> return ; } TEMP_FAILURE_RETRY ( <vul-start> \"btsnoop\\\\0\\\\0\\\\0\\\\0\\\\1\\\\0\\\\0\\\\x3\\\\xea\" , 16 )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> } logfile_fd = TEMP_FAILURE_RETRY ( <vul-start> | O_CREAT | O_EXCL <vul-end>, S_IRUSR | <vul-start> return ; } TEMP_FAILURE_RETRY ( <vul-start> 16 ) ; if ( logfile_fd!= INVALID_FD ) close ( logfile_fd ) ;\n"
 },
 {
  "id": 449,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 void comps_mrtree_unite ( COMPS_MRTree * rt1 , COMPS_MRTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it , * it2 ; struct Pair { COMPS_HSList * subnodes ; char * key ; <vul-start> char added ; <vul-end> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; <vul-start> pair -> added = 0 ; <vul-end> for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_MRTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_MRTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair ->",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> * key ; <vul-end> } * pair <vul-start> it ) ; <vul-end> for ( it\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> * key ; <vul-end> } * pair <vul-start> it ) ; <vul-end> for ( it\n"
 },
 {
  "id": 450,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 4 ; <vul-end> break ; case <vul-start> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 4 ; <vul-end> break ; case <vul-start> ; break ; } while ( ++ context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 4 ; break ; }\n"
 },
 {
  "id": 451,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_cyclic_refresh_free ( CYCLIC_REFRESH * cr ) { vpx_free ( cr -> map ) ; <vul-start> vpx_free ( cr ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> vpx_free ( cr -> last_coded_q_map ) ; vpx_free ( cr\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> map ) ; vpx_free <vul-end> ( cr )\n"
 },
 {
  "id": 452,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 SQLWCHAR * _single_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { <vul-start> return in ; <vul-end> } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 1 ) ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; return chr ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) { return NULL <vul-end> ; } while\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) { return NULL <vul-end> ; } while\n"
 },
 {
  "id": 453,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <vul-start> value [ n ] >= min && value [ n ] <= max && <vul-end> field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max <vul-start> && field -> usage [",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ] <= max && value [ n ] - min < field -> maxusage <vul-start> && field -> value [ n ] - min < field -> maxusage && field -> <vul-start> <= max && value [ n ] - min < field -> maxusage &&\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> HID_MAIN_ITEM_VARIABLE ) && ( ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <vul-start> ] <= max ) <vul-start> <= max && ( ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && <vul-start> ] <= max )\n"
 },
 {
  "id": 454,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int amd_gpio_probe ( struct platform_device * pdev ) { int ret = 0 ; int irq_base ; struct resource * res ; struct amd_gpio * gpio_dev ; gpio_dev = devm_kzalloc ( & pdev -> dev , sizeof ( struct amd_gpio ) , GFP_KERNEL ) ; if ( ! gpio_dev ) return - ENOMEM ; spin_lock_init ( & gpio_dev -> lock ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { dev_err ( & pdev -> dev , \"Failed to get gpio io resource.\\\\n\" ) ; return - EINVAL ; } gpio_dev -> base = devm_ioremap_nocache ( & pdev -> dev , res -> start , resource_size ( res ) ) ; if ( ! gpio_dev -> base ) return - ENOMEM ; irq_base = platform_get_irq ( pdev , 0 ) ; if ( irq_base < 0 ) { dev_err ( & pdev -> dev , \"Failed to get gpio IRQ.\\\\n\" ) ; return - EINVAL ; } gpio_dev -> pdev = pdev ; gpio_dev -> gc . direction_input = amd_gpio_direction_input ; gpio_dev -> gc . direction_output = amd_gpio_direction_output ; gpio_dev -> gc . get = amd_gpio_get_value ; gpio_dev -> gc . set = amd_gpio_set_value ; gpio_dev -> gc . set_debounce = amd_gpio_set_debounce ; gpio_dev -> gc . dbg_show = amd_gpio_dbg_show ; gpio_dev -> gc . base = 0 ; gpio_dev -> gc . label = pdev -> name ; gpio_dev -> gc . owner = THIS_MODULE ; gpio_dev -> gc . parent = & pdev -> dev ; gpio_dev -> gc . ngpio = TOTAL_NUMBER_OF_PINS",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> -> pctrl = devm_pinctrl_register ( & pdev -> dev , <vul-end> & amd_pinctrl_desc , <vul-start> & amd_pinctrl_desc , <vul-end> gpio_dev ) ; <vul-start> ( ret ) return ret <vul-end> ; ret = <vul-start> gc ) ; <vul-end> return ret ;\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> dev ) ; ret = pinctrl_register ( & amd_pinctrl_desc, & pdev -> dev, gpio_dev ) ; if ( ret ) goto out1 ; <vul-start> -> pctrl = <vul-end> gpiochip_add_data ( & <vul-start> ret ) goto out2 <vul-end> ; ret = <vul-start> gc ) ; out2 : <vul-end> pinctrl_unregister ( gpio_dev\n"
 },
 {
  "id": 455,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void read_sequence_header ( decoder_info_t * decoder_info , stream_t * stream ) { decoder_info -> width = get_flc ( 16 , stream ) ; decoder_info -> height = get_flc ( 16 , stream ) ; <vul-start> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <vul-end> decoder_info -> pb_split = get_flc ( 1 , stream ) ; decoder_info -> tb_split_enable = get_flc ( 1 , stream ) ; decoder_info -> max_num_ref = get_flc ( 2 , stream ) + 1 ; decoder_info -> interp_ref = get_flc ( 2 , stream ) ; decoder_info -> max_delta_qp = get_flc ( 1 , stream ) ; decoder_info -> deblocking = get_flc ( 1 , stream ) ; decoder_info -> clpf = get_flc ( 1 , stream ) ; decoder_info -> use_block_contexts = get_flc ( 1 , stream ) ; decoder_info -> bipred = get_flc ( 2 , stream ) ; decoder_info -> qmtx = get_flc ( 1 , stream ) ; if ( decoder_info -> qmtx ) { decoder_info -> qmtx_offset = get_flc ( 6 , stream ) - 32 ; } decoder_info -> subsample = get_flc ( 2 , stream ) ; decoder_info -> subsample = ( decoder_info -> subsample & 1 ) * 20 + ( decoder_info -> subsample & 2 ) * 22 + ( ( decoder_info -> subsample & 3 ) == 3 ) * 2 + 400 ; decoder_info -> num_reorder_pics = get_flc ( 4 , stream ) ; if ( decoder_info -> subsample != 400 ) { decoder_info -> cfl_intra = get_flc ( 1 , stream ) ; decoder_info -> cfl_inter",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 3 , stream ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; decoder_info -> <vul-end> pb_split = get_flc\n"
 },
 {
  "id": 456,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void InsertRow ( Image * image , unsigned char * p , ssize_t y , int bpp , ExceptionInfo * exception ) { int bit ; Quantum index ; register Quantum * q ; ssize_t x ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ; x += 4 <vul-end> ) { index\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; x += 4 <vul-end> ) { index\n"
 },
 {
  "id": 457,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 SYSCALL_DEFINE5 ( osf_getsysinfo , unsigned long , op , void __user * , buffer , unsigned long , nbytes , int __user * , start , void __user * , arg ) { unsigned long w ; struct percpu_struct * cpu ; switch ( op ) { case GSI_IEEE_FP_CONTROL : w = current_thread_info ( ) -> ieee_state & IEEE_SW_MASK ; w = swcr_update_status ( w , rdfpcr ( ) ) ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 0 ; case GSI_IEEE_STATE_AT_SIGNAL : break ; case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ; w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ; if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ; cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ; w = cpu -> type ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_GET_HWRPB : <vul-start> if ( nbytes < sizeof ( * hwrpb ) ) <vul-end> return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ; return 1 ; default : break ; } return - EOPNOTSUPP ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> if ( nbytes > <vul-end> sizeof ( *\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> * hwrpb ) ||! access_ok ( VERIFY_WRITE, buffer, nbytes )\n"
 },
 {
  "id": 458,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void sum_intra_stats ( VP8_COMP * cpi , MACROBLOCK * x ) { const MACROBLOCKD * xd = & x -> e_mbd ; const MB_PREDICTION_MODE m = xd -> mode_info_context -> mbmi . mode ; const MB_PREDICTION_MODE uvm = xd -> mode_info_context -> mbmi . uv_mode ; # ifdef MODE_STATS const int is_key = cpi -> common . frame_type == KEY_FRAME ; ++ ( is_key ? uv_modes : inter_uv_modes ) [ uvm ] ; if ( m == B_PRED ) { unsigned int * const bct = is_key ? b_modes : inter_b_modes ; int b = 0 ; do { ++ bct [ xd -> block [ b ] . bmi . mode ] ; } while ( ++ b < 16 ) ; } <vul-start> # endif <vul-end> ++ x -> ymode_count [ m ] ; ++ x -> uv_mode_count [ uvm ] ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; } # else ( void ) cpi ; #\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; } # else ( void ) cpi ; ( void ) x ; #\n"
 },
 {
  "id": 459,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 smb_sdrc_t smb_com_flush ( smb_request_t * sr ) { smb_ofile_t * file ; smb_llist_t * flist ; int rc ; if ( smb_flush_required == 0 ) { rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; } if ( sr -> smb_fid != 0xffff ) { smbsr_lookup_file ( sr ) ; if ( sr -> fid_ofile == NULL ) { smbsr_error ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ; return ( SDRC_ERROR ) ; } <vul-start> smb_flush_file ( sr , sr -> fid_ofile ) ; <vul-end> } else { flist = & sr -> tid_tree -> t_ofile_list ; smb_llist_enter ( flist , RW_READER ) ; file = smb_llist_head ( flist ) ; while ( file ) { mutex_enter ( & file -> f_mutex ) ; <vul-start> smb_flush_file ( sr , file ) ; <vul-end> mutex_exit ( & file -> f_mutex ) ; file = smb_llist_next ( flist , file ) ; } smb_llist_exit ( flist ) ; } rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ) ; } smb_ofile_flush <vul-end> ( sr , <vul-start> f_mutex ) ; smb_ofile_flush <vul-end> ( sr ,\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ) ; } if ( <vul-start> -> fid_ofile ) < 0 ) return SDRC_ERROR <vul-start> f_mutex ) ; if ( <vul-start>, file ) < 0 ) return SDRC_ERROR\n"
 },
 {
  "id": 460,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; <vul-start> list_del ( & key -> graveyard_link ) ; <vul-end> kdebug ( \"- %u\" , key -> serial ) ; key_check ( key ) ; <vul-start> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <vul-end> ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; <vul-start> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <vul-end> atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; memzero_explicit ( key , sizeof ( * key ) ) ; kmem_cache_free ( key_jar , key ) ; } }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> graveyard_link ) ; short state = key -> state ; <vul-start> ; if ( state == KEY_IS_POSITIVE && <vul-end> key -> type <vul-start> ; if ( state != KEY_IS_UNINSTANTIATED <vul-end> ) atomic_dec (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> graveyard_link ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED, & key -> flags ) &&! test_bit ( KEY_FLAG_NEGATIVE, & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ; spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; <vul-start> ; if ( <vul-end> key -> type <vul-start> key -> type -> destroy ) key -> type -> destroy ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA <vul-start>, & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; if ( key -> state == KEY_IS_UNINSTANTIATED <vul-end> ) { spin_lock <vul-start> -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } <vul-end> kdebug ( \"-\n"
 },
 {
  "id": 461,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int mwifiex_pcie_alloc_cmdrsp_buf ( struct mwifiex_adapter * adapter ) { struct pcie_service_card * card = adapter -> card ; struct sk_buff * skb ; skb = dev_alloc_skb ( MWIFIEX_UPLD_SIZE ) ; if ( ! skb ) { mwifiex_dbg ( adapter , ERROR , \"Unable to allocate skb for command response data.\\\\n\" ) ; return - ENOMEM ; } skb_put ( skb , MWIFIEX_UPLD_SIZE ) ; if ( mwifiex_map_pci_memory ( adapter , skb , MWIFIEX_UPLD_SIZE , <vul-start> PCI_DMA_FROMDEVICE ) ) <vul-end> <vul-start> return - 1 ; <vul-end> card -> cmdrsp_buf = skb ; return 0 ; }",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> PCI_DMA_FROMDEVICE ) ) { kfree_skb ( skb ) ; <vul-start> - 1 ; }\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> PCI_DMA_FROMDEVICE ) ) { kfree_skb ( skb ) ; kfree ( adapter -> cmdrsp_buf ) ; <vul-start> - 1 ; }\n"
 },
 {
  "id": 462,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 void pci_lintr_request ( struct pci_vdev * dev ) { struct businfo * bi ; struct slotinfo * si ; int bestpin , bestcount , pin ; bi = pci_businfo [ dev -> bus ] ; <vul-start> assert ( bi != NULL ) ; <vul-end> si = & bi -> slotinfo [ dev -> slot ] ; bestpin = 0 ; bestcount = si -> si_intpins [ 0 ] . ii_count ; for ( pin = 1 ; pin < 4 ; pin ++ ) { if ( si -> si_intpins [ pin ] . ii_count < bestcount ) { bestpin = pin ; bestcount = si -> si_intpins [ pin ] . ii_count ; } } si -> si_intpins [ bestpin ] . ii_count ++ ; dev -> lintr . pin = bestpin + 1 ; pci_set_cfgdata8 ( dev , PCIR_INTPIN , bestpin + 1 ) ; }",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> bus ] ; if ( bi == NULL ) { pr_err ( \"%s: pci [%s] has wrong bus %d info!\\\\n\" , __func__ , dev -> name , dev -> bus ) ; return ; } <vul-end> si = &\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> bus ] ; if ( bi == NULL ) { pr_err ( \"%s: pci [%s] has wrong bus %d info!\\\\n\", __func__, dev -> name, dev -> bus ) ; return ; } <vul-end> si = &\n"
 },
 {
  "id": 463,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int setup_dev_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console ) { char path [ MAXPATHLEN ] ; struct stat s ; int ret ; ret = snprintf ( path , sizeof ( path ) , \"%s/dev/console\" , rootfs -> mount ) ; if ( ret >= sizeof ( path ) ) { ERROR ( \"console path too long\" ) ; return - 1 ; } if ( access ( path , F_OK ) ) { WARN ( \"rootfs specified but no console found at \\'%s\\'\" , path ) ; return 0 ; } if ( console -> master < 0 ) { INFO ( \"no console\" ) ; return 0 ; } if ( stat ( path , & s ) ) { SYSERROR ( \"failed to stat \\'%s\\'\" , path ) ; return - 1 ; } if ( chmod ( console -> name , s . st_mode ) ) { SYSERROR ( \"failed to set mode \\'0%o\\' to \\'%s\\'\" , s . st_mode , console -> name ) ; return - 1 ; } <vul-start> if ( mount ( console -> name , path , \"none\" , MS_BIND , 0 ) ) { <vul-end> ERROR ( \"failed to mount \\'%s\\' on \\'%s\\'\" , console -> name , path ) ; return - 1 ; } INFO ( \"console has been setup\" ) ; return 0 ; }",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> } if ( safe_mount ( console -> name , path , \"none\" , MS_BIND , 0 , rootfs -> mount <vul-end> ) ) {\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> } if ( safe_mount <vul-end> ( console ->\n"
 },
 {
  "id": 464,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 int fpm_stdio_init_child ( struct fpm_worker_pool_s * wp ) { # ifdef HAVE_SYSLOG_H if ( fpm_globals . error_log_fd == ZLOG_SYSLOG ) { closelog ( ) ; } else # endif if ( fpm_globals . error_log_fd > 0 ) { close ( fpm_globals . error_log_fd ) ; } fpm_globals . error_log_fd = - 1 ; zlog_set_fd ( - 1 ) ; <vul-start> if ( wp -> listening_socket != STDIN_FILENO ) { <vul-end> if ( 0 > dup2 ( wp -> listening_socket , STDIN_FILENO ) ) { zlog ( ZLOG_SYSERROR , \"failed to init child stdio: dup2()\" ) ; return - 1 ; } } return 0 ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> 1 ) ; <vul-end> return 0 ;\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> 1 ) ; <vul-end> return 0 ;\n"
 },
 {
  "id": 465,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 CURLcode Curl_smtp_escape_eob ( struct connectdata * conn , const ssize_t nread ) { ssize_t i ; ssize_t si ; struct Curl_easy * data = conn -> data ; struct SMTP * smtp = data -> req . protop ; char * scratch = data -> state . scratch ; char * newscratch = NULL ; char * oldscratch = NULL ; size_t eob_sent ; if ( ! scratch || data -> set . crlf ) { oldscratch = scratch ; <vul-start> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <vul-end> if ( ! newscratch ) { failf ( data , \"Failed to alloc scratch buffer!\" ) ; return CURLE_OUT_OF_MEMORY ; } <vul-start> } <vul-end> eob_sent = smtp -> eob ; for ( i = 0 , si = 0 ; i < nread ; i ++ ) { if ( SMTP_EOB [ smtp -> eob ] == data -> req . upload_fromhere [ i ] ) { smtp -> eob ++ ; if ( 2 == smtp -> eob || SMTP_EOB_LEN == smtp -> eob ) smtp -> trailing_crlf = TRUE ; else smtp -> trailing_crlf = FALSE ; } else if ( smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; if ( SMTP_EOB [ 0 ] == data -> req . upload_fromhere [ i ] ) smtp -> eob = 1 ; else smtp -> eob = 0 ; eob_sent =",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( 2 * UPLOAD_BUFSIZE <vul-end> ) ; if <vul-start> ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = scratch ; if ( data -> set. buffer_size > 0 ) { <vul-start> ; } } else { failf ( data, \"Failed to allocate scratch buffer!\" ) ; return CURLE_OUT_OF_MEMORY ; } }\n"
 },
 {
  "id": 466,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void test_decode ( struct stream_state * stream , enum TestDecodeFatality fatal , const VpxInterface * codec ) { vpx_image_t enc_img , dec_img ; if ( stream -> mismatch_seen ) return ; if ( strcmp ( codec -> name , \"vp8\" ) == 0 ) { struct vpx_ref_frame ref_enc , ref_dec ; int width , height ; width = ( stream -> config . cfg . g_w + 15 ) & ~ 15 ; height = ( stream -> config . cfg . g_h + 15 ) & ~ 15 ; vpx_img_alloc ( & ref_enc . img , VPX_IMG_FMT_I420 , width , height , 1 ) ; enc_img = ref_enc . img ; vpx_img_alloc ( & ref_dec . img , VPX_IMG_FMT_I420 , width , height , 1 ) ; dec_img = ref_dec . img ; ref_enc . frame_type = VP8_LAST_FRAME ; ref_dec . frame_type = VP8_LAST_FRAME ; vpx_codec_control ( & stream -> encoder , VP8_COPY_REFERENCE , & ref_enc ) ; vpx_codec_control ( & stream -> decoder , VP8_COPY_REFERENCE , & ref_dec ) ; } else { <vul-start> struct vp9_ref_frame ref ; <vul-end> ref . idx = 0 ; <vul-start> vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , & ref ) ; <vul-end> enc_img = ref . img ; <vul-start> vpx_codec_control ( & stream -> decoder , VP9_GET_REFERENCE , & ref ) ; <vul-end> dec_img = ref . img ; } ctx_exit_on_error ( & stream -> encoder , \"Failed to get encoder reference frame\" ) ; ctx_exit_on_error ( & stream -> decoder , \"Failed to get decoder reference frame\" ) ; if ( ! compare_img",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { struct vp9_ref_frame ref_enc , ref_dec ; ref_enc <vul-end> . idx = <vul-start> = 0 ; ref_dec . idx = 0 ; <vul-start> VP9_GET_REFERENCE , & ref_enc ) ; enc_img = ref_enc <vul-end> . img ; <vul-start> VP9_GET_REFERENCE , & ref_dec ) ; dec_img = ref_dec . img ; # if CONFIG_VP9_HIGHBITDEPTH if ( ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) != ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ) { if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & enc_img , enc_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , enc_img . d_w , enc_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & enc_img , & ref_enc . img ) ; } if ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & dec_img , dec_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , dec_img . d_w , dec_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & dec_img , & ref_dec . img ) ; } } # endif <vul-end> } ctx_exit_on_error ( <vul-start> 4 ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { find_mismatch_high ( & enc_img , & dec_img , y , u , v ) ; } else { <vul-start> v ) ; } # else find_mismatch ( & enc_img , & dec_img , y , u , v ) ; # endif\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } else { int rc ; <vul-start> = 0 ; rc = <vul-start>, & ref ) ; if ( rc!= 0 ) goto err_exit ; enc_img = ref. img ; rc = <vul-end> vpx_codec_control ( & <vul-start>, & ref ) ; if ( rc!= 0 ) goto err_exit <vul-end> ; dec_img =\n"
 },
 {
  "id": 467,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <vul-end> { MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t <vul-start> number_threads ; <vul-end> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <vul-start> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <vul-end> { <vul-start> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <vul-end> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <vul-start> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <vul-end> <vul-start> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <vul-end> } return ( pixels ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> const Image * images ) { const Image * next ; <vul-end> MagickPixelPacket * * <vul-start> j ; size_t columns , <vul-start> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <vul-end> i = 0 <vul-start> ) AcquireQuantumMemory ( <vul-end> columns , sizeof <vul-start> ( ssize_t ) <vul-end> columns ; j <vul-start> ) GetMagickPixelPacket ( images <vul-end> , & pixels\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> const Image * images ) { const Image * next ; <vul-end> MagickPixelPacket * * <vul-start> ; size_t number_threads ; size_t columns, rows ; rows = MagickMax ( images -> columns, columns ) <vul-start> ) ) ; columns = images -> columns ; for ( next = images ; next!= ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns, columns ) ; <vul-start> ) AcquireQuantumMemory ( columns, <vul-end> sizeof ( * <vul-start> ( ssize_t ) <vul-end> columns ; j <vul-start> j ++ ) { if (! <vul-start> j ] ) ) break ; } <vul-end> } return (\n"
 },
 {
  "id": 468,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <vul-end> { u16 * op ; int size ; unicode_t u ; op = pwcs ; <vul-start> while ( * s && len > 0 ) { <vul-end> if ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - EINVAL ; <vul-start> if ( u >= PLANE_SIZE ) { <vul-end> <vul-start> u -= PLANE_SIZE ; <vul-end> <vul-start> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <vul-end> <vul-start> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <vul-end> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW | <vul-start> ( u & SURROGATE_BITS ) ) ; <vul-end> } else { <vul-start> * op ++ = ( wchar_t ) u ; <vul-end> } s += size ; len -= size ; } else { <vul-start> * op ++ = * s ++ ; <vul-end> len -- ; } } return op - pwcs ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int len , enum utf16_endian endian , <vul-start> wchar_t * pwcs , int maxlen <vul-start> ; while ( <vul-end> len > 0 <vul-start> len > 0 && maxlen > 0 && * s <vul-start> - EINVAL ; s += size ; len -= size ; <vul-start> PLANE_SIZE ) { if ( maxlen < 2 ) break ; <vul-start> -= PLANE_SIZE ; put_utf16 ( op ++ , <vul-end> SURROGATE_PAIR | ( <vul-start> & SURROGATE_BITS ) , endian ) ; put_utf16 ( op ++ , <vul-end> SURROGATE_PAIR | SURROGATE_LOW <vul-start> & SURROGATE_BITS ) , endian ) ; maxlen -= 2 <vul-end> ; } else <vul-start> } else { put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <vul-end> } else { <vul-start> } else { put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <vul-end> -- ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * s, size_t <vul-end> len, wchar_t <vul-start> > 0 ) { if ( len < 2 ) return - EINVAL ; <vul-end> if ( * <vul-start> - EINVAL ; * op ++ = ( wchar_t ) ( SURROGATE_PAIR | ( ( u >> 10 ) & SURROGATE_BITS ) ) ; * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW | ( u & SURROGATE_BITS ) ) ; } else { * op ++ = ( wchar_t ) u ; } s += size ; len -= size ; } else { * op ++ = * s ++ ; len -- ; } } if ( len < 0 ) return - EINVAL ; <vul-start> PLANE_SIZE ) { size <vul-end> -= PLANE_SIZE ; <vul-start> -= PLANE_SIZE ; if ( len < 0 ) return - EINVAL ; <vul-start> wchar_t ) ( 0xff & 0xff ) ; <vul-end> * op ++ <vul-start> SURROGATE_PAIR | ( u >> 8 ) & SURROGATE_BITS <vul-end> ) ; * <vul-start> SURROGATE_PAIR | SURROGATE_LOW | ( u & SURROGATE_BITS ) ) ; } else { * op ++ = ( wchar_t ) u ; } s += size ; len -= size ; } else { * op ++ = * s ++ ; len -- ; } } if ( len == 0 ) return - EINVAL ; <vul-end> return op - <vul-start> pwcs ; } <vul-end>      \n"
 },
 {
  "id": 469,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <vul-start> horDiff16 ( tif , cp0 , cc ) ; <vul-end> TIFFSwabArrayOfShort ( wp , wc ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> swabHorDiff16 ( TIFF <vul-start> / 2 ; if ( ! <vul-start> , cc ) ) return 0 <vul-start> wc ) ; return 1 ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> swabHorDiff16 ( TIFF <vul-start> / 2 ; if ( wc > 0 && cc <= 2 ) { TIFFErrorExt ( tif -> tif_clientdata, \"horDiff8\", \"%s\", \"(horDiff8)\" ) ; return 0 ; } <vul-start> wc ) ; return 1 ;\n"
 },
 {
  "id": 470,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int snd_hrtimer_stop ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ; <vul-start> return 0 ; <vul-end> }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> 0 ) ; hrtimer_try_to_cancel ( & stime -> hrt ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 0 ) ; stime -> in_callback = 0 ;\n"
 },
 {
  "id": 471,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static bool ldm_frag_add ( const u8 * data , int size , struct list_head * frags ) { struct frag * f ; struct list_head * item ; int rec , num , group ; BUG_ON ( ! data || ! frags ) ; if ( size < 2 * VBLK_SIZE_HEAD ) { ldm_error ( \"Value of size is to small.\" ) ; return false ; } group = get_unaligned_be32 ( data + 0x08 ) ; rec = get_unaligned_be16 ( data + 0x0C ) ; num = get_unaligned_be16 ( data + 0x0E ) ; if ( ( num < 1 ) || ( num > 4 ) ) { ldm_error ( \"A VBLK claims to have %d parts.\" , num ) ; return false ; } if ( rec >= num ) { ldm_error ( \"REC value (%d) exceeds NUM value (%d)\" , rec , num ) ; return false ; } list_for_each ( item , frags ) { f = list_entry ( item , struct frag , list ) ; if ( f -> group == group ) goto found ; } f = kmalloc ( sizeof ( * f ) + size * num , GFP_KERNEL ) ; if ( ! f ) { ldm_crit ( \"Out of memory.\" ) ; return false ; } f -> group = group ; f -> num = num ; f -> rec = rec ; f -> map = 0xFF << num ; list_add_tail ( & f -> list , frags ) ; found : <vul-start> if ( f -> map & ( 1 <<",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> : if ( rec >= f -> num ) { ldm_error ( \"REC value (%d) exceeds NUM value (%d)\" , rec , f -> num ) ; return false ; } if (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> : if ( ( <vul-start> << rec ) ) == 0\n"
 },
 {
  "id": 472,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void estimate_ref_frame_costs ( VP9_COMP * cpi , int segment_id , <vul-end> unsigned int * ref_costs_single , unsigned int * ref_costs_comp , <vul-start> vp9_prob * comp_mode_p ) { <vul-end> <vul-start> VP9_COMMON * const cm = & cpi -> common ; <vul-end> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; int seg_ref_active = vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { vpx_memset ( ref_costs_single , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_single ) ) ; <vul-start> vpx_memset ( ref_costs_comp , 0 , MAX_REF_FRAMES * sizeof ( * ref_costs_comp ) ) ; <vul-end> * comp_mode_p = 128 ; } else { <vul-start> vp9_prob intra_inter_p = vp9_get_intra_inter_prob ( cm , xd ) ; <vul-end> <vul-start> vp9_prob comp_inter_p = 128 ; <vul-end> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { comp_inter_p = vp9_get_reference_mode_prob ( cm , xd ) ; * comp_mode_p = comp_inter_p ; } else { * comp_mode_p = 128 ; } ref_costs_single [ INTRA_FRAME ] = vp9_cost_bit ( intra_inter_p , 0 ) ; if ( cm -> reference_mode != COMPOUND_REFERENCE ) { <vul-start> vp9_prob ref_single_p1 = vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ; <vul-end> <vul-start> vp9_prob ref_single_p2 = vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ; <vul-end> unsigned int base_cost = vp9_cost_bit ( intra_inter_p , 1 ) ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) base_cost += vp9_cost_bit ( comp_inter_p , 0 ) ; ref_costs_single [ LAST_FRAME ] = ref_costs_single [ GOLDEN_FRAME ] = ref_costs_single [ ALTREF_FRAME ] = base_cost ; ref_costs_single [ LAST_FRAME ] += vp9_cost_bit ( ref_single_p1 , 0",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> void estimate_ref_frame_costs ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <vul-end> int segment_id , <vul-start> * ref_costs_comp , vpx_prob <vul-end> * comp_mode_p ) <vul-start> comp_mode_p ) { int seg_ref_active = segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { memset <vul-end> ( ref_costs_single , <vul-start> ) ) ; memset <vul-end> ( ref_costs_comp , <vul-start> } else { vpx_prob <vul-end> intra_inter_p = vp9_get_intra_inter_prob <vul-start> xd ) ; vpx_prob <vul-end> comp_inter_p = 128 <vul-start> COMPOUND_REFERENCE ) { vpx_prob <vul-end> ref_single_p1 = vp9_get_pred_prob_single_ref_p1 <vul-start> xd ) ; vpx_prob <vul-end> ref_single_p2 = vp9_get_pred_prob_single_ref_p2 <vul-start> SINGLE_REFERENCE ) { vpx_prob <vul-end> ref_comp_p = vp9_get_pred_prob_comp_ref_p\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void estimate_ref_frame_costs ( VP9_COMMON * cm, MACROBLOCKD * xd, <vul-end> int segment_id, <vul-start> * ref_costs_comp, vpx_prob <vul-end> * comp_mode_p ) <vul-start> comp_mode_p ) { const <vul-start> ref_costs_single ) ) <vul-end> ; } else <vul-start> } else { vpx_prob intra_inter_p = vp9_get_intra_inter_prob ( cm, xd ) ; vpx_prob <vul-end> comp_inter_p = 128 <vul-start> comp_inter_p = 128 ; * comp_mode_p = comp_mode_p <vul-start> COMPOUND_REFERENCE ) { vpx_prob <vul-end> ref_single_p1 = vp9_get_pred_prob_single_ref_p1 <vul-start> xd ) ; vpx_prob <vul-end> ref_single_p2 = vp9_get_pred_prob_single_ref_p2 <vul-start> SINGLE_REFERENCE ) { vpx_prob <vul-end> ref_comp_p = vp9_get_pred_prob_comp_ref_p <vul-start> cm, xd ) ; unsigned int base_cost = vp9_cost_bit ( ref_comp_p, 1 ) ; ref_costs_single [ LAST_FRAME ] = base_cost + vp9_cost_bit ( ref_comp_p, 2 ) ; ref_costs_single [ GOLDEN_FRAME ] = base_cost + vp9_cost_bit ( ref_comp_p, 3\n"
 },
 {
  "id": 473,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int write_superframe_index ( vpx_codec_alg_priv_t * ctx ) { uint8_t marker = 0xc0 ; unsigned int mask ; int mag , index_sz ; assert ( ctx -> pending_frame_count ) ; assert ( ctx -> pending_frame_count <= 8 ) ; marker |= ctx -> pending_frame_count - 1 ; for ( mag = 0 , mask = 0xff ; mag < 4 ; mag ++ ) { if ( ctx -> pending_frame_magnitude < mask ) break ; mask <<= 8 ; mask |= 0xff ; } marker |= mag << 3 ; index_sz = 2 + ( mag + 1 ) * ctx -> pending_frame_count ; if ( ctx -> pending_cx_data_sz + index_sz < ctx -> cx_data_sz ) { uint8_t * x = ctx -> pending_cx_data + ctx -> pending_cx_data_sz ; <vul-start> int i , j ; <vul-end> * x ++ = marker ; for ( i = 0 ; i < ctx -> pending_frame_count ; i ++ ) { unsigned int this_sz = ( unsigned int ) ctx -> pending_frame_sizes [ i ] ; for ( j = 0 ; j <= mag ; j ++ ) { * x ++ = this_sz & 0xff ; this_sz >>= 8 ; } } * x ++ = marker ; ctx -> pending_cx_data_sz += index_sz ; <vul-start> } <vul-end> return index_sz ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , j ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA uint8_t marker_test = 0xc0 ; int mag_test = 2 ; int frames_test = 4 ; int index_sz_test = 2 + mag_test * frames_test ; marker_test |= frames_test - 1 ; marker_test |= ( mag_test - 1 ) << 3 ; * x ++ = marker_test ; for ( i = 0 ; i < mag_test * frames_test ; ++ i ) * x ++ = 0 ; * x ++ = marker_test ; ctx -> pending_cx_data_sz += index_sz_test ; printf ( \"Added supplemental superframe data\\\\n\" ) ; # endif <vul-start> += index_sz ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA index_sz += index_sz_test ; # endif\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, j ; if ( ctx -> pending_cx_data_sz + index_sz > ctx -> cx_data_sz ) { return - 1 ; } <vul-start> += index_sz ; if ( ctx -> pending_cx_data_sz + index_sz > ctx -> cx_data_sz ) { return - 1 ; }\n"
 },
 {
  "id": 474,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int http_receive_data ( HTTPContext * c ) { HTTPContext * c1 ; int len , loop_run = 0 ; while ( c -> chunked_encoding && ! c -> chunk_size && c -> buffer_end > c -> buffer_ptr ) { len = recv ( c -> fd , c -> buffer_ptr , 1 , 0 ) ; if ( len < 0 ) { if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && ff_neterrno ( ) != AVERROR ( EINTR ) ) goto fail ; return 0 ; } else if ( len == 0 ) { goto fail ; } else if ( c -> buffer_ptr - c -> buffer >= 2 && ! memcmp ( c -> buffer_ptr - 1 , \"\\\\r\\\\n\" , 2 ) ) { c -> chunk_size = strtol ( c -> buffer , 0 , 16 ) ; <vul-start> if ( c -> chunk_size == 0 ) <vul-end> goto fail ; c -> buffer_ptr = c -> buffer ; break ; } else if ( ++ loop_run > 10 ) goto fail ; else c -> buffer_ptr ++ ; } if ( c -> buffer_end > c -> buffer_ptr ) { len = recv ( c -> fd , c -> buffer_ptr , FFMIN ( c -> chunk_size , c -> buffer_end - c -> buffer_ptr ) , 0 ) ; if ( len < 0 ) { if ( ff_neterrno ( ) != AVERROR ( EAGAIN ) && ff_neterrno ( ) != AVERROR ( EINTR ) ) goto fail ; } else if ( len ==",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> c -> chunk_size <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <vul-end> c -> buffer_ptr <vul-start> ; else { av_assert0 ( len <= c -> chunk_size ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> c -> chunk_size < c -> chunk_size || c -> buffer_end < c -> chunk_size <vul-end> ) goto fail <vul-start> ; else { if ( c -> chunk_size < c -> buffer_ptr || c -> buffer_end - c -> buffer < 0 ) goto fail ;\n"
 },
 {
  "id": 475,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , \" %s\" , tok2str ( nfsproc_str , \"proc-%u\" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , \" post dattr:\" ) ) ; dp = parse_post_op_attr",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ! er ) { ND_TCHECK ( <vul-end> dp [ 0 <vul-start> 0 ] ) ; ND_PRINT ( ( ndo , \" c %04x\" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <vul-end> return ; case\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>! er ) { ND_TCHECK_32BITS ( & dp [ 0 ] ) ; <vul-start> ) ) ; }\n"
 },
 {
  "id": 476,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 bool f2fs_init_extent_tree ( struct inode * inode , struct f2fs_extent * i_ext ) { <vul-start> struct f2fs_sb_info * sbi = F2FS_I_SB ( inode ) ; <vul-end> struct extent_tree * et ; struct extent_node * en ; struct extent_info ei ; if ( ! f2fs_may_extent_tree ( inode ) ) { if ( i_ext && i_ext -> len ) { i_ext -> len = 0 ; return true ; } return false ; } et = __grab_extent_tree ( inode ) ; <vul-start> if ( ! i_ext || ! i_ext -> len ) <vul-end> return false ; get_extent_info ( & ei , i_ext ) ; write_lock ( & et -> lock ) ; if ( atomic_read ( & et -> node_cnt ) ) goto out ; en = __init_extent_tree ( sbi , et , & ei ) ; if ( en ) { spin_lock ( & sbi -> extent_lock ) ; list_add_tail ( & en -> list , & sbi -> extent_list ) ; spin_unlock ( & sbi -> extent_lock ) ; } out : write_unlock ( & et -> lock ) ; <vul-start> return false ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext <vul-end> ) ; if <vul-start> if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <vul-end> ) ; return <vul-start> ) ; return ret <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( inode ) ; bool ret = false <vul-start> i_ext -> len ) goto out ; if (! sbi -> i_sb -> s_iflags <vul-start> lock ) ; out :\n"
 },
 {
  "id": 477,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) <vul-start> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <vul-end> typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != (",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ( n ) \\\\\\n{ <vul-end> sum = ( <vul-start> ++ ; } \\\\\\n} <vul-end> typedef struct PCDTable <vul-start> buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <vul-start> RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ( n ) \\\\\\n{ <vul-end> sum = ( <vul-start> buffer ) ; if ( buffer == ( unsigned char * ) RelinquishMagickMemory ( buffer ) ) ThrowBinaryException ( CorruptImageError, \"MemoryAllocationFailed\", image -> filename ) ; } \\\\\\n<<vul-end> typedef struct PCDTable <vul-start> 16 ) { if ( buffer == ( unsigned char * ) RelinquishMagickMemory ( buffer ) ) ThrowBinaryException ( CorruptImageError, \"MemoryAllocationFailed\", image -> filename ) ; <vul-start> buffer ) ; if ( buffer == ( unsigned char * ) RelinquishMagickMemory ( buffer ) ) ThrowBinaryException ( CorruptImageError, \"MemoryAllocationFailed\", image -> filename ) ;\n"
 },
 {
  "id": 478,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void write_image_file ( const vpx_image_t * img , const int planes [ 3 ] , FILE * file ) { <vul-start> int i , y ; <vul-end> for ( i = 0 ; i < 3 ; ++ i ) { const int plane = planes [ i ] ; const unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; const int w = vpx_img_plane_width ( img , plane ) ; const int h = vpx_img_plane_height ( img , plane ) ; for ( y = 0 ; y < h ; ++ y ) { <vul-start> fwrite ( buf , 1 , w , file ) ; <vul-end> buf += stride ; } } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , y ; # if CONFIG_VP9_HIGHBITDEPTH const int bytes_per_sample = ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ; # else const int bytes_per_sample = 1 ; # endif <vul-start> ( buf , bytes_per_sample <vul-end> , w ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> i, y ; const int bytespp = ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH )? 2 : 1 <vul-start> y ) { if ( bytespp < 1 || bytespp > 255 ) { vpx_log ( VPX_LOG_ERROR, \"vpx: write_image_file: failed to write %d * %d bytes\\\\n\", stride, bytespp ) ; break ; }\n"
 },
 {
  "id": 479,
  "question": "CWE-706 Code Input Vulnerable Code Is: CWE-706 void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( \"Unexpected off_t/time_t size\" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( \"ambiguous target\" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , \"\" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for (",
  "golden_answers": [
   "CWE-706 Fixed Code Lines are: <vul-start> ; if ( * cp == '\\\\0' || <vul-end> strchr ( cp <vul-start> ) != NULL || <vul-end> strcmp ( cp <vul-start> ( cp , \".\" ) == 0 || strcmp ( cp , <vul-start> ) == 0 <vul-end> ) { run_err\n"
  ],
  "generated_answer": "CWE-706 Fixed Code Lines are: <vul-start> if ( ( ( cp == 0 ) && ( <vul-start>!= NULL ) )\n"
 },
 {
  "id": 480,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int DoOneObject ( char * cinput ) { <vul-start> int num , i , num1 , num2 ; <vul-end> <vul-start> char * s , * t , * StartClean ; <vul-end> <vul-start> double * argbuf = 0 ; <vul-end> SetDefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == ' ' || * t == '\\\\t' || * t == '\\\\n' ) t ++ ; <vul-start> outpos = outputbuffer ; <vul-end> <vul-start> outpos += sprintf ( outpos , \"\\\\\\\\axo@setObject{%s}%%\\\\n{%s%c}%%\\\\n{\" , s , t , TERMCHAR ) ; <vul-end> <vul-start> if ( * s == '0' && s [ 1 ] == ']' ) { <vul-end> if ( strcmp ( nameobject , \"AxodrawWantsPDF\" ) == 0 ) { identification = 1 ; <vul-start> outpos += sprintf ( outpos , \"Axohelp version %d.%d. PDF output.}\" , VERSION , SUBVERSION ) ; <vul-end> <vul-start> fprintf ( outfile , \"%s\" , outputbuffer ) ; <vul-end> return ( 0 ) ; } else { fprintf ( stderr , \"%s: Illegal request in identification string [0]: %s\\\\n\" , axohelp , nameobject ) ; <vul-start> if ( argbuf ) free ( argbuf ) ; <vul-end> return ( - 1 ) ; } } StartClean = outpos ; nameobject = t ; while ( * t != ' ' && * t != '\\\\t' && * t != '\\\\n' && * t ) t ++ ; *",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> num1 , num2 , retcode <vul-start> , * t <vul-end> ; double * <vul-start> argbuf = 0 ; retcode = - 1 <vul-start> t ++ ; fprintf ( outfile , \"\\\\\\\\axo@setObject{%s}%%\\\\n{%s%c}%%\\\\n{\" , s , t , TERMCHAR ) ; <vul-start> = outputbuffer ; nameobject = t ; while ( * t != ' ' && * t != '\\\\t' && * t != '\\\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == ' ' || * t == '\\\\t' || * t == '\\\\n' ) t ++ <vul-end> ; if ( <vul-start> 1 ] == 0 <vul-end> ) { if <vul-start> = 1 ; fprintf ( outfile , \"Axohelp version %d.%d. PDF output.\" <vul-end> , VERSION , <vul-start> SUBVERSION ) ; goto SUCCESS ; } else { fprintf ( <vul-end> stderr , \"%s: Illegal request in identification string [0]: %s\\\\n\" <vul-start> nameobject ) ; goto EXIT ; } } <vul-end> if ( ( <vul-start> == 0 ) goto EXIT <vul-end> ; if ( <vul-start> inname ) ; goto EXIT <vul-end> ; } else <vul-start> argbuf ) ; argbuf = 0 ; <vul-start> == 0 ) goto EXIT <vul-end> ; if ( <vul-start> inname ) ; goto EXIT <vul-end> ; } else <vul-start> argbuf ) ; argbuf = 0 ; <vul-start> == 0 ) goto EXIT <vul-end> ; for ( <vul-start> argbuf ) ; argbuf = 0 ; <vul-start> inname ) ; goto EXIT <vul-end> ; } } <vul-start> inname ) ; goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <vul-start> argbuf ) ; } fprintf ( outfile , \"}\\\\n\" ) ; return ( retcode <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> cinput ) { SetDefaults ( ) ; <vul-start>, num2 ; double * argbuf = 0 ; <vul-start> * StartClean ; <vul-end> s = cinput <vul-start> t ++ ; if ( s == cinput ) return ( - 1 ) ; outpos = outputbuffer <vul-end> ; outpos += <vul-start> ( outpos, \"\\\\\\\\axo@setObject{%s}%%\\\\n{%s%c}%%\\\\n{\" <vul-end>, s, <vul-start>, t, TERMCHAR ) ; if ( s == cinput ) return ( - 1 ) ; outpos += sprintf ( outpos, \"Axohelp version %d.%d. PDF output.}\", VERSION, SUBVERSION ) ; fprintf ( outfile, \"%s\", outputbuffer ) ; return ( 0 ) ; } else <vul-end> if ( * <vul-start> == '0' && ( <vul-start> [ 1 ]!= ']' ) <vul-end> ) { if <vul-start> = 1 ; if ( s == cinput ) return ( 0 ) ; <vul-start> argbuf ) ; return ( 0 ) ; <vul-start> nameobject ) ; free ( argbuf ) ; return ( - 1 ) ; } } else if ( strcmp ( nameobject, \"DashCurve\" ) == 0 ) { if ( s == cinput ) return ( 0 ) ; <vul-end> fprintf ( stderr <vul-start> inname ) ; <vul-end> free ( argbuf <vul-start> argbuf ) ; <vul-end> return ( - <vul-start> 1 ) ; <vul-end> } else if <vul-start> 0 ) { if ( s == cinput ) return ( 0 ) ; <vul-end> } else if <vul-start>!= '\\\\n' ) { if ( s == cinput ) return ( - 1 ) ; <vul-start> inname ) ; <vul-end> free ( argbuf <vul-start> argbuf ) ; <vul-end> return ( - <vul-start> 1 ) ; } } if ( s == cinput ) return ( 0 ) ; <vul-end> } else if <vul-start> { if ( s == cinput ) return ( - 1 ) ; <vul-start> 1 ) ; if ( s == cinput ) return ( 0 ) ; <vul-start> 0 ) { if ( s == cinput ) return ( - 1 ) ; <vul-start> 1 ) ; if ( s == cinput ) return ( - 1 ) ; <vul-start> 1 ) ; if ( s == cinput ) return ( - 1 ) ; <vul-start> 0 ) { if ( s == c"
 },
 {
  "id": 481,
  "question": "CWE-358 Code Input Vulnerable Code Is: CWE-358 int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <vul-start> int is_udplite = IS_UDPLITE ( sk ) ; <vul-end> bool slow ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <vul-start> if ( udp_lib_checksum_complete ( skb ) ) <vul-end> goto csum_copy_err ; } <vul-start> if ( skb_csum_unnecessary ( skb ) ) <vul-end> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) )",
  "golden_answers": [
   "CWE-358 Fixed Code Lines are: <vul-start> ( sk ) ; bool checksum_valid = false <vul-start> partial_cov ) { checksum_valid = ! <vul-end> udp_lib_checksum_complete ( skb <vul-start> ( skb ) ; if ( ! checksum_valid <vul-start> } if ( checksum_valid ||\n"
  ],
  "generated_answer": "CWE-358 Fixed Code Lines are: <vul-start> ( sk ) ; bool checksum_valid = false <vul-start> partial_cov ) { checksum_valid =! <vul-end> udp_lib_checksum_complete ( skb <vul-start> ( skb ) ; if (! checksum_valid <vul-start> } if ( checksum_valid ||\n"
 },
 {
  "id": 482,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t decoder_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , int * is_intra_only , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) { int intra_only_flag = 0 ; <vul-start> uint8_t clear_buffer [ 9 ] ; <vul-end> if ( data + data_sz <= data ) return VPX_CODEC_INVALID_PARAM ; si -> is_kf = 0 ; si -> w = si -> h = 0 ; if ( decrypt_cb ) { data_sz = VPXMIN ( sizeof ( clear_buffer ) , data_sz ) ; decrypt_cb ( decrypt_state , data , clear_buffer , data_sz ) ; data = clear_buffer ; <vul-start> } <vul-end> { int show_frame ; int error_resilient ; struct vpx_read_bit_buffer rb = { data , data + data_sz , 0 , NULL , NULL } ; const int frame_marker = vpx_rb_read_literal ( & rb , 2 ) ; const BITSTREAM_PROFILE profile = vp9_read_profile ( & rb ) ; if ( frame_marker != VP9_FRAME_MARKER ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( profile >= MAX_PROFILES ) return VPX_CODEC_UNSUP_BITSTREAM ; <vul-start> if ( ( profile >= 2 && data_sz <= 1 ) || data_sz < 1 ) <vul-end> return VPX_CODEC_UNSUP_BITSTREAM ; if ( vpx_rb_read_bit ( & rb ) ) { vpx_rb_read_literal ( & rb , 3 ) ; return VPX_CODEC_OK ; } <vul-start> if ( data_sz <= 8 ) <vul-end> return VPX_CODEC_UNSUP_BITSTREAM ; si -> is_kf = ! vpx_rb_read_bit ( & rb ) ; show_frame = vpx_rb_read_bit ( & rb ) ; error_resilient = vpx_rb_read_bit ( & rb ) ; if ( si -> is_kf ) { if ( ! vp9_read_sync_code ( & rb ) )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> uint8_t clear_buffer [ 10 <vul-end> ] ; if <vul-start> clear_buffer ; } if ( data_sz < 1 ) return VPX_CODEC_UNSUP_BITSTREAM ; <vul-start> ; if ( vpx_rb_read_bit ( & rb ) ) { if ( profile > <vul-end> 2 && data_sz <vul-start> 2 && data_sz < 2 ) return VPX_CODEC_UNSUP_BITSTREAM ; <vul-end> vpx_rb_read_literal ( & <vul-start> if ( data_sz < 10 <vul-end> ) return VPX_CODEC_UNSUP_BITSTREAM\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> uint8_t clear_buffer [ 10 <vul-end> ] ; if <vul-start> clear_buffer ; } # if CONFIG_VP9_HIGHBITDEPTH if ( data_sz > MAX_DECODE_SIZE ) return VPX_CODEC_UNSUP_BITSTREAM ; # else <vul-start> return VPX_CODEC_UNSUP_BITSTREAM ; # endif <vul-start> } if (! vpx_rb_read_bit ( & rb ) ) return VPX_CODEC_UNSUP_BITSTREAM ; if ( <vul-start> = clear_buffer ; # if CONFIG_VP9_HIGHBITDEPTH if ( data_sz > MAX_DECODE_SIZE ) return VPX_CODEC_UNSUP_BITSTREAM ; # else if ( data_sz < 1 ) return VPX_CODEC_UNSUP_BITSTREAM ; # endif\n"
 },
 {
  "id": 483,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int keepalived_main ( int argc , char * * argv ) { bool report_stopped = true ; struct utsname uname_buf ; char * end ; set_time_now ( ) ; save_cmd_line_options ( argc , argv ) ; debug = 0 ; # ifndef _DEBUG_ prog_type = PROG_TYPE_PARENT ; # endif # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; <vul-start> # endif <vul-end> openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ; # ifdef _MEM_CHECK_ mem_log_init ( PACKAGE_NAME , \"Parent process\" ) ; # endif if ( uname ( & uname_buf ) ) log_message ( LOG_INFO , \"Unable to get uname() information - error %d\" , errno ) ; else { os_major = ( unsigned ) strtoul ( uname_buf . release , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { os_minor = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { if ( ! isdigit ( end [ 1 ] ) ) os_major = 0 ; else os_release = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; } } if ( ! os_major ) log_message ( LOG_INFO , \"Unable to parse kernel version %s\" , uname_buf . release ) ; if ( ! config_id ) { end = strchrnul ( uname_buf",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; # endif umask ( 022 ) ; <vul-start> ( ) ; global_data -> umask = umask_val ; <vul-start> ) ; } <vul-end> # ifdef _MEM_CHECK_\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; # endif # ifdef _DEBUG_ log_command_line ( 0 ) ; # endif <vul-start> daemon_mode ) ; if (! global_data -> instance_name ) { if ( global_data -> daemon_mode ) log_message ( LOG_INFO, \"Not going to make daemonize. (PID=%d)\", global_data -> daemon_mode ) ; goto end ; } <vul-start> daemon_mode ) ; if (! global_data -> daemon_mode ) log_message ( LOG_INFO, \"Using daemonize. (PID=%d)\", global_data -> daemon_mode ) ;\n"
 },
 {
  "id": 484,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static bool r_bin_mdmp_init_directory ( struct r_bin_mdmp_obj * obj ) { int i ; <vul-start> ut8 * directory_base ; <vul-end> struct minidump_directory * entry ; directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ; sdb_num_set ( obj -> kv , \"mdmp_directory.offset\" , obj -> hdr -> stream_directory_rva , 0 ) ; sdb_set ( obj -> kv , \"mdmp_directory.format\" , \"[4]E? \" \"(mdmp_stream_type)StreamType \" \"(mdmp_location_descriptor)Location\" , 0 ) ; <vul-start> for ( i = 0 ; i < ( int ) obj -> hdr -> number_of_streams ; i ++ ) { <vul-end> <vul-start> entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <vul-end> <vul-start> r_bin_mdmp_init_directory_entry ( obj , entry ) ; <vul-end> } return true ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> int i ; struct minidump_directory entry <vul-end> ; sdb_num_set ( <vul-start> 0 ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ; <vul-start> ++ ) { ut32 delta = <vul-end> i * sizeof <vul-start> struct minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <vul-start> ) ) ; if ( r ) { <vul-start> ( obj , & <vul-start> entry ) ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> int i ; struct minidump_directory * entry ; directory_base = obj -> b -> buf + obj -> hdr -> stream_directory_rva ; sdb_num_set ( obj -> kv, \"mdmp_directory.offset\", obj -> hdr -> stream_directory_rva, 0 ) ; sdb_set ( obj -> kv, \"mdmp_directory.format\", \"[4]E? \" \"(mdmp_stream_type)StreamType \" \"(mdmp_location_descriptor)Location\", 0 ) ; entry = ( struct minidump_directory * ) ( directory_base + ( i * sizeof ( struct minidump_directory ) ) ) ; <vul-start> 0 ) ; <vul-end> r_bin_mdmp_init_directory_entry ( obj <vul-start> obj, entry, 0\n"
 },
 {
  "id": 485,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { <vul-start> Com_Printf ( \"Usage: writeconfig <filename>\\\\n\" ) ; <vul-end> return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , \".cfg\" ) ; Com_Printf ( \"Writing %s.\\\\n\" , filename ) ; Com_WriteConfigToFile ( filename ) ; }",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> Com_Printf ( \"Usage: writeconfig <filename>\\\\n\" ) ; return ; } if ( ! COM_CompareExtension ( filename , \".cfg\" ) ) { Com_Printf ( \"Com_WriteConfig_f: Only the \\\\\".cfg\\\\\" extension is supported by this command!\\\\n\"\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> 2 ) { COM_Error ( \"Usage: writeconfig <filename>\\\\n\" ) ; return ; } if (! COM_CompareExtension ( Cmd_Argv ( 1 ), \".cfg\" ) ) {\n"
 },
 {
  "id": 486,
  "question": "CWE-89 Code Input Vulnerable Code Is: CWE-89 int msPostGISLayerSetTimeFilter ( layerObj * lp , const char * timestring , const char * timefield ) { char * * atimes , * * aranges = NULL ; int numtimes = 0 , i = 0 , numranges = 0 ; size_t buffer_size = 512 ; char buffer [ 512 ] , bufferTmp [ 512 ] ; buffer [ 0 ] = '\\\\0' ; bufferTmp [ 0 ] = '\\\\0' ; if ( ! lp || ! timestring || ! timefield ) <vul-start> return MS_FALSE ; <vul-end> if ( strstr ( timestring , \",\" ) == NULL && strstr ( timestring , \"/\" ) == NULL ) { createPostgresTimeCompareSimple ( timefield , timestring , buffer , buffer_size ) ; } else { atimes = msStringSplit ( timestring , ',' , & numtimes ) ; if ( atimes == NULL || numtimes < 1 ) return MS_FALSE ; strlcat ( buffer , \"(\" , buffer_size ) ; for ( i = 0 ; i < numtimes ; i ++ ) { if ( i != 0 ) { strlcat ( buffer , \" OR \" , buffer_size ) ; } strlcat ( buffer , \"(\" , buffer_size ) ; aranges = msStringSplit ( atimes [ i ] , '/' , & numranges ) ; if ( ! aranges ) return MS_FALSE ; if ( numranges == 1 ) { createPostgresTimeCompareSimple ( timefield , atimes [ i ] , bufferTmp , buffer_size ) ; strlcat ( buffer , bufferTmp , buffer_size ) ; } else if ( numranges == 2 ) { createPostgresTimeCompareRange ( timefield ,",
  "golden_answers": [
   "CWE-89 Fixed Code Lines are: <vul-start> return MS_FALSE ; if ( strchr ( timestring , '\\\\'' ) || strchr ( timestring , '\\\\\\\\' ) ) { msSetError ( MS_MISCERR , \"Invalid time filter.\" , \"msPostGISLayerSetTimeFilter()\" ) ; return MS_FALSE ; }\n"
  ],
  "generated_answer": "CWE-89 Fixed Code Lines are: <vul-start> ) return MS_FALSE ; if ( strlen ( timestring ) > buffer_size ) return MS_FALSE\n"
 },
 {
  "id": 487,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void kvm_lapic_sync_to_vapic ( struct kvm_vcpu * vcpu ) { u32 data , tpr ; int max_irr , max_isr ; <vul-start> struct kvm_lapic * apic = vcpu -> arch . apic ; <vul-end> void * vapic ; apic_sync_pv_eoi_to_guest ( vcpu , apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; tpr = kvm_apic_get_reg ( apic , APIC_TASKPRI ) & 0xff ; max_irr = apic_find_highest_irr ( apic ) ; if ( max_irr < 0 ) max_irr = 0 ; max_isr = apic_find_highest_isr ( apic ) ; if ( max_isr < 0 ) max_isr = 0 ; data = ( tpr & 0xff ) | ( ( max_isr & 0xf0 ) << 8 ) | ( max_irr << 24 ) ; <vul-start> vapic = kmap_atomic ( vcpu -> arch . apic -> vapic_page ) ; <vul-end> * ( u32 * ) ( vapic + offset_in_page ( vcpu -> arch . apic -> vapic_addr ) ) = data ; kunmap_atomic ( vapic ) ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> arch . apic <vul-end> ; apic_sync_pv_eoi_to_guest ( <vul-start> 24 ) ; kvm_write_guest_cached ( vcpu -> kvm , & <vul-end> vcpu -> arch <vul-start> . apic -> vapic_cache , & data , sizeof ( u32 ) <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> arch. apic <vul-end> ; apic_sync_pv_eoi_to_guest ( <vul-start> 24 ) ; kvm_write_guest_cached ( vcpu -> kvm, & <vul-end> vcpu -> arch <vul-start>. apic -> vapic_cache, & data, sizeof ( u32 ) <vul-end> ) ; }\n"
 },
 {
  "id": 488,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static void box_blur_line ( gint box_width , gint even_offset , guchar * src , guchar * dest , gint len , gint bpp ) { gint i ; gint lead ; gint output ; gint trail ; <vul-start> gint * ac ; <vul-end> ac = g_new0 ( gint , bpp ) ; lead = 0 ; if ( box_width % 2 != 0 ) { output = lead - ( box_width - 1 ) / 2 ; trail = lead - box_width ; } else { if ( even_offset == 1 ) { output = lead + 1 - box_width / 2 ; trail = lead - box_width ; } else if ( even_offset == - 1 ) { output = lead - box_width / 2 ; trail = lead - box_width ; } else { g_assert_not_reached ( ) ; } } for ( i = 0 ; i < bpp ; i ++ ) ac [ i ] = 0 ; while ( output < len ) { guint coverage = ( lead < len ? lead : len - 1 ) - ( trail >= 0 ? trail : - 1 ) ; # ifdef READABLE_BOXBLUR_CODE for ( i = 0 ; i < bpp ; i ++ ) { if ( lead < len ) ac [ i ] += src [ bpp * lead + i ] ; if ( trail >= 0 ) ac [ i ] -= src [ bpp * trail + i ] ; if ( output >= 0 ) dest [ bpp * output + i",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> gint * ac ; g_assert ( box_width > 0 )\n"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> gint * ac ; if ( box_width < 0 || len < 0 ) return\n"
 },
 {
  "id": 489,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 public int magic_getparam ( struct magic_set * ms , int param , void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : * ( size_t * ) val = ms -> indir_max ; return 0 ; case MAGIC_PARAM_NAME_MAX : * ( size_t * ) val = ms -> name_max ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : * ( size_t * ) val = ms -> elf_phnum_max ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : * ( size_t * ) val = ms -> elf_shnum_max ; return 0 ; <vul-start> default : <vul-end> errno = EINVAL ; return - 1 ; } }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> return 0 ; case MAGIC_PARAM_ELF_SHNUM_MIN : * ( size_t * ) val = ms -> elf_shnum_min ; return 0 ;\n"
 },
 {
  "id": 490,
  "question": "CWE-326 Code Input Vulnerable Code Is: CWE-326 void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) { <vul-start> static u32 ip_idents_hashrnd __read_mostly ; <vul-end> u32 hash , id ; <vul-start> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <vul-end> <vul-start> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <vul-end> ( __force u32 ) iph -> saddr , <vul-start> iph -> protocol ^ net_hash_mix ( net ) , <vul-end> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }",
  "golden_answers": [
   "CWE-326 Fixed Code Lines are: <vul-start> segs ) { <vul-end> u32 hash , <vul-start> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <vul-end> , sizeof ( <vul-start> , sizeof ( net -> ipv4 . ip_id_key <vul-end> ) ) ; <vul-start> ; hash = siphash_3u32 <vul-end> ( ( __force <vul-start> iph -> protocol , & net -> ipv4 . ip_id_key <vul-end> ) ; id\n"
  ],
  "generated_answer": "CWE-326 Fixed Code Lines are: <vul-start> segs ) { u32 id <vul-end> ; hash = <vul-start> sizeof ( ip_idents_hashrnd ) ) ; spin_lock_irq ( & net -> hash_lock <vul-start> ) ) ; id = ip_idents_reserve ( hash, segs ) ; spin_unlock_irq ( & net -> hash_lock <vul-end> ) ; }\n"
 },
 {
  "id": 491,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void start_daemon ( ) { struct usb_sock_t * usb_sock ; if ( g_options . noprinter_mode == 0 ) { usb_sock = usb_open ( ) ; if ( usb_sock == NULL ) goto cleanup_usb ; } else usb_sock = NULL ; uint16_t desired_port = g_options . desired_port ; <vul-start> struct tcp_sock_t * tcp_socket ; <vul-end> <vul-start> while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL && <vul-end> <vul-start> g_options . only_desired_port == 0 ) { <vul-end> desired_port ++ ; if ( desired_port == 1 || desired_port == 0 ) desired_port = 49152 ; <vul-start> } <vul-end> if ( tcp_socket == NULL ) goto cleanup_tcp ; <vul-start> uint16_t real_port = tcp_port_number_get ( tcp_socket ) ; <vul-end> if ( desired_port != 0 && g_options . only_desired_port == 1 && desired_port != real_port ) { ERR ( \"Received port number did not match requested port number.\" \" The requested port number may be too high.\" ) ; goto cleanup_tcp ; } printf ( \"%u|\" , real_port ) ; fflush ( stdout ) ; <vul-start> uint16_t pid ; <vul-end> if ( ! g_options . nofork_mode && ( pid = fork ( ) ) > 0 ) { printf ( \"%u|\" , pid ) ; exit ( 0 ) ; } if ( usb_can_callback ( usb_sock ) ) usb_register_callback ( usb_sock ) ; for ( ; ; ) { struct service_thread_param * args = calloc ( 1 , sizeof ( * args ) ) ; if ( args == NULL ) { ERR ( \"Failed to alloc space for thread args\" ) ; goto cleanup_thread ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> tcp_sock_t * tcp_socket = NULL , * tcp6_socket = NULL ; for ( ; ; ) { <vul-end> tcp_socket = tcp_open <vul-start> ( desired_port ) ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || <vul-end> g_options . only_desired_port <vul-start> g_options . only_desired_port ) break ; <vul-end> desired_port ++ ; <vul-start> = 49152 ; NOTE ( \"Access to desired port failed, trying alternative port %d\" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket <vul-end> == NULL ) <vul-start> ; uint16_t real_port ; if ( tcp_socket ) real_port <vul-start> tcp_port_number_get ( tcp_socket ) ; else real_port = tcp_port_number_get ( tcp6_socket <vul-start> stdout ) ; NOTE ( \"Port: %d, IPv4 %savailable, IPv6 %savailable\" , real_port , tcp_socket ? \"\" : \"not \" , tcp6_socket ? \"\" : \"not \" ) ; <vul-start> -> tcp = tcp_conn_select ( tcp_socket , tcp6_socket <vul-end> ) ; if <vul-start> tcp_socket ) ; if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>. desired_port ; int do_read = 0 ; <vul-start> * tcp_socket ; do_read = 1 ; <vul-start> == 0 ) { <vul-end> desired_port ++ ; <vul-start> = 49152 ; do_read = 0 ; <vul-start> goto cleanup_tcp ; } <vul-end> fflush ( stdout <vul-start> stdout ) ; if ( do_read ) { if ( usb_sock!= NULL ) usb_close ( usb_sock ) ; } <vul-end> if ( usb_can_callback <vul-start> tcp_socket ) ; <vul-end> return ; }\n"
 },
 {
  "id": 492,
  "question": "CWE-252 Code Input Vulnerable Code Is: CWE-252 static void init_syntax_once ( ) { register int c ; <vul-start> static int done ; <vul-end> if ( done ) return ; bzero ( re_syntax_table , sizeof re_syntax_table ) ; <vul-start> for ( c = 'a' ; c <= 'z' ; c ++ ) <vul-end> re_syntax_table [ c ] = Sword ; for ( c = 'A' ; c <= 'Z' ; c ++ ) re_syntax_table [ c ] = Sword ; for ( c = '0' ; c <= '9' ; c ++ ) re_syntax_table [ c ] = Sword ; re_syntax_table [ '_' ] = Sword ; done = 1 ; }",
  "golden_answers": [
   "CWE-252 Fixed Code Lines are: <vul-start> static int done = 0 <vul-start> ( c = 0 ; c < CHAR_SET_SIZE ; ++ c ) if ( ISALNUM ( c ) <vul-end> ) re_syntax_table [\n"
  ],
  "generated_answer": "CWE-252 Fixed Code Lines are: <vul-start> int c ; <vul-end> bzero ( re_syntax_table <vul-start> re_syntax_table ) ; init_rules ( ) <vul-end> ; }  \n"
 },
 {
  "id": 493,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ; <vul-start> if ( exists_not_none ( obj , & PyId_lower ) ) { <vul-end> int res ; <vul-start> tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ; <vul-end> if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ;",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_lower , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; lower = NULL ; } else <vul-end> { int res <vul-start> int res ; <vul-end> res = obj2ast_expr <vul-start> ) ; } if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; upper = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; step = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"dims\\\\\" missing from ExtSlice\" ) ; return 1 ; } else <vul-end> { int res <vul-start> ; Py_ssize_t i <vul-end> ; if ( <vul-start> ) { slice_ty val <vul-end> ; res = <vul-start> ) , & val <vul-end> , arena ) <vul-start> , i , val <vul-end> ) ; } <vul-start> ( tmp ) <vul-end> ; } * <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"value\\\\\" missing from Index\" ) ; return 1 ; } else <vul-end> { int res <vul-start> int res ; <vul-end> res = obj2ast_expr <vul-start> ) ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <vul-end> ( PyExc_TypeError , <vul-start> ( PyExc_TypeError , <vul-end> \"expected some sort of slice, but got %R\" , obj\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> expr_ty step ; PyObject * id = NULL ; <vul-start> obj, & id_lower ) ) { int res ; res = obj2ast_expr ( tmp, & id_lower, arena ) ; if ( res!= 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { lower = NULL ; } if ( exists_not_none ( obj, & <vul-start> ) { slice_ty val <vul-end> ; res = <vul-start> ), & val <vul-end>, arena ) <vul-start> failed ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"dims\\\\\" missing from ExtSlice\" ) ; return 1 ; } * out = ExtSlice ( dims, arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj, ( PyObject * ) Index_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( lookup_attr_id ( obj, & id_upper ) == - 1 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"upper\\\\\" missing from Index\" ) ; return 1 ; } else { <vul-start> ) ; } } * out = Index ( value, arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj, ( PyObject * ) Index_type ) ; if ( isinstance ) { if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { return 1 ; } if ( isinstance ) { asdl_seq * step ; if ( lookup_attr_id ( obj, & id_step ) == - 1 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"step\\\\\" missing from Index\" ) ; return 1 ; } else { <vul-end> PyErr_Format ( PyExc_TypeError <vul-start> ( PyExc_TypeError, <vul-end> \"expected some sort of slice but got %R\", obj ) ; failed : Py_XDECREF ( tmp ) ; <vul-end> PyErr_SetString ( PyExc_TypeError <vul-start> ( PyExc_TypeError, <vul-end> \""
 },
 {
  "id": 494,
  "question": "CWE-255 Code Input Vulnerable Code Is: CWE-255 kadm5_ret_t kadm5_randkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * keyblocks , int * n_keys ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ; <vul-start> int ret , last_pwd ; <vul-end> krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; if ( keyblocks ) * keyblocks = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( principal == NULL ) return EINVAL ; if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ; ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto done ; if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) { if ( keepold ) return KADM5_PROTECT_PRINCIPAL ; new_n_ks_tuple = 1 ; } ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto done ; ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ; if ( ret ) goto done ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto done ; kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ; ret = krb5_timeofday ( handle ->",
  "golden_answers": [
   "CWE-255 Fixed Code Lines are: <vul-start> ret , last_pwd , n_new_keys <vul-start> keyblocks ) { n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; <vul-start> -> context , n_new_keys <vul-end> , kdb ->\n"
  ],
  "generated_answer": "CWE-255 Fixed Code Lines are: <vul-start> ret, last_pwd, salt_key_data [ KADM5_MAX_KEY_DATA ] <vul-start> keyblocks ) { if ( handle -> lhandle -> flags & KADM5_FLAG_SINGLE_PASS ) { ret = krb5_get_key_data ( handle -> context, adb. key_data, salt_key_data, n_keys, & salt_key_data [ 0 ] ) ; if ( ret < 0 ) goto done ; } <vul-start> -> context, salt_key_data, <vul-end> keyblocks, n_keys\n"
 },
 {
  "id": 495,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_update_mbgraph_stats ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; int i , n_frames = vp9_lookahead_depth ( cpi -> lookahead ) ; <vul-start> YV12_BUFFER_CONFIG * golden_ref = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; <vul-end> if ( n_frames <= cpi -> rc . frames_till_gf_update_due ) return ; if ( n_frames > MAX_LAG_BUFFERS ) n_frames = MAX_LAG_BUFFERS ; cpi -> mbgraph_n_frames = n_frames ; for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; <vul-start> vpx_memset ( frame_stats -> mb_stats , 0 , <vul-end> cm -> mb_rows * cm -> mb_cols * sizeof ( * cpi -> mbgraph_stats [ i ] . mb_stats ) ) ; } for ( i = 0 ; i < n_frames ; i ++ ) { MBGRAPH_FRAME_STATS * frame_stats = & cpi -> mbgraph_stats [ i ] ; struct lookahead_entry * q_cur = vp9_lookahead_peek ( cpi -> lookahead , i ) ; assert ( q_cur != NULL ) ; update_mbgraph_frame_stats ( cpi , frame_stats , & q_cur -> img , golden_ref , cpi -> Source ) ; } <vul-start> vp9_clear_system_state ( ) ; <vul-end> separate_arf_mbs ( cpi ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> cpi , GOLDEN_FRAME ) ; assert ( golden_ref != NULL <vul-start> i ] ; memset <vul-end> ( frame_stats -> <vul-start> ) ; } vpx_clear_system_state <vul-end> ( ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> lookahead ) ; YV12_BUFFER <vul-end> * golden_ref = <vul-start> i ] ; memset <vul-end> ( frame_stats -> <vul-start> ) ; } vpx_clear_system_state <vul-end> ( ) ;\n"
 },
 {
  "id": 496,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int iowarrior_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct iowarrior * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; int i ; int retval = - ENOMEM ; dev = kzalloc ( sizeof ( struct iowarrior ) , GFP_KERNEL ) ; if ( dev == NULL ) { dev_err ( & interface -> dev , \"Out of memory\\\\n\" ) ; return retval ; } mutex_init ( & dev -> mutex ) ; atomic_set ( & dev -> intr_idx , 0 ) ; atomic_set ( & dev -> read_idx , 0 ) ; spin_lock_init ( & dev -> intr_idx_lock ) ; atomic_set ( & dev -> overflow_flag , 0 ) ; init_waitqueue_head ( & dev -> read_wait ) ; atomic_set ( & dev -> write_busy , 0 ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> udev = udev ; dev -> interface = interface ; iface_desc = interface -> cur_altsetting ; <vul-start> dev -> product_id = le16_to_cpu ( udev -> descriptor . idProduct ) ; <vul-end> for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_is_int_in ( endpoint ) ) dev -> int_in_endpoint = endpoint ; if ( usb_endpoint_is_int_out ( endpoint ) ) dev -> int_out_endpoint = endpoint ; } dev -> report_size = usb_endpoint_maxp ( dev -> int_in_endpoint ) ; if ( ( dev",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , \"Invalid number of endpoints\\\\n\" ) ; retval = - EINVAL ; goto error ; }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> idProduct ) ; if ( dev -> product_id > 0xffff ) { dev_err ( & interface -> dev, \"Invalid device product id\\\\n\" ) ; return - ENODEV ; }\n"
 },
 {
  "id": 497,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , \"%sERROR: object header size %u not a multiple of 4\" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , \"%sERROR: object header too short %u < %lu\" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , \"%s%s Object (%u) Flags: [%s\" , ident , tok2str ( rsvp_obj_values , \"Unknown\" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <vul-start> bandwidth ) ; <vul-end> ND_PRINT ( ( <vul-start> - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> * obj_tptr ; if ( obj_tlen < 4 ) goto trunc ; <vul-start> -> bandwidth ; if ( bw. i > 255 ) goto trunc ; <vul-start> ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; <vul-start> break ; case RSVP_CTYPE_IPV4_ADDRESS : if ( obj_tlen < 4 ) goto trunc ; ND_PRINT ( ( ndo, \"%s IPv4 Address: %s\", ident, ipaddr_string ( ndo, obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6_ADDRESS : if ( obj_tlen < 4 ) goto trunc ; ND_PRINT ( ( ndo, \"%s IPv6 Address: %s\", ident, ipaddr_string ( ndo, obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_UNIX_ADDRESS : if ( obj_tlen < 4 ) goto trunc ; ND_PRINT ( ( ndo, \"%s IPv4 Socket Address: %s\", ident, ipaddr_string ( ndo, obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case\n"
 },
 {
  "id": 498,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int mISDN_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sk_buff * skb ; <vul-start> struct sock * sk = sock -> sk ; <vul-end> struct sockaddr_mISDN * maddr ; int copied , err ; if ( * debug & DEBUG_SOCKET ) printk ( KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\\\n\" , __func__ , ( int ) len , flags , _pms ( sk ) -> ch . nr , sk -> sk_protocol ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; if ( sk -> sk_state == MISDN_CLOSED ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; <vul-start> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <vul-end> msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ; maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ; maddr -> family = AF_ISDN ; maddr -> dev = _pms ( sk ) -> dev -> id ; if ( ( sk -> sk_protocol == ISDN_P_LAPD_TE ) || ( sk -> sk_protocol == ISDN_P_LAPD_NT ) ) { maddr -> channel = ( mISDN_HEAD_ID ( skb ) >> 16 ) & 0xff ; maddr -> tei = ( mISDN_HEAD_ID ( skb ) >> 8 ) & 0xff ; maddr -> sapi = mISDN_HEAD_ID ( skb ) & 0xff ; } else { maddr -> channel = _pms",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> sock -> sk <vul-end> ; int copied <vul-start> ( msg -> msg_name ) { struct sockaddr_mISDN * maddr = <vul-end> msg -> msg_name <vul-start> 0xFF ; } <vul-end> msg -> msg_namelen <vul-start> msg -> msg_namelen = sizeof ( * maddr ) <vul-end> ; } copied\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> sock -> sk <vul-end> ; int copied <vul-start> return err ; memset ( msg -> msg_name, 0, sizeof ( struct sockaddr_mISDN ) ) ; <vul-start> } else { <vul-end> msg -> msg_namelen <vul-start> msg -> msg_namelen = 0 ; } <vul-end> copied = skb\n"
 },
 {
  "id": 499,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 Datum poly_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; POLYGON * poly ; int npts ; int size ; <vul-start> int isopen ; <vul-end> char * s ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( \"invalid input syntax for type polygon: \\\\\"%s\\\\\"\" , str ) ) ) ; <vul-start> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <vul-end> poly = ( POLYGON * ) palloc0 ( size ) ; SET_VARSIZE ( poly , size ) ; poly -> npts = npts ; if ( ( ! path_decode ( FALSE , npts , str , & isopen , & s , & ( poly -> p [ 0 ] ) ) ) || ( * s != '\\\\0' ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( \"invalid input syntax for type polygon: \\\\\"%s\\\\\"\" , str ) ) ) ; make_bound_box ( poly ) ; PG_RETURN_POLYGON_P ( poly ) ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> size ; int base_size ; int <vul-start> ) ) ; base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <vul-start> ] ) + base_size ; if ( base_size / npts != <vul-start> 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( \"too many points requested\" ) ) ) <vul-end> ; poly =\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ; int isopen = 0 <vul-start> ) ) ; if ( npts > MaxPixelSize / sizeof ( poly -> p [ 0 ] ) ) ereport ( ERROR, ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ), errmsg ( \"number of points (%d) exceeds the maximum allowed (%d)\", npts, ( int ) ( MaxPixelSize / sizeof ( poly -> p [ 0 ] ) ) ) ) ;\n"
 },
 {
  "id": 500,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <vul-end> <vul-start> const vp9_prob * probs ) { <vul-end> vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> void write_intra_mode ( vpx_writer <vul-end> * w , <vul-start> * w , PREDICTION_MODE <vul-end> mode , const <vul-start> mode , const vpx_prob <vul-end> * probs )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void write_intra_mode ( vpx_writer <vul-end> * w, <vul-start> * w, PREDICTION_MODE <vul-end> mode, const <vul-start> mode, const vpx_prob <vul-end> * probs )\n"
 },
 {
  "id": 501,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static inline key_ref_t __key_update ( key_ref_t key_ref , struct key_preparsed_payload * prep ) { struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) goto error ; ret = - EEXIST ; if ( ! key -> type -> update ) goto error ; down_write ( & key -> sem ) ; ret = key -> type -> update ( key , prep ) ; if ( ret == 0 ) <vul-start> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <vul-end> up_write ( & key -> sem ) ; if ( ret < 0 ) goto error ; out : return key_ref ; error : key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto out ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> == 0 ) mark_key_instantiated ( key , 0 <vul-end> ) ; up_write\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> == 0 ) mark_key_instantiated ( key, 0 <vul-end> ) ; up_write\n"
 },
 {
  "id": 502,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <vul-start> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <vul-end> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> & fl6 , rcu_dereference ( <vul-start> np -> opt ) , & final ) ; rcu_read_unlock ( <vul-end> ) ; dst\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> & fl6, rcu_dereference ( <vul-start> np -> opt )\n"
 },
 {
  "id": 503,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int save_new_data ( struct chfn_control * ctl ) { char * gecos ; int len ; len = xasprintf ( & gecos , \"%s,%s,%s,%s,%s\" , ctl -> newf . full_name , ctl -> newf . office , ctl -> newf . office_phone , ctl -> newf . home_phone , ctl -> newf . other ) ; if ( ! ctl -> newf . other ) { while ( len > 0 && gecos [ len - 1 ] == ',' ) len -- ; gecos [ len ] = 0 ; } # ifdef HAVE_LIBUSER if ( set_value_libuser ( \"chfn\" , ctl -> username , ctl -> pw -> pw_uid , LU_GECOS , gecos ) < 0 ) { # else ctl -> pw -> pw_gecos = gecos ; <vul-start> if ( setpwnam ( ctl -> pw ) < 0 ) { <vul-end> warn ( \"setpwnam failed\" ) ; # endif printf ( _ ( \"Finger information *NOT* changed. Try again later.\\\\n\" ) ) ; return - 1 ; } free ( gecos ) ; printf ( _ ( \"Finger information changed.\\\\n\" ) ) ; return 0 ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ctl -> pw , \".chfn\"\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ctl -> pw, \".chfn\"\n"
 },
 {
  "id": 504,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t %s Option (0x%02x), length %u (length bogus, should be >= 2)\" , tok2str ( bacconfopts_values , \"Unknown\" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t %s Option (0x%02x), length %u\" , tok2str ( bacconfopts_values , \"Unknown\" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , \" (length bogus, should be = 6)\" ) ) ; return len ; } <vul-start> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <vul-end> ND_PRINT ( ( ndo , \": Magic-Num 0x%08x\" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , \"\\\\n\\\\t \" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , \"\\\\n\\\\t \" , len - 2 ) ; return len ; trunc : ND_PRINT (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> len ; } ND_TCHECK_32BITS <vul-end> ( p + <vul-start> p + 2 <vul-end> ) ; ND_PRINT\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> len ; } ND_TCHECK_32BITS ( p + <vul-end> 2 ) ;\n"
 },
 {
  "id": 505,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void update_alt_ref_frame_stats ( VP9_COMP * cpi ) { RATE_CONTROL * const rc = & cpi -> rc ; rc -> frames_since_golden = 0 ; <vul-start> # if CONFIG_MULTIPLE_ARF <vul-end> if ( ! cpi -> multi_arf_enabled ) # endif rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 1 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; <vul-end> rc -> source_alt_ref_pending\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; <vul-end> rc -> source_alt_ref_pending\n"
 },
 {
  "id": 506,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { <vul-start> if ( radiotap_header -> it_version ) <vul-end> return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - <vul-start> ( unsigned long ) iterator -> _rtheader > <vul-end> ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <vul-start> iterator -> _rtheader + sizeof ( uint32_t )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vns ) { struct ieee80211_radiotap_header * header = ( struct ieee80211_radiotap_header * ) radiotap_header ; <vul-start> radiotap_header -> it_version!= IEEE80211_VERSION_1 ) return - EINVAL ; if ( ( unsigned long ) radiotap_header -> it_len > header -> it_max_length ) return - EINVAL ; if ( ( unsigned long ) radiotap_header -> it_index >= header -> it_max_index\n"
 },
 {
  "id": 507,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int nfp_abm_u32_knode_replace ( struct nfp_abm_link * alink , struct tc_cls_u32_knode * knode , __be16 proto , struct netlink_ext_ack * extack ) { struct nfp_abm_u32_match * match = NULL , * iter ; unsigned int tos_off ; u8 mask , val ; int err ; <vul-start> if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) <vul-end> <vul-start> goto err_delete ; <vul-end> tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ; val = be32_to_cpu ( knode -> sel -> keys [ 0 ] . val ) >> tos_off & 0xff ; mask = be32_to_cpu ( knode -> sel -> keys [ 0 ] . mask ) >> tos_off & 0xff ; list_for_each_entry ( iter , & alink -> dscp_map , list ) { u32 cmask ; if ( iter -> handle == knode -> handle ) { match = iter ; continue ; } cmask = iter -> mask & mask ; if ( ( iter -> val & cmask ) == ( val & cmask ) && iter -> band != knode -> res -> classid ) { NL_SET_ERR_MSG_MOD ( extack , \"conflict with already offloaded filter\" ) ; <vul-start> goto err_delete ; <vul-end> } } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) <vul-start> return - ENOMEM ; <vul-end> <vul-start> list_add ( & match -> list , & alink -> dscp_map ) ; <vul-end> } match -> handle = knode -> handle ; match -> band =",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> extack ) ) { err = - EOPNOTSUPP ; <vul-start> goto err_delete ; } <vul-start> \"conflict with already offloaded filter\" ) ; err = - EOPNOTSUPP ; <vul-start> ! match ) { err = <vul-end> - ENOMEM ; <vul-start> - ENOMEM ; goto err_delete ; } <vul-start> ) ; return err <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> int err ; struct tc_cls_u32 * dscp = alink -> dscp ; <vul-start> ) ) goto err_free <vul-end> ; tos_off = <vul-start> \"conflict with already offloaded filter\" ) ; err_free = & iter -> list ; <vul-start>! match ) { err = <vul-end> - ENOMEM ; <vul-start> -> dscp_map ) ; if ( err ) goto err_free_knode ; } dscp -> handle = knode -> handle ; dscp -> band = knode -> res -> classid <vul-start> knode ) ; err_free :\n"
 },
 {
  "id": 508,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ; <vul-start> } <vul-end> dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> NULL ; } dst_state -> speculative = src -> speculative ;\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> = NULL ; dst_state -> frame_size = 0 ;\n"
 },
 {
  "id": 509,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int translate_desc ( struct vhost_dev * dev , u64 addr , u32 len , struct iovec iov [ ] , int iov_size ) { const struct vhost_memory_region * reg ; struct vhost_memory * mem ; struct iovec * _iov ; u64 s = 0 ; int ret = 0 ; rcu_read_lock ( ) ; mem = rcu_dereference ( dev -> memory ) ; while ( ( u64 ) len > s ) { u64 size ; if ( unlikely ( ret >= iov_size ) ) { ret = - ENOBUFS ; break ; } reg = find_region ( mem , addr , len ) ; if ( unlikely ( ! reg ) ) { ret = - EFAULT ; break ; } _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <vul-start> _iov -> iov_len = min ( ( u64 ) len , size ) ; <vul-end> _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s += size ; addr += size ; ++ ret ; } rcu_read_unlock ( ) ; return ret ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> u64 ) len - s\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> -> guest_phys_addr ; if ( unlikely ( size > iov_size ) ) { ret = - EFAULT ; break ; }\n"
 },
 {
  "id": 510,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int udp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; <vul-start> bool slow ; <vul-end> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; bool slow <vul-end> ; if ( <vul-start> ) ) ; * addr_len = sizeof ( * sin ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; bool slow <vul-end> ; if ( <vul-start> ) ) ; * addr_len = sizeof ( * sin ) ;\n"
 },
 {
  "id": 511,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , struct zip_entry * rsrc ) { struct zip * zip = ( struct zip * ) a -> format -> data ; unsigned char * metadata , * mp ; int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; size_t remaining_bytes , metadata_bytes ; ssize_t hsize ; int ret = ARCHIVE_OK , eof ; switch ( rsrc -> compression ) { <vul-start> case 0 : <vul-end> # ifdef HAVE_ZLIB_H case 8 : # endif break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Unsupported ZIP compression method (%s)\" , compression_name ( rsrc -> compression ) ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Mac metadata is too large: %jd > 4M bytes\" , <vul-start> ( intmax_t ) rsrc -> uncompressed_size ) ; <vul-end> return ( ARCHIVE_WARN ) ; } metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; if ( metadata == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Can\\'t allocate memory for Mac metadata\" ) ; return ( ARCHIVE_FATAL ) ; } if ( offset < rsrc -> local_header_offset ) __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; else if ( offset != rsrc -> local_header_offset ) { __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; } hsize = zip_get_local_file_header_size ( a , 0",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Malformed OS X metadata entry: inconsistent size\" ) ; return ( ARCHIVE_FATAL ) ; } <vul-start> rsrc -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Mac metadata is too large: %jd > 4M bytes\" , ( intmax_t ) rsrc -> compressed_size <vul-start> case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> case 0 : if ( bytes_avail < 4 ) { archive_set_error ( & a -> archive, ENOMEM, \"Truncated ZIP file header\" ) ; ret = ARCHIVE_WARN ; goto exit_mac_metadata ; } <vul-start>, \"Mac metadata is too large: %jd > 4M bytes\", <vul-end> rsrc -> uncompressed_size\n"
 },
 {
  "id": 512,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void update_layer_contexts ( VP8_COMP * cpi ) { VP8_CONFIG * oxcf = & cpi -> oxcf ; if ( oxcf -> number_of_layers > 1 ) { unsigned int i ; double prev_layer_framerate = 0 ; assert ( oxcf -> number_of_layers <= VPX_TS_MAX_LAYERS ) ; <vul-start> for ( i = 0 ; i < oxcf -> number_of_layers ; i ++ ) <vul-end> { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> framerate = cpi -> ref_framerate / oxcf -> rate_decimator [ i ] ; lc -> target_bandwidth = oxcf -> target_bitrate [ i ] * 1000 ; lc -> starting_buffer_level = rescale ( ( int ) oxcf -> starting_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> optimal_buffer_level == 0 ) lc -> optimal_buffer_level = lc -> target_bandwidth / 8 ; else lc -> optimal_buffer_level = rescale ( ( int ) oxcf -> optimal_buffer_level_in_ms , lc -> target_bandwidth , 1000 ) ; if ( oxcf -> maximum_buffer_size == 0 ) lc -> maximum_buffer_size = lc -> target_bandwidth / 8 ; else lc -> maximum_buffer_size = rescale ( ( int ) oxcf -> maximum_buffer_size_in_ms , lc -> target_bandwidth , 1000 ) ; if ( i > 0 ) lc -> avg_frame_size_for_layer = ( int ) ( ( oxcf -> target_bitrate [ i ] - oxcf -> target_bitrate [ i - 1 ] ) * 1000 / ( lc -> framerate - prev_layer_framerate ) ) ; prev_layer_framerate = lc -> framerate ; } } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> oxcf -> number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i <vul-end> ) { LAYER_CONTEXT\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> VPX_TS_MAX_LAYERS ) ; if ( oxcf -> rate_decimator == NULL ) { return ; }\n"
 },
 {
  "id": 513,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - EINVAL ; if ( args [ size - 1 ] != '\\\\0' ) { if ( size == PAGE_SIZE ) return - EINVAL ; args [ size ] = '\\\\0' ; } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , \" \" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , \"current\" ) == 0 ) { if ( strcmp ( command , \"changehat\" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , \"permhat\" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , \"changeprofile\" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , \"permprofile\" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else if",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> - EINVAL ; if (! AA_DO_TEST ) sa. aad. info [ sizeof ( sa. aad. info ) - 1 ] = '\\\\0' ;\n"
 },
 {
  "id": 514,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { <vul-start> struct desc_struct * desc ; <vul-end> unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; <vul-start> desc = get_desc ( sel ) ; <vul-end> <vul-start> if ( ! desc ) <vul-end> return 0 ; <vul-start> limit = get_desc_limit ( desc ) ; <vul-end> <vul-start> if ( desc -> g ) <vul-end> limit = ( limit << 12 ) + 0xfff ; return limit ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> { struct desc_struct <vul-end> desc ; unsigned <vul-start> return 0 ; <vul-end> if ( ! <vul-start> if ( ! get_desc ( & desc , sel ) <vul-end> ) return 0 <vul-start> = get_desc_limit ( & <vul-start> if ( desc . <vul-end> g ) limit\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> { struct desc_struct <vul-end> desc ; unsigned <vul-start> return 0 ; <vul-end> if (! <vul-start> if (! get_desc ( & desc, sel ) <vul-end> ) return 0 <vul-start> = get_desc_limit ( & <vul-start> ; if ( get_gfn ( & <vul-end> desc -> g <vul-start> desc -> g )\n"
 },
 {
  "id": 515,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int lldp_private_8023_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t %s Subtype (%u)\" , tok2str ( lldp_8023_subtype_values , \"unknown\" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8023_SUBTYPE_MACPHY : if ( tlv_len < 9 ) { return hexdump ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t autonegotiation [%s] (0x%02x)\" , bittok2str ( lldp_8023_autonegotiation_values , \"none\" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t PMD autoneg capability [%s] (0x%04x)\" , bittok2str ( lldp_pmd_capability_values , \"unknown\" , EXTRACT_16BITS ( tptr + 5 ) ) , EXTRACT_16BITS ( tptr + 5 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t MAU type %s (0x%04x)\" , tok2str ( lldp_mau_types_values , \"unknown\" , EXTRACT_16BITS ( tptr + 7 ) ) , EXTRACT_16BITS ( tptr + 7 ) ) ) ; break ; case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t MDI power support [%s], power pair %s, power class %s\" , bittok2str ( lldp_mdi_values , \"none\" , * ( tptr + 4 ) ) , tok2str ( lldp_mdi_power_pairs_values , \"unknown\" , * ( tptr + 5 ) ) , tok2str ( lldp_mdi_power_class_values , \"unknown\" , * ( tptr + 6 ) ) ) ) ;",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 5 ) { return hexdump ; }\n"
 },
 {
  "id": 516,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 vpx_codec_err_t vpx_codec_set_frame_buffer_functions ( vpx_codec_ctx_t * ctx , vpx_get_frame_buffer_cb_fn_t cb_get , vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { vpx_codec_err_t res ; if ( ! ctx || ! cb_get || ! cb_release ) { res = VPX_CODEC_INVALID_PARAM ; } else if ( ! ctx -> iface || ! ctx -> priv || ! ( ctx -> iface -> caps & VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER ) ) { res = VPX_CODEC_ERROR ; } else { <vul-start> res = ctx -> iface -> dec . set_fb_fn ( ctx -> priv -> alg_priv , cb_get , cb_release , <vul-end> cb_priv ) ; } return SAVE_STATUS ( ctx , res ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> . set_fb_fn ( get_alg_priv ( ctx ) <vul-end> , cb_get ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. set_fb_fn ( get_alg_priv ( ctx ) <vul-end>, cb_get,\n"
 },
 {
  "id": 517,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"rdd\" , & IM , & input , & output ) == FAILURE ) { return ; } <vul-start> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , \"Image\" , le_gd ) ; <vul-end> if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Gamma values should be positive\" ) ; RETURN_FALSE ; }\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> le_gd ) ; if ( input < 0.0 || output < 0.0 ) { return ; }\n"
 },
 {
  "id": 518,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; <vul-start> int res , ret ; <vul-end> if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> res , ret ; if ( uaddr == uaddr2 ) return - EINVAL\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> res, ret ; if ( match_futex ( & q. key, & key2 ) ) return - EINVAL\n"
 },
 {
  "id": 519,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void tty_set_termios_ldisc ( struct tty_struct * tty , int num ) { down_write ( & tty -> termios_rwsem ) ; tty -> termios . c_line = num ; up_write ( & tty -> termios_rwsem ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> termios_rwsem ) ; tty -> disc_data = NULL ; tty -> receive_room = 0 ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> termios_rwsem ) ; tty -> disc_data = NULL ;\n"
 },
 {
  "id": 520,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version !=",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> if ( n <vul-end> != i )\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> <= 0 ) { dtls1_record_replay_check ( s, bitmap ) ; <vul-start> n ) ; }\n"
 },
 {
  "id": 521,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 struct sock * inet_csk_clone_lock ( const struct sock * sk , const struct request_sock * req , const gfp_t priority ) { struct sock * newsk = sk_clone_lock ( sk , priority ) ; if ( newsk ) { struct inet_connection_sock * newicsk = inet_csk ( newsk ) ; newsk -> sk_state = TCP_SYN_RECV ; newicsk -> icsk_bind_hash = NULL ; inet_sk ( newsk ) -> inet_dport = inet_rsk ( req ) -> ir_rmt_port ; inet_sk ( newsk ) -> inet_num = inet_rsk ( req ) -> ir_num ; inet_sk ( newsk ) -> inet_sport = htons ( inet_rsk ( req ) -> ir_num ) ; newsk -> sk_write_space = sk_stream_write_space ; sock_reset_flag ( newsk , SOCK_RCU_FREE ) ; <vul-start> newsk -> sk_mark = inet_rsk ( req ) -> ir_mark ; <vul-end> atomic64_set ( & newsk -> sk_cookie , atomic64_read ( & inet_rsk ( req ) -> ir_cookie ) ) ; newicsk -> icsk_retransmits = 0 ; newicsk -> icsk_backoff = 0 ; newicsk -> icsk_probes_out = 0 ; memset ( & newicsk -> icsk_accept_queue , 0 , sizeof ( newicsk -> icsk_accept_queue ) ) ; security_inet_csk_clone ( newsk , req ) ; } return newsk ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> mc_list = NULL ;\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> ; newsk -> sk_state |= TCP_SYN_SENT ; newsk ->\n"
 },
 {
  "id": 522,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( \"%s: asoc:%p, timeo:%ld, msg_len:%zu\\\\n\" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <vul-start> BUG_ON ( sk != asoc -> base . sk ) ; <vul-end> lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> current_timeo ) ; if <vul-end> ( sk != <vul-start> . sk ) goto do_error\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> current_timeo ) ; if ( current_timeo < 0 ) goto do_error <vul-end> ; lock_sock (\n"
 },
 {
  "id": 523,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = \"`\\\\\"\\\\\\\\\" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \\'\"\\' ; <vul-start> dlen -= 2 ; <vul-end> for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { if ( dlen < 2 ) break ; dlen -= 2 ; * pt ++ = '\\\\\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \\'\"\\' ; * pt = '\\\\0' ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; dlen -= 3 <vul-end> ; for (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = \\'\"\\' ; if ( dlen < 2 ) return ;\n"
 },
 {
  "id": 524,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi0 _U_ , uint32_t proto0 _U_ , int depth _U_ ) { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , \"INVALID-PAYLOAD-TYPE\" , \"DOI-NOT-SUPPORTED\" , \"SITUATION-NOT-SUPPORTED\" , \"INVALID-COOKIE\" , \"INVALID-MAJOR-VERSION\" , \"INVALID-MINOR-VERSION\" , \"INVALID-EXCHANGE-TYPE\" , \"INVALID-FLAGS\" , \"INVALID-MESSAGE-ID\" , \"INVALID-PROTOCOL-ID\" , \"INVALID-SPI\" , \"INVALID-TRANSFORM-ID\" , \"ATTRIBUTES-NOT-SUPPORTED\" , \"NO-PROPOSAL-CHOSEN\" , \"BAD-PROPOSAL-SYNTAX\" , \"PAYLOAD-MALFORMED\" , \"INVALID-KEY-INFORMATION\" , \"INVALID-ID-INFORMATION\" , \"INVALID-CERT-ENCODING\" , \"INVALID-CERTIFICATE\" , \"CERT-TYPE-UNSUPPORTED\" , \"INVALID-CERT-AUTHORITY\" , \"INVALID-HASH-INFORMATION\" , \"AUTHENTICATION-FAILED\" , \"INVALID-SIGNATURE\" , \"ADDRESS-NOTIFICATION\" , \"NOTIFY-SA-LIFETIME\" , \"CERTIFICATE-UNAVAILABLE\" , \"UNSUPPORTED-EXCHANGE-TYPE\" , \"UNEQUAL-PAYLOAD-LENGTHS\" , } ; static const char * ipsec_notify_error_str [ ] = { \"RESERVED\" , } ; static const char * notify_status_str [ ] = { \"CONNECTED\" , } ; static const char * ipsec_notify_status_str [ ] = { \"RESPONDER-LIFETIME\" , \"REPLAY-STATUS\" , \"INITIAL-CONTACT\" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , cp , ep2 <vul-end> , map , <vul-start> nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , \")\" ) ) ; goto trunc ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, cp, <vul-end> ep, map\n"
 },
 {
  "id": 525,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void fdct8 ( const int16_t * input , int16_t * output ) { <vul-end> <vul-start> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <vul-end> <vul-start> int t0 , t1 , t2 , t3 ; <vul-end> int x0 , x1 , x2 , x3 ; s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1 = s1 + s2 ; x2 = s1 - s2 ; x3 = s0 - s3 ; t0 = ( x0 + x1 ) * cospi_16_64 ; t1 = ( x0 - x1 ) * cospi_16_64 ; t2 = x2 * cospi_24_64 + x3 * cospi_8_64 ; t3 = - x2 * cospi_8_64 + x3 * cospi_24_64 ; <vul-start> output [ 0 ] = fdct_round_shift ( t0 ) ; <vul-end> <vul-start> output [ 2 ] = fdct_round_shift ( t2 ) ; <vul-end> <vul-start> output [ 4 ] = fdct_round_shift ( t1 ) ; <vul-end> <vul-start> output [ 6 ] = fdct_round_shift ( t3 ) ; <vul-end> t0",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> fdct8 ( const tran_low_t * input , tran_low_t <vul-end> * output ) <vul-start> output ) { tran_high_t <vul-end> s0 , s1 <vul-start> , s7 ; tran_high_t t0 , t1 , t2 , t3 ; tran_high_t <vul-end> x0 , x1 <vul-start> 0 ] = ( tran_low_t ) <vul-start> 2 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 6 ] = ( tran_low_t ) <vul-start> ; t2 = ( tran_low_t ) fdct_round_shift ( t0 ) ; t3 = ( tran_low_t ) <vul-end> fdct_round_shift ( t1 <vul-start> 1 ] = ( tran_low_t ) <vul-start> 3 ] = ( tran_low_t ) <vul-start> 5 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> fdct8 ( const tran_low_t <vul-end> * input, <vul-start> * input, tran_low_t <vul-end> * output ) <vul-start> output ) { tran_high_t <vul-end> s0, s1 <vul-start>, s7 ; tran_high_t <vul-end> t0, t1 <vul-start> 0 ] = ( tran_low_t ) <vul-start> 2 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 6 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 0 ] = ( tran_low_t ) <vul-start> 1 ] = ( tran_low_t ) <vul-start> 3 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 5 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t )\n"
 },
 {
  "id": 526,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int rm_read_multi ( AVFormatContext * s , AVIOContext * pb , AVStream * st , char * mime ) { int number_of_streams = avio_rb16 ( pb ) ; int number_of_mdpr ; int i , ret ; unsigned size2 ; for ( i = 0 ; i < number_of_streams ; i ++ ) avio_rb16 ( pb ) ; number_of_mdpr = avio_rb16 ( pb ) ; if ( number_of_mdpr != 1 ) { avpriv_request_sample ( s , \"MLTI with multiple (%d) MDPR\" , number_of_mdpr ) ; } for ( i = 0 ; i < number_of_mdpr ; i ++ ) { AVStream * st2 ; if ( i > 0 ) { st2 = avformat_new_stream ( s , NULL ) ; if ( ! st2 ) { ret = AVERROR ( ENOMEM ) ; return ret ; } st2 -> id = st -> id + ( i << 16 ) ; st2 -> codecpar -> bit_rate = st -> codecpar -> bit_rate ; st2 -> start_time = st -> start_time ; st2 -> duration = st -> duration ; st2 -> codecpar -> codec_type = AVMEDIA_TYPE_DATA ; st2 -> priv_data = ff_rm_alloc_rmstream ( ) ; if ( ! st2 -> priv_data ) return AVERROR ( ENOMEM ) ; } else st2 = st ; size2 = avio_rb32 ( pb ) ; ret = ff_rm_read_mdpr_codecdata ( s , s -> pb , st2 , st2 -> priv_data , <vul-start> size2 , mime ) ; <vul-end> if ( ret < 0 ) return ret ; } return 0 ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> , size2 , NULL <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> size2, mime, 0\n"
 },
 {
  "id": 527,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void setup_pass ( struct stream_state * stream , struct VpxEncoderConfig * global , int pass ) { if ( stream -> config . stats_fn ) { if ( ! stats_open_file ( & stream -> stats , stream -> config . stats_fn , pass ) ) fatal ( \"Failed to open statistics store\" ) ; } else { if ( ! stats_open_mem ( & stream -> stats , pass ) ) fatal ( \"Failed to open statistics store\" ) ; } <vul-start> stream -> config . cfg . g_pass = global -> passes == 2 <vul-end> ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ; <vul-start> if ( pass ) <vul-end> stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ; <vul-start> stream -> cx_time = 0 ; <vul-end> stream -> nbytes = 0 ; stream -> frames_out = 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) ; } # if CONFIG_FP_MB_STATS if ( stream -> config . fpmb_stats_fn ) { if ( ! stats_open_file ( & stream -> fpmb_stats , stream -> config . fpmb_stats_fn , pass ) ) fatal ( \"Failed to open mb statistics store\" ) ; } else { if ( ! stats_open_mem ( & stream -> fpmb_stats , pass ) ) fatal ( \"Failed to open mb statistics store\" ) ; } # endif <vul-start> ( pass ) { <vul-start> stats ) ; # if CONFIG_FP_MB_STATS stream -> config . cfg . rc_firstpass_mb_stats_in = stats_get ( & stream -> fpmb_stats ) ; # endif }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ; } if ( pass ) { <vul-start> : VPX_RC_ONE_PASS ; <vul-end> stream -> config <vul-start> stats ) ; }\n"
 },
 {
  "id": 528,
  "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 int xfs_attr3_leaf_flipflags ( struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf1 ; struct xfs_attr_leafblock * leaf2 ; struct xfs_attr_leaf_entry * entry1 ; struct xfs_attr_leaf_entry * entry2 ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_buf * bp1 ; struct xfs_buf * bp2 ; int error ; # ifdef DEBUG struct xfs_attr3_icleaf_hdr ichdr1 ; struct xfs_attr3_icleaf_hdr ichdr2 ; xfs_attr_leaf_name_local_t * name_loc ; int namelen1 , namelen2 ; char * name1 , * name2 ; # endif trace_xfs_attr_leaf_flipflags ( args ) ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp1 ) ; if ( error ) return error ; if ( args -> blkno2 != args -> blkno ) { error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno2 , - 1 , & bp2 ) ; if ( error ) return error ; } else { bp2 = bp1 ; } leaf1 = bp1 -> b_addr ; entry1 = & xfs_attr3_leaf_entryp ( leaf1 ) [ args -> index ] ; leaf2 = bp2 -> b_addr ; entry2 = & xfs_attr3_leaf_entryp ( leaf2 ) [ args -> index2 ] ; # ifdef DEBUG xfs_attr3_leaf_hdr_from_disk ( & ichdr1 , leaf1 ) ; ASSERT ( args -> index < ichdr1 . count ) ; ASSERT ( args -> index >= 0 ) ; xfs_attr3_leaf_hdr_from_disk ( & ichdr2 , leaf2 ) ; ASSERT ( args -> index2 < ichdr2 . count ) ; ASSERT ( args -> index2 >= 0 ) ; if ( entry1 -> flags & XFS_ATTR_LOCAL )",
  "golden_answers": [
   "CWE-19 Fixed Code Lines are: <vul-start> ( args -> rmtvaluelen <vul-end> ) ; xfs_trans_log_buf\n"
  ],
  "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> ( args -> rmtvaluelen <vul-end> ) ; xfs_trans_log_buf\n"
 },
 {
  "id": 529,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void read_intra_frame_mode_info ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <vul-start> int mi_row , int mi_col , vp9_reader * r ) { <vul-end> MODE_INFO * const mi = xd -> mi [ 0 ] ; MB_MODE_INFO * const mbmi = & mi -> mbmi ; <vul-start> const MODE_INFO * above_mi = xd -> mi [ - cm -> mi_stride ] ; <vul-end> <vul-start> const MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; <vul-end> const BLOCK_SIZE bsize = mbmi -> sb_type ; int i ; <vul-start> mbmi -> segment_id = read_intra_segment_id ( cm , xd , mi_row , mi_col , r ) ; <vul-end> mbmi -> skip = read_skip ( cm , xd , mbmi -> segment_id , r ) ; <vul-start> mbmi -> tx_size = read_tx_size ( cm , xd , cm -> tx_mode , bsize , 1 , r ) ; <vul-end> mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; switch ( bsize ) { case BLOCK_4X4 : for ( i = 0 ; i < 4 ; ++ i ) mi -> bmi [ i ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi , above_mi , left_mi , i ) ) ; mbmi -> mode = mi -> bmi [ 3 ] . as_mode ; break ; case BLOCK_4X8 : mi -> bmi [ 0 ] . as_mode = mi -> bmi [ 2 ] . as_mode = read_intra_mode ( r , get_y_mode_probs ( mi ,",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int mi_col , vpx_reader <vul-end> * r ) <vul-start> = xd -> above_mi <vul-end> ; const MODE_INFO <vul-start> = xd -> left_mi <vul-end> ; const BLOCK_SIZE <vul-start> int i ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ; <vul-start> ( cm , mi_offset , x_mis , y_mis <vul-end> , r ) <vul-start> cm , xd <vul-end> , 1 ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int mi_col, vpx_reader <vul-end> * r ) <vul-start> r ) { const BLOCK_SIZE bsize = mbmi -> sb_type ; <vul-start> const MODE_INFO * left_mi = xd -> left_available? xd -> mi [ - 1 ] : NULL ; const int above_mi_stride = xd -> above_mi_stride ; const MODE_INFO * <vul-start> above_mi = xd -> above_available <vul-end> ; const MODE_INFO <vul-start> const MODE_INFO * right_mi = xd -> left_available <vul-end> ; const BLOCK_SIZE <vul-start> int i ; if ( xd -> mbmi_ext. mbmi_ext_mode!= BLOCK_8X8 ) { fprintf ( stderr, \"Invalid intra mode %d\\\\n\", mbmi -> mbmi_ext. mbmi_ext_mode ) ; return ; } <vul-start>, xd, bsize, above_mi_stride <vul-end>, r ) <vul-start>, xd, left_mi_stride <vul-end>, r ) <vul-start> r ) ; if ( xd -> mbmi_ext. mbmi_ext. segment_id!= mbmi -> segment_id ) { fprintf ( stderr, \"Invalid intra mode %d\\\\n\", mbmi -> mbmi_ext. mbmi_ext. mbmi_ext_mode ) ; return ; } <vul-start>, bsize, 0 <vul-end>, r )\n"
 },
 {
  "id": 530,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 cJSON * cJSON_CreateFalse ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_False ; return item ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: \n"
 },
 {
  "id": 531,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; struct iovec iov ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return ERR_PTR ( - EINVAL ) ; } if ( ! nr_pages ) return ERR_PTR ( - EINVAL ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return ERR_PTR ( - ENOMEM ) ; ret = - ENOMEM ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; const int",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <vul-start> ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ;\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; if ( unlikely ( <vul-start> len <= 0 || bytes > PAGE_SIZE ) ) { ret = - EFAULT ; goto out_unmap ; } <vul-end> if ( bio_add_pc_page <vul-start> ) break ; if ( unlikely ( len < bytes ) ) { ret = - EFAULT ; goto out_unmap ; }\n"
 },
 {
  "id": 532,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , <vul-start> length ; <vul-end> ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic !=",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , extent , height , <vul-start> \"UnableToReadImageData\" ) ; <vul-end> height = sun_info <vul-start> \"MemoryAllocationFailed\" ) ; if ( sun_info . type == RT_ENCODED ) <vul-start> sun_data ) ; <vul-end> p = sun_pixels\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> extent, length, bytes_per_pixel <vul-start> PseudoClass ) { bytes_per_pixel = sun_info. width * sun_info. depth ; <vul-start> -> rows = bytes_per_pixel * sun_info. width <vul-end> ; if ( <vul-start> PseudoClass ) { bytes_per_pixel = sun_info. width * sun_info. depth ; <vul-start> -> columns = bytes_per_pixel * sun_info. width <vul-end> ; for ( <vul-start> ++ ) { if ( <vul-end> q == ( <vul-start> q ) ) break ; if ( SyncAuthenticPixels ( image, exception ) == MagickFalse ) break ; if ( SyncAuthenticPixels ( image, exception ) == MagickFalse ) break ; <vul-start> \"MemoryAllocationFailed\" ) ; } <vul-start> PseudoClass ) { bytes_per_pixel = sun_info. width * sun_info. depth ; <vul-start> -> rows = bytes_per_pixel * sun_info. width <vul-end> ; if ( <vul-start> == 0 ) { if ( <vul-start> \"MemoryAllocationFailed\" ) ; } <vul-start> p ++ ) { if ( <vul-start> q ) ; if ( SyncAuthenticPixels ( image, exception ) == MagickFalse ) break ; <vul-start> \"MemoryAllocationFailed\" ) ; } <vul-start> PseudoClass ) { if ( <vul-start> q ) ; if ( SyncAuthenticPixels ( image, exception ) == MagickFalse ) break ;\n"
 },
 {
  "id": 533,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int regset_tls_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void __user * ubuf ) { struct user_desc infobuf [ GDT_ENTRY_TLS_ENTRIES ] ; const struct user_desc * info ; <vul-start> if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || <vul-end> ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ; if ( kbuf ) info = kbuf ; else if ( __copy_from_user ( infobuf , ubuf , count ) ) return - EFAULT ; else info = infobuf ; <vul-start> set_tls_desc ( target , <vul-end> GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ; return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> * info ; int i ; <vul-start> = infobuf ; for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> * info ; unsigned int min_size = GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) ; unsigned int max_size = count / sizeof ( struct user_desc ) ; if ( pos < min_size || count < min_size ) return - EINVAL ; <vul-start> = infobuf ; if ( pos < max_size ) min_size = max_size ; <vul-start> ( target, min_size, <vul-end> info, count\n"
 },
 {
  "id": 534,
  "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 int xfs_attr_rmtval_set ( struct xfs_da_args * args ) { struct xfs_inode * dp = args -> dp ; struct xfs_mount * mp = dp -> i_mount ; struct xfs_bmbt_irec map ; xfs_dablk_t lblkno ; xfs_fileoff_t lfileoff = 0 ; __uint8_t * src = args -> value ; int blkcnt ; int valuelen ; int nmap ; int error ; int offset = 0 ; trace_xfs_attr_rmtval_set ( args ) ; <vul-start> blkcnt = xfs_attr3_rmt_blocks ( mp , args -> valuelen ) ; <vul-end> error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ; if ( error ) return error ; args -> rmtblkno = lblkno = ( xfs_dablk_t ) lfileoff ; args -> rmtblkcnt = blkcnt ; while ( blkcnt > 0 ) { int committed ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; nmap = 1 ; error = xfs_bmapi_write ( args -> trans , dp , ( xfs_fileoff_t ) lblkno , blkcnt , XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA , args -> firstblock , args -> total , & map , & nmap , args -> flist ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; ASSERT ( nmap == 1 )",
  "golden_answers": [
   "CWE-19 Fixed Code Lines are: <vul-start> , args -> rmtvaluelen <vul-end> ) ; error <vul-start> = args -> rmtvaluelen <vul-end> ; while (\n"
  ],
  "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> args -> valuelen ; if ( args -> rmtvaluelen == args -> valuelen ) return 0 <vul-start> -> rmtblkcnt ; if ( args -> rmtvaluelen == args -> valuelen ) return 0 ;\n"
 },
 {
  "id": 535,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; set_exception_intercept ( svm , MC_VECTOR ) ; <vul-start> set_exception_intercept ( svm , AC_VECTOR ) ; <vul-end> set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHUTDOWN ) ; set_intercept ( svm , INTERCEPT_VMRUN ) ; set_intercept ( svm , INTERCEPT_VMMCALL ) ; set_intercept ( svm , INTERCEPT_VMLOAD ) ; set_intercept ( svm , INTERCEPT_VMSAVE ) ; set_intercept ( svm",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> svm, AC_VECTOR ) ; set_exception_intercept ( svm, AC_VECTOR\n"
 },
 {
  "id": 536,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_dec -> ps_cur_slice -> u1_bottom_field_flag ; ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = u2_frame_num ; ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> i1_next_ctxt_idx = 0 ; ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores == 1 ) ps_dec -> u4_nmb_deblk = 1 ; if ( ps_seq -> u1_mb_aff_flag == 1 ) { ps_dec -> u4_nmb_deblk = 0 ; if ( ps_dec -> u4_num_cores > 2 ) ps_dec -> u4_num_cores = 2 ; } ps_dec -> u4_use_intrapred_line_copy = 0 ; if ( ps_seq -> u1_mb_aff_flag == 0 ) { ps_dec -> u4_use_intrapred_line_copy = 1 ; } ps_dec -> u4_app_disable_deblk_frm = 0 ; if (",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = 0 ; ps_dec -> u4_first_slice_in_pic = 0 ;\n"
 },
 {
  "id": 537,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( \"usage: condump <filename>\\\\n\" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; <vul-start> COM_DefaultExtension ( filename , sizeof ( filename ) , \".txt\" ) ; <vul-end> f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( \"ERROR: couldn\\'t open %s.\\\\n\" , filename ) ; return ; } Com_Printf ( \"Dumped console text to %s.\\\\n\" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != ' ' ) { break ; } if ( x != con . linewidth ) { break ; } } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> \".txt\" ) ; if ( ! COM_CompareExtension ( filename , \".txt\" ) ) { Com_Printf ( \"Con_Dump_f: Only the \\\\\".txt\\\\\" extension is supported by this command!\\\\n\" ) ; return ; }\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> \".txt\" ) ; if (! COM_CompareExtension ( filename, \".txt\" ) ) { Com_Printf ( \"Con_Dump_f: Only the \\\\\".txt\\\\\" extension is supported by this command!\\\\n\" ) ; return ; }\n"
 },
 {
  "id": 538,
  "question": "CWE-89 Code Input Vulnerable Code Is: CWE-89 char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ; <vul-start> int strindex = 0 ; <vul-end> size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , \"%%%02X\" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }",
  "golden_answers": [
   "CWE-89 Fixed Code Lines are: <vul-start> = alloc ; size_t <vul-end> strindex = 0\n"
  ],
  "generated_answer": "CWE-89 Fixed Code Lines are: <vul-start> = alloc ; size_t <vul-end> strindex = 0\n"
 },
 {
  "id": 539,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static bool states_equal ( struct bpf_verifier_env * env , struct bpf_verifier_state * old , struct bpf_verifier_state * cur ) { int i ; <vul-start> if ( old -> curframe != cur -> curframe ) <vul-end> return false ; for ( i = 0 ; i <= old -> curframe ; i ++ ) { if ( old -> frame [ i ] -> callsite != cur -> frame [ i ] -> callsite ) return false ; if ( ! func_states_equal ( old -> frame [ i ] , cur -> frame [ i ] ) ) return false ; } return true ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> cur -> curframe ) return false ; if ( old -> speculative && ! cur -> speculative\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ; if (! env_states_equal ( env, old, cur ) <vul-end> ) return false\n"
 },
 {
  "id": 540,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MagickPathExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; pwp_image = AcquireImage ( image_info , exception ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , \"SFW95\" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> read_info ) ; <vul-end> if ( EOFBlob\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> read_info ) ; <vul-end> if ( EOFBlob\n"
 },
 {
  "id": 541,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void sas_scsi_clear_queue_lu ( struct list_head * error_q , struct scsi_cmnd * my_cmd ) { struct scsi_cmnd * cmd , * n ; list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) <vul-start> sas_eh_defer_cmd ( cmd ) ; <vul-end> } }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> -> lun ) sas_eh_finish_cmd <vul-end> ( cmd )\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> -> lun ) sas_eh_finish_cmd <vul-end> ( cmd )\n"
 },
 {
  "id": 542,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 SPL_METHOD ( SplObjectStorage , unserialize ) { spl_SplObjectStorage * intern = Z_SPLOBJSTORAGE_P ( getThis ( ) ) ; char * buf ; size_t buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval entry , inf ; zval * pcount , * pmembers ; spl_SplObjectStorageElement * element ; zend_long count ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , \"s\" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pcount = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) { goto outexcept ; } -- p ; <vul-start> count = Z_LVAL_P ( pcount ) ; <vul-end> while ( count -- > 0 ) { spl_SplObjectStorageElement * pelement ; zend_string * hash ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) { goto outexcept ; } <vul-start> if ( Z_TYPE ( entry ) != IS_OBJECT ) {",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> Z_LVAL_P ( pcount ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <vul-start> } if ( <vul-end> * p == <vul-start> ; } } if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <vul-end> ; } hash\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; count = Z_LVAL <vul-end> ( pcount ) <vul-start> } else { if ( Z_TYPE ( entry )!= IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; goto outexcept ; }\n"
 },
 {
  "id": 543,
  "question": "CWE-74 Code Input Vulnerable Code Is: CWE-74 static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( \"export-desktop-XXXXXX\" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , \".service\" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree",
  "golden_answers": [
   "CWE-74 Fixed Code Lines are: <vul-start> ) ; else if ( strcmp ( arg , \"@@\" ) == 0 || strcmp ( arg , \"@@u\" ) == 0 ) g_print ( _ ( \"Skipping invalid Exec argument %s\\\\n\" ) , arg ) ; else\n"
  ],
  "generated_answer": "CWE-74 Fixed Code Lines are: <vul-start> arg ) ; else if ( g_str_has_prefix ( arg, \".desktop.\" ) ) { g_string_append_printf ( new_exec, \" %s @@desktop %s @@desktop\", arg ) ; } else { <vul-end> g_string_append_printf ( new_exec <vul-start> arg ) ; }\n"
 },
 {
  "id": 544,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static const uint8_t * decode_tiles ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) { <vul-start> VP9_COMMON * const cm = & pbi -> common ; <vul-end> const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; TileBuffer tile_buffers [ 4 ] [ 1 << 6 ] ; int tile_row , tile_col ; <vul-start> const uint8_t * end = NULL ; <vul-end> <vul-start> vp9_reader r ; <vul-end> assert ( tile_rows <= 4 ) ; assert ( tile_cols <= ( 1 << 6 ) ) ; <vul-start> vpx_memset ( cm -> above_context , 0 , <vul-end> sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ; <vul-start> vpx_memset ( cm -> above_seg_context , 0 , <vul-end> <vul-start> sizeof ( * cm -> above_seg_context ) * aligned_cols ) ; <vul-end> for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { <vul-start> const int last_tile = tile_row == tile_rows - 1 && <vul-end> tile_col == tile_cols - 1 ; const size_t size = get_tile ( data_end , last_tile , & cm -> error , & data ) ; TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; buf -> data = data ; buf -> size = size ; data += size ; } } for ( tile_row = 0 ; tile_row <",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> pbi -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <vul-start> , tile_col ; int mi_row , mi_col ; TileData * tile_data <vul-end> = NULL ; <vul-start> = NULL ; if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && pbi -> lf_worker . data1 == NULL ) { CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; pbi -> lf_worker . hook = ( VPxWorkerHook ) vp9_loop_filter_worker ; if ( pbi -> max_threads > 1 && ! winterface -> reset ( & pbi -> lf_worker ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , \"Loop filter thread creation failed\" ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , pbi -> mb . plane ) ; } <vul-end> assert ( tile_rows <vul-start> ) ) ; memset <vul-end> ( cm -> <vul-start> aligned_cols ) ; memset <vul-end> ( cm -> <vul-start> aligned_cols ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; if ( pbi -> tile_data == NULL || ( tile_cols * tile_rows ) != pbi -> total_tiles ) { vpx_free ( pbi -> tile_data ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_data , vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ; pbi -> total_tiles = tile_rows * tile_cols ; } <vul-start> ) { const TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? NULL : & cm -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { TileInfo tile ; vp9_tile_set_row ( & tile , cm , tile_row ) ; for ( mi_row = tile . mi_row_start ; mi_row < tile . mi_row_end ; mi_row += MI_BLOCK_SIZE ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; tile_data = pbi -> tile_data + tile_cols * tile_row + col ; vp9_tile_set_col ( & tile , tile_data -> cm , col ) ; vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; mi_col += MI_BLOCK_SIZE ) { decode_partition ( pbi , & tile_data -> xd , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ; } pbi -> mb . corrupted |= tile_data -> xd . corrupted ; if ( pbi -> mb . corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , \"Failed to decode tile data\" ) ; } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { const int lf_start = mi_row - MI_BLOCK_SIZE ; LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; if ( lf_start < 0 ) continue ; if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_start ; lf_data -> stop = mi_row ; if ( pbi -> max_threads > 1 ) { winterface -> launch ( & pbi -> lf_worker ) ; } else { winterface -> execute ( & pbi -> lf_worker ) ; } } if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , mi_row << MI_BLOCK_SIZE_LOG2 ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_data -> stop ; lf_data -> stop = cm -> mi_rows ; winterface -> execute ( & pbi -> lf_worker ) ; } tile_data = pbi -> tile_data + tile_cols * <vul-end> tile_rows - 1 <vul-start> tile_rows - 1 ; if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ; return vpx_reader_find_end ( & tile_data -> bit_reader ) <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> data_end ) { const VP9EncoderConfig * oxcf = & pbi -> oxcf ; <vul-start>, tile_col ; vpx_reader r ; <vul-start> = NULL ; <vul-end> assert ( tile_rows <vul-start> ) ) ; memset <vul-end> ( cm -> <vul-start> aligned_cols ) ; memset <vul-end> ( cm -> <vul-start> last_tile = tile_row!= 0 && tile_col!= 0 <vul-end> ; const size_t\n"
 },
 {
  "id": 545,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <vul-start> unsigned long tpgt ; <vul-end> int ret ; if ( strstr ( name , \"tpgt_\" ) != name ) return ERR_PTR ( - EINVAL ) ; <vul-start> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <vul-end> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( \"Unable to allocate struct vhost_scsi_tpg\" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * tpg ; u16 <vul-end> tpgt ; int <vul-start> ; if ( kstrtou16 <vul-end> ( name + <vul-start> ) || tpgt >= VHOST_SCSI_MAX_TARGET <vul-end> ) return ERR_PTR\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> unsigned long tpgt = 0 <vul-start> ; if ( kstrtoull <vul-end> ( name +\n"
 },
 {
  "id": 546,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; <vul-start> context . Xtogo = i -> width ; <vul-end> context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY *",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , \"*** ERROR *** Image bigger than global GIF canvas !\\\\n\" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , \"*** WARNING *** Adjusting X position\\\\n\" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , \"*** WARNING *** Adjusting Y position\\\\n\" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> parent ) ; if ( i -> width > 0 && i -> height > 0 ) { i -> parent -> width = GetWord ( i -> parent ) ; i -> parent -> height = GetWord ( i -> parent ) ; }\n"
 },
 {
  "id": 547,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vpx_free ( void * memblk ) { if ( memblk ) { void * addr = ( void * ) ( ( ( size_t * ) memblk ) [ - 1 ] ) ; <vul-start> # if CONFIG_MEM_MANAGER <vul-end> hmm_free ( & hmm_d , addr ) ; # else VPX_FREE_L ( addr ) ; <vul-start> # endif <vul-end> } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ] ) ; free <vul-end> ( addr ) <vul-start> addr ) ; <vul-end> } }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ] ) ; if ( addr ) { <vul-start> addr ) ; } <vul-end> } }  \n"
 },
 {
  "id": 548,
  "question": "CWE-345 Code Input Vulnerable Code Is: CWE-345 static <vul-start> void headerMergeLegacySigs ( Header h , Header sigh ) <vul-end> { HeaderIterator hi ; struct rpmtd_s td ; <vul-start> hi = headerInitIterator ( sigh ) ; <vul-end> for ( ; headerNext ( hi , & td ) ; rpmtdFreeData ( & td ) ) { switch ( td . tag ) { case RPMSIGTAG_SIZE : <vul-start> td . tag = RPMTAG_SIGSIZE ; <vul-end> break ; case RPMSIGTAG_PGP : <vul-start> td . tag = RPMTAG_SIGPGP ; <vul-end> break ; case RPMSIGTAG_MD5 : td . tag = RPMTAG_SIGMD5 ; break ; case RPMSIGTAG_GPG : td . tag = RPMTAG_SIGGPG ; break ; case RPMSIGTAG_PGP5 : td . tag = RPMTAG_SIGPGP5 ; break ; case RPMSIGTAG_PAYLOADSIZE : td . tag = RPMTAG_ARCHIVESIZE ; break ; case RPMSIGTAG_FILESIGNATURES : td . tag = RPMTAG_FILESIGNATURES ; break ; case RPMSIGTAG_FILESIGNATURELENGTH : td . tag = RPMTAG_FILESIGNATURELENGTH ; break ; case RPMSIGTAG_VERITYSIGNATURES : case RPMSIGTAG_VERITYSIGNATUREALGO : case RPMSIGTAG_SHA1 : case RPMSIGTAG_SHA256 : case RPMSIGTAG_DSA : case RPMSIGTAG_RSA : default : <vul-start> if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) <vul-end> continue ; break ; } <vul-start> if ( ! headerIsEntry ( h , td . tag ) ) { <vul-end> switch ( td . type ) { case RPM_NULL_TYPE : continue ; break ; case RPM_CHAR_TYPE : case RPM_INT8_TYPE : case RPM_INT16_TYPE : case RPM_INT32_TYPE : case RPM_INT64_TYPE : if ( td . count != 1 ) continue ; break ; case RPM_STRING_TYPE : case RPM_STRING_ARRAY_TYPE : case RPM_BIN_TYPE : if ( td . count >= 16 * 1024 )",
  "golden_answers": [
   "CWE-345 Fixed Code Lines are: <vul-start>     static rpmTagVal <vul-end> headerMergeLegacySigs ( Header <vul-start> , Header sigh , char * * msg ) { const struct taglate_s * xl <vul-end> ; struct rpmtd_s <vul-start> rpmtd_s td ; rpmtdReset ( & td ) ; for ( xl = xlateTags ; xl -> stag ; xl ++ ) { if ( headerIsEntry ( h , xl -> xtag ) ) break ; if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) { if ( xl -> stag != xl -> xtag ) <vul-end> td . tag <vul-start> . tag = xl -> xtag ; if ( td . type != rpmTagGetTagType ( <vul-end> td . tag <vul-start> td . tag ) ) break ; if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ; if ( xl -> count && td . count != xl -> count ) break ; <vul-end> if ( ! <vul-start> if ( ! headerPut <vul-end> ( h , <vul-start> ( h , <vul-end> & td , <vul-start> , HEADERPUT_DEFAULT ) ) break ; rpmtdFreeData ( & td ) ; } } rpmtdFreeData ( & td ) ; if ( xl -> stag ) { rasprintf ( msg , \"invalid signature tag %s (%d)\" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ; } return xl -> stag <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-345 Fixed Code Lines are: <vul-start> void headerMergeLegacySigs ( ThreadData * td, <vul-start> rpmtd_s td ; int is_keyframe ; <vul-start> case RPMSIGTAG_SIZE : if ( td. count!= 1 ) continue ; <vul-start> tag = RPMTAG_SIGSIZE ; break ; case RPMSIGTAG_MD5 : td. tag = RPMTAG_MD5 <vul-start> : if ( td. tag < HEADER_TAGBASE && <vul-start>. tag >= RPMTAG_SIGBASE <vul-end> ) continue ; <vul-start> } if ( is_keyframe ) { if ( <vul-start> break ; } } <vul-start> & td, td. tag == HEADER_TAGBASE? HEADERPUT_DEFAULT : HEADERPUT_NONE <vul-end> ) ; }\n"
 },
 {
  "id": 549,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) { <vul-end> <vul-start> VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ; <vul-end> <vul-start> VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ; <vul-end> if ( ! cm ) return NULL ; vp9_zero ( * pbi ) ; if ( setjmp ( cm -> error . jmp ) ) { cm -> error . setjmp = 0 ; vp9_decoder_remove ( pbi ) ; return NULL ; } cm -> error . setjmp = 1 ; <vul-start> vp9_initialize_dec ( ) ; <vul-end> vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; <vul-start> cm -> current_video_frame = 0 ; <vul-end> <vul-start> pbi -> oxcf = * oxcf ; <vul-end> pbi -> ready_for_new_data = 1 ; <vul-start> pbi -> decoded_key_frame = 0 ; <vul-end> <vul-start> vp9_init_dequantizer ( cm ) ; <vul-end> vp9_loop_filter_init ( cm ) ; cm -> error . setjmp = 0 ; vp9_worker_init ( & pbi -> lf_worker ) ; return pbi ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * vp9_decoder_create ( BufferPool * const pool <vul-end> ) { VP9Decoder <vul-start> { VP9Decoder * volatile <vul-start> ; VP9_COMMON * volatile <vul-start> = 1 ; CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ; CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ; pbi -> need_resync = 1 ; once ( initialize_dec ) ; memset <vul-end> ( & cm <vul-start> ) ) ; memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ; <vul-start> ; pbi -> <vul-end> ready_for_new_data = 1 <vul-start> ; pbi -> common . buffer_pool = pool ; cm -> bit_depth = VPX_BITS_8 ; cm -> dequant_bit_depth = VPX_BITS_8 ; cm -> alloc_mi = vp9_dec_alloc_mi ; cm -> free_mi = vp9_dec_free_mi ; cm -> setup_mi = vp9_dec_setup_mi ; vp9_loop_filter_init ( cm ) ; cm -> error . setjmp <vul-end> = 0 ; <vul-start> = 0 ; vpx_get_worker_interface ( ) -> init <vul-end> ( & pbi\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vp9_decoder_create ( const VP9DecoderConfig <vul-end> * oxcf ) <vul-start> oxcf ) { VP9DecoderConfig * const oxcf_copy = vp9_config_copy ( oxcf ) ; VP9Decoder * const pbi = vpx_memalign ( oxcf_copy -> size <vul-end>, sizeof ( <vul-start> ) ) ; const <vul-start> = 1 ; vpx_rtcd ( ) ; if ( setjmp ( oxcf_copy -> error. jmp ) ) { oxcf_copy -> error. setjmp = 0 ; vp9_decoder_remove ( oxcf ) ; return NULL ; } vpx_memset ( <vul-end> & cm -> <vul-start> ) ) ; vp9_init_dequantizer ( cm ) ; vp9_loop_filter_init ( cm ) ; <vul-start> = 0 ; <vul-end> return pbi ;\n"
 },
 {
  "id": 550,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static cupsd_job_t * add_job ( cupsd_client_t * con , cupsd_printer_t * printer , mime_type_t * filetype ) { http_status_t status ; ipp_attribute_t * attr , * auth_info ; const char * mandatory ; const char * val ; int priority ; cupsd_job_t * job ; char job_uri [ HTTP_MAX_URI ] ; int kbytes ; int i ; int lowerpagerange ; int exact ; ipp_attribute_t * media_col , * media_margin ; ipp_t * unsup_col ; static const char * const readonly [ ] = { \"date-time-at-completed\" , \"date-time-at-creation\" , \"date-time-at-processing\" , \"job-detailed-status-messages\" , \"job-document-access-errors\" , \"job-id\" , \"job-impressions-completed\" , \"job-k-octets-completed\" , \"job-media-sheets-completed\" , \"job-pages-completed\" , \"job-printer-up-time\" , \"job-printer-uri\" , \"job-state\" , \"job-state-message\" , \"job-state-reasons\" , \"job-uri\" , \"number-of-documents\" , \"number-of-intervening-jobs\" , \"output-device-assigned\" , \"time-at-completed\" , \"time-at-creation\" , \"time-at-processing\" } ; cupsdLogMessage ( CUPSD_LOG_DEBUG2 , \"add_job(%p[%d], %p(%s), %p(%s/%s))\" , con , con -> number , printer , printer -> name , filetype , filetype ? filetype -> super : \"none\" , filetype ? filetype -> type : \"none\" ) ; if ( ! printer -> shared && _cups_strcasecmp ( con -> http -> hostname , \"localhost\" ) && _cups_strcasecmp ( con -> http -> hostname , ServerName ) ) { send_ipp_status ( con , IPP_NOT_AUTHORIZED , _ ( \"The printer or class is not shared.\" ) ) ; return ( NULL ) ; } auth_info = ippFindAttribute ( con -> request , \"auth-info\" , IPP_TAG_TEXT ) ; if ( ( status = cupsdCheckPolicy ( printer -> op_policy_ptr , con , NULL ) ) != HTTP_OK ) { send_http_error ( con , status , printer ) ; return",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ) ; } attr = ippFindAttribute ( con -> request , \"requesting-user-name\" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( \"Bad requesting-user-name value: %s\" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <vul-start> printer , job <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) ; } con -> job_context -> remote_addr = NULL ; <vul-start> ) ; } con -> job_context -> remote_addr = NULL ;\n"
 },
 {
  "id": 551,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 int xmlPushInput ( xmlParserCtxtPtr ctxt , xmlParserInputPtr input ) { int ret ; if ( input == NULL ) return ( - 1 ) ; if ( xmlParserDebugEntities ) { if ( ( ctxt -> input != NULL ) && ( ctxt -> input -> filename ) ) xmlGenericError ( xmlGenericErrorContext , \"%s(%d): \" , ctxt -> input -> filename , ctxt -> input -> line ) ; xmlGenericError ( xmlGenericErrorContext , <vul-start> \"Pushing input %d : %.30s\\\\n\" , ctxt -> inputNr + 1 , input -> cur ) ; <vul-end> } ret = inputPush ( ctxt , input ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( - 1 ) ; GROW ; return ( ret ) ; }",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> input -> cur ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1\n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> ( xmlGenericErrorContext, \"Pushing input %d : %.30s%d\\\\n\" <vul-end>, ctxt -> <vul-start> input -> cur, ctxt -> inputNr + 1\n"
 },
 {
  "id": 552,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 rfbBool InitialiseRFBConnection ( rfbClient * client ) { rfbProtocolVersionMsg pv ; int major , minor ; uint32_t authScheme ; uint32_t subAuthScheme ; rfbClientInitMsg ci ; if ( client -> listenSpecified ) errorMessageOnReadFailure = FALSE ; if ( ! ReadFromRFBServer ( client , pv , sz_rfbProtocolVersionMsg ) ) return FALSE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; errorMessageOnReadFailure = TRUE ; pv [ sz_rfbProtocolVersionMsg ] = 0 ; if ( sscanf ( pv , rfbProtocolVersionFormat , & major , & minor ) != 2 ) { rfbClientLog ( \"Not a valid VNC server (%s)\\\\n\" , pv ) ; return FALSE ; } DefaultSupportedMessages ( client ) ; client -> major = major ; client -> minor = minor ; if ( ( major == rfbProtocolMajorVersion ) && ( minor > rfbProtocolMinorVersion ) ) client -> minor = rfbProtocolMinorVersion ; if ( major == 3 && ( minor == 4 || minor == 6 ) ) { rfbClientLog ( \"UltraVNC server detected, enabling UltraVNC specific messages\\\\n\" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && ( minor == 14 || minor == 16 ) ) { minor = minor - 10 ; client -> minor = minor ; rfbClientLog ( \"UltraVNC Single Click server detected, enabling UltraVNC specific messages\\\\n\" , pv ) ; DefaultSupportedMessagesUltraVNC ( client ) ; } if ( major == 3 && minor == 5 ) { rfbClientLog ( \"TightVNC server detected, enabling TightVNC specific messages\\\\n\" , pv ) ; DefaultSupportedMessagesTightVNC ( client ) ; } if ( ( major == 3 && minor > 8",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> nameLength ) ; if ( client -> si . nameLength > 1 << 20 ) { rfbClientErr ( \"Too big desktop name length sent by server: %u B > 1 MB\\\\n\" , ( unsigned int ) client -> si . nameLength ) ; return FALSE ; } <vul-start> = malloc ( <vul-end> client -> si\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> -> desktopName = calloc ( 1, <vul-end> ( uint64_t )\n"
 },
 {
  "id": 553,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ; <vul-start> size_t <vul-end> value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } <vul-start> value = ( size_t ) ( buffer [ 0 ] << 24 ) ; <vul-end> <vul-start> value |= buffer [ 1 ] << 16 ; <vul-end> <vul-start> value |= buffer [ 2 ] << 8 ; <vul-end> <vul-start> value |= buffer [ 3 ] ; <vul-end> <vul-start> quantum . unsigned_value = ( value & 0xffffffff ) ; <vul-end> return ( quantum . signed_value ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> 4 ] ; unsigned int <vul-end> value ; if <vul-start> value = ( unsigned int ) <vul-end> buffer [ 0 <vul-start> ] << 24 <vul-end> ; value |= <vul-start> ; value |= ( unsigned int ) <vul-start> ; value |= ( unsigned int ) <vul-start> ; value |= ( unsigned int ) <vul-start> . unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ] ; size_t val <vul-end> ; if ( <vul-start> c ; } val <vul-end> = ( size_t <vul-start> 24 ) ; val <vul-end> |= buffer [ <vul-start> << 16 ; val <vul-end> |= buffer [ <vul-start> << 8 ; val <vul-end> |= buffer [ <vul-start>. unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return (\n"
 },
 {
  "id": 554,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , \"(pad1)\" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , \"(padn: trunc)\" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , \"(padn)\" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , \"(refresh: trunc)\" ) ) ; goto trunc ; } <vul-start> ND_PRINT ( ( ndo , \"(refresh: %u)\" , <vul-end> EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , \"(altcoa: trunc)\" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , \"(alt-CoA: %s)\" , ip6addr_string",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;\n"
 },
 {
  "id": 555,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int ext4_orphan_add ( handle_t * handle , struct inode * inode ) { struct super_block * sb = inode -> i_sb ; struct ext4_iloc iloc ; int err = 0 , rc ; <vul-start> if ( ! ext4_handle_valid ( handle ) ) <vul-end> return 0 ; mutex_lock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; if ( ! list_empty ( & EXT4_I ( inode ) -> i_orphan ) ) goto out_unlock ; J_ASSERT ( ( S_ISREG ( inode -> i_mode ) || S_ISDIR ( inode -> i_mode ) || S_ISLNK ( inode -> i_mode ) ) || inode -> i_nlink == 0 ) ; BUFFER_TRACE ( EXT4_SB ( sb ) -> s_sbh , \"get_write_access\" ) ; err = ext4_journal_get_write_access ( handle , EXT4_SB ( sb ) -> s_sbh ) ; if ( err ) goto out_unlock ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_unlock ; if ( NEXT_ORPHAN ( inode ) && NEXT_ORPHAN ( inode ) <= ( le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_inodes_count ) ) ) goto mem_insert ; NEXT_ORPHAN ( inode ) = le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_last_orphan ) ; EXT4_SB ( sb ) -> s_es -> s_last_orphan = cpu_to_le32 ( inode -> i_ino ) ; err = ext4_handle_dirty_super ( handle , sb ) ; rc = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; if ( ! err ) err = rc ; mem_insert : if ( ! err ) list_add ( & EXT4_I ( inode ) ->",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> if ( ! EXT4_SB ( sb ) -> s_journal <vul-end> ) return 0\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( handle ) ||! ext4_should_dioread_nolock ( inode )\n"
 },
 {
  "id": 556,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static ssize_t fuse_fill_write_pages ( struct fuse_req * req , struct address_space * mapping , struct iov_iter * ii , loff_t pos ) { struct fuse_conn * fc = get_fuse_conn ( mapping -> host ) ; unsigned offset = pos & ( PAGE_CACHE_SIZE - 1 ) ; size_t count = 0 ; int err ; req -> in . argpages = 1 ; req -> page_descs [ 0 ] . offset = offset ; do { size_t tmp ; struct page * page ; pgoff_t index = pos >> PAGE_CACHE_SHIFT ; size_t bytes = min_t ( size_t , PAGE_CACHE_SIZE - offset , iov_iter_count ( ii ) ) ; bytes = min_t ( size_t , bytes , fc -> max_write - count ) ; again : err = - EFAULT ; if ( iov_iter_fault_in_readable ( ii , bytes ) ) break ; err = - ENOMEM ; page = grab_cache_page_write_begin ( mapping , index , 0 ) ; if ( ! page ) break ; if ( mapping_writably_mapped ( mapping ) ) flush_dcache_page ( page ) ; tmp = iov_iter_copy_from_user_atomic ( page , ii , offset , bytes ) ; <vul-start> flush_dcache_page ( page ) ; <vul-end> if ( ! tmp ) { unlock_page ( page ) ; page_cache_release ( page ) ; bytes = min ( bytes , iov_iter_single_seg_count ( ii ) ) ; goto again ; } err = 0 ; req -> pages [ req -> num_pages ] = page ; req -> page_descs [ req -> num_pages ] . length = tmp ; req -> num_pages ++ ; <vul-start> iov_iter_advance ( ii ,",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> flush_dcache_page ( page ) ; iov_iter_advance ( ii , tmp <vul-start> num_pages ++ ; <vul-end> count += tmp\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> bytes ) ; <vul-end> if (! <vul-start> num_pages ++ ; if (! iov_iter_is_iovec ( page ) ) flush_dcache_page ( page ) ;\n"
 },
 {
  "id": 557,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { \"invalid\" , \"rsasig\" , \"shared-secret\" , \"dsssig\" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <vul-start> ND_TCHECK ( * ext ) ; <vul-end> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , \" len=%u method=%s\" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , \" authdata=(\" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , \") \" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , \" [|%s]\"",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <vul-end> ) ; UNALIGNED_MEMCPY\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ND_TCHECK ( * authdata <vul-end> ) ; UNALIGNED_MEMCPY\n"
 },
 {
  "id": 558,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 SYSCALL_DEFINE2 ( osf_getdomainname , char __user * , name , int , namelen ) { unsigned len ; int i ; if ( ! access_ok ( VERIFY_WRITE , name , namelen ) ) return - EFAULT ; len = namelen ; <vul-start> if ( namelen > 32 ) <vul-end> len = 32 ; down_read ( & uts_sem ) ; for ( i = 0 ; i < len ; ++ i ) { __put_user ( utsname ( ) -> domainname [ i ] , name + i ) ; if ( utsname ( ) -> domainname [ i ] == '\\\\0' ) break ; } up_read ( & uts_sem ) ; return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ; if ( len <vul-end> > 32 )\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; if ( len > MAX_DOMAIN_NAME_LEN <vul-end> ) len =\n"
 },
 {
  "id": 559,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int dcbnl_getperm_hwaddr ( struct net_device * netdev , struct nlmsghdr * nlh , u32 seq , struct nlattr * * tb , struct sk_buff * skb ) { u8 perm_addr [ MAX_ADDR_LEN ] ; if ( ! netdev -> dcbnl_ops -> getpermhwaddr ) return - EOPNOTSUPP ; <vul-start> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <vul-end> return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> - EOPNOTSUPP ; memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> netdev, perm_addr, sizeof ( perm_addr )\n"
 },
 {
  "id": 560,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) { <vul-start> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso file] Missing dref box in dinf\\\\n\" ) ) ; <vul-end> <vul-start> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <vul-end> } return GF_OK ; }",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> dref ) { GF_Box * dref ; <vul-start> ( \"[iso file] Missing dref box in dinf\\\\n\" ) ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <vul-start> GF_DataReferenceBox * ) dref ; gf_isom_box_add_for_dump_mode ( s , dref <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> dref ) { GF_ISOM_BOX_TYPE_DREF box_type = GF_ISOM_BOX_TYPE_DREF ; <vul-start> ) gf_isom_box_new ( box_type <vul-end> ) ; }\n"
 },
 {
  "id": 561,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static void setup_connection ( GsmXSMPClient * client ) { GIOChannel * channel ; int fd ; g_debug ( \"GsmXSMPClient: Setting up new connection\" ) ; fd = IceConnectionNumber ( client -> priv -> ice_connection ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; channel = g_io_channel_unix_new ( fd ) ; client -> priv -> watch_id = g_io_add_watch ( channel , G_IO_IN | G_IO_ERR , ( GIOFunc ) client_iochannel_watch , client ) ; g_io_channel_unref ( channel ) ; <vul-start> client -> priv -> protocol_timeout = g_timeout_add_seconds ( 5 , <vul-end> ( GSourceFunc ) _client_protocol_timeout , client ) ; set_description ( client ) ; g_debug ( \"GsmXSMPClient: New client \\'%s\\'\" , client -> priv -> description ) ; }",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> channel ) ; <vul-end> set_description ( client\n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> channel ) ; <vul-end> set_description ( client\n"
 },
 {
  "id": 562,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int mount_entry_on_absolute_rootfs ( struct mntent * mntent , const struct lxc_rootfs * rootfs , const char * lxc_name ) { char * aux ; char path [ MAXPATHLEN ] ; int r , ret = 0 , offset ; const char * lxcpath ; lxcpath = lxc_global_config_value ( \"lxc.lxcpath\" ) ; if ( ! lxcpath ) { ERROR ( \"Out of memory\" ) ; return - 1 ; } r = snprintf ( path , MAXPATHLEN , \"%s/%s/rootfs\" , lxcpath , lxc_name ) ; if ( r < 0 || r >= MAXPATHLEN ) goto skipvarlib ; aux = strstr ( mntent -> mnt_dir , path ) ; if ( aux ) { offset = strlen ( path ) ; goto skipabs ; } skipvarlib : aux = strstr ( mntent -> mnt_dir , rootfs -> path ) ; if ( ! aux ) { WARN ( \"ignoring mount point \\'%s\\'\" , mntent -> mnt_dir ) ; return ret ; } offset = strlen ( rootfs -> path ) ; skipabs : r = snprintf ( path , MAXPATHLEN , \"%s/%s\" , rootfs -> mount , aux + offset ) ; if ( r < 0 || r >= MAXPATHLEN ) { WARN ( \"pathnme too long for \\'%s\\'\" , mntent -> mnt_dir ) ; return - 1 ; } <vul-start> return mount_entry_on_generic ( mntent , path ) ; <vul-end> }",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> mntent , path , rootfs -> mount\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> mntent, path, rootfs\n"
 },
 {
  "id": 563,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int Downmix_Command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { downmix_module_t * pDwmModule = ( downmix_module_t * ) self ; downmix_object_t * pDownmixer ; int retsize ; if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) { return - EINVAL ; } pDownmixer = ( downmix_object_t * ) & pDwmModule -> context ; ALOGV ( \"Downmix_Command command %\" PRIu32 \" cmdSize %\" PRIu32 , cmdCode , cmdSize ) ; switch ( cmdCode ) { case EFFECT_CMD_INIT : <vul-start> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <vul-end> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) <vul-start> || pReplyData == NULL || * replySize != sizeof ( int ) ) { <vul-end> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule , ( effect_config_t * ) pCmdData , false ) ; break ; case EFFECT_CMD_RESET : Downmix_Reset ( pDownmixer , false ) ; break ; case EFFECT_CMD_GET_PARAM : ALOGV ( \"Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %\" PRIu32 \", pReplyData: %p\" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || <vul-start> pReplyData == NULL || <vul-end> * replySize < ( int ) sizeof (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> == NULL || replySize == NULL || <vul-start> ) || pReplyData == NULL || replySize <vul-start> ) || pReplyData == NULL || replySize <vul-start> == NULL || replySize == NULL || <vul-start> == NULL || replySize == NULL || <vul-start> if ( pReplyData == NULL || replySize\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> : if (! pCmdData ||! replySize || ( int ) * replySize < sizeof ( int ) ) { android_errorWriteLog ( 0x534e4554, \"63662938\" ) ; return - EINVAL ; } if ( <vul-start> effect_config_t ) ||! pReplyData || ( int ) * replySize < <vul-end> sizeof ( int <vul-start> ) ) ||! pReplyData || ( int ) * replySize < <vul-end> ( int ) <vul-start> ( int ) sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554, \"63662938\" ) ; return - EINVAL ; } if ( pCmdData -> psize!= * replySize - sizeof ( int32_t ) || ( int ) * replySize < <vul-end> ( int ) <vul-start> ) ) ||! pReplyData || ( int ) * replySize < <vul-end> ( int )\n"
 },
 {
  "id": 564,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int pfkey_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * skb ; int copied , err ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT ) ) goto out ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; err = ( flags & MSG_TRUNC ) ? skb -> len : copied ; if ( pfk -> dump . dump != NULL && 3 * atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf ) pfkey_do_dump ( pfk ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> goto out ; <vul-end> skb = skb_recv_datagram\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> goto out ; <vul-end> skb = skb_recv_datagram\n"
 },
 {
  "id": 565,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; <vul-start> if ( debug ) { <vul-end> printk ( KERN_INFO \"cx24116: %s(\" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO \"0x%02x\" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO \", \" ) ; } printk ( \") toneburst=%d\\\\n\" , toneburst ) ; } <vul-start> if ( d -> msg_len > ( CX24116_ARGLEN - CX24116_DISEQC_MSGOFS ) ) <vul-end> return - EINVAL ; for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( \"%s burst=%d\\\\n\" , __func__",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <vul-start> ) ; } <vul-end> for ( i\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, ret ; u32 * buf ; <vul-start> ) ; } buf = kmalloc ( d -> msg_len + 1, GFP_KERNEL ) ; if (! buf ) return - ENOMEM ; memcpy ( buf, d -> msg, d -> msg_len ) ; if (! buf ) return - ENOMEM ; <vul-start> CX24116_DISEQC_MSGOFS ) ) { kfree ( buf ) ; <vul-start> - EINVAL ; }\n"
 },
 {
  "id": 566,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , \"EIGRP version %u packet not supported\" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , \"EIGRP %s, length: %u\" , tok2str ( eigrp_opcode_values , \"unknown (%u)\" , eigrp_com_header -> opcode ) , len ) ) ; return ; } <vul-start> tlen = len - sizeof ( struct eigrp_common_header ) ; <vul-end> ND_PRINT ( ( ndo , \"\\\\n\\\\tEIGRP v%u, opcode: %s (%u), chksum: 0x%04x, Flags: [%s]\\\\n\\\\tseq: 0x%08x, ack: 0x%08x, AS: %u, length: %u\" , eigrp_com_header -> version , tok2str ( eigrp_opcode_values , \"unknown, type: %u\" , eigrp_com_header -> opcode ) , eigrp_com_header -> opcode , EXTRACT_16BITS ( & eigrp_com_header -> checksum ) , tok2str ( eigrp_common_header_flag_values , \"none\" , EXTRACT_32BITS ( & eigrp_com_header",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , \"EIGRP %s, length: %u (too short, < %u)\" , tok2str ( eigrp_opcode_values , \"unknown (%u)\" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <vul-start> ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , \" (too short, < %u)\" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) tlv_tptr ; if ( eigrp_tlv_len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo, \"\\\\n\\\\t illegal prefix length %u\", eigrp_tlv_len ) ) ; break ; } <vul-start> ) tlv_tptr ; if ( eigrp_tlv_ip_int -> plen < 4 ) { ND_PRINT ( ( ndo, \"\\\\n\\\\t illegal prefix length %u\", eigrp_tlv_ip_int -> plen ) ) ; break ; } <vul-start> ) ) ; if ( eigrp_tlv_ip_ext -> nexthop!= NULL ) { <vul-start> ) ) ; } <vul-start> ) tlv_tptr ; if ( eigrp_tlv_ip_int -> nexthop!= NULL ) { <vul-start> ) ) ; }\n"
 },
 {
  "id": 567,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <vul-start> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <vul-end> return 1 ; <vul-start> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <vul-end> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <vul-start> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <vul-end> return 1 ; return 0 ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <vul-start> ; if ( <vul-end> inode -> i_flock <vul-start> F_RDLCK ) ) <vul-end> return 1 ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( nfs_write_pageuptodate ( page, inode ) && <vul-end> inode -> i_flock <vul-start> inode -> i_flock!= NULL ) { if ( inode -> i_flock -> fl_type!= F_RDLCK <vul-end> ) return 1 <vul-start> ; if ( f_cred_is_suitable_write ( inode ) &&! NFS_I ( inode ) -> i_uidgid ) return 1 ; } else if ( <vul-start>!= OFFSET_MAX && S_ISREG ( inode -> i_mode ) && inode -> i_flock -> fl_end == OFFSET_MAX && <vul-start>!= F_RDLCK ) <vul-end> ) return 1\n"
 },
 {
  "id": 568,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int parse_video_info ( AVIOContext * pb , AVStream * st ) { uint16_t size_asf ; uint32_t size_bmp ; unsigned int tag ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; avio_skip ( pb , 1 ) ; size_asf = avio_rl16 ( pb ) ; tag = ff_get_bmp_header ( pb , st , & size_bmp ) ; st -> codecpar -> codec_tag = tag ; st -> codecpar -> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , tag ) ; size_bmp = FFMAX ( size_asf , size_bmp ) ; <vul-start> if ( size_bmp > BMP_HEADER_SIZE ) { <vul-end> int ret ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ; if ( ! ( st -> codecpar -> extradata = av_malloc ( st -> codecpar -> extradata_size + AV_INPUT_BUFFER_PADDING_SIZE ) ) ) { st -> codecpar -> extradata_size = 0 ; return AVERROR ( ENOMEM ) ; } memset ( st -> codecpar -> extradata + st -> codecpar -> extradata_size , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ; if ( ( ret = avio_read ( pb , st -> codecpar -> extradata , st -> codecpar -> extradata_size ) ) < 0 ) return ret ; } return 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> size_bmp ) ; st -> codecpar -> extradata_size = size_bmp - BMP_HEADER_SIZE ;\n"
 },
 {
  "id": 569,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; <vul-start> switch ( pc -> componentType ) { <vul-end> case 1 : if ( pc -> lengthComponentIdent > 0 ) <vul-start> break ; <vul-end> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; memcpy ( p , \"../\" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , \"./\" , 2 ) ; p += 2 ; tolen -= 2 ; break ; <vul-start> case 5 : <vul-end> comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; } <vul-start> elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; <vul-end> } if ( p > to + 1 ) p [ -",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> elen ) ; elen += sizeof ( struct pathComponent ) ; <vul-start> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <vul-end> case 2 : <vul-start> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <vul-start> break ; } <vul-end> } if (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> elen ) ; if ( tolen == 0 ) return - ENAMETOOLONG ; <vul-start> > 0 ) { if ( tolen == 0 ) return - ENAMETOOLONG ; memcpy ( p, from, 3 ) ; p += 3 ; tolen -= 3 ; break ; } <vul-end> case 2 : <vul-start> break ; case 6 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 2 ) ; p += 2 ; tolen -= 2 ; break ; case <vul-start> break ; } if ( tolen == 0 ) return - ENAMETOOLONG ; * p ++ = '/' ; tolen -- ; break ; case 7 : if ( tolen < 4 ) return - ENAMETOOLONG ; memcpy ( p, from + 3, 4 ) ; p += 4 ; tolen -= 4 ; break ; case 8 : if ( tolen < 8 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 8 ) ; p += 8 ; tolen -= 8 ; break ; case 9 : if ( tolen < 10 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 10 ) ; p += 8 ; tolen -= 8 ; break ; case 9 : if ( tolen < 10 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 9 ) ; p += 8 ; tolen -= 8 ; break ; case 10 : if ( tolen < 10 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 10 ) ; p += 10 ; tolen -= 10 ; break ; case 11 : if ( tolen < 11 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 11 ) ; p += 11 ; tolen -= 11 ; break ; case 12 : if ( tolen < 12 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 12 ) ; p += 12 ; tolen -= 12 ; break ; case 16 : if ( tolen < 16 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 16 ) ; p += 16 ; tolen -= 16 ; break ; case 19 : if ( tolen < 20 ) return - ENAMETOOLONG ; memcpy ( p, \"./\", 16 ) ; p += 16 ; tolen -="
 },
 {
  "id": 570,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; if ( requeue_pi ) { <vul-start> if ( refill_pi_state_cache ( ) ) <vul-end> return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : if ( pi_state != NULL ) { free_pi_state ( pi_state ) ; pi_state = NULL ; } ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) <vul-start> goto out_put_key1 ; <vul-end> hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( <vul-start> goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> { if ( WARN_ON_ONCE (! refill_pi_state_cache ( ) <vul-end> ) ) return <vul-start> ) goto out_put_key1 ; if ( flags & FLAGS_SHARED ) { if ( requeue_pi ) { atomic_dec ( & pi_state -> refcount ) ; pi_state = NULL ; } } else { ret = - EINVAL ; } } ret = get_futex_key ( uaddr1, flags & FLAGS_SHARED, & key1 ) ; if ( unlikely ( ret!= 0 ) ) goto out_unlock\n"
 },
 {
  "id": 571,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void keyring_describe ( const struct key * keyring , struct seq_file * m ) { if ( keyring -> description ) seq_puts ( m , keyring -> description ) ; else seq_puts ( m , \"[anon]\" ) ; <vul-start> if ( key_is_instantiated ( keyring ) ) { <vul-end> if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , \": %lu\" , keyring -> keys . nr_leaves_on_tree ) ; else seq_puts ( m , \": empty\" ) ; } }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_positive <vul-end> ( keyring )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_positive <vul-end> ( keyring )\n"
 },
 {
  "id": 572,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 Datum hstore_from_record ( PG_FUNCTION_ARGS ) { HeapTupleHeader rec ; int32 buflen ; HStore * out ; Pairs * pairs ; Oid tupType ; int32 tupTypmod ; TupleDesc tupdesc ; HeapTupleData tuple ; RecordIOData * my_extra ; int ncolumns ; int i , j ; Datum * values ; bool * nulls ; if ( PG_ARGISNULL ( 0 ) ) { Oid argtype = get_fn_expr_argtype ( fcinfo -> flinfo , 0 ) ; tupType = argtype ; tupTypmod = - 1 ; rec = NULL ; } else { rec = PG_GETARG_HEAPTUPLEHEADER ( 0 ) ; tupType = HeapTupleHeaderGetTypeId ( rec ) ; tupTypmod = HeapTupleHeaderGetTypMod ( rec ) ; } tupdesc = lookup_rowtype_tupdesc ( tupType , tupTypmod ) ; ncolumns = tupdesc -> natts ; my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; if ( my_extra == NULL || my_extra -> ncolumns != ncolumns ) { fcinfo -> flinfo -> fn_extra = MemoryContextAlloc ( fcinfo -> flinfo -> fn_mcxt , sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) + ncolumns * sizeof ( ColumnIOData ) ) ; my_extra = ( RecordIOData * ) fcinfo -> flinfo -> fn_extra ; my_extra -> record_type = InvalidOid ; my_extra -> record_typmod = 0 ; } if ( my_extra -> record_type != tupType || my_extra -> record_typmod != tupTypmod ) { MemSet ( my_extra , 0 , sizeof ( RecordIOData ) - sizeof ( ColumnIOData ) + ncolumns * sizeof ( ColumnIOData ) ) ; my_extra -> record_type = tupType ; my_extra -> record_typmod = tupTypmod ; my_extra -> ncolumns = ncolumns ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> ncolumns ; } Assert ( ncolumns <= MaxTupleAttributeNumber ) ;\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ncolumns ; } if ( ncolumns > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR, ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ), errmsg ( \"number of pairs (%d) exceeds the maximum allowed (%d)\", ncolumns, ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;\n"
 },
 {
  "id": 573,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t enc28j60ReceivePacket ( NetInterface * interface ) { error_t error ; <vul-start> uint16_t n ; <vul-end> uint16_t status ; <vul-start> Enc28j60Context * context ; <vul-end> context = ( Enc28j60Context * ) interface -> nicContext ; <vul-start> if ( enc28j60ReadReg ( interface , ENC28J60_REG_EPKTCNT ) ) <vul-end> { enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTL , LSB ( context -> nextPacket ) ) ; <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERDPTH , MSB ( context -> nextPacket ) ) ; <vul-end> <vul-start> enc28j60ReadBuffer ( interface , ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; <vul-end> enc28j60ReadBuffer ( interface , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ; enc28j60ReadBuffer ( interface , ( uint8_t * ) & status , sizeof ( uint16_t ) ) ; <vul-start> if ( ( status & RSV_RECEIVED_OK ) != 0 ) <vul-end> { <vul-start> n = MIN ( n , ETH_MAX_FRAME_SIZE ) ; <vul-end> <vul-start> enc28j60ReadBuffer ( interface , context -> rxBuffer , n ) ; <vul-end> error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } if ( context -> nextPacket == ENC28J60_RX_BUFFER_START ) { <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( ENC28J60_RX_BUFFER_STOP ) ) ; <vul-end> } else { <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTL , LSB ( context -> nextPacket - 1 ) ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXRDPTH , MSB ( context -> nextPacket - 1 ) ) ; <vul-end> } <vul-start> enc28j60SetBit ( interface , ENC28J60_REG_ECON2 ,",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> error ; uint16_t length <vul-end> ; uint16_t status <vul-start> uint16_t status ; uint8_t header [ 6 ] ; <vul-start> ( interface , ENC28J60_EPKTCNT ) != 0 ) { enc28j60WriteReg ( interface , ENC28J60_ERDPTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERDPTH <vul-end> , MSB ( <vul-start> ( interface , header <vul-end> , sizeof ( <vul-start> , sizeof ( header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD16LE ( header + 4 <vul-end> ) ; if <vul-start> ( status & ENC28J60_RSV_RECEIVED_OK <vul-end> ) != 0 <vul-start> 0 ) { length <vul-end> = MIN ( <vul-start> = MIN ( length <vul-end> , ETH_MAX_FRAME_SIZE ) <vul-start> -> rxBuffer , length <vul-end> ) ; error <vul-start> ( interface , ENC28J60_ERXRDPTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXRDPTH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ERXRDPTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXRDPTH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ECON2 , ENC28J60_ECON2_PKTDEC <vul-end> ) ; } <vul-start> -> rxBuffer , length <vul-end> , & ancillary\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> error ; uint16_t packet_length ; uint16_t <vul-start> Enc28j60Context * context ; uint8_t * erdptl ; uint16_t * <vul-start> ( interface, ENC28J60_EPKTCNT ) ) { enc28j60WriteReg ( interface, ENC28J60_ERDPTL, LSB ( <vul-end> context -> nextPacket <vul-start> ( interface, ENC28J60_ERDPTH <vul-end>, MSB ( <vul-start> ( interface, ENC28J60_EPKTCNT <vul-end>, sizeof ( <vul-start> ; if ( enc28j60ReadReg ( interface, ENC28J60_EPKTCNT )!= 0 ) { packet_length = ( uint16_t * ) & <vul-end> context -> nextPacket <vul-start> context -> nextPacket ; } else { if ( <vul-start> 0 ) { packet_length <vul-end> = MIN ( <vul-start> -> rxBuffer, ( uint16_t ) <vul-start> ( interface, ENC28J60_ERXRDPTL, LSB ( ENC28J60_RX_BUFFER_STOP <vul-end> ) ) ; <vul-start> ( interface, ENC28J60_ERXRDPTH <vul-end>, MSB ( <vul-start> ( interface, ENC28J60_ECON2, ECON2_PKTDEC ) ; } enc28j60WriteReg ( interface, ENC28J60_EPKTCNT, packet_length <vul-end> ) ; }\n"
 },
 {
  "id": 574,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int connection_edge_process_relay_cell ( cell_t * cell , circuit_t * circ , edge_connection_t * conn , crypt_path_t * layer_hint ) { static int num_seen = 0 ; relay_header_t rh ; unsigned domain = layer_hint ? LD_APP : LD_EXIT ; int reason ; int optimistic_data = 0 ; tor_assert ( cell ) ; tor_assert ( circ ) ; relay_header_unpack ( & rh , cell -> payload ) ; num_seen ++ ; log_debug ( domain , \"Now seen %d relay cells here (command %d, stream %d).\" , num_seen , rh . command , rh . stream_id ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Relay cell length field too long. Closing circuit.\" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( rh . stream_id == 0 ) { switch ( rh . command ) { case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_CONNECTED : case RELAY_COMMAND_DATA : case RELAY_COMMAND_END : case RELAY_COMMAND_RESOLVE : case RELAY_COMMAND_RESOLVED : case RELAY_COMMAND_BEGIN_DIR : log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Relay command %d with zero \" \"stream_id. Dropping.\" , ( int ) rh . command ) ; return 0 ; default : ; } } if ( conn && ! connection_state_is_open ( TO_CONN ( conn ) ) ) { if ( conn -> base_ . type == CONN_TYPE_EXIT && ( conn -> base_ . state == EXIT_CONN_STATE_CONNECTING || conn -> base_ . state == EXIT_CONN_STATE_RESOLVING ) && rh . command == RELAY_COMMAND_DATA ) { optimistic_data = 1 ; } else { return connection_edge_process_relay_cell_not_open ( & rh , cell , circ , conn , layer_hint ) ;",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> command == RELAY_COMMAND_BEGIN_DIR && layer_hint == 0\n"
 },
 {
  "id": 575,
  "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static int asf_read_marker ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; ASFContext * asf = s -> priv_data ; int i , count , name_len , ret ; char name [ 1024 ] ; avio_rl64 ( pb ) ; avio_rl64 ( pb ) ; count = avio_rl32 ( pb ) ; avio_rl16 ( pb ) ; name_len = avio_rl16 ( pb ) ; <vul-start> for ( i = 0 ; i < name_len ; i ++ ) <vul-end> avio_r8 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { int64_t pres_time ; <vul-start> int name_len ; <vul-end> avio_rl64 ( pb ) ; pres_time = avio_rl64 ( pb ) ; pres_time -= asf -> hdr . preroll * 10000 ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , sizeof ( name ) ) ) < name_len ) avio_skip ( pb , name_len - ret ) ; avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , AV_NOPTS_VALUE , name ) ; } return 0 ; }",
  "golden_answers": [
   "CWE-834 Fixed Code Lines are: <vul-start> pb ) ; avio_skip ( pb , name_len <vul-end> ) ; for <vul-start> ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA\n"
  ],
  "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> i ++ ) { if (! avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> int64_t pres_time ; avio_rl32 ( pb ) ; pres_time -= ( int64_t ) avio_get_preroll ( pb ) * 10000 ; avio_rl16 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb, name_len * 2, name, sizeof ( name ) ) ) < name_len ) avio_skip ( pb, name_len - ret ) ; } <vul-end> avio_rl64 ( pb\n"
 },
 {
  "id": 576,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 struct scm_fp_list * scm_fp_dup ( struct scm_fp_list * fpl ) { struct scm_fp_list * new_fpl ; int i ; if ( ! fpl ) return NULL ; new_fpl = kmemdup ( fpl , offsetof ( struct scm_fp_list , fp [ fpl -> count ] ) , GFP_KERNEL ) ; if ( new_fpl ) { for ( i = 0 ; i < fpl -> count ; i ++ ) get_file ( fpl -> fp [ i ] ) ; new_fpl -> max = new_fpl -> count ; <vul-start> } <vul-end> return new_fpl ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> -> count ; new_fpl -> user = get_uid ( fpl -> user ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> -> count ; new_fpl -> user = get_uid ( current_user ( ) ) ;\n"
 },
 {
  "id": 577,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode , <vul-start> struct ext4_ext_path * path ) <vul-end> { <vul-start> struct ext4_extent * ex ; <vul-end> int depth ; int err = 0 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; <vul-start> ext_debug ( \"ext4_convert_unwritten_extents_endio: inode %lu, logical\" <vul-end> \"block %llu, max_blocks %u\\\\n\" , inode -> i_ino , <vul-start> ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) , <vul-end> ext4_ext_get_actual_len ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> inode , struct ext4_map_blocks * map , struct <vul-start> ext4_extent * ex ; ext4_lblk_t ee_block ; unsigned int ee_len <vul-start> . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <vul-start> long long ) ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <vul-end> err = ext4_ext_get_access\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ext4_ext_path * path, unsigned long block, unsigned long max_blocks <vul-start> ext4_extent * ex ; unsigned long ext_size <vul-start> ; ext_debug ( \"ext4_convert_unwritten_extents_endio: inode %lu, logical\" \"block %llu, max_blocks %u, size %u\\\\n\" <vul-end>, inode -> <vul-start> -> i_ino, <vul-end> le32_to_cpu ( ex <vul-start> ex -> ee_block ), block, max_blocks\n"
 },
 {
  "id": 578,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , \"PACK\" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; line += PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { <vul-start> * head = NULL ; <vul-end> * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , \"ACK\" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , \"NAK\" ) ) ret = nak_pkt",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , \"Invalid empty packet\" ) ; return GIT_ERROR <vul-end> ; } if\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> PKT_LEN_SIZE ) { if ( * head )\n"
 },
 {
  "id": 579,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 <vul-start> int xmkstemp ( char * * tmpname , char * dir ) <vul-end> { char * localtmp ; <vul-start> char * tmpenv ; <vul-end> mode_t old_mode ; int fd , rc ; <vul-start> if ( dir != NULL ) <vul-end> <vul-start> tmpenv = dir ; <vul-end> else tmpenv = getenv ( \"TMPDIR\" ) ; <vul-start> if ( tmpenv ) <vul-end> rc = asprintf ( & localtmp , \"%s/%s.XXXXXX\" , tmpenv , <vul-start> program_invocation_short_name ) ; <vul-end> else rc = asprintf ( & localtmp , \"%s/%s.XXXXXX\" , _PATH_TMP , program_invocation_short_name ) ; if ( rc < 0 ) return - 1 ; old_mode = umask ( 077 ) ; fd = mkostemp ( localtmp , O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC ) ; umask ( old_mode ) ; if ( fd == - 1 ) { free ( localtmp ) ; localtmp = NULL ; } * tmpname = localtmp ; return fd ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> * tmpname , const <vul-start> char * dir , const char * prefix <vul-start> * localtmp ; const <vul-start> , rc ; <vul-end> tmpenv = dir <vul-start> tmpenv = dir ? dir : <vul-end> getenv ( \"TMPDIR\" <vul-start> ; if ( ! tmpenv ) tmpenv = _PATH_TMP ; <vul-end> rc = asprintf <vul-start> , tmpenv , prefix <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> * tmpname, uid_t dir, uid_t uid, gid_t gid <vul-end> ) { char <vul-start> * localtmp ; <vul-end> mode_t old_mode ; <vul-start>, rc ; <vul-end> tmpenv = dir <vul-start>!= NULL ) { <vul-end> tmpenv = dir <vul-start> = dir ; if ( uid!= 0 ) { rc = asprintf ( & localtmp, \"%s/%s.XXXXXX\", tmpenv, program_invocation_short_name ) ; } else { rc = asprintf ( & localtmp, \"%s/%s.XXXXXX\", _PATH_TMP, program_invocation_short_name ) ; } } else { tmpenv = getenv ( \"TMPDIR\" ) ; } <vul-end> if ( tmpenv <vul-start> \"TMPDIR\" ) ; <vul-end> rc = asprintf <vul-start>, \"%s/%s.XXXXXX\", _PATH_TMP <vul-end>, program_invocation_short_name ) <vul-start>, \"%s/%s.XXXXXX\", _PATH_TMP <vul-end>, program_invocation_short_name )\n"
 },
 {
  "id": 580,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void dhcpClientProcessMessage ( NetInterface * interface , const IpPseudoHeader * pseudoHeader , const UdpHeader * udpHeader , const NetBuffer * buffer , size_t offset , const NetRxAncillary * ancillary , void * param ) { size_t length ; DhcpClientContext * context ; DhcpMessage * message ; DhcpOption * option ; context = ( DhcpClientContext * ) param ; length = netBufferGetLength ( buffer ) - offset ; <vul-start> if ( length < sizeof ( DhcpMessage ) ) <vul-end> return ; if ( length > DHCP_MAX_MSG_SIZE ) return ; message = netBufferAt ( buffer , offset ) ; if ( message == NULL ) return ; TRACE_DEBUG ( \"\\\\r\\\\n%s: DHCP message received (%\" PRIuSIZE \" bytes)...\\\\r\\\\n\" , formatSystemTime ( osGetSystemTime ( ) , NULL ) , length ) ; dhcpDumpMessage ( message , length ) ; if ( message -> op != DHCP_OPCODE_BOOTREPLY ) return ; if ( message -> htype != DHCP_HARDWARE_TYPE_ETH ) return ; if ( message -> hlen != sizeof ( MacAddr ) ) return ; if ( message -> magicCookie != HTONL ( DHCP_MAGIC_COOKIE ) ) return ; option = dhcpGetOption ( message , length , DHCP_OPT_DHCP_MESSAGE_TYPE ) ; if ( option == NULL || option -> length != 1 ) return ; switch ( option -> value [ 0 ] ) { case DHCP_MESSAGE_TYPE_OFFER : dhcpClientParseOffer ( context , message , length ) ; break ; case DHCP_MESSAGE_TYPE_ACK : dhcpClientParseAck ( context , message , length ) ; break ; case DHCP_MESSAGE_TYPE_NAK : dhcpClientParseNak ( context , message , length ) ; break ; default : break ; } }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( DhcpMessage ) || <vul-end> length > DHCP_MAX_MSG_SIZE\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( length < offset +\n"
 },
 {
  "id": 581,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void process_blob ( struct rev_info * revs , struct blob * blob , show_object_fn show , struct strbuf * path , const char * name , void * cb_data ) { struct object * obj = & blob -> object ; <vul-start> if ( ! revs -> blob_objects ) <vul-end> return ; if ( ! obj ) die ( \"bad blob object\" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; obj -> flags |= SEEN ; <vul-start> show ( obj , path , name , cb_data ) ; <vul-end> <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> object ; size_t pathlen ; <vul-start> |= SEEN ; pathlen = path -> len ; strbuf_addstr ( path , name ) ; <vul-start> obj , path -> buf <vul-end> , cb_data ) <vul-start> cb_data ) ; strbuf_setlen ( path , pathlen ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> object ; int ret = 0 ; <vul-start> |= SEEN ; ret = <vul-start> cb_data ) ; if ( ret < 0 ) { strbuf_addf ( path, \"404: no such file or directory\" ) ; cb_data ( NULL, ret ) ; return ; } free ( obj ) ;\n"
 },
 {
  "id": 582,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int mainloop ( CLIENT * client ) { struct nbd_request request ; struct nbd_reply reply ; gboolean go_on = TRUE ; # ifdef DODBG int i = 0 ; # endif negotiate ( client -> net , client , NULL ) ; DEBUG ( \"Entering request loop!\\\\n\" ) ; reply . magic = htonl ( NBD_REPLY_MAGIC ) ; reply . error = 0 ; while ( go_on ) { char buf [ BUFSIZE ] ; size_t len ; # ifdef DODBG i ++ ; printf ( \"%d: \" , i ) ; # endif readit ( client -> net , & request , sizeof ( request ) ) ; request . from = ntohll ( request . from ) ; request . type = ntohl ( request . type ) ; if ( request . type == NBD_CMD_DISC ) { msg2 ( LOG_INFO , \"Disconnect request received.\" ) ; if ( client -> server -> flags & F_COPYONWRITE ) { if ( client -> difmap ) g_free ( client -> difmap ) ; close ( client -> difffile ) ; unlink ( client -> difffilename ) ; free ( client -> difffilename ) ; } go_on = FALSE ; continue ; } len = ntohl ( request . len ) ; if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) err ( \"Not enough magic.\" ) ; <vul-start> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <vul-end> err ( \"Request too big!\" ) ; # ifdef DODBG printf ( \"%s from %llu (%llu) len %d, \" , request .",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> len > BUFSIZE - <vul-end> sizeof ( struct\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> \"Not enough magic.\" ) ; else\n"
 },
 {
  "id": 583,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static void __nfs4_close ( struct path * path , struct nfs4_state * state , mode_t mode , int wait ) <vul-end> { struct nfs4_state_owner * owner = state -> owner ; int call_close = 0 ; <vul-start> int newstate ; <vul-end> atomic_inc ( & owner -> so_count ) ; spin_lock ( & owner -> so_lock ) ; <vul-start> switch ( mode & ( FMODE_READ | FMODE_WRITE ) ) { <vul-end> case FMODE_READ : state -> n_rdonly -- ; break ; case FMODE_WRITE : state -> n_wronly -- ; break ; case FMODE_READ | FMODE_WRITE : state -> n_rdwr -- ; } newstate = FMODE_READ | FMODE_WRITE ; if ( state -> n_rdwr == 0 ) { if ( state -> n_rdonly == 0 ) { newstate &= ~ FMODE_READ ; call_close |= test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ; call_close |= test_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } if ( state -> n_wronly == 0 ) { newstate &= ~ FMODE_WRITE ; call_close |= test_bit ( NFS_O_WRONLY_STATE , & state -> flags ) ; call_close |= test_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } if ( newstate == 0 ) clear_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } nfs4_state_set_mode_locked ( state , newstate ) ; spin_unlock ( & owner -> so_lock ) ; if ( ! call_close ) { nfs4_put_open_state ( state ) ; nfs4_put_state_owner ( owner ) ; } else nfs4_do_close ( path , state , wait ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> * state , fmode_t fmode <vul-end> , int wait <vul-start> = 0 ; fmode_t <vul-end> newstate ; atomic_inc <vul-start> ; switch ( fmode <vul-end> & ( FMODE_READ\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * state, fmode_t fmode <vul-end>, int wait <vul-start> ; int newstate ; if ( fmode & FMODE_READ ) state -> n_rdonly -- ; else if ( fmode & FMODE_WRITE ) state -> n_wronly -- <vul-start> so_lock ) ; <vul-end> if ( state\n"
 },
 {
  "id": 584,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <vul-start> return ret ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = hcd ; if (! ci -> platdata -> hostpassthrough ) hcd -> has_hostpc = 0 ;\n"
 },
 {
  "id": 585,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int snd_timer_user_params ( struct file * file , struct snd_timer_params __user * _params ) { struct snd_timer_user * tu ; struct snd_timer_params params ; struct snd_timer * t ; struct snd_timer_read * tr ; struct snd_timer_tread * ttr ; int err ; tu = file -> private_data ; if ( ! tu -> timeri ) return - EBADFD ; t = tu -> timeri -> timer ; if ( ! t ) return - EBADFD ; if ( copy_from_user ( & params , _params , sizeof ( params ) ) ) return - EFAULT ; if ( ! ( t -> hw . flags & SNDRV_TIMER_HW_SLAVE ) && params . ticks < 1 ) { err = - EINVAL ; goto _end ; } if ( params . queue_size > 0 && ( params . queue_size < 32 || params . queue_size > 1024 ) ) { err = - EINVAL ; goto _end ; } if ( params . filter & ~ ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) | ( 1 << SNDRV_TIMER_EVENT_START ) | ( 1 << SNDRV_TIMER_EVENT_STOP ) | ( 1 << SNDRV_TIMER_EVENT_CONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_PAUSE ) | ( 1 << SNDRV_TIMER_EVENT_SUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_RESUME ) | ( 1 << SNDRV_TIMER_EVENT_MSTART ) | ( 1 << SNDRV_TIMER_EVENT_MSTOP ) | ( 1 << SNDRV_TIMER_EVENT_MCONTINUE ) | ( 1 << SNDRV_TIMER_EVENT_MPAUSE ) | ( 1 << SNDRV_TIMER_EVENT_MSUSPEND ) | ( 1 << SNDRV_TIMER_EVENT_MRESUME ) ) ) { err = - EINVAL ; goto _end ; } snd_timer_stop ( tu -> timeri",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> snd_timer_tread tread ; memset ( & tread , 0 , sizeof ( tread ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> snd_timer_tread tread ; memset ( & tread, 0, sizeof ( tread ) ) ;\n"
 },
 {
  "id": 586,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int sctp_rcv ( struct sk_buff * skb ) { struct sock * sk ; struct sctp_association * asoc ; struct sctp_endpoint * ep = NULL ; struct sctp_ep_common * rcvr ; struct sctp_transport * transport = NULL ; struct sctp_chunk * chunk ; struct sctphdr * sh ; union sctp_addr src ; union sctp_addr dest ; int family ; struct sctp_af * af ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; SCTP_INC_STATS_BH ( SCTP_MIB_INSCTPPACKS ) ; if ( skb_linearize ( skb ) ) goto discard_it ; sh = sctp_hdr ( skb ) ; __skb_pull ( skb , skb_transport_offset ( skb ) ) ; if ( skb -> len < sizeof ( struct sctphdr ) ) goto discard_it ; if ( ! skb_csum_unnecessary ( skb ) && sctp_rcv_checksum ( skb ) < 0 ) goto discard_it ; skb_pull ( skb , sizeof ( struct sctphdr ) ) ; if ( skb -> len < sizeof ( struct sctp_chunkhdr ) ) goto discard_it ; family = ipver2af ( ip_hdr ( skb ) -> version ) ; af = sctp_get_af_specific ( family ) ; if ( unlikely ( ! af ) ) goto discard_it ; af -> from_skb ( & src , skb , 1 ) ; af -> from_skb ( & dest , skb , 0 ) ; if ( ! af -> addr_valid ( & src , NULL , skb ) || ! af -> addr_valid ( & dest , NULL , skb ) ) goto discard_it ; asoc = __sctp_rcv_lookup ( skb , & src , & dest , & transport",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ; if ( sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if (\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> sk ) ; if (! asoc ) { sctp_bh_unlock_sock ( sk ) ; goto discard_release ; }\n"
 },
 {
  "id": 587,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , \"invalid len\" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , \"%s\" , tok2str ( bgp_origin_values , \"Unknown Origin Typecode\" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , \"invalid len\" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , \"empty\" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , \"%s\" , tok2str ( bgp_as_path_segment_open_values , <vul-start> \"?\" , tptr [ 0 ] ) ) ) ; <vul-end> for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ] ) ) ) ; ND_TCHECK ( tptr [ 1 ]\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) ) ; if ( len < 2 ) { ND_PRINT ( ( ndo, \"invalid len\" ) ) ; break ; }\n"
 },
 {
  "id": 588,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; if ( vm_flags & VM_NORESERVE ) return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) <vul-start> return chg ; <vul-end> if ( hugepage_subpool_get_pages ( spool , chg ) ) <vul-start> return - ENOSPC ; <vul-end> <vul-start> ret = hugetlb_acct_memory ( h , chg ) ; <vul-end> if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ; <vul-start> return ret ; <vul-end> } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> < 0 ) { ret = chg ; goto out_err ; } <vul-end> if ( hugepage_subpool_get_pages <vul-start> chg ) ) { ret = <vul-end> - ENOSPC ; <vul-start> - ENOSPC ; goto out_err ; } <vul-start> chg ) ; goto out_err <vul-end> ; } if <vul-start> return 0 ; out_err : resv_map_put ( vma ) ; return ret ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> < 0 ) goto err_out <vul-end> ; if ( <vul-start> chg ) ) goto err_out <vul-end> ; ret = <vul-start> chg ) ; goto err_out <vul-end> ; } if <vul-start> return 0 ; err_out : subpool_put_pages ( spool, chg ) ; return ret ;\n"
 },
 {
  "id": 589,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 char * guestfs___first_line_of_file ( guestfs_h * g , const char * filename ) { <vul-start> CLEANUP_FREE char * * lines = NULL ; <vul-end> int64_t size ; char * ret ; size = guestfs_filesize ( g , filename ) ; if ( size == - 1 ) return NULL ; if ( size > MAX_SMALL_FILE_SIZE ) { error ( g , _ ( \"size of %s is unreasonably large (%\" PRIi64 \" bytes)\" ) , filename , size ) ; return NULL ; } lines = guestfs_head_n ( g , 1 , filename ) ; if ( lines == NULL ) return NULL ; if ( lines [ 0 ] == NULL ) { guestfs___free_string_list ( lines ) ; return safe_strdup ( g , \"\" ) ; } ret = lines [ 0 ] ; <vul-start> return ret ; <vul-end> }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> filename ) { <vul-end> char * * <vul-start> 0 ] ; free ( lines ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> lines = NULL ; char * first_line <vul-start> 0 ] ; if ( ret == NULL ) return NULL ; first_line = safe_strdup ( g, ret ) ; if ( first_line!= NULL ) { if ( strchr ( ret, '=' )!= NULL ) first_line = first_line + 1 ; if ( * first_line!= '\\\\0' ) { error ( g, _ ( \"first line of %s is not empty\" ), filename ) ; return NULL ; } }\n"
 },
 {
  "id": 590,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int perf_trace_event_perm ( struct ftrace_event_call * tp_event , struct perf_event * p_event ) { if ( ftrace_event_is_function ( tp_event ) && <vul-start> perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) <vul-end> return - EPERM ; if ( ! ( p_event -> attr . sample_type & PERF_SAMPLE_RAW ) ) return 0 ; if ( p_event -> attach_state == PERF_ATTACH_TASK ) { if ( tp_event -> flags & TRACE_EVENT_FL_CAP_ANY ) return 0 ; } if ( perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> tp_event ) && perf_paranoid_tracepoint_raw <vul-end> ( ) &&\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> tp_event ) && perf_paranoid_tracepoint_raw <vul-end> ( ) &&\n"
 },
 {
  "id": 591,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 void cipso_v4_req_delattr ( struct request_sock * req ) { <vul-start> struct ip_options * opt ; <vul-end> struct inet_request_sock * req_inet ; req_inet = inet_rsk ( req ) ; opt = req_inet -> opt ; <vul-start> if ( opt == NULL || opt -> cipso == 0 ) <vul-end> return ; cipso_v4_delopt ( & req_inet -> opt ) ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ) { struct ip_options_rcu <vul-end> * opt ; <vul-start> || opt -> opt .\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) { struct ip_options_rcu <vul-end> * opt ; <vul-start> || opt -> opt.\n"
 },
 {
  "id": 592,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; <vul-start> case 'c' : return getnum ( L , fmt , 1 ) ; <vul-end> case 'i' : case 'I' : { <vul-start> int sz = getnum ( L , fmt , sizeof ( int ) ) ; <vul-end> if ( sz > MAXINTSIZE ) luaL_error ( L , \"integral size %d is larger than limit of %d\" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> return getnum ( <vul-end> fmt , 1 <vul-start> = getnum ( <vul-end> fmt , sizeof\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> return getnum ( L, <vul-end> fmt, 1 <vul-start> = getnum ( L, <vul-end> fmt, sizeof\n"
 },
 {
  "id": 593,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int get_evtchn_to_irq ( evtchn_port_t evtchn ) { if ( evtchn >= xen_evtchn_max_channels ( ) ) return - 1 ; if ( evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] == NULL ) return - 1 ; <vul-start> return evtchn_to_irq [ EVTCHN_ROW ( evtchn ) ] [ EVTCHN_COL ( evtchn ) ] ; <vul-end> }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> 1 ; return READ_ONCE ( <vul-start> evtchn ) ] )\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> - 1 ; if ( xen_evtchn_is_intra_mode ( evtchn ) ) return - 1 ;\n"
 },
 {
  "id": 594,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int do_16x16_motion_search ( VP9_COMP * cpi , const int_mv * ref_mv , <vul-end> int_mv * dst_mv , int mb_row , int mb_col ) { <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; unsigned int err , tmp_err ; <vul-start> int_mv tmp_mv ; <vul-end> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <vul-start> xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride , <vul-end> INT_MAX ) ; dst_mv -> as_int = 0 ; <vul-start> tmp_err = do_16x16_motion_iteration ( cpi , & ref_mv -> as_mv , & tmp_mv . as_mv , <vul-end> mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_int = tmp_mv . as_int ; } if ( ref_mv -> as_int ) { unsigned int tmp_err ; int_mv zero_ref_mv , tmp_mv ; zero_ref_mv . as_int = 0 ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv . as_mv , & tmp_mv . as_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_int = tmp_mv . as_int ; err = tmp_err ; } } return err ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> cpi , const MV * ref_mv , int_mv * <vul-end> dst_mv , int <vul-start> & cpi -> td . <vul-start> , tmp_err ; MV tmp_mv ; err = vpx_sad16x16 <vul-end> ( x -> <vul-start> ] . stride <vul-end> ) ; dst_mv <vul-start> ( cpi , ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv -> as_mv = tmp_mv ; } if ( ref_mv -> row != 0 || ref_mv -> col != 0 ) { unsigned int tmp_err ; MV zero_ref_mv = { 0 , 0 } , tmp_mv ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_mv = tmp_mv <vul-end> ; err =\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int do_16x16_motion_search ( MACROBLOCK * const x <vul-end>, const int_mv <vul-start> & cpi -> td. <vul-start> int_mv tmp_mv ; if ( x -> num_planes < 2 ) { return - 1 ; } <vul-start> ]. stride <vul-end> ) ; dst_mv <vul-start> = do_16x16_motion_iteration ( x <vul-end>, & ref_mv\n"
 },
 {
  "id": 595,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t tcpSendResetSegment ( NetInterface * interface , IpPseudoHeader * pseudoHeader , TcpHeader * segment , size_t length ) { error_t error ; size_t offset ; uint8_t flags ; uint32_t seqNum ; uint32_t ackNum ; NetBuffer * buffer ; TcpHeader * segment2 ; IpPseudoHeader pseudoHeader2 ; NetTxAncillary ancillary ; if ( segment -> flags & TCP_FLAG_ACK ) { flags = TCP_FLAG_RST ; seqNum = segment -> ackNum ; ackNum = 0 ; } else { flags = TCP_FLAG_RST | TCP_FLAG_ACK ; seqNum = 0 ; ackNum = segment -> seqNum + length ; if ( segment -> flags & TCP_FLAG_SYN ) <vul-start> ackNum ++ ; <vul-end> <vul-start> if ( segment -> flags & TCP_FLAG_FIN ) <vul-end> <vul-start> ackNum ++ ; <vul-end> } buffer = ipAllocBuffer ( sizeof ( TcpHeader ) , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; segment2 = netBufferAt ( buffer , offset ) ; segment2 -> srcPort = htons ( segment -> destPort ) ; segment2 -> destPort = htons ( segment -> srcPort ) ; segment2 -> seqNum = htonl ( seqNum ) ; segment2 -> ackNum = htonl ( ackNum ) ; segment2 -> reserved1 = 0 ; segment2 -> dataOffset = 5 ; segment2 -> flags = flags ; segment2 -> reserved2 = 0 ; segment2 -> window = 0 ; segment2 -> checksum = 0 ; segment2 -> urgentPointer = 0 ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { pseudoHeader2 . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader2 . ipv4Data",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> & TCP_FLAG_SYN ) { <vul-start> ackNum ++ ; } <vul-start> & TCP_FLAG_FIN ) { <vul-start> ackNum ++ ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> & TCP_FLAG_SYN ) { <vul-start> ackNum ++ ; } <vul-start> & TCP_FLAG_FIN ) { <vul-start> ackNum ++ ; }\n"
 },
 {
  "id": 596,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static long snd_timer_user_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { <vul-start> struct snd_timer_user * tu ; <vul-end> void __user * argp = ( void __user * ) arg ; int __user * p = argp ; tu = file -> private_data ; <vul-start> switch ( cmd ) { <vul-end> case SNDRV_TIMER_IOCTL_PVERSION : return put_user ( SNDRV_TIMER_VERSION , p ) ? - EFAULT : 0 ; case SNDRV_TIMER_IOCTL_NEXT_DEVICE : return snd_timer_user_next_device ( argp ) ; case SNDRV_TIMER_IOCTL_TREAD : { int xarg ; <vul-start> mutex_lock ( & tu -> tread_sem ) ; <vul-end> if ( tu -> timeri ) { mutex_unlock ( & tu -> tread_sem ) ; return - EBUSY ; } if ( get_user ( xarg , p ) ) { mutex_unlock ( & tu -> tread_sem ) ; return - EFAULT ; } tu -> tread = xarg ? 1 : 0 ; <vul-start> mutex_unlock ( & tu -> tread_sem ) ; <vul-end> <vul-start> return 0 ; <vul-end> } case SNDRV_TIMER_IOCTL_GINFO : return snd_timer_user_ginfo ( file , argp ) ; case SNDRV_TIMER_IOCTL_GPARAMS : return snd_timer_user_gparams ( file , argp ) ; case SNDRV_TIMER_IOCTL_GSTATUS : return snd_timer_user_gstatus ( file , argp ) ; case SNDRV_TIMER_IOCTL_SELECT : return snd_timer_user_tselect ( file , argp ) ; case SNDRV_TIMER_IOCTL_INFO : return snd_timer_user_info ( file , argp ) ; case SNDRV_TIMER_IOCTL_PARAMS : return snd_timer_user_params ( file , argp ) ; case SNDRV_TIMER_IOCTL_STATUS : return snd_timer_user_status ( file , argp ) ; case SNDRV_TIMER_IOCTL_START : case SNDRV_TIMER_IOCTL_START_OLD : return snd_timer_user_start ( file ) ; case SNDRV_TIMER_IOCTL_STOP : case SNDRV_TIMER_IOCTL_STOP_OLD : return snd_timer_user_stop",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> snd_timer_user * tu <vul-end> = file -> <vul-start> -> private_data ; long ret <vul-end> ; mutex_lock ( <vul-start> & tu -> ioctl_lock ) ; ret = __snd_timer_user_ioctl ( file , cmd , arg ) <vul-end> ; mutex_unlock ( <vul-start> & tu -> ioctl_lock <vul-end> ) ; return <vul-start> ) ; return ret <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> snd_timer_user * tu <vul-end> ; int __user <vul-start> -> private_data ; mutex_lock ( & tu -> ioctl_lock ) ; tu = * p ; <vul-start> int xarg ; mutex_unlock ( & tu -> ioctl_lock ) ; <vul-start> : 0 ; mutex_unlock ( & tu -> ioctl_lock ) ; <vul-start> ) ; return - EFAULT <vul-end> ; } case\n"
 },
 {
  "id": 597,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void monitor_apply_keystate ( struct monitor * pmonitor ) { struct ssh * ssh = active_state ; struct kex * kex ; int r ; debug3 ( \"%s: packet_set_state\" , __func__ ) ; if ( ( r = ssh_packet_set_state ( ssh , child_state ) ) != 0 ) fatal ( \"%s: packet_set_state: %s\" , __func__ , ssh_err ( r ) ) ; sshbuf_free ( child_state ) ; child_state = NULL ; if ( ( kex = ssh -> kex ) != NULL ) { # ifdef WITH_OPENSSL kex -> kex [ KEX_DH_GRP1_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA1 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP14_SHA256 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP16_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GRP18_SHA512 ] = kexdh_server ; kex -> kex [ KEX_DH_GEX_SHA1 ] = kexgex_server ; kex -> kex [ KEX_DH_GEX_SHA256 ] = kexgex_server ; kex -> kex [ KEX_ECDH_SHA2 ] = kexecdh_server ; # endif kex -> kex [ KEX_C25519_SHA256 ] = kexc25519_server ; kex -> load_host_public_key = & get_hostkey_public_by_type ; kex -> load_host_private_key = & get_hostkey_private_by_type ; kex -> host_key_index = & get_hostkey_index ; kex -> sign = sshd_hostkey_sign ; } <vul-start> if ( options . compression ) { <vul-end> ssh_packet_set_compress_hooks ( ssh , pmonitor -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> sshd_hostkey_sign ; } <vul-end> }    \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } if ( pmonitor -> m_zlib!= NULL && pmonitor -> m_compress_hooks!= NULL ) <vul-end> { ssh_packet_set_compress_hooks (\n"
 },
 {
  "id": 598,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void tree2tok ( struct vp9_token * tokens , const vp9_tree_index * tree , <vul-end> int i , int v , int l ) { v += v ; ++ l ; do { <vul-start> const vp9_tree_index j = tree [ i ++ ] ; <vul-end> if ( j <= 0 ) { tokens [ - j ] . value = v ; tokens [ - j ] . len = l ; } else { tree2tok ( tokens , tree , j , v , l ) ; } } while ( ++ v & 1 ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> tokens , const vpx_tree_index <vul-end> * tree , <vul-start> do { const vpx_tree_index <vul-end> j = tree\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> tree2tok ( struct vpx_token <vul-end> * tokens, <vul-start> tokens, const vpx_tree_index <vul-end> * tree, <vul-start> do { const vpx_tree_index <vul-end> j = tree\n"
 },
 {
  "id": 599,
  "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static void ndisc_router_discovery ( struct sk_buff * skb ) { struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; struct neighbour * neigh = NULL ; struct inet6_dev * in6_dev ; struct rt6_info * rt = NULL ; int lifetime ; struct ndisc_options ndopts ; int optlen ; unsigned int pref = 0 ; __u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; optlen = ( skb_tail_pointer ( skb ) - skb_transport_header ( skb ) ) - sizeof ( struct ra_msg ) ; ND_PRINTK ( 2 , info , \"RA: %s, dev: %s\\\\n\" , __func__ , skb -> dev -> name ) ; if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) ) { ND_PRINTK ( 2 , warn , \"RA: source address is not link-local\\\\n\" ) ; return ; } if ( optlen < 0 ) { ND_PRINTK ( 2 , warn , \"RA: packet too short\\\\n\" ) ; return ; } # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST ) { ND_PRINTK ( 2 , warn , \"RA: from host or unauthorized router\\\\n\" ) ; return ; } # endif in6_dev = __in6_dev_get ( skb -> dev ) ; if ( in6_dev == NULL ) { ND_PRINTK ( 0 , err , \"RA: can\\'t find inet6 device for %s\\\\n\" , skb -> dev -> name ) ; return ; } if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) ) { ND_PRINTK ( 2 , warn , \"RA: invalid",
  "golden_answers": [
   "CWE-17 Fixed Code Lines are: <vul-start> icmp6_hop_limit ) { if ( <vul-start> cnf . hop_limit < <vul-end> ra_msg -> icmph <vul-start> icmph . icmp6_hop_limit ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , \"RA: Got route advertisement with lower hop_limit than current\\\\n\" ) ; } <vul-end> if ( rt\n"
  ],
  "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> icmp6_hop_limit ) { if ( in6_dev -> cnf. hop_limit ) ND_PRINTK ( 2, info, \" RA: %s setting hop limit\\\\n\", __func__ ) ; else\n"
 },
 {
  "id": 600,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; union { int val ; struct linger ling ; struct timeval tm ; } v ; int lv = sizeof ( int ) ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; memset ( & v , 0 , sizeof ( v ) ) ; switch ( optname ) { case SO_DEBUG : v . val = sock_flag ( sk , SOCK_DBG ) ; break ; case SO_DONTROUTE : v . val = sock_flag ( sk , SOCK_LOCALROUTE ) ; break ; case SO_BROADCAST : v . val = ! ! sock_flag ( sk , SOCK_BROADCAST ) ; break ; case SO_SNDBUF : v . val = sk -> sk_sndbuf ; break ; case SO_RCVBUF : v . val = sk -> sk_rcvbuf ; break ; case SO_REUSEADDR : v . val = sk -> sk_reuse ; break ; case SO_KEEPALIVE : v . val = ! ! sock_flag ( sk , SOCK_KEEPOPEN ) ; break ; case SO_TYPE : v . val = sk -> sk_type ; break ; case SO_PROTOCOL : v . val = sk -> sk_protocol ; break ; case SO_DOMAIN : v . val = sk -> sk_family ; break ; case SO_ERROR : v . val = - sock_error ( sk ) ; if ( v .",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> . val = ! ! <vul-start> -> flags ) <vul-end> ; break ; <vul-start> . val = ! ! <vul-start> -> flags ) <vul-end> ; break ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. val = sk -> sk_passCRED <vul-end> ; break ; <vul-start>. val = sk -> sk_peer_cred -> user ; if ( copy_to_user ( & v. val, optval, len ) ) return - EFAULT ; goto lenout <vul-end> ; break ;\n"
 },
 {
  "id": 601,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int nfc_genl_deactivate_target ( struct sk_buff * skb , struct genl_info * info ) { struct nfc_dev * dev ; u32 device_idx , target_idx ; int rc ; <vul-start> if ( ! info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) <vul-end> return - EINVAL ; device_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_DEVICE_INDEX ] ) ; dev = nfc_get_device ( device_idx ) ; if ( ! dev ) return - ENODEV ; target_idx = nla_get_u32 ( info -> attrs [ NFC_ATTR_TARGET_INDEX ] ) ; rc = nfc_deactivate_target ( dev , target_idx , NFC_TARGET_MODE_SLEEP ) ; nfc_put_device ( dev ) ; return rc ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> int rc ; struct nfc_dev * slave_dev ; <vul-start> NFC_ATTR_DEVICE_INDEX ] ) { rc = - EINVAL ; goto out ; } <vul-end> device_idx = nla_get_u32\n"
 },
 {
  "id": 602,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static void sctp_generate_timeout_event ( struct sctp_association * asoc , sctp_event_timeout_t timeout_type ) { <vul-start> struct net * net = sock_net ( asoc -> base . sk ) ; <vul-end> int error = 0 ; <vul-start> bh_lock_sock ( asoc -> base . sk ) ; <vul-end> <vul-start> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <vul-end> pr_debug ( \"%s: sock is busy: timer %d\\\\n\" , __func__ , timeout_type ) ; if ( ! mod_timer ( & asoc -> timers [ timeout_type ] , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( timeout_type ) , asoc -> state , asoc -> ep , asoc , ( void * ) timeout_type , GFP_ATOMIC ) ; if ( error ) <vul-start> asoc -> base . sk -> sk_err = - error ; <vul-end> out_unlock : <vul-start> bh_unlock_sock ( asoc -> base . sk ) ; <vul-end> sctp_association_put ( asoc ) ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ) { struct sock * sk = asoc -> base . sk ; struct <vul-start> = sock_net ( <vul-end> sk ) ; <vul-start> ; bh_lock_sock ( <vul-end> sk ) ; <vul-start> ( sock_owned_by_user ( <vul-end> sk ) ) <vul-start> ( error ) <vul-end> sk -> sk_err <vul-start> : bh_unlock_sock ( <vul-end> sk ) ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> = sock_net ( asoc <vul-end> -> base. <vul-start> -> base. sock <vul-end> ) ; int <vul-start> = 0 ; if ( sock_owned_by_user ( asoc -> base. sk ) ) { pr_debug ( \"%s: sock is busy: timer %d\\\\n\", __func__, timeout_type ) ; if (! mod_timer ( & asoc -> timers [ timeout_type ], jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } <vul-end> error = sctp_do_sm <vul-start> ( error ) <vul-end> bh_unlock_sock ( asoc <vul-start> : bh_unlock_sock ( asoc <vul-end> -> base.\n"
 },
 {
  "id": 603,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void * <vul-start> xmalloc ( size_t size ) <vul-end> <vul-start> { <vul-end> <vul-start> void * ptr = malloc ( size ) ; <vul-end> if ( ! ptr && ( size != 0 ) ) { perror ( \"xmalloc: Memory allocation failure\" ) ; abort ( ) ; } return ptr ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> xmalloc ( size_t num , size_t <vul-start> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <vul-start> = malloc ( res <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start>       static <vul-start> size ) { size_t res ; if ( check_mul_overflow ( size, & res ) ) abort ( ) ; <vul-start> * ptr = safe_calloc <vul-end> ( size )\n"
 },
 {
  "id": 604,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void lzxd_free ( struct lzxd_stream * lzx ) { struct mspack_system * sys ; if ( lzx ) { sys = lzx -> sys ; <vul-start> sys -> free ( lzx -> inbuf ) ; <vul-end> sys -> free ( lzx -> window ) ; sys -> free ( lzx ) ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> sys ; if ( lzx -> inbuf ) <vul-start> inbuf ) ; if ( lzx -> window )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> sys ; if ( lzx -> inbuf ) <vul-start> -> inbuf ) ; if ( lzx -> window )\n"
 },
 {
  "id": 605,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 struct sk_buff * * udp_gro_receive ( struct sk_buff * * head , struct sk_buff * skb , struct udphdr * uh ) { struct udp_offload_priv * uo_priv ; struct sk_buff * p , * * pp = NULL ; struct udphdr * uh2 ; unsigned int off = skb_gro_offset ( skb ) ; int flush = 1 ; <vul-start> if ( NAPI_GRO_CB ( skb ) -> udp_mark || <vul-end> ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB ( skb ) -> csum_cnt == 0 && ! NAPI_GRO_CB ( skb ) -> csum_valid ) ) goto out ; <vul-start> NAPI_GRO_CB ( skb ) -> udp_mark = 1 ; <vul-end> rcu_read_lock ( ) ; uo_priv = rcu_dereference ( udp_offload_base ) ; for ( ; uo_priv != NULL ; uo_priv = rcu_dereference ( uo_priv -> next ) ) { if ( net_eq ( read_pnet ( & uo_priv -> net ) , dev_net ( skb -> dev ) ) && uo_priv -> offload -> port == uh -> dest && uo_priv -> offload -> callbacks . gro_receive ) goto unflush ; } goto out_unlock ; unflush : flush = 0 ; for ( p = * head ; p ; p = p -> next ) { if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; uh2 = ( struct udphdr * ) ( p -> data + off ) ; if ( ( * ( u32 * ) & uh -> source != * ( u32 * ) & uh2 -> source ) || ( ! uh -> check ^ ! uh2 -> check )",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> skb ) -> encap_mark <vul-end> || ( skb <vul-start> skb ) -> encap_mark <vul-end> = 1 ;\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ; if ( skb_is_gso ( skb ) || <vul-start> goto out ; if ( skb_is_gso ( skb ) ) { NAPI_GRO_CB ( skb ) -> udp_mark = 1 ; goto out_unlock ; }\n"
 },
 {
  "id": 606,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int64_t rd_pick_intra_sbuv_mode ( VP9_COMP * cpi , MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , TX_SIZE max_tx_size ) { MACROBLOCKD * xd = & x -> e_mbd ; <vul-start> MB_PREDICTION_MODE mode ; <vul-end> MB_PREDICTION_MODE mode_selected = DC_PRED ; int64_t best_rd = INT64_MAX , this_rd ; int this_rate_tokenonly , this_rate , s ; <vul-start> int64_t this_distortion , this_sse ; <vul-end> for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { if ( ! ( cpi -> sf . intra_uv_mode_mask [ max_tx_size ] & ( 1 << mode ) ) ) continue ; xd -> mi [ 0 ] -> mbmi . uv_mode = mode ; <vul-start> super_block_uvrd ( cpi , x , & this_rate_tokenonly , <vul-end> <vul-start> & this_distortion , & s , & this_sse , bsize , best_rd ) ; <vul-end> if ( this_rate_tokenonly == INT_MAX ) continue ; this_rate = this_rate_tokenonly + <vul-start> x -> intra_uv_mode_cost [ cpi -> common . frame_type ] [ mode ] ; <vul-end> this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ; if ( this_rd < best_rd ) { mode_selected = mode ; best_rd = this_rd ; * rate = this_rate ; * rate_tokenonly = this_rate_tokenonly ; * distortion = this_distortion ; * skippable = s ; <vul-start> if ( ! x -> select_txfm_size ) { <vul-end> int i ; struct macroblock_plane * const p = x -> plane ; struct macroblockd_plane * const pd = xd",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> e_mbd ; PREDICTION_MODE mode ; PREDICTION_MODE <vul-end> mode_selected = DC_PRED <vul-start> this_distortion , this_sse ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) <vul-start> = mode ; if ( ! <vul-start> , best_rd ) <vul-end> ) continue ; <vul-start> = this_rate_tokenonly + cpi <vul-end> -> intra_uv_mode_cost [ <vul-start> ! x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ; <vul-end> } } xd\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> e_mbd ; PREDICTION_MODE mode ; PREDICTION_MODE <vul-end> mode_selected = DC_PRED <vul-start>, s ; PREDICTION_MODE <vul-end> this_distortion, this_sse <vul-start> = mode ; if ( cpi -> oxcf. aq_mode!= VPX_Q ) { super_block_uvrd ( cpi, x, & this_rate_tokenonly, & this_distortion, & s, & this_sse, bsize, best_rd ) ; } else { super_block_uvrd ( cpi, x, <vul-end> x -> intra_uv_mode_cost <vul-start> mode ] ; } <vul-start> = s ; <vul-end> } xd ->\n"
 },
 {
  "id": 607,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_keyword ( PyObject * obj , keyword_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier arg ; expr_ty value ; <vul-start> if ( exists_not_none ( obj , & PyId_arg ) ) { <vul-end> int res ; <vul-start> tmp = _PyObject_GetAttrId ( obj , & PyId_arg ) ; <vul-end> if ( tmp == NULL ) goto failed ; <vul-start> res = obj2ast_identifier ( tmp , & arg , arena ) ; <vul-end> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> arg = NULL ; } if ( _PyObject_HasAttrId ( obj , & PyId_value ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_value ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"value\\\\\" missing from keyword\" ) ; return 1 ; } * out = keyword ( arg , value , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; arg = NULL ; } else <vul-end> { int res <vul-start> int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"value\\\\\" missing from keyword\" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value <vul-end> , arena ) <vul-start> ) ; } <vul-end> * out =\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> expr_ty value ; int flags = 0 ; <vul-start> obj, & flags <vul-end> ) ) { <vul-start> int res ; res = obj2ast_identifier ( tmp, & arg, arena, & flags ) ; if ( res!= 0 <vul-end> ) goto failed <vul-start> goto failed ; Py_CLEAR ( tmp ) ; } if ( flags & PyId_value ) { int res ; res = obj2ast_expr ( tmp, & value, arena, & flags ) ; if ( res!= 0 <vul-end> ) goto failed <vul-start> ) ; } <vul-end> * out =\n"
 },
 {
  "id": 608,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void sunkbd_enable ( struct sunkbd * sunkbd , bool enable ) { serio_pause_rx ( sunkbd -> serio ) ; sunkbd -> enabled = enable ; serio_continue_rx ( sunkbd -> serio ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> serio ) ; if ( ! enable ) { wake_up_interruptible ( & sunkbd -> wait ) ; cancel_work_sync ( & sunkbd -> tq ) ; }\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> serio ) ; if (! sunkbd -> enabled ) sunkbd_uninit ( sunkbd ) ;\n"
 },
 {
  "id": 609,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 <vul-start> static int read_fragment_table ( long long * directory_table_end ) <vul-end> { int res , i ; <vul-start> int bytes = SQUASHFS_FRAGMENT_BYTES ( sBlk . s . fragments ) ; <vul-end> <vul-start> int indexes = SQUASHFS_FRAGMENT_INDEXES ( sBlk . s . fragments ) ; <vul-end> long long fragment_table_index [ indexes ] ; TRACE ( \"read_fragment_table: %d fragments, reading %d fragment indexes \" \"from 0x%llx\\\\n\" , sBlk . s . fragments , indexes , sBlk . s . fragment_table_start ) ; <vul-start> if ( sBlk . s . fragments == 0 ) { <vul-end> * directory_table_end = sBlk . s . fragment_table_start ; return TRUE ; } fragment_table = malloc ( bytes ) ; if ( fragment_table == NULL ) EXIT_UNSQUASH ( \"read_fragment_table: failed to allocate \" \"fragment table\\\\n\" ) ; res = read_fs_bytes ( fd , sBlk . s . fragment_table_start , <vul-start> SQUASHFS_FRAGMENT_INDEX_BYTES ( sBlk . s . fragments ) , <vul-end> fragment_table_index ) ; if ( res == FALSE ) { ERROR ( \"read_fragment_table: failed to read fragment table \" \"index\\\\n\" ) ; return FALSE ; } SQUASHFS_INSWAP_FRAGMENT_INDEXES ( fragment_table_index , indexes ) ; for ( i = 0 ; i < indexes ; i ++ ) { int expected = ( i + 1 ) != indexes ? SQUASHFS_METADATA_SIZE : bytes & ( SQUASHFS_METADATA_SIZE - 1 ) ; int length = read_block ( fd , fragment_table_index [ i ] , NULL , expected , ( ( char * ) fragment_table ) + ( i * SQUASHFS_METADATA_SIZE ) ) ; TRACE ( \"Read fragment table block %d, from 0x%llx, length %d\\\\n\" , i",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> long long * table_start <vul-end> ) { int <vul-start> , i ; long long <vul-end> bytes = SQUASHFS_FRAGMENT_BYTES <vul-start> = SQUASHFS_FRAGMENT_BYTES ( ( long long ) <vul-start> = SQUASHFS_FRAGMENT_INDEXES ( ( long long ) sBlk . s . fragments ) ; int length = SQUASHFS_FRAGMENT_INDEX_BYTES ( ( long long ) sBlk . s . fragments ) ; long long * fragment_table_index ; if ( length != ( * table_start - sBlk . s . fragment_table_start ) ) { ERROR ( \"read_fragment_table: Bad fragment count in super block\\\\n\" ) ; return FALSE ; } <vul-end> TRACE ( \"read_fragment_table: %d fragments, reading %d fragment indexes \" <vul-start> fragment_table_start ) ; fragment_table_index = alloc_index_table ( indexes ) ; <vul-end> fragment_table = malloc <vul-start> . fragment_table_start , length <vul-end> , fragment_table_index ) <vul-start> ) ; * table_start <vul-end> = fragment_table_index [\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> int read_fragment_table ( struct squASHfs_directory_table <vul-end> * directory_table_end ) <vul-start> int bytes = SQUASHFS_fragments_BYTES <vul-end> ( sBlk. <vul-start> int indexes = SQUASHFS_FRAGMENT_INDEXES <vul-end> ( sBlk. <vul-start> s. fragments ) ; struct squASHfs_directory_table * directory_table = sBlk. s. directory_table <vul-end> ; long long <vul-start> fragment_table_start ) ; <vul-end> fragment_table = malloc <vul-start>. fragment_table_start, SQUASHFS_FRAGMENT_INDEX_BYTES <vul-end> ( sBlk. <vul-start>. fragments ), directory_table_end ) ; if ( directory_table == NULL ) EXIT_UNSQUASH ( \"read_fragment_table: failed to allocate \" \"fragment table\\\\n\" ) ; res = read_fs_bytes ( fd, sBlk. s. fragment_table_start, SQUASHFS_FRAGMENT_INDEX_BYTES ( sBlk. s. fragments )\n"
 },
 {
  "id": 610,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int ras_getcmap ( jas_stream_t * in , ras_hdr_t * hdr , ras_cmap_t * cmap ) { int i ; int j ; int x ; int c ; int numcolors ; int actualnumcolors ; switch ( hdr -> maptype ) { case RAS_MT_NONE : break ; case RAS_MT_EQUALRGB : { jas_eprintf ( \"warning: palettized images not fully supported\\\\n\" ) ; numcolors = 1 << hdr -> depth ; <vul-start> assert ( numcolors <= RAS_CMAP_MAXSIZ ) ; <vul-end> actualnumcolors = hdr -> maplength / 3 ; for ( i = 0 ; i < numcolors ; i ++ ) { cmap -> data [ i ] = 0 ; } if ( ( hdr -> maplength % 3 ) || hdr -> maplength < 0 || hdr -> maplength > 3 * numcolors ) { return - 1 ; } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < actualnumcolors ; j ++ ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } x = 0 ; switch ( i ) { case 0 : x = RAS_RED ( c ) ; break ; case 1 : x = RAS_GREEN ( c ) ; break ; case 2 : x = RAS_BLUE ( c ) ; break ; } cmap -> data [ j ] |= x ; } } } break ; default : return - 1 ; break ; } return 0 ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> -> depth ; if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <vul-end> actualnumcolors = hdr\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> -> depth ; if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <vul-end> actualnumcolors = hdr\n"
 },
 {
  "id": 611,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int efind ( name ) char * name ; { static char efbuf [ 100 ] ; my_regex_t re ; <vul-start> sprintf ( efbuf , \"REG_%s\" , name ) ; <vul-end> assert ( strlen ( efbuf ) < sizeof ( efbuf ) ) ; re . re_endp = efbuf ; ( void ) my_regerror ( REG_ATOI , & re , efbuf , sizeof ( efbuf ) ) ; return ( atoi ( efbuf ) ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> my_regex_t re ; snprintf ( efbuf , sizeof ( efbuf ) <vul-end> , \"REG_%s\" ,\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> my_regex_t re ; my_snprintf <vul-end> ( efbuf, <vul-start> ( efbuf, sizeof ( efbuf ),\n"
 },
 {
  "id": 612,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; <vul-start> if ( img ) <vul-end> <vul-start> res = validate_img ( ctx , img ) ; <vul-end> pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = \"Conflicting flags.\" ; return VPX_CODEC_INVALID_PARAM ; } <vul-start> if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | <vul-end> VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ; vp9_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_GF ) upd ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_UPD_ARF ) upd ^= VP9_ALT_FLAG ; vp9_update_reference ( ctx -> cpi , upd ) ; } if ( flags & VP8_EFLAG_NO_UPD_ENTROPY ) { vp9_update_entropy ( ctx -> cpi , 0 ) ; } if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = VPX_CODEC_OK ; VP9_COMP * const cpi = ctx -> cpi ; const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ; size_t data_sz ; <vul-start> if ( img != NULL ) { <vul-end> res = validate_img <vul-start> img ) ; if ( res == VPX_CODEC_OK && cpi != NULL ) { data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ; if ( data_sz < 4096 ) data_sz = 4096 ; if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) { ctx -> cx_data_sz = data_sz ; free ( ctx -> cx_data ) ; ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ; if ( ctx -> cx_data == NULL ) { return VPX_CODEC_MEM_ERROR ; } } } } <vul-start> VPX_CODEC_INVALID_PARAM ; } vp9_apply_encoding_flags ( cpi , flags ) ; <vul-end> if ( ctx <vul-start> == VPX_CODEC_OK && <vul-end> cpi != NULL <vul-start> unsigned int lib_flags = 0 <vul-start> ; int64_t dst_time_stamp = timebase_units_to_ticks ( timebase , pts ) ; int64_t dst_end_time_stamp = timebase_units_to_ticks ( timebase , pts + duration ) <vul-end> ; size_t size <vul-start> & VPX_CODEC_USE_PSNR ) cpi <vul-end> -> b_calculate_psnr = <vul-start> b_calculate_psnr = 1 <vul-end> ; if ( <vul-start> ( vp9_receive_raw_frame ( cpi , flags | ctx -> next_frame_flags <vul-end> , & sd <vul-start> ) ) { <vul-end> res = update_error_state <vul-start> ) ; } ctx -> next_frame_flags = 0 ; <vul-start> ctx -> cx_data_sz <vul-end> ; if ( <vul-start> != vp9_get_compressed_data ( <vul-end> cpi , & <vul-start> size ) { <vul-end> vpx_codec_cx_pkt_t pkt ; <vul-start> vpx_codec_cx_pkt_t pkt ; # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc ) cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] . layer_size += size ; # endif if ( ! <vul-end> cpi -> common <vul-start> common . show_frame || ( cpi -> use_svc && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) <vul-end> ) { if <vul-start> -= size ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) { pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ; pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , <vul-end> dst_end_time_stamp - dst_time_stamp <vul-start> ; pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ; pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = size ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; } continue ; } pkt . <vul-start> . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) <vul-end> ; pkt . <vul-start> unsigned long ) ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp <vul-end> ) ; pkt <vul-start> . flags = get_frame_pkt_flags ( cpi , lib_flags ) <vul-end> ; if ( <vul-start> += size ; if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) <vul-start> - 1 ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; else <vul-start> -= size ; # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) { vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ; int sl ; vp9_zero ( pkt_sizes ) ; vp9_zero ( pkt_psnr ) ; pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ; pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ; for ( sl = 0 ; sl < cpi -> svc . number_spatial_layers ; ++ sl ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ; pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ; pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ; lc -> layer_size = 0 ; } vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ; } # endif # endif if ( is_one_pass_cbr_svc ( cpi ) && ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) { break ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = VPX_CODEC_OK ; int has_key = 0 ; <vul-start> ( img ) { <vul-start> img ) ; has_key = 1 ; } <vul-start> } if ( has_key ) { if ( <vul-start> VPX_CODEC_INVALID_PARAM ; } } <vul-start> / 2 && ( <vul-start> & lib_flags, ( flags & VPX_EFLAG_NO_REF_LAST ) && ( flags & VPX_EFLAG_NO_REF_GF ) && ( flags & VPX_EFLAG_NO_REF_ARF ) ) { <vul-start> ; if ( cpi -> common. show_frame == 0 ) { if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ; ctx -> pending_cx_data_sz += size ; ctx -> pending_frame_magnitude |= size ; if ( flags & VPX_EFLAG_FORCE_KF ) { ctx -> base. err_detail = \"Conflicting flags.\" ; return VPX_CODEC_INVALID_PARAM ; } } else { <vul-end> if ( cpi <vul-start> & VP9_COMP * <vul-end> cpi = ( <vul-start> VPX_CODEC_CX_FRAME_PKT ; if ( <vul-start>. pts = <vul-end> dst_time_stamp * ctx <vul-start>. g_timebase. num <vul-end> - 1 ; <vul-start> / 2 ; if ( ( flags & VP8_EFLAG_NO_UPD_LAST ) && <vul-start> ) ) { ctx -> base. err_detail = \"No need to send data.\" ; return VPX_CODEC_ERROR ; } <vul-start>. duration = 0 ; } else { unsigned int <vul-start> lib_flags, & has_key, & <vul-start> dst_time_stamp, deadline, & has_key ) ; } <vul-end> if ( ctx <vul-start> += size ; if ( has_key ) { ctx -> base. err_detail = \"No data for key.\" ; return VPX_CODEC_ERROR ; } <vul-end> } if ( <vul-start>. frame. pts = round ; ctx -> base."
 },
 {
  "id": 613,
  "question": "CWE-191 Code Input Vulnerable Code Is: CWE-191 void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = \"`\\\\\"\\\\\\\\\" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \\'\"\\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { <vul-start> dlen -= 2 ; <vul-end> if ( dlen == 0 ) break ; * pt ++ = '\\\\\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \\'\"\\' ; * pt = '\\\\0' ; }",
  "golden_answers": [
   "CWE-191 Fixed Code Lines are: <vul-start> ) ) { if ( dlen < 2 ) break ; <vul-start> dlen -= 2 <vul-end> ; * pt\n"
  ],
  "generated_answer": "CWE-191 Fixed Code Lines are: <vul-start> ) ) { if ( dlen < 2 ) break ;\n"
 },
 {
  "id": 614,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else {",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> slow ) ; cond_resched ( ) <vul-end> ; msg ->\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> slow ) ; cond_resched ( ) <vul-end> ; msg ->\n"
 },
 {
  "id": 615,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static __u8 * nci_extract_rf_params_nfcb_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcb_poll * nfcb_poll , __u8 * data ) { <vul-start> nfcb_poll -> sensb_res_len = * data ++ ; <vul-end> pr_debug ( \"sensb_res_len %d\\\\n\" , nfcb_poll -> sensb_res_len ) ; memcpy ( nfcb_poll -> sensb_res , data , nfcb_poll -> sensb_res_len ) ; data += nfcb_poll -> sensb_res_len ; return data ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> sensb_res_len = min_t ( __u8 , <vul-start> * data ++ , NFC_SENSB_RES_MAXSIZE )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> data ) { if ( nfcb_poll -> sensb_res_len > NFCB_MAX_Sensb_RES_LEN ) { pr_err ( \"%s: Invalid sensb res length %d\\\\n\", __func__, nfcb_poll -> sensb_res_len ) ; return NULL ; }\n"
 },
 {
  "id": 616,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; <vul-start> ctx -> clockid = clockid ; <vul-end> if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( \"[timerfd]\" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> wqh ) ; spin_lock_init ( & ctx -> lock ) ;\n"
 },
 {
  "id": 617,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ; <vul-start> struct mount * child , * p ; <vul-end> struct hlist_node * n ; int err ; <vul-start> if ( IS_MNT_SHARED ( dest_mnt ) ) { <vul-end> err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <vul-start> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <vul-end> lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; <vul-start> umount_tree ( child",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ) ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <vul-start> ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt <vul-end> ) ; if <vul-start> goto out ; } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <vul-start> mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <vul-start> ; out : ns -> pending_mounts = 0 ;\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ) ; struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <vul-start> int err ; lock_mount_hash ( ) ; if ( parent_path ) { detach_mnt ( source_mnt, parent_path ) ; attach_mnt ( source_mnt, dest_mnt, dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt, dest_mp, source_mnt ) ; } err = check_mounts_shared ( source_mnt, parent_path, & user_ns ) ; if ( err ) goto out ; err = validate_user_ns ( source_mnt, user_ns ) ; if ( err ) goto out ; <vul-start>, & tree_list <vul-end> ) ; } <vul-start> mnt_hash ) ; if ( child -> mnt_parent -> mnt. mnt_ns!= user_ns ) { mnt_set_mountpoint ( child -> mnt_parent -> mnt. mnt_ns, dest_mnt ) ; commit_tree ( child, parent_ns ) ; } unlock_mount_hash ( ) ; return err <vul-end> ; }  \n"
 },
 {
  "id": 618,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb , * skb_prev = NULL ; <vul-start> unsigned int maxfraglen , fragheaderlen ; <vul-end> int exthdrlen ; int dst_exthdrlen ; <vul-start> int hh_len ; <vul-end> int mtu ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kzalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ;",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> maxfraglen , fragheaderlen , mtu <vul-start> ; int hh_len <vul-end> ; int copy <vul-start> skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ; unsigned int fragheaderlen ; unsigned int <vul-start> ; int hh_len ; int opt_flen <vul-start> ) ; } opt_flen = sizeof ( struct ipv6_txoptions ) + sizeof ( struct frag_hdr ) + transhdrlen + fraggap ; if ( opt_flen > 0 && getfrag ( from, opt_flen, & opt -> opt_dst, opt_flen ) ) return - EINVAL ; <vul-start>, fl6, opt_flen, <vul-start>. opt -> opt_dst, opt_flen, <vul-end> rt ) ; <vul-start>. opt -> opt_from, opt_flen, <vul-end> rt ) ;\n"
 },
 {
  "id": 619,
  "question": "CWE-665 Code Input Vulnerable Code Is: CWE-665 int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <vul-start> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <vul-end> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( \"%s is not a valid .CAF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( \"%s: can\\'t handle version %d .CAF files!\" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( \"%s is not a valid .CAF file!\"",
  "golden_answers": [
   "CWE-665 Fixed Code Lines are: <vul-start> { uint32_t chan_chunk = 0 , desc_chunk <vul-start> , CAFAudioFormatFormat ) ; desc_chunk = 1 <vul-start> if ( ! desc_chunk || !\n"
  ],
  "generated_answer": "CWE-665 Fixed Code Lines are: <vul-start> config ) { int format_chunk = 0 ; <vul-start> CAFAudioFormatFormat ) ; if ( caf_audio_format. mFormatID > 0x10000 ) { error_line ( \"format = %s is not a valid.CAF file!\", infilename ) ; return WAVPACK_SOFT_ERROR ; } <vul-start> } if ( format_chunk!= 0 &&\n"
 },
 {
  "id": 620,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int cost_segmap ( int * segcounts , vp9_prob * probs ) { <vul-end> const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ; const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ; const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ; const int c67 = segcounts [ 6 ] + segcounts [ 7 ] ; const int c0123 = c01 + c23 ; const int c4567 = c45 + c67 ; int cost = c0123 * vp9_cost_zero ( probs [ 0 ] ) + c4567 * vp9_cost_one ( probs [ 0 ] ) ; if ( c0123 > 0 ) { cost += c01 * vp9_cost_zero ( probs [ 1 ] ) + c23 * vp9_cost_one ( probs [ 1 ] ) ; if ( c01 > 0 ) cost += segcounts [ 0 ] * vp9_cost_zero ( probs [ 3 ] ) + segcounts [ 1 ] * vp9_cost_one ( probs [ 3 ] ) ; if ( c23 > 0 ) cost += segcounts [ 2 ] * vp9_cost_zero ( probs [ 4 ] ) + segcounts [ 3 ] * vp9_cost_one ( probs [ 4 ] ) ; } if ( c4567 > 0 ) { cost += c45 * vp9_cost_zero ( probs [ 2 ] ) + c67 * vp9_cost_one ( probs [ 2 ] ) ; if ( c45 > 0 ) cost += segcounts [ 4 ] * vp9_cost_zero ( probs [ 5 ] ) + segcounts [ 5 ] * vp9_cost_one (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * segcounts , vpx_prob <vul-end> * probs )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * segcounts, vpx_prob <vul-end> * probs )\n"
 },
 {
  "id": 621,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void accumulate_frame_motion_stats ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame , double * this_frame_mv_in_out , double * mv_in_out_accumulator , double * abs_mv_in_out_accumulator , double * mv_ratio_accumulator ) { double this_frame_mvr_ratio ; double this_frame_mvc_ratio ; double motion_pct ; <vul-start> motion_pct = this_frame -> pcnt_motion ; <vul-end> * this_frame_mv_in_out = this_frame -> mv_in_out_count * motion_pct ; * mv_in_out_accumulator += this_frame -> mv_in_out_count * motion_pct ; * abs_mv_in_out_accumulator += fabs ( this_frame -> mv_in_out_count * motion_pct ) ; if ( motion_pct > 0.05 ) { this_frame_mvr_ratio = fabs ( this_frame -> mvr_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVr ) ) ; this_frame_mvc_ratio = fabs ( this_frame -> mvc_abs ) / DOUBLE_DIVIDE_CHECK ( fabs ( this_frame -> MVc ) ) ; * mv_ratio_accumulator += ( this_frame_mvr_ratio < this_frame -> mvr_abs ) ? ( this_frame_mvr_ratio * motion_pct ) : this_frame -> mvr_abs * motion_pct ; * mv_ratio_accumulator += ( this_frame_mvc_ratio < this_frame -> mvc_abs ) ? ( this_frame_mvc_ratio * motion_pct ) : this_frame -> mvc_abs * motion_pct ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> double motion_pct ; ( void ) cpi ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = this_frame -> pcnt_motion_pct <vul-end> ; * this_frame_mv_in_out\n"
 },
 {
  "id": 622,
  "question": "CWE-674 Code Input Vulnerable Code Is: CWE-674 static krb5_error_code decode_sequence_of ( const uint8_t * asn1 , size_t len , const struct atype_info * elemtype , void * * seq_out , size_t * count_out ) { krb5_error_code ret ; void * seq = NULL , * elem , * newseq ; const uint8_t * contents ; size_t clen , count = 0 ; taginfo t ; * seq_out = NULL ; * count_out = 0 ; while ( len > 0 ) { <vul-start> ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len ) ; <vul-end> if ( ret ) goto error ; if ( ! check_atype_tag ( elemtype , & t ) ) { ret = ASN1_BAD_ID ; goto error ; } newseq = realloc ( seq , ( count + 1 ) * elemtype -> size ) ; if ( newseq == NULL ) { ret = ENOMEM ; goto error ; } seq = newseq ; elem = ( char * ) seq + count * elemtype -> size ; memset ( elem , 0 , elemtype -> size ) ; ret = decode_atype ( & t , contents , clen , elemtype , elem ) ; if ( ret ) goto error ; count ++ ; } * seq_out = seq ; * count_out = count ; return 0 ; error : free_sequence_of ( elemtype , seq , count ) ; free ( seq ) ; return ret ; }",
  "golden_answers": [
   "CWE-674 Fixed Code Lines are: <vul-start> , & len , 0\n"
  ],
  "generated_answer": "CWE-674 Fixed Code Lines are: <vul-start>, & len, 0\n"
 },
 {
  "id": 623,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void fadst16_8col ( __m128i * in ) { <vul-end> __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ; const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ; const __m128i k__cospi_p31_m01 = pair_set_epi16 ( cospi_31_64 , - cospi_1_64 ) ; const __m128i k__cospi_p05_p27 = pair_set_epi16 ( cospi_5_64 , cospi_27_64 ) ; const __m128i k__cospi_p27_m05 = pair_set_epi16 ( cospi_27_64 , - cospi_5_64 ) ; const __m128i k__cospi_p09_p23 = pair_set_epi16 ( cospi_9_64 , cospi_23_64 ) ; const __m128i k__cospi_p23_m09 = pair_set_epi16 ( cospi_23_64 , - cospi_9_64 ) ; const __m128i k__cospi_p13_p19 = pair_set_epi16 ( cospi_13_64 , cospi_19_64 ) ; const __m128i k__cospi_p19_m13 = pair_set_epi16 ( cospi_19_64 , - cospi_13_64 ) ; const __m128i k__cospi_p17_p15 = pair_set_epi16 ( cospi_17_64 , cospi_15_64 ) ; const __m128i k__cospi_p15_m17 = pair_set_epi16 ( cospi_15_64 , - cospi_17_64 ) ; const __m128i k__cospi_p21_p11 = pair_set_epi16 ( cospi_21_64 , cospi_11_64 ) ; const __m128i k__cospi_p11_m21 = pair_set_epi16 ( cospi_11_64 , - cospi_21_64 ) ; const __m128i k__cospi_p25_p07 = pair_set_epi16 ( cospi_25_64 , cospi_7_64 ) ; const __m128i k__cospi_p07_m25 = pair_set_epi16 ( cospi_7_64 , - cospi_25_64 ) ; const __m128i k__cospi_p29_p03 = pair_set_epi16 ( cospi_29_64 , cospi_3_64 ) ; const __m128i k__cospi_p03_m29 = pair_set_epi16 ( cospi_3_64 , - cospi_29_64 ) ; const __m128i k__cospi_p04_p28 = pair_set_epi16 ( cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p28_m04 = pair_set_epi16 ( cospi_28_64 , - cospi_4_64 ) ; const __m128i k__cospi_p20_p12 = pair_set_epi16 ( cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p12_m20 = pair_set_epi16 ( cospi_12_64 , - cospi_20_64 ) ; const __m128i k__cospi_m28_p04 =",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>       static <vul-start> = _mm_set1_epi16 ( ( int16_t ) <vul-start> = _mm_set1_epi16 ( ( int16_t )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>       static <vul-start> = _mm_set1_epi16 ( ( int16_t ) <vul-start> = _mm_set1_epi16 ( ( int16_t ) <vul-start> 2 ] = _mm_madd1_epi16 <vul-end> ( u [ <vul-start> 3 ] = _mm_madd1_epi16 <vul-end> ( u [\n"
 },
 {
  "id": 624,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , \"Unable to create %snotify fifo %s\" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <vul-start> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <vul-end> log_message ( LOG_INFO , \"Unable to open %snotify fifo %s - errno %d\" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> -> fd = TEMP_FAILURE_RETRY ( <vul-start> | O_NONBLOCK ) )\n"
 },
 {
  "id": 625,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 static int try_read_command_binary ( conn * c ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { memcpy ( & c -> binary_header , c -> rcurr , sizeof ( c -> binary_header ) ) ; protocol_binary_request_header * req ; req = & c -> binary_header ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , \"<%d Read binary protocol data:\" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , \"\\\\n<%d \" , c -> sfd ) ; } fprintf ( stderr , \" 0x%02x\" , req -> bytes [ ii ] ) ; } fprintf ( stderr , \"\\\\n\" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen ) ; c -> binary_header . request . cas = ntohll ( req -> request . cas ) ; if ( c -> binary_header . request . magic != PROTOCOL_BINARY_REQ ) { if ( settings . verbose ) { fprintf ( stderr , \"Invalid magic: %x\\\\n\" , c -> binary_header . request . magic ) ; } conn_set_state ( c , conn_closing ) ; return - 1 ; } uint8_t extlen = c -> binary_header",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> ) + BIN_MAX_EXTLEN + 1 <vul-start> binary_header ) , extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN :\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> = current_time ; int extlen = <vul-end> sizeof ( c <vul-start> ) + BIN_MAX_EXTLEN ; if ( extlen > BIN_MAX_EXTLEN ) { fprintf ( stderr, \"Invalid extlen: %d\\\\n\", extlen ) ; return - 1 ; } memcpy ( extbuf + sizeof ( c -> binary_header ) <vul-start> binary_header ), c -> rcurr + sizeof ( c -> binary_header ) + extlen + keylen <vul-end> ) ; c\n"
 },
 {
  "id": 626,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static void add_bytes_c ( uint8_t * dst , uint8_t * src , int w ) { long i ; <vul-start> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <vul-end> long a = * ( long * ) ( src + i ) ; long b = * ( long * ) ( dst + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] += src [ i + 0 ] ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> <= w - ( int )\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> <= w - ( int )\n"
 },
 {
  "id": 627,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void * H264SwDecMalloc ( u32 size ) <vul-end> { <vul-start> return malloc ( size ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <vul-end> return malloc ( <vul-start> malloc ( size * num\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( u32 size, u32 num ) { if ( size > UINT32_MAX / num ) { ALOGE ( \"can\\'t allocate %u * %u bytes\", size, num ) ; android_errorWriteLog ( 0x534e4554, \"27855419\" ) ; return NULL ; } <vul-end> return malloc ( <vul-start> malloc ( size * num\n"
 },
 {
  "id": 628,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static void feed_table_block_tag ( struct table * tbl , char * line , struct table_mode * mode , int indent , int cmd ) { int offset ; if ( mode -> indent_level <= 0 && indent == - 1 ) return ; if ( mode -> indent_level >= CHAR_MAX && indent == 1 ) return ; setwidth ( tbl , mode ) ; feed_table_inline_tag ( tbl , line , mode , - 1 ) ; clearcontentssize ( tbl , mode ) ; if ( indent == 1 ) { mode -> indent_level ++ ; if ( mode -> indent_level <= MAX_INDENT_LEVEL ) tbl -> indent += INDENT_INCR ; } else if ( indent == - 1 ) { mode -> indent_level -- ; if ( mode -> indent_level < MAX_INDENT_LEVEL ) tbl -> indent -= INDENT_INCR ; } <vul-start> offset = tbl -> indent ; <vul-end> if ( cmd == HTML_DT ) { if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ; <vul-start> } <vul-end> if ( tbl -> indent > 0 ) { check_minimum0 ( tbl , 0 ) ; addcontentssize ( tbl , offset ) ; } }",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> INDENT_INCR ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <vul-start> -= INDENT_INCR ; if ( offset < 0 ) offset = 0 ;\n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> INDENT_INCR ; } if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) { tbl -> indent_level -- ; if ( mode -> indent_level < MAX_INDENT_LEVEL ) tbl -> indent_level = MAX_INDENT_LEVEL ; } <vul-start> -= INDENT_INCR ; if ( offset > 0 ) { if ( offset < 0 ) addcontentssize ( tbl, - 1 ) ; } else { if ( offset < 0 ) addcontentssize ( tbl, INDENT_INCR ) ; }\n"
 },
 {
  "id": 629,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static RList * r_bin_wasm_get_element_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmElementEntry * ptr = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <vul-start> ut32 len = sec -> payload_len ; <vul-end> ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; <vul-start> while ( i < len && r < count ) { <vul-end> if ( ! ( ptr = R_NEW0 ( RBinWasmElementEntry ) ) ) { return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> index , & i ) ) ) { <vul-start> free ( ptr ) ; <vul-end> return ret ; } if ( ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { <vul-start> free ( ptr ) ; <vul-end> return ret ; } if ( ! ( consume_u32 ( buf + i , buf + len , & ptr -> num_elem , & i ) ) ) { <vul-start> free ( ptr ) ; <vul-end> return ret ; } ut32 j = 0 ; while ( i < len && j < ptr -> num_elem ) { ut32 e ; if ( ! ( consume_u32 ( buf + i , buf + len , & e , & i",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <vul-start> i < len && len < buflen <vul-start> ) ) { goto beach <vul-end> ; } if <vul-start> ) ) { goto beach <vul-end> ; } if <vul-start> ) ) { goto beach <vul-end> ; } ut32 <vul-start> return ret ; beach : free ( ptr ) ; return ret ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <vul-end> ; ut32 count <vul-start> i < len && len < buflen <vul-start> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <vul-end> ; } if <vul-start> ) ) { goto beach <vul-end> ; } if <vul-start> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <vul-end> ; } ut32 <vul-start> return ret ; beach : free ( ptr ) ; return ret ;\n"
 },
 {
  "id": 630,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 public int magic_setparam ( struct magic_set * ms , int param , const void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : ms -> indir_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_NAME_MAX : ms -> name_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : ms -> elf_phnum_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : ms -> elf_shnum_max = * ( const size_t * ) val ; return 0 ; <vul-start> default : <vul-end> errno = EINVAL ; return - 1 ; } }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> return 0 ; case MAGIC_PARAM_ELF_SHNUM_MIN : ms -> elf_shnum_min = * ( const size_t * ) val ; return 0 ;\n"
 },
 {
  "id": 631,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) { <vul-end> <vul-start> int64_t max_bits = ( ( int64_t ) rc -> av_per_frame_bandwidth * <vul-end> ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ; if ( max_bits < 0 ) max_bits = 0 ; else if ( max_bits > rc -> max_frame_bandwidth ) max_bits = rc -> max_frame_bandwidth ; return ( int ) max_bits ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> rc , const VP9EncoderConfig <vul-end> * oxcf ) <vul-start> ) rc -> avg_frame_bandwidth <vul-end> * ( int64_t\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int frame_max_bits ( ThreadData * td ) { <vul-end> const VP9_CONFIG * <vul-start> VP9_CONFIG * oxcf = & td -> oxcf ; const int64_t avg_frame_bandwidth = ( int64_t ) td -> avg_frame_bandwidth ; const int64_t two_pass_vbrmax_section = oxcf -> two_pass_vbrmax_section ; if ( avg_frame_bandwidth < 0 ) avg_frame_bandwidth = 0 ; else if ( avg_frame_bandwidth > oxcf -> two_pass_vbrmax_section ) { avg_frame_bandwidth = oxcf -> two_pass_vbrmax_section ; } return max_bits <vul-end> ; }  \n"
 },
 {
  "id": 632,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void nodeConstruct ( struct SaveNode * node , tr_variant const * v , bool sort_dicts ) { node -> isVisited = false ; node -> childIndex = 0 ; if ( sort_dicts && tr_variantIsDict ( v ) ) { size_t const n = v -> val . l . count ; struct KeyIndex * tmp = tr_new ( struct KeyIndex , n ) ; for ( size_t i = 0 ; i < n ; i ++ ) { tmp [ i ] . val = v -> val . l . vals + i ; tmp [ i ] . keystr = tr_quark_get_string ( tmp [ i ] . val -> key , NULL ) ; } qsort ( tmp , n , sizeof ( struct KeyIndex ) , compareKeyIndex ) ; <vul-start> tr_variantInitDict ( & node -> sorted , n ) ; <vul-end> for ( size_t i = 0 ; i < n ; ++ i ) { <vul-start> node -> sorted . val . l . vals [ i ] = * tmp [ i ] . val ; <vul-end> } <vul-start> node -> sorted . val . l . count = n ; <vul-end> tr_free ( tmp ) ; <vul-start> node -> v = & node -> sorted ; <vul-end> } else { <vul-start> node -> v = v ; <vul-end> } }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> compareKeyIndex ) ; node -> sorted = tr_new ( tr_variant , 1 ) ; tr_variantInitDict ( <vul-end> node -> sorted <vul-start> node -> sorted -> <vul-end> val . l <vul-start> node -> sorted -> <vul-end> val . l <vul-start> tmp ) ; v = <vul-end> node -> sorted <vul-start> { node -> sorted = NULL ; } node -> v = v ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> compareKeyIndex ) ; if ( node -> sorted!= NULL ) { <vul-start> n ) ; } <vul-start> i ) { tmp [ i ]. <vul-end> val = * <vul-start> val ; } tmp [ i ]. <vul-end> val. l <vul-start> node -> sorted = tmp ; tr_free ( tmp ) <vul-start> } else { tr_free ( node -> sorted ) ;\n"
 },
 {
  "id": 633,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ;",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
 },
 {
  "id": 634,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ; int number_extensionss = 0 ; MagickBooleanType status ; RectangleInfo page ; register ssize_t i ; register unsigned char * p ; size_t delay , dispose , duration , global_colors , image_count , iterations , one ; ssize_t count , opacity ; unsigned char background , c , flag , * global_colormap , buffer [ 257 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 6 , buffer ) ; if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) buffer ,",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ResourceLimitError , \"MemoryAllocationFailed\" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) NULL ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; <vul-start> \"MemoryAllocationFailed\" ) ; }\n"
 },
 {
  "id": 635,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static mif_hdr_t * mif_hdr_get ( jas_stream_t * in ) { <vul-start> uchar magicbuf [ MIF_MAGICLEN ] ; <vul-end> char buf [ 4096 ] ; mif_hdr_t * hdr ; bool done ; jas_tvparser_t * tvp ; int id ; hdr = 0 ; tvp = 0 ; if ( jas_stream_read ( in , magicbuf , MIF_MAGICLEN ) != MIF_MAGICLEN ) { goto error ; } if ( magicbuf [ 0 ] != ( MIF_MAGIC >> 24 ) || magicbuf [ 1 ] != ( ( MIF_MAGIC >> 16 ) & 0xff ) || magicbuf [ 2 ] != ( ( MIF_MAGIC >> 8 ) & 0xff ) || magicbuf [ 3 ] != ( MIF_MAGIC & 0xff ) ) { jas_eprintf ( \"error: bad signature\\\\n\" ) ; goto error ; } if ( ! ( hdr = mif_hdr_create ( 0 ) ) ) { goto error ; } done = false ; do { if ( ! mif_getline ( in , buf , sizeof ( buf ) ) ) { jas_eprintf ( \"mif_getline failed\\\\n\" ) ; goto error ; } if ( buf [ 0 ] == '\\\\0' ) { continue ; } JAS_DBGLOG ( 10 , ( \"header line: len=%d; %s\\\\n\" , strlen ( buf ) , buf ) ) ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { jas_eprintf ( \"jas_tvparser_create failed\\\\n\" ) ; goto error ; } if ( jas_tvparser_next ( tvp ) ) { jas_eprintf ( \"cannot get record type\\\\n\" ) ; goto error ; } id = jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags2 , jas_tvparser_gettag ( tvp",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> in ) { jas_uchar <vul-end> magicbuf [ MIF_MAGICLEN\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> in ) { jas_uchar <vul-end> magicbuf [ MIF_MAGICLEN\n"
 },
 {
  "id": 636,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int rfcomm_get_dev_list ( void __user * arg ) { struct rfcomm_dev * dev ; struct rfcomm_dev_list_req * dl ; struct rfcomm_dev_info * di ; int n = 0 , size , err ; u16 dev_num ; BT_DBG ( \"\" ) ; if ( get_user ( dev_num , ( u16 __user * ) arg ) ) return - EFAULT ; if ( ! dev_num || dev_num > ( PAGE_SIZE * 4 ) / sizeof ( * di ) ) return - EINVAL ; size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; <vul-start> dl = kmalloc ( size , GFP_KERNEL ) ; <vul-end> if ( ! dl ) return - ENOMEM ; di = dl -> dev_info ; spin_lock ( & rfcomm_dev_lock ) ; list_for_each_entry ( dev , & rfcomm_dev_list , list ) { if ( test_bit ( RFCOMM_TTY_RELEASED , & dev -> flags ) ) continue ; ( di + n ) -> id = dev -> id ; ( di + n ) -> flags = dev -> flags ; ( di + n ) -> state = dev -> dlc -> state ; ( di + n ) -> channel = dev -> channel ; bacpy ( & ( di + n ) -> src , & dev -> src ) ; bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; if ( ++ n >= dev_num ) break ; } spin_unlock ( & rfcomm_dev_lock ) ; dl -> dev_num = n ; size = sizeof (",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; dl = kzalloc <vul-end> ( size ,\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; dl = kzalloc <vul-end> ( size,\n"
 },
 {
  "id": 637,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void otp_verify ( krb5_context context , krb5_data * req_pkt , krb5_kdc_req * request , krb5_enc_tkt_part * enc_tkt_reply , krb5_pa_data * pa , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_verify_respond_fn respond , void * arg ) { krb5_keyblock * armor_key = NULL ; krb5_pa_otp_req * req = NULL ; struct request_state * rs ; krb5_error_code retval ; krb5_data d , plaintext ; char * config ; <vul-start> enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ; <vul-end> armor_key = cb -> fast_armor ( context , rock ) ; if ( armor_key == NULL ) { retval = KRB5KDC_ERR_PREAUTH_FAILED ; com_err ( \"otp\" , retval , \"No armor key found when verifying padata\" ) ; goto error ; } d = make_data ( pa -> contents , pa -> length ) ; retval = decode_krb5_pa_otp_req ( & d , & req ) ; if ( retval != 0 ) { com_err ( \"otp\" , retval , \"Unable to decode OTP request\" ) ; goto error ; } retval = decrypt_encdata ( context , armor_key , req , & plaintext ) ; if ( retval != 0 ) { com_err ( \"otp\" , retval , \"Unable to decrypt nonce\" ) ; goto error ; } retval = nonce_verify ( context , armor_key , & plaintext ) ; if ( retval != 0 ) retval = timestamp_verify ( context , & plaintext ) ; krb5_free_data_contents ( context , & plaintext ) ; if ( retval != 0 ) { com_err ( \"otp\" , retval , \"Unable to verify nonce or timestamp\" ) ; goto error ; } rs",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> * config ; <vul-end> armor_key = cb <vul-start> respond = respond ; rs -> enc_tkt_reply = enc_tkt_reply\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> * config ; unsigned int flags = 0 ; <vul-start> |= TKT_FLG_PRE_AUTH ; flags |= ( request -> flags & KDC_REQ_FLAG_PRIVACY )? 0 : KRB5_FLG_HIGHBITDEPTH ; <vul-start> config ) ; if ( retval == 0 && flags & KRB5_FLG_HIGHBITDEPTH ) { rs -> flags |= TKT_FLG_HIGHBITDEPTH ; if ( cb -> get_string ( context, rock, \"otp\", & config ) == 0 ) retval = KRB5_PREAUTH_FAILED ; else if ( cb -> get_string ( context, rock, \"otp\", & config ) == 0 ) retval = KRB5_PREAUTH_FAILED ; } else { <vul-start> = respond ; }\n"
 },
 {
  "id": 638,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; <vul-start> init_thread : <vul-end> fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , \"f2fs_flush-%u:%u\" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> = fcc ; SM_I ( sbi ) -> last_cmd_type = FLUSH_CTL_NONE ;\n"
 },
 {
  "id": 639,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void <vul-end> byteSwap ( UWORD32 * buf , unsigned words ) { md5byte * p ; int i = 1 ; if ( * ( char * ) & i == 1 ) return ; p = ( md5byte * ) buf ; do { * buf ++ = ( UWORD32 ) ( ( unsigned ) p [ 3 ] << 8 | p [ 2 ] ) << 16 | ( ( unsigned ) p [ 1 ] << 8 | p [ 0 ] ) ; p += 4 ; } while ( -- words ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>       static\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>       static\n"
 },
 {
  "id": 640,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 uint8_t ethereum_extractThorchainData ( const EthereumSignTx * msg , char * buffer ) { uint16_t offset = 4 + ( 5 * 32 ) ; int16_t len = msg -> data_length - offset ; <vul-start> if ( msg -> has_data_length && len > 0 ) { <vul-end> memcpy ( buffer , msg -> data_initial_chunk . bytes + offset , len ) ; <vul-start> return len < 256 ? ( uint8_t ) len : 0 ; <vul-end> } return 0 ; }",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> len > 0 && len < 256 <vul-start> ) ; return <vul-end> ( uint8_t ) <vul-start> uint8_t ) len <vul-end> ; } return\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> ( msg -> data_length > 0 && len < 256 <vul-end> ) { memcpy <vul-start> len ) ; } return len <vul-end> ; }  \n"
 },
 {
  "id": 641,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static MYSQL * db_connect ( char * host , char * database , char * user , char * passwd ) { MYSQL * mysql ; if ( verbose ) fprintf ( stdout , \"Connecting to %s\\\\n\" , host ? host : \"localhost\" ) ; if ( ! ( mysql = mysql_init ( NULL ) ) ) return 0 ; if ( opt_compress ) mysql_options ( mysql , MYSQL_OPT_COMPRESS , NullS ) ; if ( opt_local_file ) mysql_options ( mysql , MYSQL_OPT_LOCAL_INFILE , ( char * ) & opt_local_file ) ; <vul-start> # ifdef HAVE_OPENSSL <vul-end> if ( opt_use_ssl ) { mysql_ssl_set ( mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; # endif if ( opt_protocol ) mysql_options ( mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( mysql , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; mysql_options ( mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( mysql , MYSQL_OPT_CONNECT_ATTR_ADD ,",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> opt_local_file ) ; SSL_SET_OPTIONS ( mysql ) ; <vul-end> if ( opt_protocol\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> opt_local_file ) ; SSL_SET_OPTIONS ( mysql ) ; <vul-end> if ( opt_protocol\n"
 },
 {
  "id": 642,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int isoent_gen_joliet_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) { struct iso9660 * iso9660 ; struct isoent * np ; unsigned char * p ; size_t l ; int r ; <vul-start> int ffmax , parent_len ; <vul-end> static const struct archive_rb_tree_ops rb_ops = { isoent_cmp_node_joliet , isoent_cmp_key_joliet } ; if ( isoent -> children . cnt == 0 ) return ( 0 ) ; iso9660 = a -> format_data ; if ( iso9660 -> opt . joliet == OPT_JOLIET_LONGNAME ) ffmax = 206 ; else ffmax = 128 ; <vul-start> r = idr_start ( a , idr , isoent -> children . cnt , ffmax , 6 , 2 , & rb_ops ) ; <vul-end> if ( r < 0 ) return ( r ) ; parent_len = 1 ; for ( np = isoent ; np -> parent != np ; np = np -> parent ) parent_len += np -> mb_len + 1 ; for ( np = isoent -> children . first ; np != NULL ; np = np -> chnext ) { unsigned char * dot ; int ext_off , noff , weight ; size_t lt ; <vul-start> if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax ) <vul-end> l = ffmax ; p = malloc ( ( l + 1 ) * 2 ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ENOMEM , \"Can\\'t allocate memory\" ) ; return ( ARCHIVE_FATAL",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> int r ; size_t <vul-end> ffmax , parent_len <vul-start> . cnt , ( int ) <vul-start> if ( ( <vul-end> l = np <vul-start> ; if ( <vul-end> np -> file <vul-start> if ( parent_len > 240 || <vul-end> np -> mb_len <vul-start> mb_len > 240 || parent_len + np -> mb_len > 240 <vul-start> } if ( <vul-end> l == ffmax <vul-start> else if ( <vul-end> l == ffmax <vul-start> else if ( <vul-end> l == ffmax\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ffmax, parent_len ; int mbmax <vul-start> = 128 ; mbmax = 6 ; if ( a -> format_data == ARCHIVE_DATA_V1 ) mbmax = 1024 ; <vul-start>. cnt, mbmax <vul-end>, 6, <vul-start> size_t lt ; archive_set_error ( & a -> archive, ENOMEM, \"Can\\'t allocate memory\" ) ; return ( ARCHIVE_FATAL ) ; } if ( ( int ) np -> file -> basename_utf16. length > ffmax ) { archive_set_error ( & a -> archive, ENOMEM, \"Invalid ISO-file name\" ) ; return ( ARCHIVE_FATAL ) ; } <vul-end> noff = ext_off <vul-start> ) l == mbmax <vul-end> ) noff = <vul-start> - 6 ; if ( ( int ) l == mbmax <vul-end> - 2 ) <vul-start> else if ( ( int ) l == mbmax <vul-end> - 4 ) <vul-start> else if ( ( int ) l == mbmax <vul-end> - 2 )\n"
 },
 {
  "id": 643,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_set_active_map ( VP8_COMP * cpi , unsigned char * map , unsigned int rows , unsigned int cols ) { if ( rows == cpi -> common . mb_rows && cols == cpi -> common . mb_cols ) { if ( map ) { <vul-start> vpx_memcpy ( cpi -> active_map , map , rows * cols ) ; <vul-end> cpi -> active_map_enabled = 1 ; } else cpi -> active_map_enabled = 0 ; return 0 ; } else { return - 1 ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> map ) { memcpy <vul-end> ( cpi ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> map ) { memcpy <vul-end> ( cpi ->\n"
 },
 {
  "id": 644,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <vul-start> bool valid_handle ; <vul-end> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <vul-start> valid_handle = ion_handle_validate ( client , handle ) ; <vul-end> if ( ! valid_handle ) { WARN ( 1 , \"%s: invalid handle passed to free.\\\\n\" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <vul-start> return ; <vul-end> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> handle ) { <vul-end> BUG_ON ( client <vul-start> lock ) ; ion_free_nolock <vul-end> ( client , <vul-start> client , handle <vul-end> ) ; mutex_unlock <vul-start> lock ) ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> handle ) { <vul-end> BUG_ON ( client <vul-start> lock ) ; ion_free_nolock ( client, handle <vul-end> ) ; mutex_unlock <vul-start> ) ; return <vul-end> ; }  \n"
 },
 {
  "id": 645,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void umount_tree ( struct mount * mnt , enum umount_tree_flags how ) { LIST_HEAD ( tmp_list ) ; struct mount * p ; if ( how & UMOUNT_PROPAGATE ) propagate_mount_unlock ( mnt ) ; for ( p = mnt ; p ; p = next_mnt ( p , mnt ) ) { p -> mnt . mnt_flags |= MNT_UMOUNT ; list_move ( & p -> mnt_list , & tmp_list ) ; } list_for_each_entry ( p , & tmp_list , mnt_list ) { list_del_init ( & p -> mnt_child ) ; } if ( how & UMOUNT_PROPAGATE ) propagate_umount ( & tmp_list ) ; while ( ! list_empty ( & tmp_list ) ) { <vul-start> bool disconnect ; <vul-end> p = list_first_entry ( & tmp_list , struct mount , mnt_list ) ; list_del_init ( & p -> mnt_expire ) ; list_del_init ( & p -> mnt_list ) ; <vul-start> __touch_mnt_namespace ( p -> mnt_ns ) ; <vul-end> p -> mnt_ns = NULL ; if ( how & UMOUNT_SYNC ) p -> mnt . mnt_flags |= MNT_SYNC_UMOUNT ; disconnect = disconnect_mount ( p , how ) ; pin_insert_group ( & p -> mnt_umount , & p -> mnt_parent -> mnt , disconnect ? & unmounted : NULL ) ; if ( mnt_has_parent ( p ) ) { mnt_add_count ( p -> mnt_parent , - 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { umount_mnt ( p ) ; } } change_mnt_propagation ( p , MS_PRIVATE ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ) ) { struct mnt_namespace * ns ; <vul-start> mnt_list ) ; ns = p -> mnt_ns ; if ( ns ) { ns -> mounts -- ; __touch_mnt_namespace ( ns ) ; } <vul-end> p -> mnt_ns\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ) ) { int disconnect ; struct mount * p_tmp ; <vul-start> mnt_list ) ; list_for_each_entry_safe ( p_tmp, p, & p -> mnt_child, mnt_child ) { disconnect = disconnect_mount ( p_tmp, how ) ; pin_insert_group ( & p -> mnt_umount, & p -> mnt_parent -> mnt, disconnect? & unmounted : NULL ) ; } list_add_tail ( & p -> mnt_child, & p -> mnt_parent -> mnt_mounts ) ; } <vul-end> if ( how\n"
 },
 {
  "id": 646,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void show_object ( struct object * object , struct strbuf * path , <vul-end> <vul-start> const char * last , void * data ) <vul-end> { struct bitmap * base = data ; bitmap_set ( base , find_object_pos ( object -> oid . hash ) ) ; mark_as_seen ( object ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * object , <vul-end> const char * <vul-start> const char * name <vul-end> , void *\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * object, <vul-end> const char * <vul-start> const char * name <vul-end>, void *\n"
 },
 {
  "id": 647,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void tree_to_node ( void * data , BLOCK_SIZE bsize , variance_node * node ) { int i ; <vul-start> switch ( bsize ) { <vul-end> case BLOCK_64X64 : { v64x64 * vt = ( v64x64 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_32X32 : { v32x32 * vt = ( v32x32 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_16X16 : { v16x16 * vt = ( v16x16 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] . part_variances . none ; break ; } case BLOCK_8X8 : { v8x8 * vt = ( v8x8 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) <vul-start> node -> split [ i ] = & vt -> split [ i ] ; <vul-end> break ; } default : { assert ( 0 ) ; <vul-start>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int i ; node -> part_variances = NULL ; <vul-start> [ i ] . part_variances . none ; break ; } case BLOCK_4X4 : { v4x4 * vt = ( v4x4 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] <vul-start> 0 ) ; break ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int i ; int split_size ; <vul-start> i ++ ) { <vul-start> split [ i ] ; split_size = ( i + 4 * sizeof ( v64x64 ) ) / sizeof ( v64x64 ) ; } <vul-end> break ; } <vul-start> 0 ) ; split_size = ( i + 4 * sizeof ( v16x16 ) ) / sizeof ( v16x16 ) ; <vul-start> ) ; } split_size = ( i + 4 * sizeof ( v32x32 ) ) / sizeof ( v32x32 ) ;\n"
 },
 {
  "id": 648,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void copy_and_extend_plane ( const uint8_t * src , int src_pitch , uint8_t * dst , int dst_pitch , int w , int h , int extend_top , int extend_left , int extend_bottom , int extend_right ) { int i , linesize ; const uint8_t * src_ptr1 = src ; const uint8_t * src_ptr2 = src + w - 1 ; uint8_t * dst_ptr1 = dst - extend_left ; uint8_t * dst_ptr2 = dst + w ; for ( i = 0 ; i < h ; i ++ ) { <vul-start> vpx_memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; <vul-end> <vul-start> vpx_memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; <vul-end> vpx_memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; src_ptr1 += src_pitch ; src_ptr2 += src_pitch ; dst_ptr1 += dst_pitch ; dst_ptr2 += dst_pitch ; } src_ptr1 = dst - extend_left ; src_ptr2 = dst + dst_pitch * ( h - 1 ) - extend_left ; dst_ptr1 = dst + dst_pitch * ( - extend_top ) - extend_left ; dst_ptr2 = dst + dst_pitch * ( h ) - extend_left ; linesize = extend_left + extend_right + w ; for ( i = 0 ; i < extend_top ; i ++ ) { <vul-start> vpx_memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; <vul-end> dst_ptr1 += dst_pitch ; } for ( i = 0 ; i < extend_bottom ; i ++ ) { <vul-start> vpx_memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; <vul-end> dst_ptr2 += dst_pitch ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memset <vul-end> ( dst_ptr1 , <vul-start> extend_left ) ; memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; memset <vul-end> ( dst_ptr2 , <vul-start> ++ ) { memcpy <vul-end> ( dst_ptr1 , <vul-start> ++ ) { memcpy <vul-end> ( dst_ptr2 ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memset <vul-end> ( dst_ptr1, <vul-start> extend_left ) ; memcpy ( dst_ptr1 + extend_left, src_ptr1, w ) ; memset <vul-end> ( dst_ptr2, <vul-start> ++ ) { memcpy <vul-end> ( dst_ptr1, <vul-start> ++ ) { memcpy <vul-end> ( dst_ptr2,\n"
 },
 {
  "id": 649,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 RCMS * r_pkcs7_parse_cms ( const ut8 * buffer , ut32 length ) { RASN1Object * object ; RCMS * container ; if ( ! buffer || ! length ) { return NULL ; } container = R_NEW0 ( RCMS ) ; if ( ! container ) { return NULL ; } object = r_asn1_create_object ( buffer , length ) ; <vul-start> if ( ! object || object -> list . length != 2 || ! object -> list . objects [ 0 ] || object -> list . objects [ 1 ] -> list . length != 1 ) { <vul-end> r_asn1_free_object ( object ) ; free ( container ) ; return NULL ; } container -> contentType = r_asn1_stringify_oid ( object -> list . objects [ 0 ] -> sector , object -> list . objects [ 0 ] -> length ) ; r_pkcs7_parse_signeddata ( & container -> signedData , object -> list . objects [ 1 ] -> list . objects [ 0 ] ) ; r_asn1_free_object ( object ) ; return container ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || <vul-end> object -> list\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> length!= 1 ||! object -> list. objects [ 0 ]\n"
 },
 {
  "id": 650,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int rawv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; struct sk_buff * skb ; size_t copied ; int err ; if ( flags & MSG_OOB ) <vul-start> return - EOPNOTSUPP ; <vul-end> if ( addr_len ) * addr_len = sizeof ( * sin6 ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } if ( skb_csum_unnecessary ( skb ) ) { err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else if ( msg -> msg_flags & MSG_TRUNC ) { if ( __skb_checksum_complete ( skb ) ) goto csum_copy_err ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else { err = skb_copy_and_csum_datagram_iovec ( skb , 0 , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> return - EOPNOTSUPP <vul-end> ; if ( <vul-start> ) -> iif ) ; * addr_len = sizeof ( * sin6\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> return - EOPNOTSUPP <vul-end> ; if ( <vul-start> ) -> iif ) ; * addr_len = sizeof ( * sin6\n"
 },
 {
  "id": 651,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t dm9000ReceivePacket ( NetInterface * interface ) { error_t error ; size_t i ; size_t n ; size_t length ; volatile uint8_t status ; volatile uint16_t data ; Dm9000Context * context ; context = ( Dm9000Context * ) interface -> nicContext ; <vul-start> data = dm9000ReadReg ( DM9000_REG_MRCMDX ) ; <vul-end> <vul-start> DM9000_INDEX_REG = DM9000_REG_MRCMDX1 ; <vul-end> status = LSB ( DM9000_DATA_REG ) ; if ( status == 0x01 ) { <vul-start> DM9000_INDEX_REG = DM9000_REG_MRCMD ; <vul-end> status = MSB ( DM9000_DATA_REG ) ; length = DM9000_DATA_REG ; n = MIN ( length , ETH_MAX_FRAME_SIZE ) ; i = 0 ; <vul-start> if ( ( status & ( RSR_LCS | RSR_RWTO | RSR_PLE | RSR_AE | RSR_CE | RSR_FOE ) ) == 0 ) <vul-end> { while ( ( i + 1 ) < n ) { data = DM9000_DATA_REG ; context -> rxBuffer [ i ++ ] = LSB ( data ) ; context -> rxBuffer [ i ++ ] = MSB ( data ) ; } if ( ( i + 1 ) == n ) { data = DM9000_DATA_REG ; context -> rxBuffer [ i ] = LSB ( data ) ; i += 2 ; } error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } while ( i < length ) { data = DM9000_DATA_REG ; i += 2 ; } } else { error = ERROR_BUFFER_EMPTY ; } if ( ! error ) { NetRxAncillary ancillary ; ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; } return",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> = dm9000ReadReg ( DM9000_MRCMDX <vul-end> ) ; DM9000_INDEX_REG <vul-start> ; DM9000_INDEX_REG = DM9000_MRCMDX1 <vul-end> ; status = <vul-start> { DM9000_INDEX_REG = DM9000_MRCMD <vul-end> ; status = <vul-start> status & ( DM9000_RSR_LCS | DM9000_RSR_RWTO | DM9000_RSR_PLE | DM9000_RSR_AE | DM9000_RSR_CE | DM9000_RSR_FOE <vul-end> ) ) ==\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = dm9000ReadReg ( DM9000_MRCMDX ) ; DM9000_INDEX_REG = DM9000_MRCMDX1 <vul-end> ; status = <vul-start> 0x01 ) { <vul-end> status = MSB <vul-start> ; if ( i < length &&\n"
 },
 {
  "id": 652,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> return NULL ; <vul-end> i = 0 <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD <vul-start> ; if ( <vul-end> TYPE ( CHILD\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> + nkwonlyargs > NCH ( n ) <vul-end> ) { ast_error <vul-start> + nkwonlyargs > NCH ( n ) <vul-end> ) { ast_error <vul-start> && TYPE ( CHILD ( n, i ) ) == COMMA && TYPE ( <vul-start> ; if ( ( i < NCH ( n ) && <vul-start> ) == TYPE_COMMENT )\n"
 },
 {
  "id": 653,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( IS_ERR_OR_NULL ( mp ) ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } <vul-start> else umount_tree ( mnt , 0 ) ; <vul-end> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ( mnt , UMOUNT_CONNECTED <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> } } else { struct mount * p, * tmp ; list_for_each_entry_safe ( p, tmp, & mnt -> mnt_mounts, mnt_child ) { hlist_add_head ( & p -> mnt_umount. s_list, & unmounted ) ; umount_mnt ( p ) ; } } <vul-end> } unlock_mount_hash (\n"
 },
 {
  "id": 654,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 SecureElementStatus_t SecureElementProcessJoinAccept ( JoinReqIdentifier_t joinReqType , uint8_t * joinEui , uint16_t devNonce , uint8_t * encJoinAccept , uint8_t encJoinAcceptSize , uint8_t * decJoinAccept , uint8_t * versionMinor ) { if ( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) ) { <vul-start> return SECURE_ELEMENT_ERROR_NPE ; <vul-end> } KeyIdentifier_t encKeyID = NWK_KEY ; if ( joinReqType != JOIN_REQ ) { encKeyID = J_S_ENC_KEY ; } memcpy1 ( decJoinAccept , encJoinAccept , encJoinAcceptSize ) ; if ( SecureElementAesEncrypt ( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE , encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE , encKeyID , decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_ENCRYPT ; } * versionMinor = ( ( decJoinAccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; uint32_t mic = 0 ; mic = ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ] << 0 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1 ] << 8 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2 ] << 16 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3 ] << 24 ) ; if ( * versionMinor == 0 ) { if ( SecureElementVerifyAesCmac ( decJoinAccept , ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ) , mic , NWK_KEY ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_CMAC ; } } # if ( USE_LRWAN_1_1_X_CRYPTO == 1 ) else if ( * versionMinor == 1 ) { uint8_t micHeader11 [ JOIN_ACCEPT_MIC_COMPUTATION_OFFSET ] = { 0 } ; uint16_t bufItr =",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE\n"
 },
 {
  "id": 655,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , u_int16_t subsys_id ) { struct sk_buff * oskb = skb ; struct net * net = sock_net ( skb -> sk ) ; const struct nfnetlink_subsystem * ss ; const struct nfnl_callback * nc ; static LIST_HEAD ( err_list ) ; u32 status ; int err ; if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ; replay : status = 0 ; skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; if ( ! skb ) return netlink_ack ( oskb , nlh , - ENOMEM ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) { # ifdef CONFIG_MODULES nfnl_unlock ( subsys_id ) ; request_module ( \"nfnetlink-subsys-%d\" , subsys_id ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) # endif { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } } if ( ! ss -> commit || ! ss -> abort ) { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } while ( skb -> len >= nlmsg_total_size ( 0 ) ) { int msglen , type ; nlh = nlmsg_hdr ( skb ) ; err = 0 ; <vul-start> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <vul-end> skb ->",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <vul-start> struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <vul-end> ; } if\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( skb -> len < nlh -> nlmsg_len ||\n"
 },
 {
  "id": 656,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , \"unable to get BOS descriptor\\\\n\" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , buffer , total_len ) ; if ( ret < total_len ) { dev_err ( ddev , \"unable to get BOS descriptor set\\\\n\" ) ; if ( ret >= 0 ) ret = - ENOMSG ;",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <vul-end> cap -> bLength <vul-start> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <vul-end> ; total_len -=\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) buffer ; if ( total_len < sizeof ( * cap ) ) break ;\n"
 },
 {
  "id": 657,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int ape_read_header ( AVFormatContext * s , AVFormatParameters * ap ) { AVIOContext * pb = s -> pb ; APEContext * ape = s -> priv_data ; AVStream * st ; uint32_t tag ; int i ; int total_blocks ; int64_t pts ; ape -> junklength = 0 ; tag = avio_rl32 ( pb ) ; if ( tag != MKTAG ( 'M' , 'A' , 'C' , ' ' ) ) return - 1 ; ape -> fileversion = avio_rl16 ( pb ) ; if ( ape -> fileversion < APE_MIN_VERSION || ape -> fileversion > APE_MAX_VERSION ) { av_log ( s , AV_LOG_ERROR , \"Unsupported file version - %d.%02d\\\\n\" , ape -> fileversion / 1000 , ( ape -> fileversion % 1000 ) / 10 ) ; return - 1 ; } if ( ape -> fileversion >= 3980 ) { ape -> padding1 = avio_rl16 ( pb ) ; ape -> descriptorlength = avio_rl32 ( pb ) ; ape -> headerlength = avio_rl32 ( pb ) ; ape -> seektablelength = avio_rl32 ( pb ) ; ape -> wavheaderlength = avio_rl32 ( pb ) ; ape -> audiodatalength = avio_rl32 ( pb ) ; ape -> audiodatalength_high = avio_rl32 ( pb ) ; ape -> wavtaillength = avio_rl32 ( pb ) ; avio_read ( pb , ape -> md5 , 16 ) ; if ( ape -> descriptorlength > 52 ) avio_seek ( pb , ape -> descriptorlength - 52 , SEEK_CUR ) ; ape -> compressiontype = avio_rl16 ( pb ) ; ape -> formatflags = avio_rl16 ( pb",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> } if ( ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , \"No frames in the file!\\\\n\" ) ; return AVERROR ( EINVAL ) ; } if (\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> -> totalframes > UINT32_MAX <vul-end> / sizeof (\n"
 },
 {
  "id": 658,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void Huff_transmit ( huff_t * huff , int ch , byte * fout ) { <vul-end> int i ; if ( huff -> loc [ ch ] == NULL ) { <vul-start> Huff_transmit ( huff , NYT , fout ) ; <vul-end> for ( i = 7 ; i >= 0 ; i -- ) { add_bit ( ( char ) ( ( ch >> i ) & 0x1 ) , fout ) ; } } else { <vul-start> send ( huff -> loc [ ch ] , NULL , fout ) ; <vul-end> } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> byte * fout , int maxoffset <vul-start> NYT , fout , maxoffset <vul-start> NULL , fout , maxoffset\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> byte * fout, int maxoffset <vul-start> NYT, fout, maxoffset <vul-start> NULL, fout, maxoffset\n"
 },
 {
  "id": 659,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int prob_diff_update_cost ( vp9_prob newp , vp9_prob oldp ) { <vul-end> int delp = remap_prob ( newp , oldp ) ; return update_bits [ delp ] * 256 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int prob_diff_update_cost ( vpx_prob newp , vpx_prob <vul-end> oldp ) {\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int prob_diff_update_cost ( vpx_prob newp, vpx_prob <vul-end> oldp ) {\n"
 },
 {
  "id": 660,
  "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static av_cold int rl2_read_header ( AVFormatContext * s ) { AVIOContext * pb = s -> pb ; AVStream * st ; unsigned int frame_count ; unsigned int audio_frame_counter = 0 ; unsigned int video_frame_counter = 0 ; unsigned int back_size ; unsigned short sound_rate ; unsigned short rate ; unsigned short channels ; unsigned short def_sound_size ; unsigned int signature ; unsigned int pts_den = 11025 ; unsigned int pts_num = 1103 ; unsigned int * chunk_offset = NULL ; int * chunk_size = NULL ; int * audio_size = NULL ; int i ; int ret = 0 ; avio_skip ( pb , 4 ) ; back_size = avio_rl32 ( pb ) ; signature = avio_rb32 ( pb ) ; avio_skip ( pb , 4 ) ; frame_count = avio_rl32 ( pb ) ; if ( back_size > INT_MAX / 2 || frame_count > INT_MAX / sizeof ( uint32_t ) ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 2 ) ; sound_rate = avio_rl16 ( pb ) ; rate = avio_rl16 ( pb ) ; channels = avio_rl16 ( pb ) ; def_sound_size = avio_rl16 ( pb ) ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RL2 ; st -> codecpar -> codec_tag = 0 ; st -> codecpar -> width = 320 ; st -> codecpar -> height = 200 ; st -> codecpar -> extradata_size = EXTRADATA1_SIZE ; if ( signature == RLV3_TAG &&",
  "golden_answers": [
   "CWE-834 Fixed Code Lines are: <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> pb ) ; } <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> pb ) ; } <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> & 0xFFFF ; }\n"
  ],
  "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> pb ) ; } <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> pb ) ; } <vul-start> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <vul-start> & 0xFFFF ; }\n"
 },
 {
  "id": 661,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int parseFileInner ( MaState * state , cchar * path ) { MaDirective * directive ; char * tok , * key , * line , * value ; assert ( state ) ; assert ( path && * path ) ; if ( openConfig ( state , path ) < 0 ) { return MPR_ERR_CANT_OPEN ; } for ( state -> lineNumber = 1 ; state -> file && ( line = mprReadLine ( state -> file , 0 , NULL ) ) != 0 ; state -> lineNumber ++ ) { for ( tok = line ; isspace ( ( uchar ) * tok ) ; tok ++ ) ; if ( * tok == '\\\\0' || * tok == '#' ) { continue ; } state -> key = 0 ; <vul-start> key = getDirective ( line , & value ) ; <vul-end> if ( ! state -> enabled ) { if ( key [ 0 ] != '<' ) { continue ; } } if ( ( directive = mprLookupKey ( directives , key ) ) == 0 ) { mprLog ( \"error appweb config\" , 0 , \"Unknown directive \\\\\"%s\\\\\". At line %d in %s\" , key , state -> lineNumber , state -> filename ) ; return MPR_ERR_BAD_SYNTAX ; } state -> key = key ; mprPauseGC ( ) ; if ( ( * directive ) ( state , key , value ) < 0 ) { mprResumeGC ( ) ; mprLog ( \"error appweb config\" , 0 , \"Error with directive \\\\\"%s\\\\\". At line %d in %s\"",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> = 0 ; if ( ( <vul-start> & value ) ) == 0 ) { continue ; } <vul-end> if ( !\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, & value, 0\n"
 },
 {
  "id": 662,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t decoder_set_fb_fn ( vpx_codec_alg_priv_t * ctx , vpx_get_frame_buffer_cb_fn_t cb_get , vpx_release_frame_buffer_cb_fn_t cb_release , void * cb_priv ) { if ( cb_get == NULL || cb_release == NULL ) { return VPX_CODEC_INVALID_PARAM ; <vul-start> } else if ( ctx -> pbi == NULL ) { <vul-end> ctx -> get_ext_fb_cb = cb_get ; ctx -> release_ext_fb_cb = cb_release ; ctx -> ext_priv = cb_priv ; return VPX_CODEC_OK ; } return VPX_CODEC_ERROR ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( ctx -> frame_workers <vul-end> == NULL )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> else if ( get_ext_fb_cb ( ctx ) == NULL && release_ext_fb_cb ( ctx, cb_priv ) == NULL ) return VPX_CODEC_INVALID_PARAM ; <vul-end> return VPX_CODEC_ERROR ;\n"
 },
 {
  "id": 663,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_superblock ( VP9_COMP * cpi , TOKENEXTRA * * t , int output_enabled , <vul-end> <vul-start> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <vul-end> VP9_COMMON * const cm = & cpi -> common ; <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * * mi_8x8 = xd -> mi ; MODE_INFO * mi = mi_8x8 [ 0 ] ; MB_MODE_INFO * mbmi = & mi -> mbmi ; <vul-start> PICK_MODE_CONTEXT * ctx = get_block_context ( x , bsize ) ; <vul-end> unsigned int segment_id = mbmi -> segment_id ; const int mis = cm -> mi_stride ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; <vul-start> x -> skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 && <vul-end> cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ; <vul-start> x -> skip_optimize = ctx -> is_coded ; <vul-end> ctx -> is_coded = 1 ; x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ; x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ; if ( x -> skip_encode ) return ; <vul-start> if ( cm -> frame_type == KEY_FRAME ) { <vul-end> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) { adjust_act_zbin ( cpi , x ) ; vp9_update_zbin_extra ( cpi , x )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cpi , ThreadData * td , <vul-start> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <vul-start> x = & td <vul-end> -> mb ; <vul-start> -> mbmi ; const int seg_skip = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) <vul-end> ; const int <vul-start> ! x -> select_tx_size <vul-end> && mbmi -> <vul-start> . allow_skip_recode ; if ( ! x -> skip_recode && ! cpi -> sf . use_nonrd_pick_mode ) memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; <vul-start> ; if ( ! is_inter_block ( mbmi ) ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; if ( output_enabled ) sum_intra_stats ( td -> counts , mi ) ; vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; <vul-end> } else { <vul-start> } else { int ref ; const int is_compound = has_second_ref ( mbmi ) ; <vul-start> [ 1 ] <vul-end> ) ; for <vul-start> ] ) ; assert ( cfg != NULL ) ; <vul-start> ) ; } if ( ! ( cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ) || seg_skip ) vp9_build_inter_predictors_sby <vul-end> ( xd , <vul-start> ) ) ; vp9_build_inter_predictors_sbuv ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) <vul-end> ; vp9_encode_sb ( <vul-start> vp9_tokenize_sb ( cpi , td <vul-start> ) ) ; <vul-end> } if ( <vul-start> -> skip || seg_skip <vul-end> ) ) ) <vul-start> bsize ] , get_tx_size_context <vul-end> ( xd ) <vul-start> ) , & td -> counts -> <vul-end> tx ) [ <vul-start> tx_size ; } ++ td -> counts -> tx . tx_totals [ mbmi -> tx_size ] ; ++ td -> counts -> tx . tx_totals [ get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ] ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, ThreadData * td, <vul-start>, BLOCK_SIZE bsize, PC_TREE * pc_tree <vul-start> x = & td <vul-end> -> mb ; <vul-start> ; PICK_MODE_CONTEXT * const <vul-start> bsize ] ; const <vul-start> ; x -> <vul-end> use_lp32x32fdct = cpi <vul-start> ; if ( td <vul-end> -> frame_type == <vul-start> KEY_FRAME ) { set_ref_ptrs ( cm, x, xd, mbmi -> ref_frame [ 0 ], mbmi -> ref_frame [ 1 ] ) ; if ( cpi -> oxcf. tuning == VP8_TUNE_SSIM ) { vp9_encode_sb ( x, MIN ( bsize, BLOCK_8X8 ) ) ; } else { set_ref_ptrs ( cm, x, xd, mbmi -> ref_frame [ 0 ], mbmi -> ref_frame [ 1 ] ) ; } } else { mbmi -> skip = 1 ; if ( output_enabled ) cm -> counts -> skip [ vp9_get_skip_context ( xd ) ] [ 1 ] ++ ; reset_skip_context ( xd, MAX ( bsize, BLOCK_8X8 ) ) ; } } if ( x -> skip_recode ) { x -> <vul-start> ) ) ; } vp9_build_inter_predictors_sb ( x <vul-end>, mi_row, <vul-start> -> tx_size ] ; if ( output_enabled ) sum_intra_stats ( & cm -> counts, mi ) ; vp9_tokenize_sb ( cpi, t,! output_enabled, MAX ( bsize, BLOCK_8X8 ) ) ; } if ( x -> skip_encode ) return <vul-start> ) return ; set_ref_ptrs ( cm, x, xd, mi_row, mi_col, bsize, pc_tree ) ; <vul-end> } if ( <vul-start> ) ) { vp9_build_inter_predictors_sb ( x, mi_row, mi_col, MAX ( bsize, BLOCK_8X8 ) ) ; } else { int x, y ; TX_SIZE tx_size ; if ( cpi -> oxcf. tuning == VP8_TUNE_SSIM ) { "
 },
 {
  "id": 664,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( \"BPF_LDX uses reserved fields\\\\n\" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( \"BPF_STX uses reserved fields\\\\n\" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( \"invalid bpf_ld_imm64 insn\\\\n\" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( \"unrecognized bpf_ld_imm64 insn\\\\n\" ) ; return - EINVAL ; } f =",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } <vul-start> = map ; <vul-end> fdput ( f\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> E2BIG ; } if (! bpf_map_inc ( map, false ) ) { <vul-start> = map ; <vul-end> fdput ( f\n"
 },
 {
  "id": 665,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 key_ref_t key_create_or_update ( key_ref_t keyring_ref , const char * type , const char * description , const void * payload , size_t plen , key_perm_t perm , unsigned long flags ) { struct keyring_index_key index_key = { . description = description , } ; struct key_preparsed_payload prep ; struct assoc_array_edit * edit ; const struct cred * cred = current_cred ( ) ; struct key * keyring , * key = NULL ; key_ref_t key_ref ; int ret ; index_key . type = key_type_lookup ( type ) ; if ( IS_ERR ( index_key . type ) ) { key_ref = ERR_PTR ( - ENODEV ) ; goto error ; } key_ref = ERR_PTR ( - EINVAL ) ; <vul-start> if ( ! index_key . type -> match || ! index_key . type -> instantiate || <vul-end> ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ; keyring = key_ref_to_ptr ( keyring_ref ) ; key_check ( keyring ) ; key_ref = ERR_PTR ( - ENOTDIR ) ; if ( keyring -> type != & key_type_keyring ) goto error_put_type ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = index_key . type -> def_datalen ; prep . trusted = flags & KEY_ALLOC_TRUSTED ; prep . expiry = TIME_T_MAX ; if ( index_key . type -> preparse ) { ret = index_key . type -> preparse ( & prep ) ; if ( ret < 0 ) { key_ref = ERR_PTR",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ; if ( <vul-end> ! index_key .\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start>. type -> lookup ||! index_key. type ->\n"
 },
 {
  "id": 666,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int telnet_parse ( netdissect_options * ndo , const u_char * sp , u_int length , int print ) { int i , x ; u_int c ; const u_char * osp , * p ; # define FETCH ( c , sp , length ) do { if ( length < 1 ) goto pktend ; ND_TCHECK ( * sp ) ; c = * sp ++ ; length -- ; } while ( 0 ) osp = sp ; FETCH ( c , sp , length ) ; if ( c != IAC ) goto pktend ; FETCH ( c , sp , length ) ; if ( c == IAC ) { if ( print ) ND_PRINT ( ( ndo , \"IAC IAC\" ) ) ; goto done ; } i = c - TELCMD_FIRST ; if ( i < 0 || i > IAC - TELCMD_FIRST ) goto pktend ; switch ( c ) { case DONT : case DO : case WONT : case WILL : case SB : FETCH ( x , sp , length ) ; if ( x >= 0 && x < NTELOPTS ) { if ( print ) ND_PRINT ( ( ndo , \"%s %s\" , telcmds [ i ] , telopts [ x ] ) ) ; } else { if ( print ) ND_PRINT ( ( ndo , \"%s %#x\" , telcmds [ i ] , x ) ) ; } if ( c != SB ) break ; p = sp ; while ( length > ( u_int ) ( p +",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ++ ; } ND_TCHECK ( * p ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } if ( p >= sp ) goto pktend ; if (\n"
 },
 {
  "id": 667,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <vul-start> s -> decode_mb = mpeg4_decode_studio_mb ; <vul-end> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; s -> interlaced_dct = 0 ; s ->\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; s -> <vul-end> decode_smpte_tc ( ctx\n"
 },
 {
  "id": 668,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static PyObject * builtin_compile_impl ( PyObject * module , PyObject * source , PyObject * filename , const char * mode , int flags , int dont_inherit , int optimize ) { PyObject * source_copy ; const char * str ; int compile_mode = - 1 ; int is_ast ; PyCompilerFlags cf ; <vul-start> int start [ ] = { Py_file_input , Py_eval_input , Py_single_input } ; <vul-end> PyObject * result ; cf . cf_flags = flags | PyCF_SOURCE_IS_UTF8 ; if ( flags & <vul-start> ~ ( PyCF_MASK | PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST ) ) <vul-end> { PyErr_SetString ( PyExc_ValueError , \"compile(): unrecognised flags\" ) ; goto error ; } if ( optimize < - 1 || optimize > 2 ) { PyErr_SetString ( PyExc_ValueError , \"compile(): invalid optimize value\" ) ; goto error ; } if ( ! dont_inherit ) { PyEval_MergeCompilerFlags ( & cf ) ; } if ( strcmp ( mode , \"exec\" ) == 0 ) compile_mode = 0 ; else if ( strcmp ( mode , \"eval\" ) == 0 ) compile_mode = 1 ; else if ( strcmp ( mode , \"single\" ) == 0 ) compile_mode = 2 ; <vul-start> else { <vul-end> PyErr_SetString ( PyExc_ValueError , <vul-start> \"compile() mode must be \\'exec\\', \\'eval\\' or \\'single\\'\" ) ; <vul-end> goto error ; } is_ast = PyAST_Check ( source ) ; if ( is_ast == - 1 ) goto error ; if ( is_ast ) { if ( flags & PyCF_ONLY_AST ) { Py_INCREF ( source ) ; result = source ; } else { PyArena * arena",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> Py_eval_input , Py_single_input , Py_func_type_input <vul-start> PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST | PyCF_TYPE_COMMENTS <vul-start> 2 ; else if ( strcmp ( mode , \"func_type\" ) == 0 ) { if ( ! ( flags & PyCF_ONLY_AST ) ) <vul-start> ( PyExc_ValueError , \"compile() mode \\'func_type\\' requires flag PyCF_ONLY_AST\" ) ; goto error ; } compile_mode = 3 ; } else { const char * msg ; if ( flags & PyCF_ONLY_AST ) msg = \"compile() mode must be \\'exec\\', \\'eval\\', \\'single\\' or \\'func_type\\'\" ; else msg = \"compile() mode must be \\'exec\\', \\'eval\\' or \\'single\\'\" ; PyErr_SetString ( PyExc_ValueError , msg <vul-end> ) ; goto\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ] = { Py_file_type_input, Py_eval_input, Py_single_input } ; PyObject * source_copy ; PyObject * result ; Py_type_input flags_copy ; int single_input_type = - 1 <vul-end> ; cf. <vul-start> PyCF_MASK_OBSOLETE | PyCF_DONT_IMPLY_DEDENT <vul-end> ) ) { <vul-start> = 2 ; else if ( strcmp ( mode, \"single\" ) == 0 ) { single_input_type = Py_single_input ; } else { PyErr_SetString ( PyExc_ValueError, \"compile() mode must be \\'exec\\', \\'eval\\' or \\'single\\'\" ) ; goto error ; } <vul-end> is_ast = PyAST_Check <vul-start> PyCompilerFlags cf ; PyObject * start [ ] = { Py_file_input, Py_eval_input, Py_single_input } ; <vul-start> PyCF_single_input } ; if ( source_copy == NULL ) { Py_XDECREF ( source_copy ) ; goto error ; } flags_copy = lookup_flags_copy ( flags_copy, filename, & single_input_type ) ; if (! flags_copy ) { Py_XDECREF ( source_copy ) ; goto error ; } result = ( PyObject * ) Py_CompileStringObject ( single_input_type, filename, start [ compile_mode ], & cf, optimize ) ; Py_XDECREF ( source_copy ) ; <vul-start> PyExc_ValueError, \"compile() result is not a string\" <vul-end> ) ; goto\n"
 },
 {
  "id": 669,
  "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 int main ( int argc , char * argv [ ] ) { struct mschm_decompressor * chmd ; struct mschmd_header * chm ; struct mschmd_file * file , * * f ; unsigned int numf , i ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; user_umask = umask ( 0 ) ; umask ( user_umask ) ; MSPACK_SYS_SELFTEST ( i ) ; if ( i ) return 0 ; if ( ( chmd = mspack_create_chm_decompressor ( NULL ) ) ) { for ( argv ++ ; * argv ; argv ++ ) { printf ( \"%s\\\\n\" , * argv ) ; if ( ( chm = chmd -> open ( chmd , * argv ) ) ) { for ( numf = 0 , file = chm -> files ; file ; file = file -> next ) numf ++ ; if ( ( f = ( struct mschmd_file * * ) calloc ( numf , sizeof ( struct mschmd_file * ) ) ) ) { for ( i = 0 , file = chm -> files ; file ; file = file -> next ) f [ i ++ ] = file ; qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) { <vul-start> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <vul-end> printf ( \"Extracting %s\\\\n\"",
  "golden_answers": [
   "CWE-22 Fixed Code Lines are: <vul-start> = create_output_name ( <vul-end> f [ i <vul-start> ] -> filename <vul-end> ) ; printf\n"
  ],
  "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start> 1, 0, 0\n"
 },
 {
  "id": 670,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void test_function ( char * ( * my_asnprintf ) ( char * , size_t * , const char * , ... ) ) { char buf [ 8 ] ; int size ; for ( size = 0 ; size <= 8 ; size ++ ) { size_t length = size ; char * result = my_asnprintf ( NULL , & length , \"%d\" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , \"12345\" ) == 0 ) ; ASSERT ( length == 5 ) ; free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , \"DEADBEEF\" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , \"%d\" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , \"12345\" ) == 0 ) ; ASSERT ( length == 5 ) ; <vul-start> if ( size < 6 ) <vul-end> ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & \"DEADBEEF\" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( size < 5 + 1 <vul-end> ) ASSERT ( <vul-start> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , \"DEADBEEF\" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , \"%2.0f\" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , \"163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208\" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & \"DEADBEEF\" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> if ( size <= 8 <vul-end> ) ASSERT ( <vul-start> ) ; } free ( buf ) ;\n"
 },
 {
  "id": 671,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 char * selaGetCombName ( SELA * sela , l_int32 size , l_int32 direction ) { char * selname ; <vul-start> char combname [ L_BUF_SIZE ] ; <vul-end> l_int32 i , nsels , sx , sy , found ; SEL * sel ; PROCNAME ( \"selaGetCombName\" ) ; if ( ! sela ) return ( char * ) ERROR_PTR ( \"sela not defined\" , procName , NULL ) ; if ( direction != L_HORIZ && direction != L_VERT ) return ( char * ) ERROR_PTR ( \"invalid direction\" , procName , NULL ) ; if ( direction == L_HORIZ ) <vul-start> snprintf ( combname , L_BUF_SIZE , \"sel_comb_%dh\" , size ) ; <vul-end> else <vul-start> snprintf ( combname , L_BUF_SIZE , \"sel_comb_%dv\" , size ) ; <vul-end> found = FALSE ; nsels = selaGetCount ( sela ) ; for ( i = 0 ; i < nsels ; i ++ ) { sel = selaGetSel ( sela , i ) ; selGetParameters ( sel , & sy , & sx , NULL , NULL ) ; if ( sy != 1 && sx != 1 ) continue ; selname = selGetName ( sel ) ; if ( ! strcmp ( selname , combname ) ) { found = TRUE ; break ; } } if ( found ) return stringNew ( selname ) ; else return ( char * ) ERROR_PTR ( \"sel not found\" , procName , NULL ) ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> char combname [ L_BUFSIZE <vul-end> ] ; l_int32 <vul-start> ( combname , L_BUFSIZE <vul-end> , \"sel_comb_%dh\" , <vul-start> ( combname , L_BUFSIZE <vul-end> , \"sel_comb_%dv\" ,\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char combname [ L_BUFSIZE <vul-end> ] ; l_int32 <vul-start> ( combname, L_BUFSIZE <vul-end>, \"sel_comb_%dh\", <vul-start> ( combname, L_BUFSIZE <vul-end>, \"sel_comb_%dv\",\n"
 },
 {
  "id": 672,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void update_switchable_interp_probs ( VP9_COMMON * cm , vp9_writer * w ) { <vul-end> int j ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) prob_diff_update ( vp9_switchable_interp_tree , <vul-start> cm -> fc . switchable_interp_prob [ j ] , <vul-end> <vul-start> cm -> counts . switchable_interp [ j ] , SWITCHABLE_FILTERS , w ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cm , vpx_writer * w , FRAME_COUNTS * counts <vul-end> ) { int <vul-start> cm -> fc -> <vul-end> switchable_interp_prob [ j <vul-start> j ] , counts -> <vul-end> switchable_interp [ j\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cm, vpx_writer * w, FRAME_COUNTS * counts <vul-end> ) { int <vul-start> cm -> fc -> <vul-end> switchable_interp_prob [ j <vul-start> j ], counts -> <vul-end> switchable_interp [ j\n"
 },
 {
  "id": 673,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) { <vul-start> int rc ; <vul-end> unsigned char key2 [ 8 ] ; <vul-start> struct crypto_skcipher * tfm_des ; <vul-end> struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ; <vul-start> tfm_des = crypto_alloc_skcipher ( \"ecb(des)\" , 0 , CRYPTO_ALG_ASYNC ) ; <vul-end> if ( IS_ERR ( tfm_des ) ) { <vul-start> rc = PTR_ERR ( tfm_des ) ; <vul-end> cifs_dbg ( VFS , \"could not allocate des crypto API\\\\n\" ) ; <vul-start> goto smbhash_err ; <vul-end> } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , \"could not allocate des crypto API\\\\n\" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ; <vul-start> sg_init_one ( & sgin , in , 8 ) ; <vul-end> sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , \"could not encrypt crypt key rc: %d\\\\n\" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ; <vul-start> smbhash_err : <vul-end> return rc ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> key ) { <vul-end> unsigned char key2 <vul-start> ] ; struct crypto_cipher * tfm_des <vul-end> ; str_to_key ( <vul-start> ; tfm_des = crypto_alloc_cipher ( \"des\" <vul-end> , 0 , <vul-start> , 0 , 0 <vul-end> ) ; if <vul-start> ) ) { <vul-end> cifs_dbg ( VFS <vul-start> \"could not allocate des crypto API\\\\n\" ) ; return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <vul-end> ( tfm_des , <vul-start> 8 ) ; crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <vul-end> ( tfm_des ) <vul-start> tfm_des ) ; return 0 <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> key ) { <vul-end> unsigned char key2 <vul-start> crypto_skcipher * tfm_des, * tfm_des_tmp <vul-start> key2 ) ; tfm_des_tmp <vul-end> = crypto_alloc_skcipher ( <vul-start> = crypto_alloc_skcipher ( \"ecb(des)\\\\n\" <vul-end>, 0, <vul-start> ) ) { <vul-end> cifs_dbg ( VFS <vul-start> \"could not allocate des crypto API\\\\n\" ) ; return - EINVAL <vul-end> ; } crypto_skcipher_setkey <vul-start> 8 ) ; rc = smbhash_initialize ( out, key2, 8 ) ; if (! rc ) rc = - EINVAL ; <vul-start> tfm_des ) ; <vul-end> return rc ;\n"
 },
 {
  "id": 674,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int tipc_nl_publ_dump ( struct sk_buff * skb , struct netlink_callback * cb ) { int err ; u32 tsk_portid = cb -> args [ 0 ] ; u32 last_publ = cb -> args [ 1 ] ; u32 done = cb -> args [ 2 ] ; struct net * net = sock_net ( skb -> sk ) ; struct tipc_sock * tsk ; if ( ! tsk_portid ) { struct nlattr * * attrs ; struct nlattr * sock [ TIPC_NLA_SOCK_MAX + 1 ] ; err = tipc_nlmsg_parse ( cb -> nlh , & attrs ) ; if ( err ) return err ; <vul-start> err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , <vul-end> <vul-start> attrs [ TIPC_NLA_SOCK ] , <vul-end> tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock [ TIPC_NLA_SOCK_REF ] ) return - EINVAL ; <vul-start> tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; <vul-end> } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ; <vul-start> lock_sock ( & tsk -> sk ) ; <vul-end> err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ; if ( ! err ) done = 1 ; release_sock ( & tsk -> sk ) ; sock_put ( & tsk -> sk ) ; cb -> args [ 0 ] = tsk_portid ; cb -> args [ 1 ] = last_publ ; cb -> args [ 2 ] = done ; return skb -> len ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> return err ; if ( ! <vul-end> attrs [ TIPC_NLA_SOCK <vul-start> attrs [ TIPC_NLA_SOCK <vul-end> ] ) return <vul-start> - EINVAL ; err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock <vul-end> [ TIPC_NLA_SOCK_REF ] <vul-start> [ TIPC_NLA_SOCK_REF ] <vul-end> ) return - <vul-start> - EINVAL ; tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> return err ; lock_sock ( & tsk -> sk ) ; <vul-start>, TIPC_NLA_SOCK_MAX, & <vul-start> - EINVAL ; if (! sock [ TIPC_NLA_SOCK_REF ] ) { release_sock ( & tsk -> sk ) ; return - EINVAL ; } <vul-start> - EINVAL ; <vul-end> err = __tipc_nl_list_sk_publ\n"
 },
 {
  "id": 675,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int ext4_insert_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; handle_t * handle ; struct ext4_ext_path * path ; struct ext4_extent * extent ; ext4_lblk_t offset_lblk , len_lblk , ee_start_lblk = 0 ; unsigned int credits , ee_len ; int ret = 0 , depth , split_flag = 0 ; loff_t ioffset ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_insert_range ( inode , offset , len ) ; offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; len_lblk = len >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( inode -> i_size + len > inode -> i_sb -> s_maxbytes ) { ret = - EFBIG ; goto out_mutex ; } if ( offset >= i_size_read ( inode ) )",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <vul-start> ioffset ) ; <vul-end> credits = ext4_writepage_trans_blocks <vul-start> ) ; goto out_mmap <vul-end> ; } inode <vul-start> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <vul-end> ext4_inode_resume_unlocked_dio ( inode\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <vul-start> ioffset ) ; <vul-end> credits = ext4_writepage_trans_blocks <vul-start> ; goto out_dio ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem )\n"
 },
 {
  "id": 676,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 static int fuse_notify_inval_entry ( struct fuse_conn * fc , unsigned int size , struct fuse_copy_state * cs ) { struct fuse_notify_inval_entry_out outarg ; int err = - ENOMEM ; char * buf ; struct qstr name ; buf = kzalloc ( FUSE_NAME_MAX + 1 , GFP_KERNEL ) ; if ( ! buf ) goto err ; err = - EINVAL ; if ( size < sizeof ( outarg ) ) goto err ; err = fuse_copy_one ( cs , & outarg , sizeof ( outarg ) ) ; if ( err ) goto err ; err = - ENAMETOOLONG ; if ( outarg . namelen > FUSE_NAME_MAX ) goto err ; <vul-start> name . name = buf ; <vul-end> name . len = outarg . namelen ; <vul-start> err = fuse_copy_one ( cs , buf , outarg . namelen + 1 ) ; <vul-end> if ( err ) goto err ; fuse_copy_finish ( cs ) ; buf [ outarg . namelen ] = 0 ; name . hash = full_name_hash ( name . name , name . len ) ; down_read ( & fc -> killsb ) ; err = - ENOENT ; if ( fc -> sb ) err = fuse_reverse_inval_entry ( fc -> sb , outarg . parent , & name ) ; up_read ( & fc -> killsb ) ; kfree ( buf ) ; return err ; err : kfree ( buf ) ; fuse_copy_finish ( cs ) ; return err ; }",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> goto err ; err = - EINVAL ; if ( size != sizeof ( outarg ) + <vul-end> outarg . namelen <vul-start> + 1 ) goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 )\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start>. name = ( char * ) <vul-start>. namelen ; if ( name. name [ name. len ]!= '\\\\0' ) { err = - ENAMETOOLONG ; goto err ; }\n"
 },
 {
  "id": 677,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int cdrom_ioctl_select_disc ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , \"entering CDROM_SELECT_DISC\\\\n\" ) ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) ) return - ENOSYS ; if ( arg != CDSL_CURRENT && arg != CDSL_NONE ) { <vul-start> if ( ( int ) arg >= cdi -> capacity ) <vul-end> return - EINVAL ; } if ( cdi -> ops -> select_disc ) return cdi -> ops -> select_disc ( cdi , arg ) ; cd_dbg ( CD_CHANGER , \"Using generic cdrom_select_disc()\\\\n\" ) ; return cdrom_select_disc ( cdi , arg ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> { if ( <vul-end> arg >= cdi\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> { if ( arg < CDSL_CURRENT || arg > <vul-end> cdi -> capacity\n"
 },
 {
  "id": 678,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int nci_extract_activation_params_iso_dep ( struct nci_dev * ndev , struct nci_rf_intf_activated_ntf * ntf , __u8 * data ) { struct activation_params_nfca_poll_iso_dep * nfca_poll ; struct activation_params_nfcb_poll_iso_dep * nfcb_poll ; switch ( ntf -> activation_rf_tech_and_mode ) { case NCI_NFC_A_PASSIVE_POLL_MODE : nfca_poll = & ntf -> activation_params . nfca_poll_iso_dep ; <vul-start> nfca_poll -> rats_res_len = * data ++ ; <vul-end> pr_debug ( \"rats_res_len %d\\\\n\" , nfca_poll -> rats_res_len ) ; if ( nfca_poll -> rats_res_len > 0 ) { memcpy ( nfca_poll -> rats_res , data , nfca_poll -> rats_res_len ) ; } break ; case NCI_NFC_B_PASSIVE_POLL_MODE : nfcb_poll = & ntf -> activation_params . nfcb_poll_iso_dep ; <vul-start> nfcb_poll -> attrib_res_len = * data ++ ; <vul-end> pr_debug ( \"attrib_res_len %d\\\\n\" , nfcb_poll -> attrib_res_len ) ; if ( nfcb_poll -> attrib_res_len > 0 ) { memcpy ( nfcb_poll -> attrib_res , data , nfcb_poll -> attrib_res_len ) ; } break ; default : pr_err ( \"unsupported activation_rf_tech_and_mode 0x%x\\\\n\" , ntf -> activation_rf_tech_and_mode ) ; return NCI_STATUS_RF_PROTOCOL_ERROR ; } return NCI_STATUS_OK ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> rats_res_len = min_t ( __u8 , <vul-start> * data ++ , 20 ) <vul-start> -> attrib_res_len = min_t ( __u8 , <vul-start> * data ++ , 50 )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. nfca_poll_iso_dep ; if (! nfca_poll -> rats_res_len ) return NCI_STATUS_RF_PROTOCOL_ERROR ; <vul-start>. nfcb_poll_iso_dep ; if (! nfcb_poll -> attrib_res_len ) return NCI_STATUS_RF_PROTOCOL_ERROR ;\n"
 },
 {
  "id": 679,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void snd_timer_user_tinterrupt ( struct snd_timer_instance * timeri , unsigned long resolution , unsigned long ticks ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread * r , r1 ; struct timespec tstamp ; int prev , append = 0 ; memset ( & tstamp , 0 , sizeof ( tstamp ) ) ; spin_lock ( & tu -> qlock ) ; if ( ( tu -> filter & ( ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) | ( 1 << SNDRV_TIMER_EVENT_TICK ) ) ) == 0 ) { spin_unlock ( & tu -> qlock ) ; return ; } if ( tu -> last_resolution != resolution || ticks > 0 ) { if ( timer_tstamp_monotonic ) ktime_get_ts ( & tstamp ) ; else getnstimeofday ( & tstamp ) ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_RESOLUTION ) ) && tu -> last_resolution != resolution ) { <vul-start> r1 . event = SNDRV_TIMER_EVENT_RESOLUTION ; <vul-end> r1 . tstamp = tstamp ; r1 . val = resolution ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; tu -> last_resolution = resolution ; append ++ ; } if ( ( tu -> filter & ( 1 << SNDRV_TIMER_EVENT_TICK ) ) == 0 ) goto __wake ; if ( ticks == 0 ) goto __wake ; if ( tu -> qused > 0 ) { prev = tu -> qtail == 0 ? tu -> queue_size - 1 : tu -> qtail - 1 ; r = & tu -> tqueue [ prev ] ; if ( r -> event ==",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> resolution ) { memset ( & r1 , 0 , sizeof ( r1 ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> resolution ) { memset ( & r1, 0, sizeof ( r1 ) ) ;\n"
 },
 {
  "id": 680,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int hci_uart_set_proto ( struct hci_uart * hu , int id ) { const struct hci_uart_proto * p ; int err ; p = hci_uart_get_proto ( id ) ; if ( ! p ) return - EPROTONOSUPPORT ; hu -> proto = p ; <vul-start> set_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <vul-end> err = hci_uart_register_dev ( hu ) ; if ( err ) { <vul-start> clear_bit ( HCI_UART_PROTO_READY , & hu -> flags ) ; <vul-end> <vul-start> return err ; <vul-end> } return 0 ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> = p ; <vul-end> err = hci_uart_register_dev <vul-start> err ) { return err ; } set_bit <vul-end> ( HCI_UART_PROTO_READY , <vul-start> ) ; return <vul-end> 0 ; }\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> = p ; spin_lock_irq ( & hu -> lock <vul-end> ) ; err <vul-start> err ) { spin_unlock_irq ( & hu -> lock <vul-end> ) ; return <vul-start> return err ; } spin_unlock_irq ( & hu -> lock ) ; <vul-end> return 0 ;\n"
 },
 {
  "id": 681,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd , int start_mb_row ) { volatile const int * last_row_current_mb_col ; volatile int * current_mb_col ; int mb_row ; VP8_COMMON * pc = & pbi -> common ; const int nsync = pbi -> sync_range ; const int first_row_no_sync_above = pc -> mb_cols + nsync ; int num_part = 1 << pbi -> common . multi_token_partition ; int last_mb_row = start_mb_row ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; YV12_BUFFER_CONFIG * yv12_fb_lst = pbi -> dec_fb_ref [ LAST_FRAME ] ; int recon_y_stride = yv12_fb_new -> y_stride ; int recon_uv_stride = yv12_fb_new -> uv_stride ; unsigned char * ref_buffer [ MAX_REF_FRAMES ] [ 3 ] ; unsigned char * dst_buffer [ 3 ] ; int i ; int ref_fb_corrupted [ MAX_REF_FRAMES ] ; ref_fb_corrupted [ INTRA_FRAME ] = 0 ; for ( i = 1 ; i < MAX_REF_FRAMES ; i ++ ) { YV12_BUFFER_CONFIG * this_fb = pbi -> dec_fb_ref [ i ] ; ref_buffer [ i ] [ 0 ] = this_fb -> y_buffer ; ref_buffer [ i ] [ 1 ] = this_fb -> u_buffer ; ref_buffer [ i ] [ 2 ] = this_fb -> v_buffer ; ref_fb_corrupted [ i ] = this_fb -> corrupted ; } dst_buffer [ 0 ] = yv12_fb_new -> y_buffer ; dst_buffer [ 1 ] = yv12_fb_new -> u_buffer ; dst_buffer [ 2 ] = yv12_fb_new -> v_buffer ; xd -> up_available = ( start_mb_row != 0 ) ; for ( mb_row = start_mb_row ; mb_row < pc -> mb_rows ; mb_row",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> above_context ; memset <vul-end> ( xd -> <vul-start> 1 ) { memcpy <vul-end> ( ( pbi <vul-start> 16 ) ; memcpy <vul-end> ( ( pbi <vul-start> 8 ) ; memcpy <vul-end> ( ( pbi\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> above_context ; memset <vul-end> ( xd -> <vul-start> -> above_context ; memset <vul-end> ( xd ->\n"
 },
 {
  "id": 682,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static PyTypeObject * make_type ( char * type , PyTypeObject * base , char * * fields , int num_fields ) <vul-start> { <vul-end> PyObject * fnames , * result ; int i ; fnames = PyTuple_New ( num_fields ) ; if ( ! fnames ) return NULL ; for ( i = 0 ; i < num_fields ; i ++ ) { PyObject * field = PyUnicode_FromString ( fields [ i ] ) ; if ( ! field ) { Py_DECREF ( fnames ) ; return NULL ; } PyTuple_SET_ITEM ( fnames , i , field ) ; } <vul-start> result = PyObject_CallFunction ( ( PyObject * ) & PyType_Type , \"s(O){sOss}\" , <vul-end> <vul-start> type , base , \"_fields\" , fnames , \"__module__\" , \"_ast3\" ) ; <vul-end> Py_DECREF ( fnames ) ; return ( PyTypeObject * ) result ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> num_fields ) { _Py_IDENTIFIER ( __module__ ) ; _Py_IDENTIFIER ( _ast3 ) ; <vul-start> & PyType_Type , \"s(O){OOOO}\" <vul-end> , type , <vul-start> , base , _PyUnicode_FromId ( & PyId__fields ) <vul-end> , fnames , <vul-start> , fnames , _PyUnicode_FromId ( & PyId___module__ ) , _PyUnicode_FromId ( & PyId__ast3 ) <vul-end> ) ; Py_DECREF\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> num_fields ) { PyObject * type_copy, * <vul-start> ) ; } type_copy = PyObject_CallFunction ( ( PyObject * ) & PyType_Type, \"s(O){sOss}\", type, base, \"_fields\", fnames, \"__module__\", \"_ast3\" ) ; if (! type_copy ) { Py_DECREF ( fnames ) ; return NULL ; } <vul-start>, \"s(O){sOss}\", type_copy <vul-end>, base, <vul-start> \"__module__\", \"_ast3\" <vul-end> ) ; Py_DECREF\n"
 },
 {
  "id": 683,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; int count , i ; <vul-start> count = be32_to_cpu ( aclp -> acl_cnt ) ; <vul-end> acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start>, i ; if ( count > UIO_MAXIO ) return ERR_PTR ( - EINVAL ) ;\n"
 },
 {
  "id": 684,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int hls_slice_header ( HEVCContext * s ) { GetBitContext * gb = & s -> HEVClc -> gb ; SliceHeader * sh = & s -> sh ; int i , ret ; <vul-start> sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; <vul-end> if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) { s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; if ( IS_IDR ( s ) ) ff_hevc_clear_refs ( s ) ; } sh -> no_output_of_prior_pics_flag = 0 ; if ( IS_IRAP ( s ) ) sh -> no_output_of_prior_pics_flag = get_bits1 ( gb ) ; sh -> pps_id = get_ue_golomb_long ( gb ) ; if ( sh -> pps_id >= HEVC_MAX_PPS_COUNT || ! s -> ps . pps_list [ sh -> pps_id ] ) { av_log ( s -> avctx , AV_LOG_ERROR , \"PPS id out of range: %d\\\\n\" , sh -> pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> first_slice_in_pic_flag && s -> ps . pps != ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ) { av_log ( s -> avctx , AV_LOG_ERROR , \"PPS changed between slices.\\\\n\" ) ; return AVERROR_INVALIDDATA ; } s -> ps . pps = ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ; if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) sh -> no_output_of_prior_pics_flag = 1 ;",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , \"Two slices reporting being the first in the same frame.\\\\n\" ) ; return 1 ; }\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start>, ret ; int pic_flag = 0 ; if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) pic_flag = 1 ; <vul-start> -> first_slice_in_pic_flag = pic_flag <vul-end> ; if (\n"
 },
 {
  "id": 685,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int xlate_to_uni ( const unsigned char * name , int len , unsigned char * outname , int * longlen , int * outlen , int escape , int utf8 , struct nls_table * nls ) { const unsigned char * ip ; unsigned char nc ; unsigned char * op ; unsigned int ec ; int i , k , fill ; int charlen ; if ( utf8 ) { <vul-start> * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ; <vul-end> if ( * outlen < 0 ) return * outlen ; else if ( * outlen > FAT_LFN_LEN ) return - ENAMETOOLONG ; op = & outname [ * outlen * sizeof ( wchar_t ) ] ; } else { if ( nls ) { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; * outlen += 1 ) { if ( escape && ( * ip == ':' ) ) { if ( i > len - 5 ) return - EINVAL ; ec = 0 ; for ( k = 1 ; k < 5 ; k ++ ) { nc = ip [ k ] ; ec <<= 4 ; if ( nc >= '0' && nc <= '9' ) { ec |= nc - '0' ; continue ; } if ( nc >= 'a' && nc <= 'f' ) { ec |= nc - ( 'a' - 10 ) ; continue ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , len , UTF16_HOST_ENDIAN , <vul-start> * ) outname , FAT_LFN_LEN + 2\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * outlen = utf8s_to_utf32s <vul-end> ( name,\n"
 },
 {
  "id": 686,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int evm_update_evmxattr ( struct dentry * dentry , const char * xattr_name , const char * xattr_value , size_t xattr_value_len ) { struct inode * inode = dentry -> d_inode ; struct evm_ima_xattr_data xattr_data ; int rc = 0 ; rc = evm_calc_hmac ( dentry , xattr_name , xattr_value , xattr_value_len , xattr_data . digest ) ; if ( rc == 0 ) { xattr_data . type = EVM_XATTR_HMAC ; rc = __vfs_setxattr_noperm ( dentry , XATTR_NAME_EVM , & xattr_data , sizeof ( xattr_data ) , 0 ) ; } <vul-start> else if ( rc == - ENODATA ) <vul-end> rc = inode -> i_op -> removexattr ( dentry , XATTR_NAME_EVM ) ; <vul-start> return rc ; <vul-end> }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> == - ENODATA && inode -> i_op -> removexattr ) { <vul-end> rc = inode <vul-start> XATTR_NAME_EVM ) ; }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> - ENODATA ) { <vul-start> XATTR_NAME_EVM ) ; }\n"
 },
 {
  "id": 687,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static inline int mount_entry_on_generic ( struct mntent * mntent , <vul-start> const char * path ) <vul-end> { unsigned long mntflags ; char * mntdata ; int ret ; bool optional = hasmntopt ( mntent , \"optional\" ) != NULL ; ret = mount_entry_create_dir_file ( mntent , path ) ; if ( ret < 0 ) return optional ? 0 : - 1 ; cull_mntent_opt ( mntent ) ; if ( parse_mntopts ( mntent -> mnt_opts , & mntflags , & mntdata ) < 0 ) { free ( mntdata ) ; return - 1 ; } ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , <vul-start> mntflags , mntdata , optional ) ; <vul-end> free ( mntdata ) ; return ret ; }",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> char * path , const char * rootfs <vul-start> mntdata , optional , rootfs\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> char * path, uid_t * check_ruid <vul-start> mntdata, optional, check_ruid\n"
 },
 {
  "id": 688,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int tile_worker_hook ( void * arg1 , void * arg2 ) { <vul-end> <vul-start> TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ; <vul-end> <vul-start> const TileInfo * const tile = ( TileInfo * ) arg2 ; <vul-end> <vul-start> int mi_row , mi_col ; <vul-end> for ( mi_row = tile -> mi_row_start ; mi_row < tile -> mi_row_end ; mi_row += MI_BLOCK_SIZE ) { vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile -> mi_col_start ; mi_col < tile -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) { <vul-start> decode_partition ( tile_data -> cm , & tile_data -> xd , tile , <vul-end> <vul-start> mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 ) ; <vul-end> } } return ! tile_data -> xd . corrupted ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int tile_worker_hook ( <vul-end> TileWorkerData * const <vul-start> * const tile_data , <vul-end> const TileInfo * <vul-start> * const tile ) { <vul-end> int mi_row , <vul-start> mi_row , mi_col ; if ( setjmp ( tile_data -> error_info . jmp ) ) { tile_data -> error_info . setjmp = 0 ; tile_data -> xd . corrupted = 1 ; return 0 ; } tile_data -> error_info . setjmp = 1 ; tile_data -> xd . error_info = & tile_data -> error_info <vul-start> ( tile_data -> pbi <vul-end> , & tile_data <vul-start> tile_data -> xd <vul-end> , mi_row , <vul-start> bit_reader , BLOCK_64X64 , 4\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int tile_worker_hook ( TileWorkerData * const tile_data, TileInfo * const tile, int mi_row, mi_col ) { <vul-end> const TileWorkerData * <vul-start> const TileWorkerData * <vul-end> tile_data = ( <vul-start> ) arg1 ; <vul-end> int mi_row, <vul-start> mi_row, mi_col ; vp9_zero ( tile_data -> xd. left_context ) ; vp9_zero ( tile_data -> xd. left_seg_context ) <vul-start> { decode_partition ( <vul-end> & tile_data -> <vul-start> bit_reader, BLOCK_64X64, tile_data -> partition_map\n"
 },
 {
  "id": 689,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void subtract_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame -= frame -> frame ; <vul-start> section -> intra_error -= frame -> intra_error ; <vul-end> section -> coded_error -= frame -> coded_error ; section -> sr_coded_error -= frame -> sr_coded_error ; <vul-start> section -> ssim_weighted_pred_err -= frame -> ssim_weighted_pred_err ; <vul-end> section -> pcnt_inter -= frame -> pcnt_inter ; section -> pcnt_motion -= frame -> pcnt_motion ; section -> pcnt_second_ref -= frame -> pcnt_second_ref ; <vul-start> section -> pcnt_neutral -= frame -> pcnt_neutral ; <vul-end> section -> MVr -= frame -> MVr ; section -> mvr_abs -= frame -> mvr_abs ; section -> MVc -= frame -> MVc ; section -> mvc_abs -= frame -> mvc_abs ; section -> MVrv -= frame -> MVrv ; section -> MVcv -= frame -> MVcv ; section -> mv_in_out_count -= frame -> mv_in_out_count ; section -> new_mv_count -= frame -> new_mv_count ; section -> count -= frame -> count ; section -> duration -= frame -> duration ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; section -> weight -= frame -> weight ; section -> <vul-start> ; section -> <vul-end> pcnt_inter -= frame <vul-start> frame -> pcnt_neutral ; section -> intra_skip_pct -= frame -> intra_skip_pct ; section -> inactive_zone_rows -= frame -> inactive_zone_rows ; section -> inactive_zone_cols -= frame -> inactive_zone_cols\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; section -> weight -= frame -> weight ; section -> <vul-start> ; section -> <vul-end> pcnt_inter -= frame <vul-start> frame -> pcnt_neutral ; section -> intra_skip_pct -= frame -> intra_skip_pct ; section -> inactive_zone_rows -= frame -> inactive_zone_rows ; section -> inactive_zone_cols -= frame -> inactive_zone_cols\n"
 },
 {
  "id": 690,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int check_stack_boundary ( struct bpf_verifier_env * env , int regno , int access_size , bool zero_size_allowed , struct bpf_call_arg_meta * meta ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = state -> regs ; int off , i , slot , spi ; if ( regs [ regno ] . type != PTR_TO_STACK ) { if ( zero_size_allowed && access_size == 0 && register_is_null ( regs [ regno ] ) ) return 0 ; verbose ( env , \"R%d type=%s expected=%s\\\\n\" , regno , reg_type_str [ regs [ regno ] . type ] , reg_type_str [ PTR_TO_STACK ] ) ; return - EACCES ; } if ( ! tnum_is_const ( regs [ regno ] . var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , regs [ regno ] . var_off ) ; verbose ( env , \"invalid variable stack read R%d var_off=%s\\\\n\" , regno , tn_buf ) ; <vul-start> } <vul-end> off = regs [ regno ] . off + regs [ regno ] . var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK || off + access_size > 0 || access_size < 0 || ( access_size == 0 && ! zero_size_allowed ) ) { verbose ( env , \"invalid stack type R%d off=%d access_size=%d\\\\n\" , regno , off , access_size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> tn_buf ) ; return - EACCES ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> tn_buf ) ; return - EACCES ;\n"
 },
 {
  "id": 691,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int fill_autodev ( const struct lxc_rootfs * rootfs ) { int ret ; char path [ MAXPATHLEN ] ; int i ; mode_t cmask ; INFO ( \"Creating initial consoles under container /dev\" ) ; ret = snprintf ( path , MAXPATHLEN , \"%s/dev\" , rootfs -> path ? rootfs -> mount : \"\" ) ; if ( ret < 0 || ret >= MAXPATHLEN ) { ERROR ( \"Error calculating container /dev location\" ) ; return - 1 ; } if ( ! dir_exists ( path ) ) return 0 ; INFO ( \"Populating container /dev\" ) ; cmask = umask ( S_IXUSR | S_IXGRP | S_IXOTH ) ; for ( i = 0 ; i < sizeof ( lxc_devs ) / sizeof ( lxc_devs [ 0 ] ) ; i ++ ) { const struct lxc_devs * d = & lxc_devs [ i ] ; ret = snprintf ( path , MAXPATHLEN , \"%s/dev/%s\" , rootfs -> path ? rootfs -> mount : \"\" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; ret = mknod ( path , d -> mode , makedev ( d -> maj , d -> min ) ) ; if ( ret && errno != EEXIST ) { char hostpath [ MAXPATHLEN ] ; FILE * pathfile ; ret = snprintf ( hostpath , MAXPATHLEN , \"/dev/%s\" , d -> name ) ; if ( ret < 0 || ret >= MAXPATHLEN ) return - 1 ; pathfile = fopen ( path , \"wb\" )",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> ; if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <vul-end> NULL ) !=\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> ; if ( safe_mount <vul-end> ( hostpath, <vul-start> MS_BIND, NULL, rootfs -> path? rootfs -> mount : NULL\n"
 },
 {
  "id": 692,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int newseg ( struct ipc_namespace * ns , struct ipc_params * params ) { key_t key = params -> key ; int shmflg = params -> flg ; size_t size = params -> u . size ; int error ; struct shmid_kernel * shp ; size_t numpages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; struct file * file ; char name [ 13 ] ; int id ; vm_flags_t acctflag = 0 ; if ( size < SHMMIN || size > ns -> shm_ctlmax ) return - EINVAL ; if ( numpages << PAGE_SHIFT < size ) return - ENOSPC ; if ( ns -> shm_tot + numpages < ns -> shm_tot || ns -> shm_tot + numpages > ns -> shm_ctlall ) return - ENOSPC ; shp = ipc_rcu_alloc ( sizeof ( * shp ) ) ; if ( ! shp ) return - ENOMEM ; shp -> shm_perm . key = key ; shp -> shm_perm . mode = ( shmflg & S_IRWXUGO ) ; shp -> mlock_user = NULL ; shp -> shm_perm . security = NULL ; error = security_shm_alloc ( shp ) ; if ( error ) { ipc_rcu_putref ( shp , ipc_rcu_free ) ; return error ; } sprintf ( name , \"SYSV%08x\" , key ) ; if ( shmflg & SHM_HUGETLB ) { struct hstate * hs ; size_t hugesize ; hs = hstate_sizelog ( ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; if ( ! hs ) { error = - EINVAL ; goto no_file ; } hugesize = ALIGN (",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <vul-start> no_id ; } <vul-end> list_add ( &\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; list_add ( & shp -> shm_clist, & current -> sysvshm. shm_clist ) ; <vul-start> no_id ; } <vul-end> ipc_unlock_object ( &\n"
 },
 {
  "id": 693,
  "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static int mv_read_header ( AVFormatContext * avctx ) { MvContext * mv = avctx -> priv_data ; AVIOContext * pb = avctx -> pb ; AVStream * ast = NULL , * vst = NULL ; int version , i ; int ret ; avio_skip ( pb , 4 ) ; version = avio_rb16 ( pb ) ; if ( version == 2 ) { uint64_t timestamp ; int v ; avio_skip ( pb , 22 ) ; ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; avpriv_set_pts_info ( vst , 64 , 1 , 15 ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; vst -> avg_frame_rate = av_inv_q ( vst -> time_base ) ; vst -> nb_frames = avio_rb32 ( pb ) ; v = avio_rb32 ( pb ) ; switch ( v ) { case 1 : vst -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ; break ; case 2 : vst -> codecpar -> format = AV_PIX_FMT_ARGB ; vst -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; break ; default : avpriv_request_sample ( avctx , \"Video compression %i\" , v ) ; break ; } vst -> codecpar -> codec_tag = 0 ; vst -> codecpar -> width = avio_rb32 ( pb ) ; vst -> codecpar -> height = avio_rb32 ( pb ) ; avio_skip ( pb , 12 ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; ast",
  "golden_answers": [
   "CWE-834 Fixed Code Lines are: <vul-start> ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA\n"
  ],
  "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;\n"
 },
 {
  "id": 694,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int nfs4_xdr_dec_getacl ( struct rpc_rqst * rqstp , struct xdr_stream * xdr , struct nfs_getaclres * res ) { struct compound_hdr hdr ; int status ; status = decode_compound_hdr ( xdr , & hdr ) ; if ( status ) goto out ; status = decode_sequence ( xdr , & res -> seq_res , rqstp ) ; if ( status ) goto out ; status = decode_putfh ( xdr ) ; if ( status ) goto out ; <vul-start> status = decode_getacl ( xdr , rqstp , & res -> acl_len ) ; <vul-end> out : return status ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> , rqstp , res <vul-end> ) ; out\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> goto out ; if (! res -> acl_len. h. type ) { status = nfs_request_nfs_getacl ( xdr, rqstp, & res -> acl_len ) ; if ( status ) goto out ; }\n"
 },
 {
  "id": 695,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 int pci_bus_configured ( int bus ) { <vul-start> assert ( bus >= 0 && bus < MAXBUSES ) ; <vul-end> return ( pci_businfo [ bus ] != NULL ) ; }",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> bus ) { <vul-end> return ( pci_businfo\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> bus ) { if ( bus < 0 || <vul-end> bus < MAXBUSES <vul-start> bus < MAXBUSES ) return 0 <vul-end> ; return (\n"
 },
 {
  "id": 696,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static inline void header_put_be_int ( SF_PRIVATE * psf , int x ) <vul-start> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <vul-end> <vul-start> { psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <vul-end> <vul-start> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <vul-end> <vul-start> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <vul-end> <vul-start> psf -> header [ psf -> headindex ++ ] = x ; <vul-end> <vul-start> } ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> x ) { <vul-end> psf -> header <vul-start> psf -> header . ptr [ <vul-end> psf -> header <vul-start> psf -> header . indx <vul-end> ++ ] = <vul-start> psf -> header . ptr <vul-start> [ psf -> header . indx <vul-end> ++ ] = <vul-start> psf -> header . ptr <vul-start> [ psf -> header . indx <vul-end> ++ ] = <vul-start> psf -> header . ptr <vul-start> [ psf -> header . indx <vul-end> ++ ] = <vul-start> x ; } <vul-end>      \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> x ) { <vul-end> psf -> header <vul-start> psf -> header. ptr [ <vul-end> psf -> header <vul-start> psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> psf -> header. ptr <vul-start> [ psf -> header. indx <vul-end> ++ ] = <vul-start> x ; } <vul-end>      \n"
 },
 {
  "id": 697,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void sctp_auth_get_cookie_params ( struct sctp_tcb * stcb , struct mbuf * m , uint32_t offset , uint32_t length ) { struct sctp_paramhdr * phdr , tmp_param ; uint16_t plen , ptype ; uint8_t random_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_random * p_random = NULL ; uint16_t random_len = 0 ; uint8_t hmacs_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_hmac_algo * hmacs = NULL ; uint16_t hmacs_len = 0 ; uint8_t chunks_store [ SCTP_PARAM_BUFFER_SIZE ] ; struct sctp_auth_chunk_list * chunks = NULL ; uint16_t num_chunks = 0 ; sctp_key_t * new_key ; uint32_t keylen ; length += offset ; phdr = ( struct sctp_paramhdr * ) sctp_m_getptr ( m , offset , sizeof ( struct sctp_paramhdr ) , ( uint8_t * ) & tmp_param ) ; while ( phdr != NULL ) { ptype = ntohs ( phdr -> param_type ) ; plen = ntohs ( phdr -> param_length ) ; <vul-start> if ( ( plen == 0 ) || ( offset + plen > length ) ) <vul-end> break ; if ( ptype == SCTP_RANDOM ) { if ( plen > sizeof ( random_store ) ) break ; phdr = sctp_get_next_param ( m , offset , ( struct sctp_paramhdr * ) random_store , plen ) ; if ( phdr == NULL ) return ; p_random = ( struct sctp_auth_random * ) phdr ; random_len = plen - sizeof ( * p_random ) ; } else if ( ptype == SCTP_HMAC_LIST ) { uint16_t num_hmacs ; uint16_t i ; if ( plen > sizeof ( hmacs_store ) ) break ; phdr = sctp_get_next_param ( m , offset",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( ( plen < sizeof ( struct sctp_paramhdr ) <vul-end> ) || (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( plen < sizeof ( struct sctp_paramhdr ) <vul-end> ) break ;\n"
 },
 {
  "id": 698,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 uint32_t virtio_config_readl ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t val ; <vul-start> k -> get_config ( vdev , vdev -> config ) ; <vul-end> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldl_p ( vdev -> config + addr ) ; return val ; }",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> uint32_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <vul-start> -> config ) <vul-end> ; val =\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> uint32_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <vul-start> -> config ) <vul-end> ; val =\n"
 },
 {
  "id": 699,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_frame ( vpx_codec_ctx_t * ctx , <vul-end> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <vul-start> VpxVideoWriter * writer ) { <vul-end> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , \"Failed to encode frame.\" ) ; <vul-start> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <vul-end> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , \"Failed to write compressed frame.\" ) ; printf ( keyframe ? \"K\" : \".\" ) ; fflush ( stdout ) ; } } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> encode_frame ( vpx_codec_ctx_t <vul-start> writer ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> encode_frame ( vpx_codec_ctx_t <vul-start> writer ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
 },
 {
  "id": 700,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 enum auth_stat gssrpc__svcauth_gss ( struct svc_req * rqst , struct rpc_msg * msg , bool_t * no_dispatch ) { enum auth_stat retstat ; XDR xdrs ; SVCAUTH * auth ; struct svc_rpc_gss_data * gd ; struct rpc_gss_cred * gc ; struct rpc_gss_init_res gr ; int call_stat , offset ; OM_uint32 min_stat ; log_debug ( \"in svcauth_gss()\" ) ; rqst -> rq_xprt -> xp_verf = gssrpc__null_auth ; if ( rqst -> rq_xprt -> xp_auth == NULL || rqst -> rq_xprt -> xp_auth == & svc_auth_none ) { if ( ( auth = calloc ( sizeof ( * auth ) , 1 ) ) == NULL ) { fprintf ( stderr , \"svcauth_gss: out_of_memory\\\\n\" ) ; return ( AUTH_FAILED ) ; } if ( ( gd = calloc ( sizeof ( * gd ) , 1 ) ) == NULL ) { fprintf ( stderr , \"svcauth_gss: out_of_memory\\\\n\" ) ; return ( AUTH_FAILED ) ; } auth -> svc_ah_ops = & svc_auth_gss_ops ; SVCAUTH_PRIVATE ( auth ) = gd ; rqst -> rq_xprt -> xp_auth = auth ; } else gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; log_debug ( \"xp_auth=%p, gd=%p\" , rqst -> rq_xprt -> xp_auth , gd ) ; if ( rqst -> rq_cred . oa_length <= 0 ) return ( AUTH_BADCRED ) ; gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; memset ( gc , 0 , sizeof ( * gc ) ) ; log_debug ( \"calling xdrmem_create()\" ) ; log_debug ( \"oa_base=%p, oa_length=%u\" , rqst -> rq_cred . oa_base , rqst -> rq_cred . oa_length )",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> gr_token ) ; <vul-end> ret_freegc ( AUTH_FAILED <vul-start> gd -> checksum <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> gr_token ) ; <vul-end> ret_freegc ( AUTH_FAILED <vul-start> gr_token ) ; <vul-end> if (! <vul-start> -> checksum ) <vul-end> ; if (\n"
 },
 {
  "id": 701,
  "question": "CWE-129 Code Input Vulnerable Code Is: CWE-129 static int cbs_av1_read_uvlc ( CodedBitstreamContext * ctx , GetBitContext * gbc , const char * name , uint32_t * write_to , uint32_t range_min , uint32_t range_max ) { <vul-start> uint32_t value ; <vul-end> <vul-start> int position , zeroes , i , j ; <vul-end> char bits [ 65 ] ; if ( ctx -> trace_enable ) position = get_bits_count ( gbc ) ; <vul-start> zeroes = i = 0 ; <vul-end> while ( 1 ) { <vul-start> if ( get_bits_left ( gbc ) < zeroes + 1 ) { <vul-end> av_log ( ctx -> log_ctx , AV_LOG_ERROR , \"Invalid uvlc code at \" \"%s: bitstream ended.\\\\n\" , name ) ; return AVERROR_INVALIDDATA ; } <vul-start> if ( get_bits1 ( gbc ) ) { <vul-end> bits [ i ++ ] = '1' ; <vul-start> break ; <vul-end> } else { bits [ i ++ ] = '0' ; ++ zeroes ; } } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { value = get_bits_long ( gbc , zeroes ) ; for ( j = 0 ; j < zeroes ; j ++ ) <vul-start> bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? '1' : '0' ; <vul-end> <vul-start> value += ( 1 << zeroes ) - 1 ; <vul-end> } if ( ctx -> trace_enable ) { bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , value ) ; } if ( value < range_min",
  "golden_answers": [
   "CWE-129 Fixed Code Lines are: <vul-start> ) { uint32_t zeroes , bits_value , <vul-start> ; int position <vul-end> ; if ( <vul-start> ; zeroes = <vul-end> 0 ; while <vul-start> gbc ) < <vul-end> 1 ) { <vul-start> gbc ) ) break ; ++ zeroes ; } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { if ( get_bits_left ( gbc ) < zeroes ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , \"Invalid uvlc code at \" \"%s: bitstream ended.\\\\n\" , name ) ; return AVERROR_INVALIDDATA ; } bits_value = get_bits_long ( gbc , zeroes ) ; value = bits_value + ( UINT32_C ( 1 ) << zeroes ) - 1 ; } if ( ctx -> trace_enable ) { char bits [ 65 ] ; int i , j , k ; if ( zeroes >= 32 ) { while ( zeroes > 32 ) { k = FFMIN ( zeroes - 32 , 32 ) ; for ( i = 0 ; i < k ; i ++ ) bits [ i ] = '0' ; bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , 0 ) ; zeroes -= k ; position += k ; } } for ( i = 0 ; i < zeroes ; i ++ ) bits [ i ] = '0' ; <vul-end> bits [ i <vul-start> = '1' ; if ( zeroes < 32 ) { <vul-end> for ( j <vul-start> ] = ( bits_value <vul-end> >> ( zeroes <vul-start> : '0' ; } <vul-end> bits [ i\n"
  ],
  "generated_answer": "CWE-129 Fixed Code Lines are: <vul-start> ) { uint32_t bits [ 65 ] ; int position, j ; uint32_t value <vul-end> ; int position <vul-start> position, zeroes <vul-end> ; char bits <vul-start> gbc ) ; for ( i = 0 ; i < 65 ; ++ i <vul-end> ) { if <vul-start> ) ) { bits [ i <vul-end> ] = '1' <vul-start> = '1' ; } else { bits [ i ++ ] = '0' ; ++ zeroes ; } } <vul-end> value = get_bits_long <vul-start> j ++ ) { <vul-start> : '0' ; } if ( ctx -> trace_enable ) { bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx, position, name, NULL, bits, value ) ; } <vul-end> if ( value\n"
 },
 {
  "id": 702,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame , <vul-end> <vul-start> double this_frame_mv_in_out ) { <vul-end> double frame_boost ; <vul-start> if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min ) <vul-end> <vul-start> frame_boost = ( IIFACTOR * this_frame -> intra_error / <vul-end> <vul-start> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; <vul-end> else frame_boost = ( IIFACTOR * cpi -> twopass . gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; if ( this_frame_mv_in_out > 0.0 ) frame_boost += frame_boost * ( this_frame_mv_in_out * 2.0 ) ; else frame_boost += frame_boost * ( this_frame_mv_in_out / 2.0 ) ; <vul-start> return MIN ( frame_boost , GF_RMAX ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cpi , const <vul-start> , double this_frame_mv_in_out , double max_boost <vul-start> double frame_boost ; const double lq = vp9_convert_qindex_to_q ( cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ; const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ; int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ; <vul-end> frame_boost = ( <vul-start> frame_boost = ( BASELINE_ERR_PER_MB * num_mbs ) <vul-end> / DOUBLE_DIVIDE_CHECK ( <vul-start> -> coded_error ) ; frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction <vul-end> ; if ( <vul-start> ( frame_boost , max_boost * boost_q_correction <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, const FIRSTPASS_STATS * stats <vul-end>, double this_frame_mv_in_out <vul-start>, double this_frame_mv_in_out, double gf_group_id <vul-start> ; if ( stats <vul-end> -> intra_error > <vul-start> -> intra_error > gf_group_id_min ) { <vul-start> ( IIFACTOR * stats <vul-end> -> intra_error / <vul-start> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; } else { frame_boost = ( IIFACTOR * stats <vul-end> -> intra_error / <vul-start> ) ) ; } <vul-start> 2.0 ) ; if ( gf_group_id!= 0 ) { gf_group_boost_level = MIN ( gf_group_boost, GF_RMAX ) ; } else { gf_group_boost_level = GF_RMAX ; } }\n"
 },
 {
  "id": 703,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , uint32_t length ) { <vul-start> int v , i ; <vul-end> if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length ; i ++ ) { v = bytestream2_get_byte ( & s -> gb ) ; s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; } } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || <vul-start> ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) <vul-end> return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length / 2 ; i ++ ) { v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; if ( s -> bit_depth > 8 ) AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; else s -> transparent_color_be [ i ] = v ; } } else { return AVERROR_INVALIDDATA ; } bytestream2_skip ( & s -> gb , 4 ) ; s -> has_trns = 1 ; return 0 ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> , i ; if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , \"trns before IHDR\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , \"trns after IDAT\\\\n\" ) ; return AVERROR_INVALIDDATA ; } <vul-start> != 6 ) || s -> bit_depth == 1\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> v, i ; if ( s -> has_trns ) return AVERROR_INVALIDDATA <vul-start>!= 6 ) || ( s -> color_type == PNG_COLOR_TYPE_RGB && length!= 7 )\n"
 },
 {
  "id": 704,
  "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 <vul-start> struct mb_cache * <vul-end> <vul-start> ext4_xattr_create_cache ( char * name ) <vul-end> { <vul-start> return mb_cache_create ( name , HASH_BUCKET_BITS ) ; <vul-end> }",
  "golden_answers": [
   "CWE-19 Fixed Code Lines are: <vul-start>     struct mb2_cache <vul-end> * ext4_xattr_create_cache ( <vul-start> * ext4_xattr_create_cache ( void <vul-end> ) { return <vul-start> ) { return mb2_cache_create ( <vul-end> HASH_BUCKET_BITS ) ;\n"
  ],
  "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start>       struct mb2_cache <vul-end> * ext4_xattr_create_cache ( <vul-start> char * name, struct mb2_cache * e ) { if (! ext4_xattr_create_cache ) return NULL ; <vul-end> return mb_cache_create ( <vul-start> ( name, e -> mb2_cache_hash_bucket_bits <vul-end> ) ; }\n"
 },
 {
  "id": 705,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void adjust_branches ( struct bpf_prog * prog , int pos , int delta ) { struct bpf_insn * insn = prog -> insnsi ; int insn_cnt = prog -> len ; int i ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) != BPF_JMP || BPF_OP ( insn -> code ) == BPF_CALL || BPF_OP ( insn -> code ) == BPF_EXIT ) continue ; if ( i < pos && i + insn -> off + 1 > pos ) insn -> off += delta ; <vul-start> else if ( i > pos && i + insn -> off + 1 < pos ) <vul-end> insn -> off -= delta ; } }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> i > pos + delta <vul-start> off + 1 <= pos + delta <vul-end> ) insn ->\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> if ( i >= <vul-end> pos && i <vul-start> off + 1 <= <vul-end> pos ) insn\n"
 },
 {
  "id": 706,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int main ( int argc , char * argv [ ] ) { <vul-start> p_fm_config_conx_hdlt hdl ; <vul-end> int instance = 0 ; fm_mgr_config_errno_t res ; char * rem_addr = NULL ; char * community = \"public\" ; char Opts [ 256 ] ; int arg ; char * command ; int i ; strcpy ( Opts , \"i:d:h-\" ) ; while ( ( arg = getopt ( argc , argv , Opts ) ) != EOF ) { switch ( arg ) { case 'h' : case '-' : usage ( argv [ 0 ] ) ; return ( 0 ) ; case 'i' : instance = atol ( optarg ) ; break ; case 'd' : rem_addr = optarg ; break ; default : usage ( argv [ 0 ] ) ; return ( - 1 ) ; } } if ( optind >= argc ) { fprintf ( stderr , \"Command required\\\\n\" ) ; usage ( argv [ 0 ] ) ; return - 1 ; } command = argv [ optind ++ ] ; printf ( \"Connecting to %s FM instance %d\\\\n\" , ( rem_addr == NULL ) ? \"LOCAL\" : rem_addr , instance ) ; if ( ( res = fm_mgr_config_init ( & hdl , instance , rem_addr , community ) ) != FM_CONF_OK ) { fprintf ( stderr , \"Failed to initialize the client handle: %d\\\\n\" , res ) ; <vul-start> goto die_clean ; <vul-end> } if ( ( res = fm_mgr_config_connect ( hdl ) ) != FM_CONF_OK ) { fprintf ( stderr , \"Failed to connect: (%d) %s\\\\n\"",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> { p_fm_config_conx_hdlt hdl = NULL <vul-start> ) ; goto cleanup <vul-end> ; } if <vul-start> ) ; goto cleanup <vul-end> ; } for <vul-start> 0 ) { res = <vul-end> commandList [ i <vul-start> ] ) ; goto cleanup ; <vul-start> - 1 ; cleanup : if ( hdl ) { if ( hdl -> sm_hdl ) { if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ; } if ( hdl -> pm_hdl ) { if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ; } if ( hdl -> fe_hdl ) { if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ; } <vul-end> free ( hdl <vul-start> hdl ) ; }\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ] ) { int ret = 0 ; <vul-start> ) ; goto err <vul-end> ; } for <vul-start> 0 ) { ret = <vul-end> commandList [ i <vul-start> ] ) ; if ( ret < 0 ) { fprintf ( stderr, \"Failed to execute command: (%d) %s\\\\n\", ret, fm_mgr_get_error_str ( res ) ) ; goto die_clean ; } } fprintf ( stderr, \"Command (%s) is not valid\\\\n\", command ) ; usage ( argv [ 0 ] ) ; res = - 1 ; err : if ( hdl ) free ( hdl ) ; return <vul-end> res ; } <vul-start> - 1 ; err <vul-end> : if ( <vul-start> ) ; return ( res ) <vul-end> ; }  \n"
 },
 {
  "id": 707,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( \"%s failed vm entry %x\\\\n\" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return 0 ; return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> : case EXIT_REASON_INVEPT : case EXIT_REASON_VM_EXITING\n"
 },
 {
  "id": 708,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static long gfs2_fallocate ( struct file * file , int mode , loff_t offset , loff_t len ) { struct inode * inode = file -> f_path . dentry -> d_inode ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct gfs2_inode * ip = GFS2_I ( inode ) ; unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ; loff_t bytes , max_bytes ; struct gfs2_alloc * al ; int error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ; <vul-start> next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift ; <vul-end> if ( mode & ~ FALLOC_FL_KEEP_SIZE ) return - EOPNOTSUPP ; offset &= bsize_mask ; len = next - offset ; bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2 ; if ( ! bytes ) bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize ; gfs2_holder_init ( ip -> i_gl , LM_ST_EXCLUSIVE , 0 , & ip -> i_gh ) ; error = gfs2_glock_nq ( & ip -> i_gh ) ; if ( unlikely ( error ) ) goto out_uninit ; if ( ! gfs2_write_alloc_required ( ip , offset , len ) ) goto out_unlock ; while ( len > 0 ) { if ( len < bytes ) bytes = len ; al = gfs2_alloc_get ( ip ) ; if",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <vul-start> ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , <vul-end> & max_bytes ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. sb_bsize_shift ; if ( next > sdp -> sd_max_rg_data ) { error = - EOPNOTSUPP ; goto out_unlock ; } <vul-start>, & ind_blocks ) ; if ( error ) goto out_unlock ; max_bytes = max_bytes >> sdp -> sd_sb. sb_bsize_shift\n"
 },
 {
  "id": 709,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int dccp_print_option ( netdissect_options * ndo , const u_char * option , u_int hlen ) { uint8_t optlen , i ; ND_TCHECK ( * option ) ; if ( * option >= 32 ) { ND_TCHECK ( * ( option + 1 ) ) ; optlen = * ( option + 1 ) ; if ( optlen < 2 ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , \"CCID option %u optlen too short\" , * option ) ) ; else ND_PRINT ( ( ndo , \"%s optlen too short\" , tok2str ( dccp_option_values , \"Option %u\" , * option ) ) ) ; return 0 ; } } else optlen = 1 ; if ( hlen < optlen ) { if ( * option >= 128 ) ND_PRINT ( ( ndo , \"CCID option %u optlen goes past header length\" , * option ) ) ; else ND_PRINT ( ( ndo , \"%s optlen goes past header length\" , tok2str ( dccp_option_values , \"Option %u\" , * option ) ) ) ; return 0 ; } ND_TCHECK2 ( * option , optlen ) ; if ( * option >= 128 ) { ND_PRINT ( ( ndo , \"CCID option %d\" , * option ) ) ; switch ( optlen ) { case 4 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_16BITS ( option + 2 ) ) ) ; break ; case 6 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; default : break",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( optlen == 6 <vul-end> ) ND_PRINT ( <vul-start> ( ndo , \" [optlen != 6]\" <vul-end> ) ) ; <vul-start> case 42 : switch ( optlen ) { case 6 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; case 8 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , \" (elapsed time %u)\" , EXTRACT_16BITS ( option + 6 ) ) ) ; break ; case 10 : ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , \" (elapsed time %u)\" , EXTRACT_32BITS ( option + 6 ) ) ) ; break ; default : ND_PRINT ( ( ndo , \" [optlen != 6 or 8 or 10]\" ) ) ; break ; } break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <vul-start> , \" %u\" , EXTRACT_16BITS <vul-end> ( option + <vul-start> ( ndo , \" [optlen != 4 or 6]\" <vul-end> ) ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> case 41 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> ) ) ; <vul-end> break ; case <vul-start> case 42 : ND_TCHECK_32BITS ( option + 2 ) ; <vul-start> ) ) ; <vul-end> ND_PRINT ( ( <vul-start> case 43 : ND_TCHECK_16BITS ( option + 2 ) ; <vul-start> ) ) ; <vul-end> ND_PRINT ( ( <vul-start> ) ) ; } if ( optlen == 4 ) { ND_PRINT ( ( ndo, \" %u\", EXTRACT_32BITS ( option + 2 ) ) ) ; } else { ND_PRINT ( ( ndo, \" optlen!= 4\" ) ) ; } break ; case 43 : if ( optlen == 6 ) { ND_PRINT ( ( ndo, \" 0x\" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo, \"%02x\", * ( option + 2 + i ) ) ) ; } else { ND_PRINT ( ( ndo, \" optlen!= 6\" ) ) ; } break ; case 44 : if ( optlen == 4 ) { ND_PRINT ( ( ndo, \" 0x\" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo, \"%02x\", * ( option + 2 + i ) ) ) ; } else { ND_PRINT ( ( ndo, \" optlen!= 4\" ) ) ; } break ; case 44 : if ( optlen == 4 ) { ND_PRINT ( ( ndo, \" \" ) ) ; for ( i = 0 ; i < optlen - 2 ; i ++ ) ND_PRINT ( ( ndo, \"%02x\", * ( option + 2 + i ) ) ) ; } else { ND_PRINT ( ( ndo, \" optlen!= 4\" ) ) ; } break ; case 42 : if ( optlen == 4 ) { ND_PRINT ( ( ndo, \" %u\", EXTRACT_32BITS ( option + 2 ) ) ) ; } else { <vul-start> ) ) ; } <vul-end> break ; }\n"
 },
 {
  "id": 710,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , \"%s > %s: [|pgm]\" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { ND_PRINT ( ( ndo , \"%s > %s: [|pgm]\" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , \"%s.%s > %s.%s: \" , ip6addr_string ( ndo , & ip6 ->",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) <vul-start> ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_LENGTH option, length %u != %u]\" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , \" OPTS LEN (extra?) %d\" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_FRAGMENT option, length %u != %u]\" , opt_len , PGM_OPT_FRAGMENT_LEN <vul-end> ) ) ; <vul-start> return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" FRAG seq %u off %u len %u\" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , \" NAK LIST\" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , \"[Option length not a multiple of 4]\" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , \" %u\" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 <vul-end> ; opts_len -= <vul-start> -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) <vul-end> if ( opt_len <vul-start> ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_JOIN option, length %u != %u]\" , opt_len , PGM_OPT_JOIN_LEN <vul-end> ) ) ; <vul-start> ; bp += 4 ; ND_PRINT ( ( ndo , \" JOIN %u\" , seq <vul-end> ) ) ; <vul-start> ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) <vul-end> if ( opt_len <vul-start> if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_NAK_BO_IVL option, length %u != %u]\" , opt_len , PGM_OPT_NAK_BO_IVL_LEN <vul-end> ) ) ; <vul-start> return ; } bp += 2 ; offset = <vul-end> EXTRACT_32BITS ( bp <vul-start> ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" BACKOFF ivl %u ivlseq %u\" , offset , seq ) <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) <vul-end> if ( opt_len <vul-start> ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_NAK_BO_RNG option, length %u != %u]\" , opt_len , PGM_OPT_NAK_BO_RNG_LEN <vul-end> ) ) ; <vul-start> += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; <vul-start> ; bp += 4 ; ND_PRINT ( ( ndo , \" BACKOFF max %u min %u\" , offset <vul-end> , seq ) <vul-start> ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) <vul-end> if ( opt_len <vul-start> if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_REDIRECT option, length %u < %u]\" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_REDIRECT option, length %u != %u + address size]\" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN <vul-end> ) ) ; <vul-start> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <vul-end> : if ( <vul-start> ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_REDIRECT option, length %u != %u + address size]\" , PGM_OPT_REDIRECT_FIXED_LEN <vul-end> , opt_len ) <vul-start> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , \" REDIRECT %s\" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) <vul-end> if ( opt_len <vul-start> ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_PARITY_PRM option, length %u != %u]\" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" PARITY MAXTGS %u\" , len ) <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) <vul-end> if ( opt_len <vul-start> ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_PARITY_GRP option, length %u != %u]\" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" PARITY GROUP %u\" , seq ) <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_CURR_TGSIZE option, length %u != %u]\" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , \" PARITY ATGS %u\" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_NBR_UNREACH option, length %u != %u]\" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" NBR_UNREACH\" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , \" PATH_NLA [%d]\" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_SYN option, length %u != %u]\" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" SYN\" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_FIN option, length %u != %u]\" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" FIN\" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_RST option, length %u != %u]\" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" RST\" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , \" CR\" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_CRQST option, length %u != %u]\" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , \" CRQST\" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_DATA option, length %u < %u]\" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_DATA option, length %u != %u + address size]\" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_DATA option, length %u != %u + address size]\" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN <vul-end> + sizeof ( <vul-start> ( ndo , \" PGMCC DATA %u %s\" , offset <vul-end> , nla_buf ) <vul-start> break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) <vul-end> if ( opt_len <vul-start> if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , \"[Bad PGM_OPT_PGMCC_FEEDBACK option, length %u < %u]\" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]\" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <vul-end> ) ) ; <vul-start> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <vul-end> : if ( <vul-start> ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , \"[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]\" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <vul-end> ) ) ; <vul-start> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <vul-end> ) ; opts_len <vul-start> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <vul-end> + sizeof (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -= 4 ; if ( opts_len < 4 ) goto trunc ; <vul-start> case PGM_OPT_FRAGMENT : ND_TCHECK_16BITS ( bp ) ; <vul-start> -= 4 ; ND_TCHECK_16BITS ( bp ) ;\n"
 },
 {
  "id": 711,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t httpParseParam ( const char_t * * pos , HttpParam * param ) { error_t error ; size_t i ; uint8_t c ; bool_t escapeFlag ; bool_t separatorFound ; const char_t * p ; if ( pos == NULL || param == NULL ) return ERROR_INVALID_PARAMETER ; param -> name = NULL ; param -> nameLen = 0 ; param -> value = NULL ; param -> valueLen = 0 ; escapeFlag = FALSE ; separatorFound = FALSE ; error = ERROR_IN_PROGRESS ; i = 0 ; p = * pos ; while ( error == ERROR_IN_PROGRESS ) { c = ( uint8_t ) p [ i ] ; if ( param -> name == NULL ) { if ( c == '\\\\0' ) { error = ERROR_NOT_FOUND ; } else if ( c == ' ' || c == '\\\\t' || c == ',' || c == ';' ) { } <vul-start> else if ( isalnum ( c ) || strchr ( \"!#$%&\\'*+-.^_`|~\" , c ) || c >= 128 ) <vul-end> { param -> name = p + i ; } else { error = ERROR_INVALID_SYNTAX ; } } else if ( param -> nameLen == 0 ) { if ( c == '\\\\0' || c == ',' || c == ';' ) { param -> nameLen = p + i - param -> name ; error = NO_ERROR ; } else if ( c == ' ' || c == '\\\\t' ) { param -> nameLen = p + i - param -> name ; } else if ( c == '='",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" , <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" , <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" , <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" , <vul-start> c ) || osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" ,\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> c ) || ( p + i >= 128 ) && <vul-start> c ) || ( p + i >= 128 ) && <vul-start> c ) || ( p + i >= 128 ) && <vul-start> c ) || ( p + i >= 128 ) &&\n"
 },
 {
  "id": 712,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 <vul-start> static void cancel_att_send_op ( struct att_send_op * op ) <vul-end> { if ( op -> destroy ) op -> destroy ( op -> user_data ) ; op -> user_data = NULL ; op -> callback = NULL ; op -> destroy = NULL ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> void cancel_att_send_op ( void * data ) { <vul-start> att_send_op * op = data ; <vul-end> if ( op\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start>       <vul-end> void cancel_att_send_op (\n"
 },
 {
  "id": 713,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , \".fini_array\" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , \".init_array\" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , \".preinit_array\" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { <vul-start> for ( i = 0 ; i < sec -> size ; i += 4 ) { <vul-end> ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else { <vul-start> for ( i = 0 ; i < sec -> size ; i += 8 ) { <vul-end> ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; ( i + 3 ) <vul-end> < sec -> <vul-start> = 0 ; ( i + 7 ) <vul-end> < sec ->\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 32 ) { if (! r_list_is_empty ( ret ) ) { <vul-start> } else { if (! r_list_is_empty ( ret ) ) { <vul-start> 8 ) { if (! r_list_is_empty ( ret ) ) { <vul-start> ba ) ; }\n"
 },
 {
  "id": 714,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void nw_cache_free ( nw_cache * cache , void * obj ) { if ( cache -> free < cache -> free_total ) { cache -> free_arr [ cache -> free ++ ] = obj ; <vul-start> } else { <vul-end> uint32_t new_free_total = cache -> free_total * 2 ; void * new_arr = realloc ( cache -> free_arr , new_free_total * sizeof ( void * ) ) ; if ( new_arr ) { cache -> free_total = new_free_total ; cache -> free_arr = new_arr ; cache -> free_arr [ cache -> free ++ ] = obj ; } else { free ( obj ) ; } <vul-start> } <vul-end> }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ; } else if ( cache -> free_total < NW_CACHE_MAX_SIZE ) <vul-start> ; } } else { free ( obj ) ; }\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = obj ; cache -> free_total ++ ; <vul-start> ) ; } cache -> free_total = new_free_total ;\n"
 },
 {
  "id": 715,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int jpc_dec_tileinit ( jpc_dec_t * dec , jpc_dec_tile_t * tile ) { jpc_dec_tcomp_t * tcomp ; int compno ; int rlvlno ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; jpc_dec_prc_t * prc ; int bndno ; jpc_tsfb_band_t * bnd ; int bandno ; jpc_dec_ccp_t * ccp ; int prccnt ; jpc_dec_cblk_t * cblk ; int cblkcnt ; uint_fast32_t tlprcxstart ; uint_fast32_t tlprcystart ; uint_fast32_t brprcxend ; uint_fast32_t brprcyend ; uint_fast32_t tlcbgxstart ; uint_fast32_t tlcbgystart ; uint_fast32_t brcbgxend ; uint_fast32_t brcbgyend ; uint_fast32_t cbgxstart ; uint_fast32_t cbgystart ; uint_fast32_t cbgxend ; uint_fast32_t cbgyend ; uint_fast32_t tlcblkxstart ; uint_fast32_t tlcblkystart ; uint_fast32_t brcblkxend ; uint_fast32_t brcblkyend ; uint_fast32_t cblkxstart ; uint_fast32_t cblkystart ; uint_fast32_t cblkxend ; uint_fast32_t cblkyend ; uint_fast32_t tmpxstart ; uint_fast32_t tmpystart ; uint_fast32_t tmpxend ; uint_fast32_t tmpyend ; jpc_dec_cp_t * cp ; <vul-start> jpc_tsfb_band_t bnds [ 64 ] ; <vul-end> jpc_pchg_t * pchg ; int pchgno ; jpc_dec_cmpt_t * cmpt ; cp = tile -> cp ; tile -> realmode = 0 ; if ( cp -> mctid == JPC_MCT_ICT ) { tile -> realmode = 1 ; } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { ccp = & tile -> cp -> ccps [ compno ] ; if ( ccp -> qmfbid == JPC_COX_INS ) { tile -> realmode = 1 ; } tcomp -> numrlvls = ccp -> numrlvls ; if ( ! ( tcomp -> rlvls = jas_alloc2 ( tcomp -> numrlvls",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> jpc_tsfb_band_t bnds [ JPC_MAXBANDS <vul-end> ] ; jpc_pchg_t\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> * cp ; jpc_tsfb_band_t <vul-end> bnds [ 64 <vul-start> ; if (! bnds [ 0 ] ||! bnds [ 1 ] ) { return - 1 ; } if (\n"
 },
 {
  "id": 716,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void ndpi_reset_packet_line_info ( struct ndpi_packet_struct * packet ) { packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 , <vul-start> packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , <vul-end> packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet ->\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>, packet -> http_contentlen. ptr = NULL, packet -> http_contentlen. len = 0, packet -> <vul-start>, packet -> http_cookie. ptr = NULL, packet -> http_cookie. <vul-end> len = 0\n"
 },
 {
  "id": 717,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; if ( ! proc_fd_access_allowed ( inode ) ) goto out ; error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ; <vul-start> nd -> last_type = LAST_BIND ; <vul-end> out : return ERR_PTR ( error ) ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> path ) ; <vul-end> out : return\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> path ) ; if ( error == 0 )\n"
 },
 {
  "id": 718,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ; <vul-start> assert ( pow ( ( float ) r + 1 , dim ) > entries ) ; <vul-end> <vul-start> assert ( ( int ) floor ( pow ( ( float ) r , dim ) ) <= entries ) ; <vul-end> return r ; }",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> ++ r ; if <vul-end> ( pow ( <vul-start> , dim ) <= entries ) return - 1 ; if <vul-end> ( ( int <vul-start> dim ) ) > entries ) return - 1 <vul-end> ; return r\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> ++ r ; if ( r < 0 || r >= dim ) return - 1 ; <vul-start> entries ) ; if ( r < 0 || r >= dim ) return - 1 <vul-end> ; return r\n"
 },
 {
  "id": 719,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void xen_netbk_fill_frags ( struct xen_netbk * netbk , struct sk_buff * skb ) { struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i ; for ( i = 0 ; i < nr_frags ; i ++ ) { skb_frag_t * frag = shinfo -> frags + i ; struct xen_netif_tx_request * txp ; struct page * page ; u16 pending_idx ; pending_idx = frag_get_pending_idx ( frag ) ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ; __skb_fill_page_desc ( skb , i , page , txp -> offset , txp -> size ) ; skb -> len += txp -> size ; skb -> data_len += txp -> size ; skb -> truesize += txp -> size ; get_page ( netbk -> mmap_pages [ pending_idx ] ) ; <vul-start> xen_netbk_idx_release ( netbk , pending_idx ) ; <vul-end> } }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> netbk , pending_idx , XEN_NETIF_RSP_OKAY\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> netbk, pending_idx, XEN_NETIF_RSP_OKAY\n"
 },
 {
  "id": 720,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <vul-end> { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != NULL ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } if ( open_stateid != NULL ) <vul-start> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <vul-end> write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; <vul-start> update_open_stateflags ( state , open_flags ) ; <vul-end> spin_unlock ( & state -> owner -> so_lock ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> * deleg_stateid , fmode_t fmode <vul-end> ) { write_seqlock <vul-start> , open_stateid , fmode <vul-end> ) ; write_sequnlock <vul-start> ( state , fmode <vul-end> ) ; spin_unlock\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * deleg_stateid, fmode_t fmode <vul-end> ) { write_seqlock <vul-start>, open_stateid, fmode <vul-end> ) ; write_sequnlock <vul-start> ( state, fmode <vul-end> ) ; spin_unlock\n"
 },
 {
  "id": 721,
  "question": "CWE-436 Code Input Vulnerable Code Is: CWE-436 static void flatpak_proxy_client_finalize ( GObject * object ) { FlatpakProxyClient * client = FLATPAK_PROXY_CLIENT ( object ) ; client -> proxy -> clients = g_list_remove ( client -> proxy -> clients , client ) ; <vul-start> g_clear_object ( & client -> proxy ) ; <vul-end> g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; free_side ( & client -> client_side ) ; free_side ( & client -> bus_side ) ; G_OBJECT_CLASS ( flatpak_proxy_client_parent_class ) -> finalize ( object ) ; }",
  "golden_answers": [
   "CWE-436 Fixed Code Lines are: <vul-start> client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE\n"
  ],
  "generated_answer": "CWE-436 Fixed Code Lines are: <vul-start> client ) ; g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; g_clear_object ( & client -> proxy <vul-end> ) ; g_hash_table_destroy\n"
 },
 {
  "id": 722,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int my_csr_reader ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , REALTYPE * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , \"r\" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , \"cannot open CSR file!\\\\n\" ) ; return - 1 ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , \"could not read file length!\\\\n\" ) ; return - 1 ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <vul-start> if ( sscanf ( l_line , \"%u %u %u\" , o_row_count , o_column_count , o_element_count ) == 3 ) { <vul-end> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( REALTYPE * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <vul-end> { * o_column_idx\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start>, o_element_count ) && 0!= * o_row_count && 0!= * o_column_count && 0!= * o_element_count ) <vul-end> { * o_column_idx\n"
 },
 {
  "id": 723,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int jp2_box_put ( jp2_box_t * box , jas_stream_t * out ) { jas_stream_t * tmpstream ; bool extlen ; bool dataflag ; tmpstream = 0 ; dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( box -> ops -> putdata ) { if ( ( * box -> ops -> putdata ) ( box , tmpstream ) ) { goto error ; } } box -> len = jas_stream_tell ( tmpstream ) + JP2_BOX_HDRLEN ( false ) ; jas_stream_rewind ( tmpstream ) ; } extlen = ( box -> len >= ( ( ( uint_fast64_t ) 1 ) << 32 ) ) != 0 ; if ( jp2_putuint32 ( out , extlen ? 1 : box -> len ) ) { goto error ; } if ( jp2_putuint32 ( out , box -> type ) ) { goto error ; } if ( extlen ) { if ( jp2_putuint64 ( out , box -> len ) ) { goto error ; } } if ( dataflag ) { <vul-start> if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) { <vul-end> goto error ; } jas_stream_close ( tmpstream ) ; } return 0 ; error : if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return - 1 ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ) ) { jas_eprintf ( \"cannot copy box data\\\\n\" ) ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> { if (! box -> ops -> putdata ) { if ( ( * box -> ops -> putdata ) ( box, tmpstream ) ) { goto error ; } } if ( <vul-start> ) ) { goto error ; } <vul-end> jas_stream_close ( tmpstream\n"
 },
 {
  "id": 724,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <vul-start> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <vul-end> <vul-start> Min ( 4 , dds_info -> height - y ) , exception ) ; <vul-end> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> , y , MagickMin <vul-end> ( 4 , <vul-start> x ) , MagickMin <vul-end> ( 4 , <vul-start> ; } } return ( <vul-start> dds_info , 8 , exception ) ) <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, y, MagickMin <vul-end> ( 4, <vul-start> x ), MagickMin <vul-end> ( 4, <vul-start> ; } } return ( <vul-start> dds_info, 8, exception ) ) <vul-end> ; }  \n"
 },
 {
  "id": 725,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8dx_receive_compressed_data ( VP8D_COMP * pbi , size_t size , const uint8_t * source , int64_t time_stamp ) { <vul-start> # if HAVE_NEON <vul-end> int64_t dx_store_reg [ 8 ] ; # endif VP8_COMMON * cm = & pbi -> common ; int retcode = - 1 ; <vul-start> pbi -> common . error . error_code = VPX_CODEC_OK ; <vul-end> retcode = check_fragments_for_errors ( pbi ) ; if ( retcode <= 0 ) return retcode ; <vul-start> # if HAVE_NEON <vul-end> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( dx_store_reg ) ; } # endif cm -> new_fb_idx = get_free_fb ( cm ) ; pbi -> dec_fb_ref [ INTRA_FRAME ] = & cm -> yv12_fb [ cm -> new_fb_idx ] ; pbi -> dec_fb_ref [ LAST_FRAME ] = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; pbi -> dec_fb_ref [ GOLDEN_FRAME ] = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; pbi -> dec_fb_ref [ ALTREF_FRAME ] = & cm -> yv12_fb [ cm -> alt_fb_idx ] ; if ( setjmp ( pbi -> common . error . jmp ) ) { cm -> yv12_fb [ cm -> lst_fb_idx ] . corrupted = 1 ; if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; goto decode_exit ; } pbi -> common . error . setjmp = 1 ; retcode = vp8_decode_frame ( pbi ) ; if ( retcode < 0 ) { if ( cm -> fb_idx_ref_cnt [ cm ->",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> time_stamp ) { <vul-end> VP8_COMMON * cm <vul-start> - 1 ; ( void ) size ; ( void ) source ; <vul-start> return retcode ; <vul-end> cm -> new_fb_idx <vul-start> ; decode_exit : <vul-end> pbi -> common <vul-start> = 0 ; vp8_clear_system_state ( ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> time_stamp ) { <vul-end> VP8_COMMON * cm <vul-start> - 1 ; # if CONFIG_MULTI_RES_ENCODING if ( cm -> mr_total_resolutions > 1 ) { vp8_clear_system_state ( ) ; } # endif <vul-start> return retcode ; <vul-end> cm -> new_fb_idx <vul-start> = 0 ; pbi -> common. error. error_code = VPX_CODEC_ERROR ;\n"
 },
 {
  "id": 726,
  "question": "CWE-755 Code Input Vulnerable Code Is: CWE-755 void AcpiNsTerminate ( void ) { ACPI_STATUS Status ; <vul-start> ACPI_FUNCTION_TRACE ( NsTerminate ) ; <vul-end> # ifdef ACPI_EXEC_APP { ACPI_OPERAND_OBJECT * Prev ; <vul-start> ACPI_OPERAND_OBJECT * Next ; <vul-end> Next = AcpiGbl_ModuleCodeList ; while ( Next ) { Prev = Next ; Next = Next -> Method . Mutex ; Prev -> Method . Mutex = NULL ; AcpiUtRemoveReference ( Prev ) ; } <vul-start> } <vul-end> # endif AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ; Status = AcpiUtAcquireMutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( Status ) ) { return_VOID ; } AcpiNsDeleteNode ( AcpiGbl_RootNode ) ; ( void ) AcpiUtReleaseMutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , \"Namespace freed\\\\n\" ) ) ; return_VOID ; }",
  "golden_answers": [
   "CWE-755 Fixed Code Lines are: <vul-start> ACPI_STATUS Status ; <vul-end> ACPI_OPERAND_OBJECT * Prev <vul-start> ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <vul-start> ) ; } <vul-end> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode\n"
  ],
  "generated_answer": "CWE-755 Fixed Code Lines are: <vul-start> ACPI_STATUS Status ; <vul-end> ACPI_OPERAND_OBJECT * Prev <vul-start> ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <vul-start> ) ; } <vul-end> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode\n"
 },
 {
  "id": 727,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_withitem ( void * _o ) { withitem_ty o = ( withitem_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } result = PyType_GenericNew ( withitem_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_expr ( o -> context_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_context_expr , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> optional_vars ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_optional_vars , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } result\n"
 },
 {
  "id": 728,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void LineTo ( double x1 , double y1 ) { <vul-start> outpos += <vul-end> sprintf ( outpos , \"\\\\n %12.3f %12.3f l\" , x1 , y1 ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> y1 ) { sprintf ( outputbuffer <vul-end> , \"\\\\n %12.3f %12.3f l\" , <vul-start> y1 ) ; sendClean ( outputbuffer ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> y1 ) { sprintf ( outputbuffer <vul-end>, \"\\\\n %12.3f %12.3f l\", <vul-start> y1 ) ; sendClean ( outputbuffer ) ;\n"
 },
 {
  "id": 729,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t dm9000UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint8_t hashTable [ 8 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( \"Updating MAC filter...\\\\r\\\\n\" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; hashTable [ 7 ] = 0x80 ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = dm9000CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = crc & 0x3F ; hashTable [ k / 8 ] |= ( 1 << ( k % 8 ) ) ; } } for ( i = 0 ; i < 8 ; i ++ ) { <vul-start> dm9000WriteReg ( DM9000_REG_MAR0 + i , hashTable [ i ] ) ; <vul-end> } TRACE_DEBUG ( \" MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" \" \"%02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\\\r\\\\n\" , <vul-start> dm9000ReadReg ( DM9000_REG_MAR0 ) , dm9000ReadReg ( DM9000_REG_MAR1 ) , <vul-end> dm9000ReadReg ( DM9000_REG_MAR2 ) , dm9000ReadReg ( DM9000_REG_MAR3 ) , dm9000ReadReg ( DM9000_REG_MAR4 ) , dm9000ReadReg ( DM9000_REG_MAR5 ) , dm9000ReadReg ( DM9000_REG_MAR6 ) , dm9000ReadReg ( DM9000_REG_MAR7 ) ) ; return NO_ERROR ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> { dm9000WriteReg ( DM9000_MAR0 <vul-end> + i , <vul-start> , dm9000ReadReg ( DM9000_MAR0 ) , dm9000ReadReg ( DM9000_MAR1 ) , dm9000ReadReg ( DM9000_MAR2 ) , dm9000ReadReg ( DM9000_MAR3 ) , dm9000ReadReg ( DM9000_MAR4 ) , dm9000ReadReg ( DM9000_MAR5 ) , dm9000ReadReg ( DM9000_MAR6 ) , dm9000ReadReg ( DM9000_MAR7 <vul-end> ) ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> { dm9000WriteReg ( DM9000_MAR0 + i, hashTable [ i ] ) ; } for ( i = 0 ; i < 8 ; i ++ ) { dm9000WriteReg ( DM9000_MAR1 + i, hashTable [ i ] ) ; } for ( i = 0 ; i < 8 ; i ++ ) { dm9000WriteReg ( DM9000_MAR2 + i, hashTable [ i ] ) ; } for ( i = 0 ; i < 8 ; i ++ ) { dm9000WriteReg ( DM9000_MAR3 + i, hashTable [ i ] ) ; } for ( i = 0 ; i < 8 ; i ++ ) { dm9000WriteReg ( DM9000_MAR0 + i, DM9000_MAR1_BASE_ADDRESS <vul-end> + i, <vul-start>, dm9000ReadReg ( DM9000_MAR2 ), dm9000ReadReg ( DM9000_MAR3 ), dm9000ReadReg ( DM9000_MAR4 ), dm9000ReadReg ( DM9000_MAR5 ), dm9000ReadReg ( DM9000_MAR6 ), dm9000ReadReg ( DM9000_MAR7 ) ) ; } TRACE_DEBUG ( \" DM9000 MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\\\r\\\\n\", dm9000ReadReg ( DM9000_MAR0 ), dm9000ReadReg ( DM9000_MAR1 ), dm9000ReadReg ( DM9000_MAR2 ), dm9000ReadReg ( DM9000_MAR3 ), dm9000ReadReg ( DM9000_MAR4 ), dm9000ReadReg ( DM9000_MAR5 ), dm9000ReadReg ( DM9000_MAR6 ), dm9000ReadReg ( DM9000_MAR7 ) ) ; } TRACE_DEBUG ( \" DM9000 MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8"
 },
 {
  "id": 730,
  "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ; <vul-start> } <vul-end> retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel (",
  "golden_answers": [
   "CWE-19 Fixed Code Lines are: <vul-start> -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <vul-start> -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;\n"
  ],
  "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; <vul-start> ( args -> rmtvaluelen2 && args -> rmtvaluelen2 ) { error = xfs_attr3_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } else <vul-end> error = xfs_attr3_leaf_read\n"
 },
 {
  "id": 731,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const char * <vul-start> parse_field ( netdissect_options * ndo , const char * * pptr , int * len ) <vul-end> { const char * s ; <vul-start> if ( * len <= 0 || ! pptr || ! * pptr ) <vul-end> return NULL ; if ( * pptr > ( const char * ) ndo -> ndo_snapend ) return NULL ; s = * pptr ; <vul-start> while ( * pptr <= ( const char * ) ndo -> ndo_snapend && * len >= 0 && * * pptr ) { <vul-end> ( * pptr ) ++ ; ( * len ) -- ; } ( * pptr ) ++ ; ( * len ) -- ; <vul-start> if ( * len < 0 || * pptr > ( const char * ) ndo -> ndo_snapend ) <vul-end> return NULL ; return s ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> int * len , int * truncated <vul-start> * s ; <vul-end> s = * <vul-start> * pptr ; for ( ; ; ) { if ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST ( <vul-end> * * pptr <vul-start> * pptr ) ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\\\0' ) { break ; } <vul-end> ( * pptr <vul-start> ) -- ; <vul-end> return s ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> int * len, int * snapend <vul-start> * s ; <vul-end> s = * <vul-start> * pptr ; if ( * len == 0 || * pptr == <vul-end> ( const char <vul-start> ndo -> ndo_snapend ) ) return NULL ; if ( * snapend <vul-end> && * len <vul-start> >= 0 && ( * len ) -- ) { if ( * snapend == <vul-end> ( const char <vul-start> char * ) snapend ) return NULL ; } else { if ( * len < 0 || <vul-start> len < 0 <vul-end> ) return NULL\n"
 },
 {
  "id": 732,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ; <vul-start> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <vul-end> CORE_MMU_USER_PARAM_SIZE ) ; <vul-start> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <vul-end> return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <vul-start> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <vul-end> uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> uaddr_t a ; uaddr_t end_addr = 0 ; <vul-start> len , & end_addr <vul-end> ) ) return <vul-start> ( a = ROUNDDOWN ( uaddr , addr_incr ) <vul-end> ; a < <vul-start> ; a < end_addr <vul-end> ; a +=\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> a ; size_t addr_incr ; if ( flags & TEE_MEMORY_ACCESS_USER_CODE ) return TEE_ERROR_ACCESS_DENIED ; addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE, ( size_t ) len ) ; if ( flags & TEE_MEMORY_ACCESS_SECURE ) return TEE_ERROR_SECURE ; if ( flags & TEE_MEMORY_ACCESS_READ ) return TEE_ERROR_ACCESS_DENIED ; if ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) return TEE_ERROR_ACCESS_DENIED ; <vul-start>, & a <vul-end> ) ) return <vul-start> return TEE_ERROR_ACCESS_DENIED ; if ( addr_incr > CORE_MMU_USER_PARAM_SIZE - uaddr ) return TEE_ERROR_ACCESS_DENIED ;\n"
 },
 {
  "id": 733,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( \"%s: metadata is null!\" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = \"camera_metadata\" , . alignment = METADATA_ALIGNMENT } , { . name = \"camera_metadata_buffer_entry\" , . alignment = ENTRY_ALIGNMENT } , { . name = \"camera_metadata_data\" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( \"%s: Metadata pointer is not aligned (actual %p, \" \"expected %p) to type %s\" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( \"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( \"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \" \"(%\" PRIu32 \")\" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> } size_t data_size ; if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , <vul-end> entry . type <vul-start> . count ) != OK ) { ALOGE ( \"%s: Entry data size is invalid. type: %u count: %u\" , __FUNCTION__ , entry . type , entry . count ) ; return ERROR ; } <vul-end> if ( data_size\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ERROR ; } const size_t count = entry. count ; if ( count > ( size_t ) ( * expected_size - entry. data. offset ) ) { ALOGE ( \"%s: Entry index %zu had bad data alignment \" \"(address %p),\" \" expected align %zu (tag name %s)\", __FUNCTION__, i, ( uintptr_t ) ( <vul-end> entry. type <vul-start>. type, ( size_t ) entry. data. offset, ( size_t ) entry. data. length ) ; return ERROR ; } <vul-end> if ( data_size\n"
 },
 {
  "id": 734,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , \" ubik call %s\" , tok2str ( ubik_req , \"op#%d\" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , \" syncsite %s\" , temp ? \"yes\" : \"no\" ) ) ; ND_PRINT ( ( ndo , \" votestart\" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , \" dbversion\" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , \" tid\" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , \" site\" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , \" tid\" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , \" tid\" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , \" file\" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , \" pos\" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , \" length\" ) ) ; INTOUT (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( ) ; ND_TCHECK_32BITS ( bp ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( ) ; if ( len < sizeof ( int32_t ) ) goto trunc ;\n"
 },
 {
  "id": 735,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( \"section len: %u properties %u\\\\n\" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh .",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <vul-start> ) p + ofs <vul-end> - 2 * <vul-start> sizeof ( uint32_t ) <vul-start> SIZE_T_FORMAT \"u) id=%x type=%x offs=0x%tx,0x%x\\\\n\" , i , <vul-end> inp [ i <vul-start> - p , offs <vul-end> ) ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { if ( cdf_check_stream_offset ( sst, h, p, <vul-end> ( i << <vul-start> + 1 ), __LINE__ ) == - 1 ) goto out <vul-end> ; if ( <vul-start> 0 ) ; if ( cdf_check_stream_offset ( sst, h, p, q - p, <vul-end> ( i << <vul-start> + 1 ), __LINE__ ) == - 1 ) goto out <vul-end> ; if (\n"
 },
 {
  "id": 736,
  "question": "CWE-665 Code Input Vulnerable Code Is: CWE-665 static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( iph -> ihl < 5 || iph -> version != 4 ) goto inhdr_error ; if ( ! pskb_may_pull ( skb , iph -> ihl * 4 ) ) goto inhdr_error ; iph = ip_hdr ( skb ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; } <vul-start> if ( iph -> ihl == 5 ) { <vul-end> memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ; <vul-start> } <vul-end> opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev",
  "golden_answers": [
   "CWE-665 Fixed Code Lines are: <vul-start> drop ; } memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <vul-start> == 5 ) <vul-end> return 0 ; <vul-start> return 0 ; <vul-end> opt -> optlen\n"
  ],
  "generated_answer": "CWE-665 Fixed Code Lines are: <vul-start> == 5 ) <vul-end> return 0 ; <vul-start> return 0 ; <vul-end> opt -> optlen\n"
 },
 {
  "id": 737,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 <vul-start> static char * mongo_data_append ( char * start , const void * data , int len ) { <vul-end> memcpy ( start , data , len ) ; return start + len ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * data , size_t <vul-end> len ) {\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * data, size_t <vul-end> len ) {\n"
 },
 {
  "id": 738,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static struct mm_struct * mm_init ( struct mm_struct * mm , struct task_struct * p , struct user_namespace * user_ns ) { mm -> mmap = NULL ; mm -> mm_rb = RB_ROOT ; mm -> vmacache_seqnum = 0 ; atomic_set ( & mm -> mm_users , 1 ) ; atomic_set ( & mm -> mm_count , 1 ) ; init_rwsem ( & mm -> mmap_sem ) ; INIT_LIST_HEAD ( & mm -> mmlist ) ; mm -> core_state = NULL ; atomic_long_set ( & mm -> nr_ptes , 0 ) ; mm_nr_pmds_init ( mm ) ; mm -> map_count = 0 ; mm -> locked_vm = 0 ; mm -> pinned_vm = 0 ; memset ( & mm -> rss_stat , 0 , sizeof ( mm -> rss_stat ) ) ; spin_lock_init ( & mm -> page_table_lock ) ; mm_init_cpumask ( mm ) ; mm_init_aio ( mm ) ; mm_init_owner ( mm , p ) ; <vul-start> mmu_notifier_mm_init ( mm ) ; <vul-end> init_tlb_flush_pending ( mm ) ; # if defined ( CONFIG_TRANSPARENT_HUGEPAGE ) && ! USE_SPLIT_PMD_PTLOCKS mm -> pmd_huge_pte = NULL ; # endif if ( current -> mm ) { mm -> flags = current -> mm -> flags & MMF_INIT_MASK ; mm -> def_flags = current -> mm -> def_flags & VM_INIT_DEF_MASK ; } else { mm -> flags = default_dump_filter ; mm -> def_flags = 0 ; } if ( mm_alloc_pgd ( mm ) ) goto fail_nopgd ; if ( init_new_context ( p , mm ) ) goto fail_nocontext ; mm -> user_ns = get_user_ns ( user_ns ) ; return",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> p ) ; init_tlb_flush_pending ( mm ) ; <vul-start> mmu_notifier_mm_init ( mm <vul-end> ) ; #\n"
 },
 {
  "id": 739,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 SEL * selReadStream ( FILE * fp ) { char * selname ; <vul-start> char linebuf [ L_BUF_SIZE ] ; <vul-end> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ; PROCNAME ( \"selReadStream\" ) ; if ( ! fp ) return ( SEL * ) ERROR_PTR ( \"stream not defined\" , procName , NULL ) ; if ( fscanf ( fp , \" Sel Version %d\\\\n\" , & version ) != 1 ) return ( SEL * ) ERROR_PTR ( \"not a sel file\" , procName , NULL ) ; if ( version != SEL_VERSION_NUMBER ) return ( SEL * ) ERROR_PTR ( \"invalid sel version\" , procName , NULL ) ; <vul-start> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <vul-end> return ( SEL * ) ERROR_PTR ( \"error reading into linebuf\" , procName , NULL ) ; selname = stringNew ( linebuf ) ; <vul-start> sscanf ( linebuf , \" ------ %s ------\" , selname ) ; <vul-end> if ( fscanf ( fp , \" sy = %d, sx = %d, cy = %d, cx = %d\\\\n\" , & sy , & sx , & cy , & cx ) != 4 ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( \"dimensions not read\" , procName , NULL ) ; } if ( ( sel = selCreate ( sy , sx , selname ) ) == NULL ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR (",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> char linebuf [ L_BUFSIZE <vul-end> ] ; l_int32 <vul-start> ( linebuf , L_BUFSIZE <vul-end> , fp ) <vul-start> ( linebuf , \"  ------  %200s  ------\" <vul-end> , selname )\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char linebuf [ L_BUFSIZE <vul-end> ] ; l_int32 <vul-start> ( linebuf, L_BUFSIZE <vul-end>, fp ) <vul-start> ( linebuf, \" ------ %511s ------\" <vul-end>, selname )\n"
 },
 {
  "id": 740,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void xenvif_disconnect ( struct xenvif * vif ) { <vul-start> struct net_device * dev = vif -> dev ; <vul-end> <vul-start> if ( netif_carrier_ok ( dev ) ) { <vul-end> rtnl_lock ( ) ; netif_carrier_off ( dev ) ; if ( netif_running ( dev ) ) <vul-start> xenvif_down ( vif ) ; <vul-end> <vul-start> rtnl_unlock ( ) ; <vul-end> xenvif_put ( vif ) ; } atomic_dec ( & vif -> refcnt ) ; wait_event ( vif -> waiting_to_free , atomic_read ( & vif -> refcnt ) == 0 ) ; del_timer_sync ( & vif -> credit_timeout ) ; if ( vif -> irq ) unbind_from_irqhandler ( vif -> irq , vif ) ; unregister_netdev ( vif -> dev ) ; xen_netbk_unmap_frontend_rings ( vif ) ; free_netdev ( vif -> dev ) ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> vif ) { <vul-end> if ( netif_carrier_ok <vul-start> ( netif_carrier_ok ( vif -> <vul-end> dev ) ) <vul-start> dev ) ) xenvif_carrier_off <vul-end> ( vif ) <vul-start> vif ) ; <vul-end> atomic_dec ( &\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> vif ) { int rc = - EBUSY ; <vul-start> dev ) ) goto out ; <vul-end> if ( netif_carrier_ok <vul-start> dev ) ) goto out ; <vul-end> xenvif_down ( vif <vul-start> vif ) ; out : <vul-end> atomic_dec ( &\n"
 },
 {
  "id": 741,
  "question": "CWE-326 Code Input Vulnerable Code Is: CWE-326 <vul-start> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <vul-end> const struct in6_addr * dst , const struct in6_addr * src ) { <vul-start> u32 hash , id ; <vul-end> <vul-start> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <vul-end> <vul-start> hash = __ipv6_addr_jhash ( src , hash ) ; <vul-end> hash ^= net_hash_mix ( net ) ; id = ip_idents_reserve ( hash , 1 ) ; if ( unlikely ( ! id ) ) id = 1 << 31 ; return id ; }",
  "golden_answers": [
   "CWE-326 Fixed Code Lines are: <vul-start> net * net <vul-end> , const struct <vul-start> src ) { const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <vul-start> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <vul-end> ) ; hash <vul-start> ; hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <vul-end> ) ; id\n"
  ],
  "generated_answer": "CWE-326 Fixed Code Lines are: <vul-start> * net, struct ipv6_txoptions * opt, <vul-start> ) { u32 id ; if ( opt -> opt. optlen < sizeof ( struct in6_addr ) ) return 0 <vul-end> ; hash = <vul-start> ; hash = ipv6_select_id <vul-end> ( dst, <vul-start> ( dst, opt -> opt. <vul-start> ; hash = ipv6_select_id <vul-end> ( src,\n"
 },
 {
  "id": 742,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 vpx_codec_err_t vpx_svc_init ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * enc_cfg ) { <vul-start> int max_intra_size_pct ; <vul-end> vpx_codec_err_t res ; <vul-start> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <vul-end> if ( svc_ctx == NULL || codec_ctx == NULL || iface == NULL || enc_cfg == NULL ) { return VPX_CODEC_INVALID_PARAM ; } if ( si == NULL ) return VPX_CODEC_MEM_ERROR ; si -> codec_ctx = codec_ctx ; si -> width = enc_cfg -> g_w ; si -> height = enc_cfg -> g_h ; if ( enc_cfg -> kf_max_dist < 2 ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"key frame distance too small: %d\\\\n\" , enc_cfg -> kf_max_dist ) ; return VPX_CODEC_INVALID_PARAM ; } si -> kf_dist = enc_cfg -> kf_max_dist ; if ( svc_ctx -> spatial_layers == 0 ) svc_ctx -> spatial_layers = VPX_SS_DEFAULT_LAYERS ; if ( svc_ctx -> spatial_layers < 1 || svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"spatial layers: invalid value: %d\\\\n\" , svc_ctx -> spatial_layers ) ; return VPX_CODEC_INVALID_PARAM ; } <vul-start> res = parse_quantizer_values ( svc_ctx , si -> quantizers , 0 ) ; <vul-end> if ( res != VPX_CODEC_OK ) return res ; <vul-start> res = parse_quantizer_values ( svc_ctx , si -> quantizers_keyframe , 1 ) ; <vul-end> if ( res != VPX_CODEC_OK ) <vul-start> memcpy ( si -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; <vul-end> res = parse_scale_factors ( svc_ctx , si -> scale_factors ) ; if ( res != VPX_CODEC_OK )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> enc_cfg ) { <vul-end> vpx_codec_err_t res ; <vul-start> vpx_codec_err_t res ; int i ; SvcInternal_t <vul-end> * const si <vul-start> VPX_CODEC_INVALID_PARAM ; } if ( svc_ctx -> temporal_layering_mode == 3 ) { svc_ctx -> temporal_layers = 3 ; } else if ( svc_ctx -> temporal_layering_mode == 2 ) { svc_ctx -> temporal_layers = 2 ; } for ( i = 0 ; i < VPX_SS_MAX_LAYERS ; ++ i ) { si -> svc_params . max_quantizers [ i ] = MAX_QUANTIZER ; si -> svc_params . min_quantizers [ i ] = 0 ; si -> svc_params . scaling_factor_num [ i ] = DEFAULT_SCALE_FACTORS_NUM [ i ] ; si -> svc_params . scaling_factor_den [ i ] = DEFAULT_SCALE_FACTORS_DEN [ i ] ; } res = parse_options ( svc_ctx , si -> options <vul-end> ) ; if <vul-start> return res ; if ( svc_ctx -> spatial_layers < 1 ) svc_ctx -> spatial_layers = 1 ; if ( svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) svc_ctx -> spatial_layers = VPX_SS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers < 1 ) svc_ctx -> temporal_layers = 1 ; if ( svc_ctx -> temporal_layers > VPX_TS_MAX_LAYERS ) svc_ctx -> temporal_layers = VPX_TS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers * svc_ctx -> spatial_layers > VPX_MAX_LAYERS ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"spatial layers * temporal layers exceeds the maximum number of \" \"allowed layers of %d\\\\n\" , svc_ctx -> spatial_layers * svc_ctx -> temporal_layers , ( int ) VPX_MAX_LAYERS ) ; return VPX_CODEC_INVALID_PARAM ; } assign_layer_bitrates ( svc_ctx , enc_cfg ) ; # if CONFIG_SPATIAL_SVC for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) enc_cfg -> ss_enable_auto_alt_ref [ i ] = si -> enable_auto_alt_ref [ i ] ; # endif if ( svc_ctx -> temporal_layers > 1 ) { int i ; for ( i = 0 ; i < svc_ctx -> temporal_layers ; ++ i ) { enc_cfg -> ts_target_bitrate [ i ] = enc_cfg -> rc_target_bitrate / svc_ctx -> temporal_layers ; enc_cfg -> ts_rate_decimator [ i ] = 1 << ( svc_ctx -> temporal_layers - 1 - i ) ; } } if ( svc_ctx -> threads ) enc_cfg -> g_threads = svc_ctx -> threads ; enc_cfg -> ss_number_layers = svc_ctx -> spatial_layers ; enc_cfg -> ts_number_layers = svc_ctx -> temporal_layers ; if ( enc_cfg -> rc_end_usage == VPX_CBR ) { enc_cfg -> rc_resize_allowed = 0 ; enc_cfg -> rc_min_quantizer = 2 ; enc_cfg -> rc_max_quantizer = 63 ; enc_cfg -> rc_undershoot_pct = 50 ; enc_cfg -> rc_overshoot_pct = 50 ; enc_cfg -> rc_buf_initial_sz = 20 ; enc_cfg -> rc_buf_optimal_sz = 600 ; enc_cfg -> rc_buf_sz = 1000 ; } if ( enc_cfg -> g_error_resilient == 0 && si -> use_multiple_frame_contexts == 0 ) enc_cfg -> g_error_resilient = 1 ; res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR <vul-end> ) ; if <vul-start> != VPX_CODEC_OK ) { svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc_enc_init error\\\\n\" ) ; <vul-end> return res ; <vul-start> return res ; } vpx_codec_control <vul-end> ( codec_ctx , <vul-start> ( codec_ctx , VP9E_SET_SVC , 1 ) ; <vul-end> vpx_codec_control ( codec_ctx <vul-start> ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & si -> svc_params <vul-end> ) ; return\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> enc_cfg ) { <vul-end> vpx_codec_err_t res ; <vul-start> vpx_codec_err_t res ; SvcInternal_t <vul-end> * const si <vul-start> } res = vpx_codec_init_interface ( codec_ctx, iface, enc_cfg ) ; if ( res!= VPX_CODEC_OK ) return res ; res = <vul-start> si -> quantizers, svc_ctx -> spatial_layers <vul-end> ) ; if <vul-start> return res ; memcpy <vul-end> ( si -> <vul-start> si -> quantizers_keyframe <vul-end>, 1 ) <vul-start>!= VPX_CODEC_OK ) { <vul-start> return res ; } <vul-start> ( codec_ctx, VP9E_SET_SVC, 1 ) ; vpx_codec_control ( codec_ctx, VP8E_SET_CPUUSED, 1 ) ; vpx_codec_control ( codec_ctx, VP8E_SET_STATIC_THRESHOLD, 1 ) ; vpx_codec_control ( codec_ctx, VP8E_SET_NOISE_SENSITIVITY, 1 ) ; vpx_codec_control ( codec_ctx, VP8E_SET_TOKEN_PARTITIONS, 1 ) ; int max_intra_size_pct ; int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { int j ; svc_log ( svc_ctx, SVC_LOG_ERROR, \"svc_enc_init error\\\\n\" ) ; return res ; } res = vpx_codec_init_interface ( codec_ctx, iface, enc_cfg ) ; if ( res!= VPX_CODEC_OK ) { svc_log ( svc_ctx, SVC_LOG_ERROR, \"svc_enc_init error\\\\n\" ) ; return res ; } <vul-end> si -> layers\n"
 },
 {
  "id": 743,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info !=",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> size_t ) ldblk + 1\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( size_t ) MagickMax ( GetBlobSize ( image ), <vul-end> sizeof ( *\n"
 },
 {
  "id": 744,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int _mkp_stage_30 ( struct plugin * p , struct client_session * cs , struct session_request * sr ) { mk_ptr_t referer ; ( void ) p ; ( void ) cs ; PLUGIN_TRACE ( \"[FD %i] Mandril validating URL\" , cs -> socket ) ; <vul-start> if ( mk_security_check_url ( sr -> uri ) < 0 ) { <vul-end> PLUGIN_TRACE ( \"[FD %i] Close connection, blocked URL\" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } PLUGIN_TRACE ( \"[FD %d] Mandril validating hotlinking\" , cs -> socket ) ; referer = mk_api -> header_get ( & sr -> headers_toc , \"Referer\" , strlen ( \"Referer\" ) ) ; if ( mk_security_check_hotlink ( sr -> uri_processed , sr -> host , referer ) < 0 ) { PLUGIN_TRACE ( \"[FD %i] Close connection, deny hotlinking.\" , cs -> socket ) ; mk_api -> header_set_http_status ( sr , MK_CLIENT_FORBIDDEN ) ; return MK_PLUGIN_RET_CLOSE_CONX ; } return MK_PLUGIN_RET_NOT_ME ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ( sr -> uri_processed <vul-end> ) < 0\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( sr -> remote <vul-end> ) < 0\n"
 },
 {
  "id": 745,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int a2dp_ctrl_receive ( struct a2dp_stream_common * common , void * buffer , int length ) { <vul-start> int ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <vul-end> if ( ret < 0 ) { ERROR ( \"ack failed (%s)\" , strerror ( errno ) ) ; if ( errno == EINTR ) { <vul-start> ret = recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ; <vul-end> if ( ret < 0 ) { ERROR ( \"ack failed (%s)\" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } else { skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } return ret ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> int ret = TEMP_FAILURE_RETRY ( <vul-start> length , MSG_NOSIGNAL ) <vul-start> { ret = TEMP_FAILURE_RETRY ( <vul-start> length , MSG_NOSIGNAL )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> int ret = TEMP_FAILURE_RETRY ( <vul-start> length, MSG_NOSIGNAL ) <vul-start> { ret = TEMP_FAILURE_RETRY ( <vul-start> length, MSG_NOSIGNAL )\n"
 },
 {
  "id": 746,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int ndp_sock_open ( struct ndp * ndp ) { int sock ; int ret ; int err ; int val ; sock = socket ( PF_INET6 , SOCK_RAW , IPPROTO_ICMPV6 ) ; if ( sock == - 1 ) { err ( ndp , \"Failed to create ICMP6 socket.\" ) ; return - errno ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVPKTINFO , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , \"Failed to setsockopt IPV6_RECVPKTINFO.\" ) ; err = - errno ; goto close_sock ; } val = 255 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_MULTICAST_HOPS , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { <vul-start> err ( ndp , \"Failed to setsockopt IPV6_MULTICAST_HOPS.\" ) ; <vul-end> err = - errno ; goto close_sock ; } ndp -> sock = sock ; return 0 ; close_sock : close ( sock ) ; return err ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ndp , \"Failed to setsockopt IPV6_MULTICAST_HOPS.\" ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\"\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ( ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS\" <vul-end> ) ; err\n"
 },
 {
  "id": 747,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void BezierOval ( double w , double h , char * action ) <vul-start> { <vul-end> outpos += sprintf ( outpos , \" %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\\\n\" , - w , - w , h * BzK , - w * BzK , h , h ) ; outpos += sprintf ( outpos , \" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\\\n\" , w * BzK , h , w , h * BzK , w ) ; outpos += sprintf ( outpos , \" %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\\\n\" , w , - h * BzK , w * BzK , - h , - h ) ; outpos += sprintf ( outpos , \" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\\\n\" , - w * BzK , - h , - w , - h * BzK , - w , action ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> action ) { char * outpos = outputbuffer ; <vul-start> action ) ; sendClean ( outputbuffer ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> action ) { char * outpos = outputbuffer ; <vul-start> action ) ; sendClean ( outputbuffer ) ;\n"
 },
 {
  "id": 748,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) { <vul-start> int i ; <vul-end> memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , \"max_devices=\" , 12 ) == 0 ) sscanf ( argv [ i ] , \"max_devices=%u\" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , \"manual\" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , \"debug\" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , \"nouserok\" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , \"openasuser\" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , \"alwaysok\" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , \"interactive\" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , \"cue\" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , \"nodetect\" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , \"authfile=\" , 9 ) == 0 )",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> cfg ) { struct stat st ; FILE * file = NULL ; int fd = - 1 ; <vul-start> } else { fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <vul-end> , & st <vul-start> == 0 ) && <vul-end> S_ISREG ( st <vul-start> { file = fdopen ( fd <vul-end> , \"a\" ) <vul-start> = file ; cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <vul-end> } } } <vul-start> ) ; } if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> { int i <vul-end> ; cfg -> <vul-start> ) ) { int optxt_size = 0 ; <vul-start> ) ; } if ( cfg -> debug_file!= NULL && cfg -> debug_file!= stderr ) { optxt_size = strlen ( cfg -> debug_file ) ; cfg -> debug_file = fopen ( filename, \"a\" ) ; if ( cfg -> debug_file!= NULL && optxt_size > 0 ) cfg -> debug_file = fopen ( filename, \"a\" ) ; }\n"
 },
 {
  "id": 749,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void pin_remove ( struct fs_pin * pin ) { spin_lock ( & pin_lock ) ; <vul-start> hlist_del ( & pin -> m_list ) ; <vul-end> <vul-start> hlist_del ( & pin -> s_list ) ; <vul-end> spin_unlock ( & pin_lock ) ; spin_lock_irq ( & pin -> wait . lock ) ; pin -> done = 1 ; wake_up_locked ( & pin -> wait ) ; spin_unlock_irq ( & pin -> wait . lock ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> pin_lock ) ; hlist_del_init <vul-end> ( & pin <vul-start> m_list ) ; hlist_del_init <vul-end> ( & pin\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> pin_lock ) ; hlist_del_init <vul-end> ( & pin <vul-start> m_list ) ; hlist_del_init <vul-end> ( & pin\n"
 },
 {
  "id": 750,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int temporal_filter_find_matching_mb_c ( VP9_COMP * cpi , uint8_t * arf_frame_buf , uint8_t * frame_ptr_buf , int stride ) { <vul-start> MACROBLOCK * x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; <vul-start> int step_param ; <vul-end> int sadpb = x -> sadperbit16 ; <vul-start> int bestsme = INT_MAX ; <vul-end> MV best_ref_mv1 = { 0 , 0 } ; MV best_ref_mv1_full ; MV * ref_mv = & x -> e_mbd . mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv ; struct buf_2d src = x -> plane [ 0 ] . src ; struct buf_2d pre = xd -> plane [ 0 ] . pre [ 0 ] ; best_ref_mv1_full . col = best_ref_mv1 . col >> 3 ; best_ref_mv1_full . row = best_ref_mv1 . row >> 3 ; x -> plane [ 0 ] . src . buf = arf_frame_buf ; x -> plane [ 0 ] . src . stride = stride ; xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ; xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ; <vul-start> if ( cpi -> speed < 8 ) <vul-end> step_param = cpi -> sf . reduce_first_step_size + ( ( cpi -> speed > 5 ) ? 1 : 0 ) ; else step_param = cpi -> sf . reduce_first_step_size + 2 ; <vul-start> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { MACROBLOCK * const x = & cpi -> td . <vul-end> mb ; MACROBLOCKD <vul-start> -> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <vul-start> bestsme = INT_MAX ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <vul-start> = stride ; step_param = mv_sf -> reduce_first_step_size ; step_param = MIN ( step_param , MAX_MVSEARCH_STEPS <vul-end> - 2 ) <vul-start> - 2 ) <vul-end> ; vp9_hex_search ( <vul-start> , 1 , cond_cost_list ( cpi , cost_list ) , <vul-start> ref_mv ) ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , NULL , 0 , 0 ) ; <vul-end> x -> plane\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> & cpi -> td. <vul-start> -> e_mbd ; const int step_param = 0 ; const int <vul-end> sadpb = x <vul-start> -> sadperbit16 ; const int <vul-end> bestsme = INT_MAX <vul-start> = stride ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { step_param = MIN ( step_param, ( xd -> bd - 2 ) ) ; } else { <vul-start> + 2 ; } # else step_param = cpi -> sf. reduce_first_step_size + 2 ; # endif <vul-start> ( step_param, MAX_MVSEARCH_STEPS - 2 <vul-end> ) ; vp9_hex_search <vul-start> 1, & x -> fn_ptr [ BLOCK_16X16 ], 0, <vul-end> & best_ref_mv1, <vul-start> ref_mv ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { sse = MIN ( sse, ( xd -> bd - 2 ) ) ; } else { sse = MIN ( sse, ( xd -> bd - 2 ) ) ; } # else sse = MIN ( sse, ( xd -> sf. subpel_iters_per_step * 2 ) ) ; # endif\n"
 },
 {
  "id": 751,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) { struct uvesafb_pal_entry * entries ; int shift = 16 - dac_width ; int i , err = 0 ; if ( info -> var . bits_per_pixel == 8 ) { if ( cmap -> start + cmap -> len > info -> cmap . start + info -> cmap . len || cmap -> start < info -> cmap . start ) return - EINVAL ; <vul-start> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <vul-end> if ( ! entries ) return - ENOMEM ; for ( i = 0 ; i < cmap -> len ; i ++ ) { entries [ i ] . red = cmap -> red [ i ] >> shift ; entries [ i ] . green = cmap -> green [ i ] >> shift ; entries [ i ] . blue = cmap -> blue [ i ] >> shift ; entries [ i ] . pad = 0 ; } err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; kfree ( entries ) ; } else { for ( i = 0 ; i < cmap -> len ; i ++ ) { err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , cmap -> green [ i ] , cmap -> blue [ i ] , 0 , info ) ; } } return err ;",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ; entries = kmalloc_array ( cmap -> len , <vul-end> sizeof ( * <vul-start> * entries ) , <vul-end> GFP_KERNEL ) ;\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; entries = kzalloc <vul-end> ( sizeof (\n"
 },
 {
  "id": 752,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int build_segment_manager ( struct f2fs_sb_info * sbi ) { struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; struct f2fs_sm_info * sm_info ; int err ; sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , GFP_KERNEL ) ; if ( ! sm_info ) return - ENOMEM ; sbi -> sm_info = sm_info ; sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ; if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ; if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ; sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ; sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ; sm_info -> min_hot_blocks = DEF_MIN_HOT_BLOCKS ; sm_info -> trim_sections = DEF_BATCHED_TRIM_SECTIONS ; INIT_LIST_HEAD ( & sm_info -> sit_entry_set ) ; <vul-start> if ( test_opt ( sbi , FLUSH_MERGE ) && ! f2fs_readonly ( sbi -> sb ) ) { <vul-end> err = create_flush_cmd_control ( sbi ) ; if ( err ) return err ; } err = create_discard_cmd_control ( sbi ) ; if ( err ) return",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ; if ( <vul-end> ! f2fs_readonly (\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ; if ( <vul-end>! f2fs_readonly (\n"
 },
 {
  "id": 753,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 const char * vpx_svc_get_message ( const SvcContext * svc_ctx ) { <vul-start> const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ; <vul-end> if ( svc_ctx == NULL || si == NULL ) return NULL ; return si -> message_buffer ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) { const SvcInternal_t <vul-end> * const si\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) { const SvcInternal_t <vul-end> * const si\n"
 },
 {
  "id": 754,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ; <vul-start> int procfd = payload -> procfd ; <vul-end> lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ; <vul-start> uid_t new_uid ; <vul-end> gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { <vul-start> ERROR ( \"error using IPC to receive notification from initial process (0)\" ) ; <vul-end> shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( \"could not ensure correct architecture\" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 )",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> -> ipc_socket ; <vul-end> lxc_attach_options_t * options <vul-start> int fd ; int lsm_labelfd ; <vul-start> { ERROR ( \"Error using IPC to receive notification from initial process (0): %s.\" , strerror ( errno ) <vul-end> ) ; shutdown <vul-start> { ERROR ( \"Error using IPC to notify initial process for initialization (1): %s.\" , strerror ( errno ) <vul-end> ) ; shutdown <vul-start> { ERROR ( \"Error using IPC to receive message from initial process \" \"that it is done pre-initializing (2): %s\" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <vul-end> if ( ( <vul-start> \"privileges.\" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; <vul-start> ( \"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \" \"gainable privileges.\" ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( \"Error using IPC to tell parent to set up LSM labels (3): %s.\" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 <vul-start> int on_exec ; ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( \"Error using IPC for parent to tell us LSM label fd (4): %s.\" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <vul-start> ( lsm_set_label_at ( lsm_labelfd <vul-end> , on_exec , <vul-start> 0 ) { SYSERROR ( \"Failed to set LSM label.\" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <vul-end> } if ( <vul-start> \"Loading seccomp policy\" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <vul-end> lxc_proc_put_context_info ( init_ctx <vul-start> ) ; } <vul-end> rexit ( payload\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> -> ipc_socket ; <vul-end> lxc_attach_options_t * options <vul-start> int fd ; int procfd = payload -> procfd ; <vul-start> { ERROR ( \"error using IPC to receive notification from initial process (0)\" <vul-end> ) ; shutdown <vul-start> { ERROR ( \"error using IPC to receive final notification from initial process (1)\" <vul-end> ) ; shutdown <vul-start> \"privileges.\" ) ; close ( procfd <vul-end> ) ; } <vul-start> \"gainable privileges.\" ) ; close ( procfd ) ; <vul-start> 0 ) { SYSERROR ( \"error using IPC to set LSM label (at %d)\", on_exec <vul-end> ) ; shutdown <vul-start> { ERROR ( \"error using IPC to receive final notification from initial process (2)\" <vul-end> ) ; shutdown <vul-start> \"loading seccomp policy\" ) ; close ( procfd <vul-end> ) ; } <vul-start> } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC? 1 : 0 ; if ( lsm_set_label_at ( procfd, on_exec, init_ctx -> lsm_label ) <vul-end> < 0 ) <vul-start> { ERROR ( \"error using IPC to set LSM label (at %d)\", on_exec ) ; shutdown ( ipc_socket, SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && init_ctx -> container -> lxc_conf -> seccomp && ( lxc_seccomp_load ( init_ctx -> container -> lxc_conf )!= 0 ) ) { ERROR ( \"Failed to load seccomp policy\" ) ; shutdown ( ipc_socket, SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( procfd!= - 1 ) { SYSERROR ( \"could not ensure correct architecture\" ) ; shutdown ( ipc_socket, SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_read_nointr_expect"
 },
 {
  "id": 755,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int64_t vp9_pick_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , <vul-end> <vul-start> const TileInfo * const tile , <vul-end> int mi_row , int mi_col , int * returnrate , int64_t * returndistortion , BLOCK_SIZE bsize ) { MACROBLOCKD * xd = & x -> e_mbd ; <vul-start> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-end> struct macroblock_plane * const p = & x -> plane [ 0 ] ; struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; <vul-start> MB_PREDICTION_MODE this_mode , best_mode = ZEROMV ; <vul-end> <vul-start> MV_REFERENCE_FRAME ref_frame , best_ref_frame = LAST_FRAME ; <vul-end> INTERP_FILTER best_pred_filter = EIGHTTAP ; int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , VP9_ALT_FLAG } ; <vul-start> int64_t best_rd = INT64_MAX ; <vul-end> int64_t this_rd = INT64_MAX ; int rate = INT_MAX ; int64_t dist = INT64_MAX ; VP9_COMMON * cm = & cpi -> common ; <vul-start> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; <vul-end> const int64_t inter_mode_thresh = RDCOST ( x -> rdmult , x -> rddiv , <vul-start> intra_cost_penalty , 0 ) ; <vul-end> const int64_t intra_mode_cost = 50 ; unsigned char segment_id = mbmi -> segment_id ; <vul-start> const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ; <vul-end> <vul-start> const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>       void <vul-end> vp9_pick_inter_mode ( VP9_COMP <vul-start> * x , TileDataEnc * tile_data , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; SPEED_FEATURES * const sf = & cpi -> sf ; <vul-end> TileInfo * const <vul-start> TileInfo * const tile_info = & tile_data -> tile_info ; MACROBLOCKD * const <vul-end> xd = & <vul-start> ; MB_MODE_INFO * const <vul-start> ] -> mbmi <vul-end> ; struct macroblockd_plane <vul-start> 0 ] ; PREDICTION_MODE <vul-end> best_mode = ZEROMV <vul-start> best_ref_frame = LAST_FRAME ; MV_REFERENCE_FRAME usable_ref_frame ; TX_SIZE best_tx_size = TX_SIZES <vul-start> VP9_ALT_FLAG } ; RD_COST this_rdc , best_rdc ; uint8_t skip_txfm = SKIP_TXFM_NONE , best_mode_skip_txfm = SKIP_TXFM_NONE ; unsigned int var_y = UINT_MAX ; unsigned int sse_y = UINT_MAX ; const int reduction_fac = ( bsize <= BLOCK_16X16 ) ? ( ( bsize <= BLOCK_8X8 ) ? 4 : 2 ) : 0 ; const <vul-end> int intra_cost_penalty = <vul-start> int intra_cost_penalty = vp9_get_intra_cost_penalty ( <vul-end> cm -> base_qindex <vul-start> cm -> y_dc_delta_q , cm -> bit_depth ) >> reduction_fac <vul-end> ; const int64_t <vul-start> , 0 ) <vul-end> ; const int <vul-start> = cpi -> rd . threshes [ mbmi -> <vul-end> segment_id ] [ <vul-start> const rd_thresh_freq_fact = tile_data -> thresh_freq_fact <vul-end> [ bsize ] <vul-start> [ bsize ] <vul-end> ; INTERP_FILTER filter_ref <vul-start> ; INTERP_FILTER filter_ref ; const int bsl = mi_width_log2_lookup [ bsize ] ; const int pred_filter_search = cm -> <vul-end> interp_filter == SWITCHABLE <vul-start> == SWITCHABLE ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int const_motion [ MAX_REF_FRAMES ] = { 0 } ; const int bh = num_4x4_blocks_high_lookup [ bsize ] << 2 ; const int bw = num_4x4_blocks_wide_lookup [ bsize ] << 2 ; PRED_BUFFER tmp [ 4 ] ; DECLARE_ALIGNED ( 16 , uint8_t , pred_buf [ 3 * 64 * 64 ] ) ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , pred_buf_16 [ 3 * 64 * 64 ] ) ; # endif struct buf_2d orig_dst = pd -> dst ; PRED_BUFFER * best_pred = NULL ; PRED_BUFFER * this_mode_pred = NULL ; const int pixels_in_block = bh * bw ; int reuse_inter_pred = cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ; int ref_frame_skip_mask = 0 ; int idx ; int best_pred_sad = INT_MAX ; int best_early_term = 0 ; int ref_frame_cost [ MAX_REF_FRAMES ] ; init_ref_frame_cost ( cm , xd , ref_frame_cost ) ; if ( reuse_inter_pred ) { int i ; for ( i = 0 ; i < 3 ; i ++ ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) tmp [ i ] . data = CONVERT_TO_BYTEPTR ( & pred_buf_16 [ pixels_in_block * i ] ) ; else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # endif tmp [ i ] . stride = bw ; tmp [ i ] . in_use = 0 ; } tmp [ 3 ] . data = pd -> dst . buf ; tmp [ 3 ] . stride = pd -> dst . stride ; tmp [ 3 ] . in_use = 0 ; } x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; x <vul-end> -> skip = <vul-start> = 0 ; <vul-end> if ( xd <vul-start> . interp_filter ; else filter_ref = cm -> interp_filter ; vp9_rd_cost_reset ( & best_rdc ) ; vp9_rd_cost_reset ( rd_cost ) ; mbmi -> sb_type = bsize ; mbmi -> ref_frame [ 0 ] = NONE ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ) ; # if CONFIG_VP9_TEMPORAL_DENOISING vp9_denoiser_reset_frame_stats ( ctx ) ; # endif if ( cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) { usable_ref_frame = LAST_FRAME ; } else { usable_ref_frame = GOLDEN_FRAME ; } <vul-start> ; ref_frame <= usable_ref_frame <vul-end> ; ++ ref_frame <vul-start> ref_frame ) { const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , ref_frame ) ; x -> pred_mv_sad [ ref_frame ] = INT_MAX ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; if ( ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) && ( yv12 != NULL ) ) { int_mv * const candidates = x -> mbmi_ext -> ref_mvs [ ref_frame ] ; const struct scale_factors * const sf = & cm -> frame_refs [ ref_frame - 1 ] . sf ; vp9_setup_pred_block ( xd , yv12_mb [ ref_frame ] , yv12 , mi_row , mi_col , sf , sf ) ; if ( cm -> use_prev_frame_mvs ) vp9_find_mv_refs ( cm , xd , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col , NULL , NULL , x -> mbmi_ext -> mode_context ) ; else const_motion [ ref_frame ] = mv_refs_rt ( cm , x , xd , tile_info , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col ) ; vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , candidates , & frame_mv [ NEARESTMV ] [ ref_frame ] , & frame_mv [ NEARMV ] [ ref_frame ] ) ; <vul-start> if ( ! vp9_is_scaled ( sf ) && bsize >= BLOCK_8X8 ) vp9_mv_pred ( cpi , x , yv12_mb [ ref_frame ] [ 0 ] . buf , yv12 -> y_stride , ref_frame , bsize ) ; } else { ref_frame_skip_mask |= ( 1 << ref_frame ) ; } } for ( idx = 0 ; idx < RT_INTER_MODES ; ++ idx ) { int rate_mv = 0 ; int mode_rd_thresh ; int mode_index ; int i ; int64_t this_sse ; int is_skippable ; int this_early_term = 0 ; PREDICTION_MODE this_mode = ref_mode_set [ idx ] . pred_mode ; if ( cpi -> use_svc ) this_mode = ref_mode_set_svc [ idx ] . pred_mode ; if ( ! ( cpi -> sf . inter_mode_mask [ bsize ] & ( 1 << this_mode ) ) ) continue ; ref_frame = ref_mode_set [ idx ] . ref_frame ; if ( cpi -> use_svc ) ref_frame = ref_mode_set_svc [ idx ] . ref_frame ; if ( ! <vul-start> ) continue ; if ( const_motion [ ref_frame ] && this_mode == NEARMV ) continue ; i = <vul-end> ( ref_frame == <vul-start> == LAST_FRAME ) ? GOLDEN_FRAME : LAST_FRAME ; if ( ( cpi -> ref_frame_flags & flag_list [ i ] ) && sf -> reference_masking ) if ( x -> pred_mv_sad [ ref_frame ] > ( x -> pred_mv_sad [ i ] << 1 ) ) ref_frame_skip_mask |= <vul-end> ( 1 << <vul-start> ( 1 << ref_frame ) ; if ( ref_frame_skip_mask & ( 1 << ref_frame ) ) continue ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; mbmi -> ref_frame [ 0 ] = ref_frame ; set_ref_ptrs ( cm , xd , ref_frame , NONE ) ; mode_index = mode_idx [ ref_frame ] [ <vul-start> ( this_mode ) ] ; mode_rd_thresh = best_mode_skip_txfm ? rd_threshes [ mode_index ] << 1 : rd_threshes [ mode_index ] ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) <vul-end> ) continue ; <vul-start> NEWMV ) { if ( ref_frame > LAST_FRAME && ! cpi -> use_svc ) { int tmp_sad ; int dis , cost_list [ 5 ] ; if ( bsize < BLOCK_16X16 ) continue ; tmp_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ; if ( tmp_sad > x -> pred_mv_sad [ LAST_FRAME ] ) continue ; if ( tmp_sad + ( num_pels_log2_lookup [ bsize ] << 4 ) > best_pred_sad ) continue ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = mbmi -> mv [ 0 ] . as_int ; rate_mv = vp9_mv_bit_cost ( & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . row >>= 3 ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . col >>= 3 ; cpi -> find_fractional_mv_step ( x , & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr <vul-end> [ bsize ] <vul-start> [ bsize ] , cpi -> sf . mv . subpel_force_stop , cpi -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref_frame ] , NULL , 0 , 0 ) ; } else if ( ! combined_motion_search ( cpi , x , bsize , mi_row , mi_col , & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv , best_rdc . rdcost ) ) { continue ; } } if ( this_mode == NEWMV && ref_frame == LAST_FRAME && frame_mv [ NEWMV ] [ LAST_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ LAST_FRAME ] = best_pred_sad ; } if ( cpi -> use_svc ) { if ( this_mode == NEWMV && ref_frame == GOLDEN_FRAME && <vul-end> frame_mv [ NEWMV <vul-start> NEWMV ] [ GOLDEN_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + <vul-end> ( frame_mv [ <vul-start> NEWMV ] [ GOLDEN_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ GOLDEN_FRAME ] = best_pred_sad ; } <vul-end> } if ( <vul-start> this_mode != NEARESTMV && <vul-end> frame_mv [ this_mode <vul-start> . as_int ; if ( reuse_inter_pred ) { if ( ! this_mode_pred ) { this_mode_pred = & tmp [ 3 ] ; } else { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = bw ; } } <vul-start> SWITCHABLE ) && pred_filter_search && ( ref_frame == LAST_FRAME || ( ref_frame == GOLDEN_FRAME && cpi -> use_svc ) ) && ( <vul-start> as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) <vul-start> ) != 0 ) ) { <vul-end> int pf_rate [ <vul-start> 3 ] ; unsigned int pf_var [ 3 ] ; unsigned int pf_sse [ 3 ] ; TX_SIZE pf_tx_size [ 3 ] ; int64_t best_cost = INT64_MAX ; INTERP_FILTER best_filter = SWITCHABLE , filter ; PRED_BUFFER * current_pred = this_mode_pred ; for ( filter = EIGHTTAP ; filter <= EIGHTTAP_SMOOTH ; ++ filter ) { int64_t cost ; <vul-start> -> interp_filter = filter <vul-end> ; vp9_build_inter_predictors_sby ( <vul-start> & pf_rate [ filter ] , <vul-end> & pf_dist [ <vul-start> & pf_dist [ filter ] , & pf_var [ filter ] , & pf_sse [ filter ] ) ; pf_rate [ filter ] += vp9_get_switchable_rate ( cpi , xd ) ; cost <vul-end> = RDCOST ( <vul-start> -> rddiv , pf_rate [ filter ] , pf_dist [ filter ] ) ; pf_tx_size [ filter ] = mbmi -> tx_size ; if ( cost < best_cost ) { best_filter = filter ; best_cost = cost ; skip_txfm = x -> skip_txfm [ 0 ] ; if ( reuse_inter_pred ) { if ( this_mode_pred != current_pred ) { free_pred_buffer ( this_mode_pred ) ; this_mode_pred = current_pred ; } if ( filter < EIGHTTAP_SHARP ) { current_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = current_pred -> data ; pd -> dst . stride = bw ; } } } } if ( reuse_inter_pred && this_mode_pred != current_pred ) free_pred_buffer ( current_pred ) ; mbmi -> interp_filter = best_filter ; mbmi -> tx_size = pf_tx_size [ best_filter ] ; this_rdc . rate = pf_rate [ best_filter ] ; this_rdc . dist = pf_dist [ best_filter ] ; var_y = pf_var [ best_filter ] ; sse_y = pf_sse [ best_filter ] ; x -> skip_txfm [ 0 ] = skip_txfm ; if ( reuse_inter_pred ) { pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = this_mode_pred -> stride ; } <vul-end> } else { <vul-start> bsize ) ; if ( bsize > BLOCK_32X32 && ! cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) && cm -> base_qindex ) { model_rd_for_sb_y_large ( cpi , bsize , x , xd , & this_rdc . rate , & this_rdc . dist , & var_y , & sse_y , mi_row , mi_col , & this_early_term ) ; } else { <vul-start> xd , & this_rdc . <vul-start> rate , & this_rdc . dist , & var_y , & sse_y ) ; } } if ( ! this_early_term ) { this_sse = ( int64_t ) sse_y ; block_yrd ( cpi , x , & this_rdc . rate , & this_rdc . dist , & is_skippable , & this_sse , 0 , bsize , MIN ( mbmi -> tx_size , TX_16X16 ) ) ; x -> skip_txfm [ 0 ] = is_skippable ; if ( is_skippable ) { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } else { if ( RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , this_sse ) ) { this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; } else { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; this_rdc . dist = this_sse ; x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; } } if ( cm -> interp_filter == SWITCHABLE ) { if ( ( mbmi -> mv [ 0 ] . as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) & 0x07 ) this_rdc . rate += vp9_get_switchable_rate ( cpi , xd ) ; } } else { this_rdc . rate += cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi , xd ) : 0 ; this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } if ( x -> color_sensitivity [ 0 ] || x -> color_sensitivity [ 1 ] ) { int uv_rate = 0 ; int64_t uv_dist = 0 ; if ( x -> color_sensitivity [ 0 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 1 ) ; if ( x -> color_sensitivity [ 1 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 2 ) ; model_rd_for_sb_uv ( cpi , bsize , x , xd , & uv_rate , & uv_dist , & var_y , & sse_y ) ; this_rdc . rate += uv_rate ; this_rdc . dist += uv_dist ; } this_rdc . <vul-end> rate += rate_mv <vul-start> += rate_mv ; this_rdc . rate += cpi <vul-end> -> inter_mode_cost [ <vul-start> -> inter_mode_cost [ x -> mbmi_ext -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ; this_rdc . rate += ref_frame_cost [ ref_frame ] ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; if ( cpi -> allow_encode_breakout ) { encode_breakout_test ( cpi , x , bsize , mi_row , mi_col , ref_frame , this_mode , var_y , sse_y , yv12_mb , & this_rdc . rate , & this_rdc . dist ) ; if ( x -> skip ) { this_rdc . rate += rate_mv ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; } } # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) vp9_denoiser_update_frame_stats ( mbmi , sse_y , this_mode , ctx ) ; # else ( void ) ctx ; # endif if ( this_rdc . rdcost < best_rdc . rdcost || x -> skip ) { best_rdc = this_rdc <vul-end> ; best_mode = <vul-start> -> interp_filter ; best_tx_size = mbmi -> tx_size ; <vul-start> = ref_frame ; best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; best_early_term = this_early_term ; if ( reuse_inter_pred ) { free_pred_buffer ( best_pred ) ; best_pred = this_mode_pred ; } } else { if ( reuse_inter_pred ) free_pred_buffer ( this_mode_pred ) ; } if ( x -> skip ) break ; if ( best_early_term && idx > 0 ) { x -> skip = 1 ; break ; <vul-end> } } mbmi <vul-start> ; mbmi -> tx_size = best_tx_size ; mbmi -> <vul-start> . as_int ; x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( best_rdc . rdcost == INT64_MAX || ( ! x -> skip && best_rdc . rdcost > inter_mode_thresh && bsize <= cpi -> sf . max_intra_bsize ) ) { struct estimate_block_intra_args args = { cpi , x , DC_PRED , 0 , 0 } ; const TX_SIZE intra_tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; int i ; TX_SIZE best_intra_tx_size = TX_SIZES ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data == orig_dst . buf ) { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif best_pred = this_mode_pred ; } } pd -> dst = orig_dst ; for ( i = 0 ; i < 4 ; ++ i ) { const PREDICTION_MODE this_mode = intra_mode_list [ i ] ; THR_MODES mode_index = mode_idx [ INTRA_FRAME ] [ mode_offset ( this_mode ) ] ; int mode_rd_thresh = rd_threshes [ mode_index ] ; if ( ! ( ( 1 << this_mode ) & cpi -> sf . intra_y_mode_bsize_mask [ bsize ] ) ) continue ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) ) continue ; mbmi -> mode = this_mode ; mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; args . mode = this_mode ; args . rate = 0 ; args . dist = 0 ; mbmi -> tx_size = intra_tx_size ; vp9_foreach_transformed_block_in_plane <vul-end> ( xd , <vul-start> ( xd , bsize , 0 , estimate_block_intra , & args ) ; this_rdc . rate = args . rate ; this_rdc . dist = args . dist ; this_rdc . rate += cpi <vul-end> -> mbmode_cost [ <vul-start> this_mode ] ; this_rdc . rate += ref_frame_cost [ INTRA_FRAME ] ; this_rdc . <vul-start> += intra_cost_penalty ; this_rdc . rdcost <vul-end> = RDCOST ( <vul-start> -> rddiv , this_rdc . rate , this_rdc . <vul-end> dist ) ; <vul-start> ; if ( this_rdc . rdcost < best_rdc . rdcost ) { best_rdc = this_rdc ; best_mode = this_mode ; best_intra_tx_size = mbmi -> tx_size ; best_ref_frame = INTRA_FRAME ; mbmi -> uv_mode = this_mode ; mbmi -> mv [ 0 ] . as_int = INVALID_MV ; best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; } } if ( best_ref_frame != INTRA_FRAME ) { mbmi -> tx_size = best_tx_size ; } else { mbmi -> tx_size = best_intra_tx_size ; } } pd -> dst = orig_dst ; mbmi -> mode = best_mode ; mbmi -> ref_frame [ 0 ] = best_ref_frame ; x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data != orig_dst . buf && is_inter_mode ( mbmi -> mode ) ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif } } if ( cpi -> sf . adaptive_rd_thresh ) { THR_MODES best_mode_idx = mode_idx [ best_ref_frame ] [ mode_offset ( mbmi -> mode ) ] ; if ( best_ref_frame == INTRA_FRAME ) { int intra_modes = sizeof ( intra_mode_list ) / sizeof ( PREDICTION_MODE ) ; int i ; for ( i = 0 ; i < intra_modes ; i ++ ) { update_thresh_freq_fact ( cpi , tile_data , bsize , INTRA_FRAME , best_mode_idx , intra_mode_list [ i ] ) ; } } else { for ( ref_frame = LAST_FRAME ; ref_frame <= GOLDEN_FRAME ; ++ ref_frame ) { PREDICTION_MODE this_mode ; if ( best_ref_frame != ref_frame ) continue ; for ( this_mode = NEARESTMV ; this_mode <= NEWMV ; ++ this_mode ) { update_thresh_freq_fact ( cpi , tile_data , bsize , ref_frame , best_mode_idx , this_mode ) ; } } } } * rd_cost = best_rdc <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>       void <vul-end> vp9_pick_inter_mode ( VP9_COMP <vul-start> * cpi, TileDataEnc * tile_data, <vul-start> * x, <vul-end> int mi_row, <vul-start> -> e_mbd ; MB_MODE_INFO_EXT * mbmi_ext = x -> mbmi_ext ; <vul-start> 0 ] ; PREDICTION_MODE <vul-end> best_mode = ZEROMV <vul-start> ZEROMV ; MV_REFERENCE_FRAME <vul-end> best_ref_frame = LAST_FRAME <vul-start> best_ref_frame = LAST_FRAME <vul-end> ; INTERP_FILTER best_pred_filter <vul-start> VP9_ALT_FLAG } ; <vul-end> VP9_COMMON * cm <vul-start> -> common ; # if CONFIG_VP9_HIGHBITDEPTH int intra_cost_penalty = vp9_get_high_inter_cost_penalty ( cm, bsize ) ; # else int intra_cost_penalty = vp9_dc_quant ( cm -> base_qindex, cm -> y_dc_delta_q ) ; # endif <vul-end> const int64_t inter_mode_thresh <vul-start>, intra_cost_penalty, PREDICTION_MODE <vul-end> ) ; const <vul-start>. interp_filter ; unsigned char segment_id = mbmi -> segment_id ; <vul-start> const rd_threshes = xd -> rd_threshes <vul-end> [ segment_id ] <vul-start> = 0 ; unsigned int64_t <vul-end> rate_mode = 0 <vul-start> ( ref_frame = LAST_FRAME <vul-end> ; ref_frame <= <vul-start> ; ref_frame <= LAST_FRAME <vul-end> ; ++ ref_frame <vul-start> 0 ] = get_ref_frame ( x, tile, ref_frame ) <vul-end> ; clamp_mv2 ( <vul-start> ; if ( cpi <vul-end> -> sf. <vul-start> -> base_qindex, mbmi_ext -> <vul-end> y_dc_delta_q ) ; <vul-start> -> rddiv, mbmi_ext -> <vul-end> interp_filter == SWITCHABLE <vul-start> == SWITCHABLE ) <vul-end> vp9_setup_buffer_inter ( cpi <vul-start>, yv12_mb, mbmi_ext, mi_row, mi_col, frame_mv [ NEARESTM"
 },
 {
  "id": 756,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int stv06xx_start ( struct gspca_dev * gspca_dev ) { struct sd * sd = ( struct sd * ) gspca_dev ; struct usb_host_interface * alt ; struct usb_interface * intf ; int err , packet_size ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , \"Couldn\\'t get altsetting\\\\n\" ) ; return - EIO ; } <vul-start> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <vul-end> err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ; if ( err < 0 ) return err ; err = sd -> sensor -> start ( sd ) ; if ( err < 0 ) goto out ; err = stv06xx_write_bridge ( sd , STV_ISO_ENABLE , 1 ) ; out : if ( err < 0 ) gspca_dbg ( gspca_dev , D_STREAM , \"Starting stream failed\\\\n\" ) ; else gspca_dbg ( gspca_dev , D_STREAM , \"Started streaming\\\\n\" ) ; return ( err < 0 ) ? err : 0 ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> EIO ; } if ( alt -> desc. bNumEndpoints < 1 ) { gspca_err ( gspca_dev, \"Invalid number of endpoints\\\\n\" ) ; return - EINVAL ; }\n"
 },
 {
  "id": 757,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static struct cifsSesInfo * cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) { int rc = - ENOMEM , xid ; struct cifsSesInfo * ses ; xid = GetXid ( ) ; <vul-start> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <vul-end> if ( ses ) { cFYI ( 1 , \"Existing smb sess found (status=%d)\" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } if ( ses -> need_reconnect ) { cFYI ( 1 , \"Session needs reconnect\" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; FreeXid ( xid ) ; return ses ; } cFYI ( 1 , \"Existing smb sess not found\" ) ; ses = sesInfoAlloc ( ) ; if ( ses == NULL ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) sprintf ( ses -> serverName , \"%pI6\" , & server -> addr . sockAddr6 . sin6_addr ) ; else sprintf ( ses ->",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> server , volume_info <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( server, get_username ( volume_info ) <vul-end> ) ; if\n"
 },
 {
  "id": 758,
  "question": "CWE-320 Code Input Vulnerable Code Is: CWE-320 int sshkey_load_file ( int fd , struct sshbuf * blob ) { u_char buf [ 1024 ] ; size_t len ; struct stat st ; <vul-start> int r ; <vul-end> if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ; if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size > MAX_KEY_FILE_SIZE ) return SSH_ERR_INVALID_FORMAT ; <vul-start> for ( ; ; ) { <vul-end> if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { if ( errno == EPIPE ) break ; r = SSH_ERR_SYSTEM_ERROR ; goto out ; } if ( ( r = sshbuf_put ( blob , buf , len ) ) != 0 ) goto out ; if ( sshbuf_len ( blob ) > MAX_KEY_FILE_SIZE ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } } if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size != ( off_t ) sshbuf_len ( blob ) ) { r = SSH_ERR_FILE_CHANGED ; goto out ; } r = 0 ; out : explicit_bzero ( buf , sizeof ( buf ) ) ; if ( r != 0 ) sshbuf_reset ( blob ) ; return r ; }",
  "golden_answers": [
   "CWE-320 Fixed Code Lines are: <vul-start> ; int r , dontmax = 0 <vul-start> return SSH_ERR_INVALID_FORMAT ; if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;\n"
  ],
  "generated_answer": "CWE-320 Fixed Code Lines are: <vul-start> ; int r ; int no_copy_file = 0 <vul-start> ; ) { if ( no_copy_file ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; }\n"
 },
 {
  "id": 759,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; sig_none = timr -> it_sigev_notify == SIGEV_NONE ; iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) <vul-start> timr -> it_overrun += ( int ) kc -> timer_forward ( timr , now ) ; <vul-end> remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> -> it_overrun += <vul-end> kc -> timer_forward\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> sig_none ) ) { if ( iv & REQUEUE_ABORT ) { if ( sig_none ) cur_setting -> it_value. tv_nsec = 1 ; } else { cur_setting -> it_value. tv_nsec = 0 ; } <vul-start> now ) ; }\n"
 },
 {
  "id": 760,
  "question": "CWE-254 Code Input Vulnerable Code Is: CWE-254 void impeg2d_flush_ext_and_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; <vul-start> while ( u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE ) <vul-end> { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; <vul-start> while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX ) <vul-end> { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }",
  "golden_answers": [
   "CWE-254 Fixed Code Lines are: <vul-start> ; while ( ( <vul-start> u4_start_code == USER_DATA_START_CODE ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <vul-start> ) != START_CODE_PREFIX && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )\n"
  ],
  "generated_answer": "CWE-254 Fixed Code Lines are: <vul-start> START_CODE_LEN ) ; if <vul-end> ( u4_start_code == <vul-start> u4_start_code == USER_DATA_START_CODE ) { while ( ( <vul-end> impeg2d_bit_stream_nxt ( ps_stream <vul-start> )!= START_CODE_PREFIX ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )\n"
 },
 {
  "id": 761,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static bool regsafe ( struct bpf_reg_state * rold , struct bpf_reg_state * rcur , struct idpair * idmap ) { if ( ! ( rold -> live & REG_LIVE_READ ) ) return true ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , live ) ) == 0 ) return true ; if ( rold -> type == NOT_INIT ) return true ; if ( rcur -> type == NOT_INIT ) return false ; switch ( rold -> type ) { case SCALAR_VALUE : if ( rcur -> type == SCALAR_VALUE ) { return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; } else { <vul-start> return rold -> umin_value == 0 && <vul-end> rold -> umax_value == U64_MAX && rold -> smin_value == S64_MIN && rold -> smax_value == S64_MAX && tnum_is_unknown ( rold -> var_off ) ; } case PTR_TO_MAP_VALUE : return memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) == 0 && range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_MAP_VALUE_OR_NULL : if ( rcur -> type != PTR_TO_MAP_VALUE_OR_NULL ) return false ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) ) return false ; return check_ids ( rold -> id , rcur -> id , idmap ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET : if ( rcur -> type != rold -> type ) return false ; if ( rold -> range",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> else { return false <vul-end> ; } case\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> return rold -> is_const_var && tnum_in ( rold -> var_off, rcur -> var_off ) == false ; return rold ->\n"
 },
 {
  "id": 762,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void copy_to_user_state ( struct xfrm_state * x , struct xfrm_usersa_info * p ) { <vul-start> memcpy ( & p -> id , & x -> id , sizeof ( p -> id ) ) ; <vul-end> memcpy ( & p -> sel , & x -> sel , sizeof ( p -> sel ) ) ; memcpy ( & p -> lft , & x -> lft , sizeof ( p -> lft ) ) ; memcpy ( & p -> curlft , & x -> curlft , sizeof ( p -> curlft ) ) ; memcpy ( & p -> stats , & x -> stats , sizeof ( p -> stats ) ) ; memcpy ( & p -> saddr , & x -> props . saddr , sizeof ( p -> saddr ) ) ; p -> mode = x -> props . mode ; p -> replay_window = x -> props . replay_window ; p -> reqid = x -> props . reqid ; p -> family = x -> props . family ; p -> flags = x -> props . flags ; p -> seq = x -> km . seq ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> p ) { memset ( p , 0 , sizeof ( * p ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> p ) { memset ( p, 0, sizeof ( * p ) ) ;\n"
 },
 {
  "id": 763,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int ip6_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; __be32 frag_id = 0 ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( ! skb -> local_df && skb -> len > mtu ) { skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return - EMSGSIZE ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } mtu -= hlen + sizeof ( struct frag_hdr ) ; if ( skb_has_frag_list ( skb ) ) { int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( (",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ipv6_select_ident ( fh , rt <vul-start> ipv6_select_ident ( fh , rt\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ipv6_select_ident ( fh, net <vul-start> ) ; } if (! skb -> cb -> family ) goto out ;\n"
 },
 {
  "id": 764,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_yv12_realloc_frame_buffer ( YV12_BUFFER_CONFIG * ybf , int width , int height , int border ) { if ( ybf ) { int aligned_width = ( width + 15 ) & ~ 15 ; int aligned_height = ( height + 15 ) & ~ 15 ; int y_stride = ( ( aligned_width + 2 * border ) + 31 ) & ~ 31 ; int yplane_size = ( aligned_height + 2 * border ) * y_stride ; int uv_width = aligned_width >> 1 ; int uv_height = aligned_height >> 1 ; int uv_stride = y_stride >> 1 ; int uvplane_size = ( uv_height + border ) * uv_stride ; const int frame_size = yplane_size + 2 * uvplane_size ; if ( ! ybf -> buffer_alloc ) { ybf -> buffer_alloc = ( uint8_t * ) vpx_memalign ( 32 , frame_size ) ; ybf -> buffer_alloc_sz = frame_size ; } if ( ! ybf -> buffer_alloc || ybf -> buffer_alloc_sz < frame_size ) return - 1 ; if ( border & 0x1f ) return - 3 ; ybf -> y_crop_width = width ; ybf -> y_crop_height = height ; ybf -> y_width = aligned_width ; ybf -> y_height = aligned_height ; ybf -> y_stride = y_stride ; <vul-start> ybf -> uv_width = uv_width ; <vul-end> ybf -> uv_height = uv_height ; ybf -> uv_stride = uv_stride ; ybf -> alpha_width = 0 ; ybf -> alpha_height = 0 ; ybf -> alpha_stride = 0 ; ybf -> border = border ; ybf -> frame_size = frame_size ; ybf -> y_buffer = ybf -> buffer_alloc + (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; ybf -> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; ybf -> <vul-end> alpha_width = 0\n"
 },
 {
  "id": 765,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 )",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> RT_ENCODED ) && ( ( number_pixels * <vul-end> sun_info . depth <vul-start> sun_info . depth ) > ( 8 * <vul-end> sun_info . length <vul-start> sun_info . length ) <vul-start> ( bytes_per_line + bytes_per_line <vul-end> % 2 )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( ( <vul-start>!= RT_ENCODED ) && ( ( sun_info. depth + 7 ) / 8 ) > <vul-end> sun_info. length <vul-start> sun_info. length <vul-end> ) ThrowReaderException ( <vul-start> ) break ; if ( ( <vul-start> & 0xc0 )!= 0x59a66a95 ) <vul-start> sun_info. width ; if ( ( sun_info. type == RT_STANDARD ) && ( sun_info. depth >= 8 ) ) ThrowReaderException ( ResourceLimitError, \"MemoryAllocationFailed\" )\n"
 },
 {
  "id": 766,
  "question": "CWE-287 Code Input Vulnerable Code Is: CWE-287 CMD_FUNC ( m_authenticate ) { aClient * agent_p = NULL ; if ( ! SASL_SERVER || ! MyConnect ( sptr ) || BadPtr ( parv [ 1 ] ) || ! CHECKPROTO ( sptr , PROTO_SASL ) ) return 0 ; if ( sptr -> local -> sasl_complete ) { sendto_one ( sptr , err_str ( ERR_SASLALREADY ) , me . name , BadPtr ( sptr -> name ) ? \"*\" : sptr -> name ) ; return 0 ; } <vul-start> if ( strlen ( parv [ 1 ] ) > 400 ) <vul-end> { sendto_one ( sptr , err_str ( ERR_SASLTOOLONG ) , me . name , BadPtr ( sptr -> name ) ? \"*\" : sptr -> name ) ; return 0 ; } if ( * sptr -> local -> sasl_agent ) agent_p = find_client ( sptr -> local -> sasl_agent , NULL ) ; if ( agent_p == NULL ) { char * addr = BadPtr ( sptr -> ip ) ? \"0\" : sptr -> ip ; char * certfp = moddata_client_get ( sptr , \"certfp\" ) ; sendto_server ( NULL , 0 , 0 , \":%s SASL %s %s H %s %s\" , me . name , SASL_SERVER , encode_puid ( sptr ) , addr , addr ) ; if ( certfp ) sendto_server ( NULL , 0 , 0 , \":%s SASL %s %s S %s %s\" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] , certfp ) ; else sendto_server ( NULL , 0 , 0 , \":%s",
  "golden_answers": [
   "CWE-287 Fixed Code Lines are: <vul-start> } if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , ' ' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , \"*\" , \"AUTHENTICATE\" , \"Invalid parameter\" ) ; return 0 ; } if (\n"
  ],
  "generated_answer": "CWE-287 Fixed Code Lines are: <vul-start> } if ( * sptr -> local -> sasl_agent ) agent_p = find_client ( sptr -> local -> sasl_agent, NULL ) ; if ( agent_p == NULL ) { char * addr = BadPtr ( sptr -> ip )? \"0\" : sptr -> ip ; char * certfp = moddata_client_get ( sptr, \"certfp\" ) ; if ( certfp ) sendto_server ( NULL, 0, 0, \":%s SASL %s %s H %s %s\", me. name, SASL_SERVER, encode_puid ( sptr ), parv [ 1 ], addr, certfp ) ; else sendto_server ( NULL, 0, 0, \":%s SASL %s %s S %s %s\", AGENT_SID ( agent_p ), encode_puid ( sptr ), parv [ 1 ], certfp ) ; } else sendto_server ( NULL, 0, 0, \":%s SASL %s %s C %s\", me. name, AGENT_SID ( agent_p ), parv [ 1 ] ) ; } else { if ( <vul-start> 1 ] ) <vul-end> ; } else\n"
 },
 {
  "id": 767,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 <vul-start> void ptrace_triggered ( struct perf_event * bp , int nmi , <vul-end> struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event_attr attr ; attr = bp -> attr ; attr . disabled = true ; modify_user_hw_breakpoint ( bp , & attr ) ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> perf_event * bp <vul-end> , struct perf_sample_data\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> perf_event * bp <vul-end>, struct perf_sample_data\n"
 },
 {
  "id": 768,
  "question": "CWE-74 Code Input Vulnerable Code Is: CWE-74 gboolean flatpak_run_add_environment_args ( FlatpakBwrap * bwrap , const char * app_info_path , FlatpakRunFlags flags , const char * app_id , FlatpakContext * context , GFile * app_id_dir , GPtrArray * previous_app_id_dirs , FlatpakExports * * exports_out , GCancellable * cancellable , GError * * error ) { g_autoptr ( GError ) my_error = NULL ; g_autoptr ( FlatpakExports ) exports = NULL ; g_autoptr ( FlatpakBwrap ) proxy_arg_bwrap = flatpak_bwrap_new ( flatpak_bwrap_empty_env ) ; gboolean has_wayland = FALSE ; gboolean allow_x11 = FALSE ; if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_IPC ) == 0 ) { g_debug ( \"Disallowing ipc access\" ) ; flatpak_bwrap_add_args ( bwrap , \"--unshare-ipc\" , NULL ) ; } if ( ( context -> shares & FLATPAK_CONTEXT_SHARED_NETWORK ) == 0 ) { g_debug ( \"Disallowing network access\" ) ; flatpak_bwrap_add_args ( bwrap , \"--unshare-net\" , NULL ) ; } if ( context -> devices & FLATPAK_CONTEXT_DEVICE_ALL ) { flatpak_bwrap_add_args ( bwrap , \"--dev-bind\" , \"/dev\" , \"/dev\" , NULL ) ; if ( g_file_test ( \"/dev/shm\" , G_FILE_TEST_IS_DIR ) ) { if ( ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM ) == 0 ) flatpak_bwrap_add_args ( bwrap , \"--tmpfs\" , \"/dev/shm\" , NULL ) ; } else if ( g_file_test ( \"/dev/shm\" , G_FILE_TEST_IS_SYMLINK ) ) { g_autofree char * link = flatpak_readlink ( \"/dev/shm\" , NULL ) ; if ( g_strcmp0 ( link , \"/run/shm\" ) == 0 ) { if ( context -> devices & FLATPAK_CONTEXT_DEVICE_SHM && g_file_test ( \"/run/shm\" , G_FILE_TEST_IS_DIR ) ) flatpak_bwrap_add_args ( bwrap , \"--bind\" , \"/run/shm\" , \"/run/shm\" , NULL ) ; else flatpak_bwrap_add_args",
  "golden_answers": [
   "CWE-74 Fixed Code Lines are: <vul-start> ; if ( <vul-end> ! flatpak_run_in_transient_unit (\n"
  ],
  "generated_answer": "CWE-74 Fixed Code Lines are: <vul-start> flags ) ; flatpak_bwrap_add_args ( bwrap, \"--envp\", g_environ_getenv ( bwrap -> envp, \"PATH\" )!= NULL ) { g_debug ( \"Environment variable in /dev/shm is set\" ) ; flatpak_bwrap_bwrap_add_args ( bwrap, \"--envp\", g_environ_getenv ( bwrap -> envp, \"PATH\" ), NULL ) ; }\n"
 },
 {
  "id": 769,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static mode_t set_umask ( const char * optarg ) { long umask_long ; mode_t umask_val ; char * endptr ; umask_long = strtoll ( optarg , & endptr , 0 ) ; if ( * endptr || umask_long < 0 || umask_long & ~ 0777L ) { fprintf ( stderr , \"Invalid --umask option %s\" , optarg ) ; <vul-start> return ; <vul-end> } umask_val = umask_long & 0777 ; umask ( umask_val ) ; umask_cmdline = true ; return umask_val ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ) ; return 0\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> optarg ) ; umask_cmdline = true ;\n"
 },
 {
  "id": 770,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 krb5_error_code kdc_process_s4u2self_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , krb5_const_principal client_princ , krb5_const_principal header_srv_princ , krb5_boolean issuing_referral , const krb5_db_entry * server , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_timestamp kdc_time , krb5_pa_s4u_x509_user * * s4u_x509_user , krb5_db_entry * * princ_ptr , const char * * status ) { krb5_error_code code ; krb5_boolean is_local_tgt ; krb5_pa_data * pa_data ; int flags ; krb5_db_entry * princ ; * princ_ptr = NULL ; pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_S4U_X509_USER ) ; if ( pa_data != NULL ) { code = kdc_process_s4u_x509_user ( kdc_context , request , pa_data , tgs_subkey , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else { pa_data = krb5int_find_pa_data ( kdc_context , request -> padata , KRB5_PADATA_FOR_USER ) ; if ( pa_data != NULL ) { code = kdc_process_for_user ( kdc_active_realm , pa_data , tgs_session , s4u_x509_user , status ) ; if ( code != 0 ) return code ; } else return 0 ; } flags = 0 ; switch ( krb5_princ_type ( kdc_context , request -> server ) ) { case KRB5_NT_SRV_HST : if ( krb5_princ_size ( kdc_context , request -> server ) == 2 ) flags |= KRB5_PRINCIPAL_COMPARE_IGNORE_REALM ; break ; case KRB5_NT_ENTERPRISE_PRINCIPAL : flags |= KRB5_PRINCIPAL_COMPARE_ENTERPRISE ; break ; default : break ; } if ( ! krb5_principal_compare_flags ( kdc_context , request -> server , client_princ , flags ) ) { * status = \"INVALID_S4U2SELF_REQUEST\" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> ) ) ; princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> ) ) ; if (! is_local_tgt &&! issuing_referral ) { * status = \"NOT_CROSS_REALM_REQUEST\" ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; }\n"
 },
 {
  "id": 771,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } <vul-start> f2fs_wait_discard_bios ( sbi ) ; <vul-end> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ;",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> f2fs_wait_discard_bios ( sbi , true\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) ; } if ( is_sbi_flag_set ( sbi, SBI_IS_DIRTY ) ||! f2fs_mount_state ( sbi, DIOUNT_STATE ) ) { struct cp_control cpc = {. reason = CP_UMOUNT | CP_TRIMMED, } ; write_checkpoint ( sbi, & cpc ) ; }\n"
 },
 {
  "id": 772,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void read_frame_reference_mode_probs ( VP9_COMMON * cm , vp9_reader * r ) { <vul-end> <vul-start> FRAME_CONTEXT * const fc = & cm -> fc ; <vul-end> int i ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) for ( i = 0 ; i < COMP_INTER_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_inter_prob [ i ] ) ; if ( cm -> reference_mode != COMPOUND_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) { vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 0 ] ) ; vp9_diff_update_prob ( r , & fc -> single_ref_prob [ i ] [ 1 ] ) ; } if ( cm -> reference_mode != SINGLE_REFERENCE ) for ( i = 0 ; i < REF_CONTEXTS ; ++ i ) vp9_diff_update_prob ( r , & fc -> comp_ref_prob [ i ] ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cm , vpx_reader <vul-end> * r ) <vul-start> const fc = <vul-end> cm -> fc\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cm, vpx_reader <vul-end> * r ) <vul-start> r ) { FRAME_CONTEXT_EXT * const fc = cm -> fc ; int i ; if (! fc -> fc_kind_input ) return ; <vul-start> const fc = <vul-end> fc -> fc\n"
 },
 {
  "id": 773,
  "question": "CWE-347 Code Input Vulnerable Code Is: CWE-347 err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return \"2\" \"exponentiation failed; too many octets\" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( \"verify_sh decrypted SIG1:\" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( \"pad_len calculated: %d hash_len: %d\" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return \"3\" \"SIG padding does not check out\" ; } <vul-start> s += padlen + 3 ; <vul-end> <vul-start> ( * psig ) = s ; <vul-end> return NULL ; }",
  "golden_answers": [
   "CWE-347 Fixed Code Lines are: <vul-start> \"SIG padding does not check out\" ; } ( * psig ) = s + <vul-end> padlen + 3 <vul-start> + 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return \"4\" \"invalid Padding String\" ; } <vul-end> return NULL ;\n"
  ],
  "generated_answer": "CWE-347 Fixed Code Lines are: <vul-start> \"SIG padding does not check out\" ; } if ( s + padlen + 3 > s_max_octets ) { return \"3\" \"SIG padding failed; too many octets\" ; } <vul-start> + 3 ; if ( s > s_max_octets ) { return \"3\" \"SIG padding failed; too many octets\" ; }\n"
 },
 {
  "id": 774,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int rfcomm_sock_bind ( struct socket * sock , struct sockaddr * addr , int addr_len ) { <vul-start> struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; <vul-end> struct sock * sk = sock -> sk ; <vul-start> int chan = sa -> rc_channel ; <vul-end> <vul-start> int err = 0 ; <vul-end> BT_DBG ( \"sk %p %pMR\" , sk , & sa -> rc_bdaddr ) ; if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ; <vul-start> lock_sock ( sk ) ; <vul-end> if ( sk -> sk_state != BT_OPEN ) { err = - EBADFD ; goto done ; } if ( sk -> sk_type != SOCK_STREAM ) { err = - EINVAL ; goto done ; } write_lock ( & rfcomm_sk_list . lock ) ; <vul-start> if ( chan && __rfcomm_get_listen_sock_by_addr ( chan , & sa -> rc_bdaddr ) ) { <vul-end> err = - EADDRINUSE ; } else { <vul-start> bacpy ( & rfcomm_pi ( sk ) -> src , & sa -> rc_bdaddr ) ; <vul-end> <vul-start> rfcomm_pi ( sk ) -> channel = chan ; <vul-end> sk -> sk_state = BT_BOUND ; } write_unlock ( & rfcomm_sk_list . lock ) ; done : release_sock ( sk ) ; return err ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> { struct sockaddr_rc sa <vul-end> ; struct sock <vul-start> sk ; int len , <vul-end> err = 0 <vul-start> err = 0 <vul-end> ; if ( <vul-start> - EINVAL ; memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( \"sk %p %pMR\" , sk , & sa . rc_bdaddr ) ; <vul-start> ; if ( sa . rc_channel <vul-end> && __rfcomm_get_listen_sock_by_addr ( <vul-start> && __rfcomm_get_listen_sock_by_addr ( sa . rc_channel , & sa . <vul-end> rc_bdaddr ) ) <vul-start> , & sa . <vul-end> rc_bdaddr ) ; <vul-start> -> channel = sa . rc_channel <vul-end> ; sk ->\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> addr_len ) { <vul-end> struct sock * <vul-start> -> sk ; struct sockaddr_storage * sa = ( struct sockaddr_storage <vul-end> * ) addr <vul-start> -> rc_channel ; struct rfcomm_sock * rfcomm_pi = ( struct rfcomm_sock * ) addr ; struct <vul-start> - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_rc ) ) return - EINVAL ; <vul-start> ; if ( rfcomm_pi && <vul-start> && __rfcomm_get_listen_sock_by_addr ( rfcomm_pi -> <vul-end> chan, & <vul-start> } else { memcpy <vul-end> ( & rfcomm_pi <vul-start> rc_bdaddr ) ; } rfcomm_sock_set_chan ( sk ) <vul-end> ; sk ->\n"
 },
 {
  "id": 775,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int dnxhd_decode_header ( DNXHDContext * ctx , AVFrame * frame , const uint8_t * buf , int buf_size , int first_field ) { int i , cid , ret ; int old_bit_depth = ctx -> bit_depth , bitdepth ; uint64_t header_prefix ; if ( buf_size < 0x280 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , \"buffer too small (%d < 640).\\\\n\" , buf_size ) ; return AVERROR_INVALIDDATA ; } header_prefix = ff_dnxhd_parse_header_prefix ( buf ) ; if ( header_prefix == 0 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\\\n\" , buf [ 0 ] , buf [ 1 ] , buf [ 2 ] , buf [ 3 ] , buf [ 4 ] ) ; return AVERROR_INVALIDDATA ; } if ( buf [ 5 ] & 2 ) { ctx -> cur_field = buf [ 5 ] & 1 ; frame -> interlaced_frame = 1 ; frame -> top_field_first = first_field ^ ctx -> cur_field ; av_log ( ctx -> avctx , AV_LOG_DEBUG , \"interlaced %d, cur field %d\\\\n\" , buf [ 5 ] & 3 , ctx -> cur_field ) ; } else { ctx -> cur_field = 0 ; } ctx -> mbaff = ( buf [ 0x6 ] >> 5 ) & 1 ; ctx -> height = AV_RB16 ( buf + 0x18 ) ; ctx -> width = AV_RB16 ( buf + 0x1a ) ; switch ( buf [ 0x21 ] >> 5 ) { case 1 : bitdepth = 8 ; break ; case 2 : bitdepth",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> mb_height > 68 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , \"mb height too big: %d\\\\n\" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <vul-end> ( ctx -> <vul-start> AVERROR_INVALIDDATA ; } <vul-end> if ( buf_size\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } else { ctx -> data_offset = 0x280 ; <vul-start> AVERROR_INVALIDDATA ; } <vul-end> } if (\n"
 },
 {
  "id": 776,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( \"Interrupt %d, without any data\\\\n\" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( \"MUX error, status is %02x, data is %02x\\\\n\" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT &&",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ( likely ( serio <vul-end> && ! filtered\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( likely (! ( port -> exists || filtered ) <vul-end> ) serio_interrupt (\n"
 },
 {
  "id": 777,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void ImportGrayQuantum ( const Image * image , QuantumInfo * quantum_info , const MagickSizeType number_pixels , const unsigned char * magick_restrict p , Quantum * magick_restrict q , ExceptionInfo * exception ) { QuantumAny range ; register ssize_t x ; ssize_t bit ; unsigned int pixel ; assert ( image != ( Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; <vul-start> switch ( quantum_info -> depth ) <vul-end> { case 1 : { register Quantum black , white ; black = 0 ; white = QuantumRange ; if ( quantum_info -> min_is_white != MagickFalse ) { black = QuantumRange ; white = 0 ; } for ( x = 0 ; x < ( ( ssize_t ) number_pixels - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 1 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } for ( bit = 0 ; bit < ( ssize_t ) ( number_pixels % 8 ) ; bit ++ ) { SetPixelGray ( image , ( ( * p ) & ( 0x01 << ( 7 - bit ) ) ) == 0 ? black : white , q ) ; q += GetPixelChannels ( image ) ; } if ( bit != 0 ) p ++ ; break ; } case 4 :",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> MagickCoreSignature ) ; pixel = 0 ;\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> MagickCoreSignature ) ; if ( ( quantum_info -> depth > 3 ) || ( quantum_info -> depth == 4 ) ) { q = GetPixelChannels ( image ) ; return ; }\n"
 },
 {
  "id": 778,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 key_ref_t lookup_user_key ( key_serial_t id , unsigned long lflags , key_perm_t perm ) { struct keyring_search_context ctx = { . match_data . cmp = lookup_user_key_possessed , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , . flags = KEYRING_SEARCH_NO_STATE_CHECK , } ; struct request_key_auth * rka ; struct key * key ; key_ref_t key_ref , skey_ref ; int ret ; try_again : ctx . cred = get_current_cred ( ) ; key_ref = ERR_PTR ( - ENOKEY ) ; switch ( id ) { case KEY_SPEC_THREAD_KEYRING : if ( ! ctx . cred -> thread_keyring ) { if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) goto error ; ret = install_thread_keyring ( ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error ; } goto reget_creds ; } key = ctx . cred -> thread_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_PROCESS_KEYRING : if ( ! ctx . cred -> process_keyring ) { if ( ! ( lflags & KEY_LOOKUP_CREATE ) ) goto error ; ret = install_process_keyring ( ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error ; } goto reget_creds ; } key = ctx . cred -> process_keyring ; __key_get ( key ) ; key_ref = make_key_ref ( key , 1 ) ; break ; case KEY_SPEC_SESSION_KEYRING : if ( ! ctx . cred -> session_keyring ) { ret = install_user_keyrings ( ) ; if ( ret < 0 ) goto error ; if (",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED <vul-end> ) goto invalid_key\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) &&! key_is_positive ( key <vul-end> ) ) goto\n"
 },
 {
  "id": 779,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyObject * ast2obj_expr ( void * _o ) { expr_ty o = ( expr_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <vul-start> Py_INCREF ( Py_None ) ; <vul-end> return Py_None ; } switch ( o -> kind ) { case BoolOp_kind : result = PyType_GenericNew ( BoolOp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_boolop ( o -> v . BoolOp . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . BoolOp . values , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_values , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case BinOp_kind : result = PyType_GenericNew ( BinOp_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . BinOp . left ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_left , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . BinOp . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) ==",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } switch\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> o ) { Py_RETURN_NONE <vul-end> ; } switch\n"
 },
 {
  "id": 780,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t vp8_decode ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; unsigned int resolution_change = 0 ; unsigned int w , h ; <vul-start> if ( update_fragments ( ctx , data , data_sz , & res ) <= 0 ) <vul-end> return res ; w = ctx -> si . w ; h = ctx -> si . h ; res = vp8_peek_si_internal ( ctx -> fragments . ptrs [ 0 ] , ctx -> fragments . sizes [ 0 ] , & ctx -> si , ctx -> decrypt_cb , ctx -> decrypt_state ) ; if ( ( res == VPX_CODEC_UNSUP_BITSTREAM ) && ! ctx -> si . is_kf ) { res = VPX_CODEC_OK ; } if ( ! ctx -> decoder_init && ! ctx -> si . is_kf ) res = VPX_CODEC_UNSUP_BITSTREAM ; if ( ( ctx -> si . h != h ) || ( ctx -> si . w != w ) ) resolution_change = 1 ; <vul-start> if ( ! res && ctx -> defer_alloc ) <vul-end> { int i ; for ( i = 1 ; ! res && i < NELEMENTS ( ctx -> mmaps ) ; i ++ ) { vpx_codec_dec_cfg_t cfg ; cfg . w = ctx -> si . w ; cfg . h = ctx -> si . h ; ctx -> mmaps [ i ] . id = vp8_mem_req_segs [ i ] . id ; ctx -> mmaps [ i ] . sz =",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; if ( ! ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( <vul-start> ! res && ! <vul-end> ctx -> decoder_init <vul-start> ctx -> decoder_init <vul-end> ) { VP8D_CONFIG <vul-start> ; ctx -> decoder_init = 1 ; } if ( ctx -> decoder_init ) { ctx -> <vul-start> ctx -> decrypt_state <vul-end> ; } if <vul-start> = 0 ; vp8_clear_system_state ( ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, h ; int i ; <vul-start> = 1 ; <vul-end> ctx -> decoder_init <vul-start> = 0 ; ctx -> postproc_cfg. post_proc_flag = 1 ; ctx -> postproc_cfg. noise_level = 0 ; } if (! res && ctx -> decoder_init ) { int i ; for ( i = 1 ; i < NELEMENTS ( ctx -> mmaps ) ; i ++ ) { vpx_codec_dec_cfg_t cfg ; cfg. w = ctx -> si. w ; cfg. h = ctx -> si. h ; ctx -> mmaps [ i ]. id = vp8_mem_req_segs [ i ]. id ; ctx -> mmaps [ i ]. sz = vp8_mem_req_segs [ i ]. sz ; ctx -> mmaps [ i ]. pre_size = ctx -> pre_size ; ctx -> mmaps [ i ]. post_size = ctx -> post_size ; } if ( vp8_init_postproc ( ctx ) ) vpx_internal_error ( & pc -> error, VPX_CODEC_MEM_ERROR, \"Failed to allocate postproc buffers\" ) ; } res = vp8_create_decoder_instances ( & ctx -> yv12_frame_buffers, & oxcf ) ; ctx -> yv12_frame_buffers. pbi [ 0 ] -> decrypt_cb = ctx -> decrypt_cb ; ctx -> yv12_frame_buffers. pbi [ 0 ] -> decrypt_state = ctx -> decrypt_state ; } ctx -> decoder_init = 1 ; } if (! res && ctx -> si. is_kf ) { int i ; for ( i = 1 ; i < NELEMENTS ( ctx -> mmaps ) ; i ++ ) { VP8D_COMMON * const pc = & ctx -> mmaps [ i ] ; MACROBLOCKD * const xd = & pc -> mb ; int prev_mb_rows = pc -> mb_rows ; if ( ctx -> si. w!= w ) { int j ; for ( j = 1 ; j < NELEMENTS ( ctx -> mmaps ) ; i ++ ) { VP8D_MIP * const pc_prev = & ctx -> mmaps [ i ] ; if ("
 },
 {
  "id": 781,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void SetTransferMatrix ( double x11 , double x12 , double x21 , double x22 , double x , double y ) { if ( ( fabs ( x11 - 1. ) > 0.001 ) || ( fabs ( x22 - 1. ) > 0.001 ) || ( fabs ( x12 ) > 0.001 ) || ( fabs ( x21 ) > 0.001 ) || ( fabs ( x ) > 0.001 ) || ( fabs ( y ) > 0.001 ) ) { <vul-start> outpos += <vul-end> sprintf ( outpos , \"%12.3f %12.3f %12.3f %12.3f %12.3f %12.3f cm\\\\n\" , x11 , x12 , x21 , x22 , x , y ) ; <vul-start> } <vul-end> }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ) ) { sprintf ( outputbuffer <vul-end> , \"%12.3f %12.3f %12.3f %12.3f %12.3f %12.3f cm\\\\n\" , <vul-start> y ) ; sendClean ( outputbuffer ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) ) { sprintf ( outputbuffer <vul-end>, \"%12.3f %12.3f %12.3f %12.3f %12.3f cm\\\\n\", <vul-start> y ) ; sendClean ( outputbuffer ) ;\n"
 },
 {
  "id": 782,
  "question": "CWE-287 Code Input Vulnerable Code Is: CWE-287 static void start_auth_request ( PgSocket * client , const char * username ) { int res ; PktBuf * buf ; <vul-start> client -> auth_user = client -> db -> auth_user ; <vul-end> client -> pool = get_pool ( client -> db , client -> db -> auth_user ) ; if ( ! find_server ( client ) ) { client -> wait_for_user_conn = true ; return ; } slog_noise ( client , \"Doing auth_conn query\" ) ; client -> wait_for_user_conn = false ; client -> wait_for_user = true ; if ( ! sbuf_pause ( & client -> sbuf ) ) { release_server ( client -> link ) ; disconnect_client ( client , true , \"pause failed\" ) ; return ; } client -> link -> ready = 0 ; res = 0 ; buf = pktbuf_dynamic ( 512 ) ; if ( buf ) { pktbuf_write_ExtQuery ( buf , cf_auth_query , 1 , username ) ; res = pktbuf_send_immediate ( buf , client -> link ) ; pktbuf_free ( buf ) ; } if ( ! res ) disconnect_server ( client -> link , false , \"unable to send login query\" ) ; }",
  "golden_answers": [
   "CWE-287 Fixed Code Lines are: <vul-start> ; client -> <vul-end> pool = get_pool\n"
  ],
  "generated_answer": "CWE-287 Fixed Code Lines are: <vul-start> * buf ; if ( client -> auth_user!= client -> db -> auth_user ) { slog_noise ( client, \"Not going to make auth_user connection\" ) ; return ; } client -> auth_user = client -> db -> auth_user ; client -> pool = get_pool ( client -> db, client -> db -> auth_user ) ; if (! find_server ( client ) ) { client -> wait_for_user_conn = true ; return ; } slog_noise ( client, \"Doing auth_conn query\" ) ; client -> auth_user_conn = false ; client -> wait_for_user = true ;\n"
 },
 {
  "id": 783,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_refining_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int error_per_bit , int search_range , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; int i , j ; short this_row_offset , this_col_offset ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; unsigned char * best_address = ( unsigned char * ) ( base_pre + d -> offset + ( ref_mv -> as_mv . row * pre_stride ) + ref_mv -> as_mv . col ) ; unsigned char * check_here ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; bestsad = fn_ptr -> sdf ( what , what_stride , best_address , <vul-start> in_what_stride",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> best_address , in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> check_here , in_what_stride <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> best_address, in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> check_here, in_what_stride <vul-end> ) ; if\n"
 },
 {
  "id": 784,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t enc28j60Init ( NetInterface * interface ) { uint8_t revisionId ; Enc28j60Context * context ; TRACE_INFO ( \"Initializing ENC28J60 Ethernet controller...\\\\r\\\\n\" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; enc28j60SoftReset ( interface ) ; sleep ( 10 ) ; context = ( Enc28j60Context * ) interface -> nicContext ; context -> currentBank = UINT16_MAX ; context -> nextPacket = ENC28J60_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } <vul-start> revisionId = enc28j60ReadReg ( interface , ENC28J60_REG_EREVID ) ; <vul-end> TRACE_INFO ( \"ENC28J60 revision ID: 0x%02X\\\\r\\\\n\" , revisionId ) ; <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ECOCON , 0x00 ) ; <vul-end> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR1 , interface -> macAddr . b [ 0 ] ) ; <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR2 , interface -> macAddr . b [ 1 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR3 , interface -> macAddr . b [ 2 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR4 , interface -> macAddr . b [ 3 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR5 , interface -> macAddr . b [ 4 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_MAADR6 , interface -> macAddr . b [ 5 ] ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTL , LSB ( ENC28J60_RX_BUFFER_START ) ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXSTH , MSB ( ENC28J60_RX_BUFFER_START ) ) ; <vul-end> <vul-start> enc28j60WriteReg ( interface , ENC28J60_REG_ERXNDL",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( interface , ENC28J60_EREVID <vul-end> ) ; TRACE_INFO <vul-start> ( interface , ENC28J60_ECOCON , ENC28J60_ECOCON_COCON_DISABLED ) ; enc28j60WriteReg ( interface , ENC28J60_MAADR5 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR4 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR3 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR2 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR1 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_MAADR0 <vul-end> , interface -> <vul-start> ( interface , ENC28J60_ERXSTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXSTH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ERXNDL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXNDH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ERXRDPTL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_ERXRDPTH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_ERXFCON , ENC28J60_ERXFCON_UCEN | ENC28J60_ERXFCON_CRCEN | ENC28J60_ERXFCON_HTEN | ENC28J60_ERXFCON_BCEN ) ; enc28j60WriteReg ( interface , ENC28J60_EHT0 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT1 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT3 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT4 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT5 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT6 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT7 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON1 , ENC28J60_MACON1_TXPAUS | ENC28J60_MACON1_RXPAUS | ENC28J60_MACON1_MARXEN <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN | ENC28J60_MACON3_FULDPX <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MACON4 , ENC28J60_MACON4_DEFER ) ; enc28j60WriteReg ( interface , ENC28J60_MAMXFLL <vul-end> , LSB ( <vul-start> ( interface , ENC28J60_MAMXFLH <vul-end> , MSB ( <vul-start> ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_FD <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_HD <vul-end> ) ; # <vul-start> ( interface , ENC28J60_MAIPGL , ENC28J60_MAIPGL_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MAIPGH , ENC28J60_MAIPGH_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MACLCON2 , ENC28J60_MACLCON2_COLWIN_DEFAULT <vul-end> ) ; # <vul-start> ( interface , ENC28J60_PHCON1 , ENC28J60_PHCON1_PDPXMD <vul-end> ) ; # <vul-start> ( interface , ENC28J60_PHCON1 <vul-end> , 0x0000 ) <vul-start> ( interface , ENC28J60_PHCON2 , ENC28J60_PHCON2_HDLDIS <vul-end> ) ; enc28j60WritePhyReg <vul-start> ( interface , ENC28J60_PHLCON , ENC28J60_PHLCON_LACFG_LINK | ENC28J60_PHLCON_LBCFG_TX_RX | ENC28J60_PHLCON_LFRQ_40_MS | ENC28J60_PHLCON_STRCH ) ; enc28j60WriteReg ( interface , ENC28J60_EIR , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE | ENC28J60_EIE_PKTIE | ENC28J60_EIE_LINKIE | ENC28J60_EIE_TXIE | ENC28J60_EIE_TXERIE <vul-end> ) ; enc28j60WritePhyReg <vul-start> ( interface , ENC28J60_PHIE , ENC28J60_PHIE_PLNKIE | ENC28J60_PHIE_PGEIE <vul-end> ) ; enc28j60SetBit <vul-start> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_RXEN <vul-end> ) ; enc28j60DumpReg\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( interface, ENC28J60_EREVID <vul-end> ) ; TRACE_INFO <vul-start> ( interface, ENC28J60_ECOCON <vul-end>, 0x00 ) <vul-start> ( interface, ENC28J60_MABBIPG <vul-end>, 0x12 ) <vul-start> ( interface, ENC28J60_MAIPGL <vul-end>, 0x12 ) <vul-start> ( interface, ENC28J60_MAIPGH <vul-end>, 0x0C ) <vul-start> ( interface, ENC28J60_MAADR1 <vul-end>, LSB ( <vul-start> ( interface, ENC28J60_MAADR2 <vul-end>, LSB ( <vul-start> ( interface, ENC28J60_MAADR4 <vul-end>, interface -> <vul-start> ( interface, ENC28J60_MAADR5 <vul-end>, interface -> <vul-start> ( interface, ENC28J60_MAADR6 <vul-end>, interface -> <vul-start> ( interface, ENC28J60_ERXFCON, ENC28J60_ERXFCON_UCEN | ENC28J60_ERXFCON_CRCEN | ENC28J60_ERXFCON_HTEN | ENC28J60_ERXFCON_BCEN <vul-end> ) ; enc28j60WriteReg <vul-start> ( interface, ENC28J60_EIR, ENC28J60_EIR_INTIE | ENC28J60_EIR_TXIE | ENC28J60_EIR_TXERIE ) ; enc28j60WriteReg ( interface, ENC28J60_EIR_CRS, ENC28J60_EIR_CRS_DEFAULT_MASK ) ; if ( context -> txBuffer == NULL ) { return ERROR_OUT_OF_FRAME ; } } <vul-end> return ERROR_SUCCESS ;\n"
 },
 {
  "id": 785,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , \"echo %s, id %u, seq %u\" , dp -> icmp_type == ICMP_ECHO ? \"request\" : \"reply\" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) ,",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> 0 ) { ND_TCHECK_16BITS ( & dp -> icmp_cksum ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> if ( sum == 0 && plen == 0 ) goto trunc ; if ( sum\n"
 },
 {
  "id": 786,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; struct kvm_memory_slot * memslot , * slot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ;",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ; <vul-start> ) goto out_free <vul-end> ; r = <vul-start> ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <vul-start> return 0 ; out_slots : kfree ( slots ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> srcu ) ; r = <vul-start> r ) goto out <vul-end> ; if ( <vul-start> if (! r && npages ) kvm_iommu_unmap_pages ( kvm, & old ) ; r = - ENOMEM ; slots = kmemdup ( mem -> memslots, sizeof ( struct kvm_memslots ), GFP_KERNEL ) ; if (! slots ) goto out_free ; slot = id_to_memslot ( slots, mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots, NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots, slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; <vul-start> srcu ) ; r = <vul-start> ) goto out_free <vul-end> ; kvm_arch_commit_memory_region ( <vul-start> return 0 ; out_free : kvm_free_physmem_slot ( & old, & new ) ; <vul-end> return r ;\n"
 },
 {
  "id": 787,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void sctp_association_free ( struct sctp_association * asoc ) { struct sock * sk = asoc -> base . sk ; struct sctp_transport * transport ; struct list_head * pos , * temp ; int i ; <vul-start> if ( ! asoc -> temp ) { <vul-end> list_del ( & asoc -> asocs ) ; if ( sctp_style ( sk , TCP ) && sctp_sstate ( sk , LISTENING ) ) sk -> sk_ack_backlog -- ; } asoc -> base . dead = true ; sctp_outq_free ( & asoc -> outqueue ) ; sctp_ulpq_free ( & asoc -> ulpq ) ; sctp_inq_free ( & asoc -> base . inqueue ) ; sctp_tsnmap_free ( & asoc -> peer . tsn_map ) ; sctp_ssnmap_free ( asoc -> ssnmap ) ; sctp_bind_addr_free ( & asoc -> base . bind_addr ) ; for ( i = SCTP_EVENT_TIMEOUT_NONE ; i < SCTP_NUM_TIMEOUT_TYPES ; ++ i ) { if ( del_timer ( & asoc -> timers [ i ] ) ) sctp_association_put ( asoc ) ; } kfree ( asoc -> peer . cookie ) ; kfree ( asoc -> peer . peer_random ) ; kfree ( asoc -> peer . peer_chunks ) ; kfree ( asoc -> peer . peer_hmacs ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { transport = list_entry ( pos , struct sctp_transport , transports ) ; list_del_rcu ( pos ) ; sctp_transport_free ( transport ) ; } asoc -> peer . transport_count = 0 ; sctp_asconf_queue_teardown ( asoc ) ; if ( asoc -> asconf_addr_del_pending != NULL ) kfree",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> if ( ! list_empty ( & asoc -> asocs ) <vul-end> ) { list_del\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> asoc -> temp &&! list_empty ( & asoc -> asocs )\n"
 },
 {
  "id": 788,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ;",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> , VCPU_SREG_LDTR , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if <vul-start> , cpl , true , NULL <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if <vul-start>, cpl, true, NULL <vul-end> ) ; if\n"
 },
 {
  "id": 789,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int dhcpv4_print ( netdissect_options * ndo , const u_char * cp , u_int length , int indent ) { u_int i , t ; const u_char * tlv , * value ; uint8_t type , optlen ; i = 0 ; while ( i < length ) { <vul-start> tlv = cp + i ; <vul-end> type = ( uint8_t ) tlv [ 0 ] ; optlen = ( uint8_t ) tlv [ 1 ] ; value = tlv + 2 ; ND_PRINT ( ( ndo , \"\\\\n\" ) ) ; for ( t = indent ; t > 0 ; t -- ) ND_PRINT ( ( ndo , \"\\\\t\" ) ) ; ND_PRINT ( ( ndo , \"%s\" , tok2str ( dh4opt_str , \"Unknown\" , type ) ) ) ; <vul-start> ND_PRINT ( ( ndo , \" (%u)\" , optlen + 2 ) ) ; <vul-end> switch ( type ) { case DH4OPT_DNS_SERVERS : case DH4OPT_NTP_SERVERS : { if ( optlen < 4 || optlen % 4 != 0 ) { return - 1 ; } for ( t = 0 ; t < optlen ; t += 4 ) ND_PRINT ( ( ndo , \" %s\" , ipaddr_string ( ndo , value + t ) ) ) ; } break ; case DH4OPT_DOMAIN_SEARCH : { const u_char * tp = value ; while ( tp < value + optlen ) { ND_PRINT ( ( ndo , \" \" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , value + optlen ) ) == NULL ) return -",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> length ) { if ( i + 2 > length ) return - 1 ; <vul-start> 2 ) ) ; if ( i + 2 + optlen > length ) return - 1\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> length ) { if ( i + 2 > length ) return - 1 ; <vul-start> 2 ) ) ; if ( i + 2 + optlen > length ) return - 1\n"
 },
 {
  "id": 790,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( \"WV1F\" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( \"QMP4\" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , \"frame skip %d\\\\n\" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , \"startcode: %3X \" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Object Start\" ) ;",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> studio_profile ) { <vul-end> if ( !\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> studio_profile ) { if <vul-end> ( s -> <vul-start> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO <vul-end> ) { avpriv_request_sample\n"
 },
 {
  "id": 791,
  "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 static int ext4_xattr_block_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; int error ; <vul-start> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <vul-end> ea_idebug ( inode , \"buffer=%p, buffer_size=%ld\" , buffer , ( long ) buffer_size ) ; error = 0 ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , \"reading block %llu\" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , \"b_count=%d, refcount=%d\" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { EXT4_ERROR_INODE ( inode , \"bad block %llu\" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; error = ext4_xattr_list_entries ( dentry , BFIRST ( bh ) , buffer , buffer_size ) ; cleanup : brelse ( bh ) ; return error ; }",
  "golden_answers": [
   "CWE-19 Fixed Code Lines are: <vul-start> error ; struct mb2_cache <vul-end> * ext4_mb_cache =\n"
  ],
  "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> error ; struct mb2_cache <vul-end> * ext4_mb_cache =\n"
 },
 {
  "id": 792,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , \"nreslevels2decode %d invalid or uninitialized\\\\n\" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> -> band = av_calloc <vul-end> ( reslevel -> <vul-start> -> prec = av_calloc <vul-end> ( reslevel ->\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> log2_prec_height ) ; if ( codsty -> transform == FF_DWT53 ) { reslevel -> band = av_malloc_array ( reslevel -> nbands, sizeof ( * reslevel -> band ) ) ; if (! reslevel -> band ) return AVERROR ( ENOMEM ) ; } else { <vul-start> ) ) ; } <vul-start> ; } } }\n"
 },
 {
  "id": 793,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static inline signed int ReadPropertySignedLong ( const EndianType endian , const unsigned char * buffer ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; unsigned int value ; if ( endian == LSBEndian ) { <vul-start> value = ( unsigned int ) ( ( buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | <vul-end> <vul-start> ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; <vul-end> <vul-start> quantum . unsigned_value = ( value & 0xffffffff ) ; <vul-end> return ( quantum . signed_value ) ; } <vul-start> value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ) | ( buffer [ 1 ] << 16 ) | <vul-end> <vul-start> ( buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; <vul-end> <vul-start> quantum . unsigned_value = ( value & 0xffffffff ) ; <vul-end> return ( quantum . signed_value ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> unsigned int ) <vul-end> buffer [ 3 <vul-start> ] << 24 ; value |= ( unsigned int ) <vul-end> buffer [ 2 <vul-start> ] << 16 ; value |= ( unsigned int ) <vul-end> buffer [ 1 <vul-start> ] << 8 ; value |= ( unsigned int ) <vul-end> buffer [ 0 <vul-start> [ 0 ] <vul-end> ; quantum . <vul-start> . unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return ( <vul-start> unsigned int ) <vul-end> buffer [ 0 <vul-start> ] << 24 ; value |= ( unsigned int ) <vul-end> buffer [ 1 <vul-start> ] << 16 ; value |= ( unsigned int ) <vul-end> buffer [ 2 <vul-start> ] << 8 ; value |= ( unsigned int ) <vul-end> buffer [ 3 <vul-start> [ 3 ] <vul-end> ; quantum . <vul-start> . unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> unsigned int ) <vul-end> buffer [ 3 <vul-start> ] << 24 ; value |= ( unsigned int ) <vul-end> buffer [ 2 <vul-start> ] << 16 ; value |= ( unsigned int ) <vul-end> buffer [ 1 <vul-start> ] << 8 ; value |= ( unsigned int ) <vul-end> buffer [ 0 <vul-start> [ 0 ] <vul-end> ; quantum. <vul-start>. unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return ( <vul-start> unsigned int ) <vul-end> buffer [ 0 <vul-start> ] << 24 ; value |= ( unsigned int ) <vul-end> buffer [ 1 <vul-start> ] << 16 ; value |= ( unsigned int ) <vul-end> buffer [ 2 <vul-start> ] << 8 ; value |= ( unsigned int ) <vul-end> buffer [ 3 <vul-start> [ 3 ] ; quantum. unsigned_value = <vul-end> value & 0xffffffff <vul-start> value & 0xffffffff <vul-end> ; return (\n"
 },
 {
  "id": 794,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <vul-start> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <vul-end> if ( ! tmp ) <vul-start> return ; <vul-end> while ( count > stride ) { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + cp [ 0 ] ) & 0xff ) ; cp ++ ) count -= stride ; } _TIFFmemcpy ( tmp , cp0 , cc ) ; cp = ( uint8 * ) cp0 ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ bps * count + byte ] = tmp [ byte * wc + count ] ; # else cp [ bps * count + byte ] = tmp [ ( bps - byte - 1 ) * wc + count ] ; # endif } } _TIFFfree ( tmp ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> fpAcc ( TIFF <vul-start> cc ) ; if <vul-end> ( cc % <vul-start> * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"fpAcc\" , \"%s\" , \"cc%(bps*stride))!=0\" ) ; return 0 ; } <vul-end> if ( ! <vul-start> tmp ) return 0 <vul-start> tmp ) ; return 1 ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> fpAcc ( TIFF <vul-start> cc ) ; if <vul-end> ( ( cc <vul-start> stride ) )!= 0 ) { TIFFErrorExt ( tif -> tif_clientdata, \"fpAcc\", \"%s\", \"(cc%(bps*stride))!=0\" ) ; return 0 ; } <vul-end> if (! <vul-start> tmp ) return 0 <vul-start> tmp ) ; return 1 ;\n"
 },
 {
  "id": 795,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int ast_type_init ( PyObject * self , PyObject * args , PyObject * kw ) { <vul-start> _Py_IDENTIFIER ( _fields ) ; <vul-end> Py_ssize_t i , numfields = 0 ; int res = - 1 ; PyObject * key , * value , * fields ; <vul-start> fields = _PyObject_GetAttrId ( ( PyObject * ) Py_TYPE ( self ) , & PyId__fields ) ; <vul-end> if ( ! fields ) PyErr_Clear ( ) ; if ( fields ) { numfields = PySequence_Size ( fields ) ; if ( numfields == - 1 ) goto cleanup ; } res = 0 ; <vul-start> if ( PyTuple_GET_SIZE ( args ) > 0 ) { <vul-end> if ( numfields != PyTuple_GET_SIZE ( args ) ) { <vul-start> PyErr_Format ( PyExc_TypeError , \"%.400s constructor takes %s\" <vul-end> \"%zd positional argument%s\" , <vul-start> Py_TYPE ( self ) -> tp_name , <vul-end> numfields == 0 ? \"\" : \"either 0 or \" , numfields , numfields == 1 ? \"\" : \"s\" ) ; res = - 1 ; goto cleanup ; } for ( i = 0 ; i < PyTuple_GET_SIZE ( args ) ; i ++ ) { PyObject * name = PySequence_GetItem ( fields , i ) ; if ( ! name ) { res = - 1 ; goto cleanup ; } res = PyObject_SetAttr ( self , name , PyTuple_GET_ITEM ( args , i ) ) ; Py_DECREF ( name ) ; if ( res < 0 ) goto cleanup ; } <vul-start> } <vul-end> if ( kw ) { i = 0 ; while",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> kw ) { <vul-end> Py_ssize_t i , <vul-start> * fields ; if ( lookup_attr_id <vul-end> ( ( PyObject <vul-start> , & PyId__fields , & fields ) < 0 ) { goto cleanup ; } <vul-end> if ( fields <vul-start> ; if ( numfields < <vul-start> ( args ) <vul-end> ) { PyErr_Format <vul-start> ( PyExc_TypeError , \"%.400s constructor takes at most \" <vul-end> \"%zd positional argument%s\" , Py_TYPE <vul-start> ) -> tp_name <vul-end> , numfields , <vul-start> cleanup ; } <vul-end> if ( kw\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> kw ) { PyObject * type = <vul-end> Py_TYPE ( self <vul-start> Py_TYPE ( self <vul-end> ) ; if <vul-start> * fields ; if ( type == NULL ) { PyErr_Clear ( ) ; return - 1 ; } <vul-start> = 0 ; <vul-end> if ( PyTuple_GET_SIZE <vul-start> ) ) { return ast_type_init2 ( self, args, kw ) ; } res = - 1 ; key = PyObject_GetAttr ( self, <vul-end> Py_TYPE ( self <vul-start> ) -> tp_name ) ; if ( key == NULL ) { res = - 1 ; goto cleanup ; } res = PyObject_SetAttr ( self, key <vul-start> cleanup ; } <vul-end> if ( kw\n"
 },
 {
  "id": 796,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_frame ( vpx_codec_ctx_t * codec , <vul-end> vpx_image_t * img , int frame_index , <vul-start> VpxVideoWriter * writer ) { <vul-end> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( codec , img , frame_index , 1 , 0 , VPX_DL_GOOD_QUALITY ) ; if ( res != VPX_CODEC_OK ) die_codec ( codec , \"Failed to encode frame\" ) ; <vul-start> while ( ( pkt = vpx_codec_get_cx_data ( codec , & iter ) ) != NULL ) { <vul-end> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) { die_codec ( codec , \"Failed to write compressed frame\" ) ; } printf ( keyframe ? \"K\" : \".\" ) ; fflush ( stdout ) ; } } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> encode_frame ( vpx_codec_ctx_t <vul-start> writer ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> encode_frame ( vpx_codec_ctx_t <vul-start> writer ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
 },
 {
  "id": 797,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , \"blacklisted by %s\\\\n\" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; out1 : if ( info -> unbind ) info -> unbind ( dev, udev ) ;\n"
 },
 {
  "id": 798,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int mpi_powm ( MPI res , MPI base , MPI exp , MPI mod ) { mpi_ptr_t mp_marker = NULL , bp_marker = NULL , ep_marker = NULL ; mpi_ptr_t xp_marker = NULL ; mpi_ptr_t tspace = NULL ; mpi_ptr_t rp , ep , mp , bp ; mpi_size_t esize , msize , bsize , rsize ; int esign , msign , bsign , rsign ; mpi_size_t size ; int mod_shift_cnt ; int negative_result ; int assign_rp = 0 ; mpi_size_t tsize = 0 ; int rc = - ENOMEM ; esize = exp -> nlimbs ; msize = mod -> nlimbs ; size = 2 * msize ; esign = exp -> sign ; msign = mod -> sign ; rp = res -> d ; ep = exp -> d ; if ( ! msize ) return - EINVAL ; if ( ! esize ) { <vul-start> rp [ 0 ] = 1 ; <vul-end> <vul-start> res -> nlimbs = ( msize == 1 && mod -> d [ 0 ] == 1 ) ? 0 : 1 ; <vul-end> res -> sign = 0 ; goto leave ; } mp = mp_marker = mpi_alloc_limb_space ( msize ) ; if ( ! mp ) goto enomem ; mod_shift_cnt = count_leading_zeros ( mod -> d [ msize - 1 ] ) ; if ( mod_shift_cnt ) mpihelp_lshift ( mp , mod -> d , msize , mod_shift_cnt ) ; else MPN_COPY ( mp , mod -> d , msize ) ; bsize = base -> nlimbs ; bsign = base -> sign ; if",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> esize ) { <vul-end> res -> nlimbs <vul-start> : 1 ; if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> esize ) { if ( msize == 1 && mod -> d [ 0 ] == 1 ) { res -> nlimbs = 0 ; } else { <vul-start> = 1 ; } <vul-start>? 0 : 2 * msize <vul-end> ; res ->\n"
 },
 {
  "id": 799,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int DecodeTime ( char * str , int * tmask , struct tm * tm , fsec_t * fsec ) { char * cp ; * tmask = DTK_TIME_M ; tm -> tm_hour = strtol ( str , & cp , 10 ) ; if ( * cp != ':' ) return - 1 ; str = cp + 1 ; tm -> tm_min = strtol ( str , & cp , 10 ) ; if ( * cp == '\\\\0' ) { tm -> tm_sec = 0 ; * fsec = 0 ; } else if ( * cp != ':' ) return - 1 ; else { str = cp + 1 ; tm -> tm_sec = strtol ( str , & cp , 10 ) ; if ( * cp == '\\\\0' ) * fsec = 0 ; else if ( * cp == '.' ) { # ifdef HAVE_INT64_TIMESTAMP <vul-start> char fstr [ MAXDATELEN + 1 ] ; <vul-end> strncpy ( fstr , ( cp + 1 ) , 7 ) ; strcpy ( fstr + strlen ( fstr ) , \"000000\" ) ; * ( fstr + 6 ) = '\\\\0' ; * fsec = strtol ( fstr , & cp , 10 ) ; # else str = cp ; * fsec = strtod ( str , & cp ) ; # endif if ( * cp != '\\\\0' ) return - 1 ; } else return - 1 ; } # ifdef HAVE_INT64_TIMESTAMP if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\\\0' ? * cp ++ : '0' ; fstr [ i ] <vul-end> = '\\\\0' ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] <vul-end> = '\\\\0' ;\n"
 },
 {
  "id": 800,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int em_ret ( struct x86_emulate_ctxt * ctxt ) { <vul-start> ctxt -> dst . type = OP_REG ; <vul-end> ctxt -> dst . addr . reg = & ctxt -> _eip ; <vul-start> ctxt -> dst . bytes = ctxt -> op_bytes ; <vul-end> return em_pop ( ctxt ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <vul-end> ctxt -> op_bytes <vul-start> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ctxt ) { unsigned long eip <vul-end> ; ctxt -> <vul-start> ctxt -> op_bytes ; eip = rcu_dereference_protected ( ctxt -> eip, 1 ) ; if (! eip ) return - EFAULT ; rcu_assign_pointer ( ctxt -> eip, eip )\n"
 },
 {
  "id": 801,
  "question": "CWE-88 Code Input Vulnerable Code Is: CWE-88 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , \"submodule\" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , \"disallowed submodule name: %s\" , name ) ; if ( ! strcmp ( key , \"url\" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , \"disallowed submodule url: %s\" , value ) ; <vul-start> free ( name ) ; <vul-end> return 0 ; }",
  "golden_answers": [
   "CWE-88 Fixed Code Lines are: <vul-start> value ) ; if ( ! strcmp ( key , \"path\" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , \"disallowed submodule path: %s\" , value ) ;\n"
  ],
  "generated_answer": "CWE-88 Fixed Code Lines are: <vul-start> value ) ; if (! strcmp ( key, \"url\" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options, data -> obj, FSCK_MSG_GITMODULES_URL, \"disallowed submodule url: %s\", value ) ;\n"
 },
 {
  "id": 802,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( Parse * pParse , ExprList * pList , Expr * pExpr ) { struct ExprList_item * pItem ; sqlite3 * db = pParse -> db ; assert ( db != 0 ) ; if ( pList == 0 ) { pList = sqlite3DbMallocRawNN ( db , sizeof ( ExprList ) ) ; if ( pList == 0 ) { goto no_mem ; } pList -> nExpr = 0 ; } else if ( ( pList -> nExpr & ( pList -> nExpr - 1 ) ) == 0 ) { ExprList * pNew ; pNew = sqlite3DbRealloc ( db , pList , <vul-start> sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ; <vul-end> if ( pNew == 0 ) { goto no_mem ; } pList = pNew ; } pItem = & pList -> a [ pList -> nExpr ++ ] ; assert ( offsetof ( struct ExprList_item , zName ) == sizeof ( pItem -> pExpr ) ) ; assert ( offsetof ( struct ExprList_item , pExpr ) == 0 ) ; memset ( & pItem -> zName , 0 , sizeof ( * pItem ) - offsetof ( struct ExprList_item , zName ) ) ; pItem -> pExpr = pExpr ; return pList ; no_mem : sqlite3ExprDelete ( db , pExpr ) ; sqlite3ExprListDelete ( db , pList ) ; return 0 ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ( 2 * ( sqlite3_int64 )\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ) + ( 2LL <vul-end> * pList ->\n"
 },
 {
  "id": 803,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int rd_pick_intra4x4mby_modes ( MACROBLOCK * mb , int * Rate , int * rate_y , int * Distortion , int best_rd ) { MACROBLOCKD * const xd = & mb -> e_mbd ; int i ; int cost = mb -> mbmode_cost [ xd -> frame_type ] [ B_PRED ] ; int distortion = 0 ; int tot_rate_y = 0 ; int64_t total_rd = 0 ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; const int * bmode_costs ; <vul-start> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <vul-end> <vul-start> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <vul-end> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; intra_prediction_down_copy ( xd , xd -> dst . y_buffer - xd -> dst . y_stride + 16 ) ; bmode_costs = mb -> inter_bmode_costs ; for ( i = 0 ; i < 16 ; i ++ ) { MODE_INFO * const mic = xd -> mode_info_context ; const int mis = xd -> mode_info_stride ; B_PREDICTION_MODE UNINITIALIZED_IS_SAFE ( best_mode ) ; int UNINITIALIZED_IS_SAFE ( r ) , UNINITIALIZED_IS_SAFE ( ry ) , UNINITIALIZED_IS_SAFE ( d ) ; if ( mb -> e_mbd . frame_type == KEY_FRAME ) { const B_PREDICTION_MODE A = above_block_mode ( mic , i , mis ) ; const B_PREDICTION_MODE L = left_block_mode ( mic , i ) ; bmode_costs = mb -> bmode_costs [ A ] [ L ]",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * bmode_costs ; memcpy <vul-end> ( & t_above <vul-start> ) ) ; memcpy <vul-end> ( & t_left\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * bmode_costs ; memcpy <vul-end> ( & t_above <vul-start> ) ) ; memcpy <vul-end> ( & t_left\n"
 },
 {
  "id": 804,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static struct ucma_multicast * ucma_alloc_multicast ( struct ucma_context * ctx ) { struct ucma_multicast * mc ; mc = kzalloc ( sizeof ( * mc ) , GFP_KERNEL ) ; if ( ! mc ) return NULL ; mutex_lock ( & mut ) ; <vul-start> mc -> id = idr_alloc ( & multicast_idr , mc , 0 , 0 , GFP_KERNEL ) ; <vul-end> mutex_unlock ( & mut ) ; if ( mc -> id < 0 ) goto error ; mc -> ctx = ctx ; list_add_tail ( & mc -> list , & ctx -> mc_list ) ; return mc ; error : kfree ( mc ) ; return NULL ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> & multicast_idr , NULL <vul-end> , 0 ,\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> -> id = idr_create ( & multicast_idr, mc <vul-end>, 0,\n"
 },
 {
  "id": 805,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static BOOL autodetect_recv_bandwidth_measure_results ( rdpRdp * rdp , wStream * s , AUTODETECT_RSP_PDU * autodetectRspPdu ) { BOOL success = TRUE ; if ( autodetectRspPdu -> headerLength != 0x0E ) return FALSE ; <vul-start> WLog_VRB ( AUTODETECT_TAG , \"received Bandwidth Measure Results PDU\" ) ; <vul-end> Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureTimeDelta ) ; Stream_Read_UINT32 ( s , rdp -> autodetect -> bandwidthMeasureByteCount ) ; if ( rdp -> autodetect -> bandwidthMeasureTimeDelta > 0 ) rdp -> autodetect -> netCharBandwidth = rdp -> autodetect -> bandwidthMeasureByteCount * 8 / rdp -> autodetect -> bandwidthMeasureTimeDelta ; else rdp -> autodetect -> netCharBandwidth = 0 ; IFCALLRET ( rdp -> autodetect -> BandwidthMeasureResults , success , rdp -> context , autodetectRspPdu -> sequenceNumber ) ; return success ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , \"received Bandwidth Measure Results PDU\" ) ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, \"received Bandwidth Measure Results PDU\" ) ; if ( Stream_GetRemainingLength ( s ) < 6 ) return FALSE\n"
 },
 {
  "id": 806,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void nfs4_close_done ( struct rpc_task * task , void * data ) { struct nfs4_closedata * calldata = data ; struct nfs4_state * state = calldata -> state ; struct nfs_server * server = NFS_SERVER ( calldata -> inode ) ; if ( RPC_ASSASSINATED ( task ) ) return ; switch ( task -> tk_status ) { case 0 : nfs_set_open_stateid ( state , & calldata -> res . stateid , 0 ) ; renew_lease ( server , calldata -> timestamp ) ; break ; case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED : <vul-start> if ( calldata -> arg . open_flags == 0 ) <vul-end> break ; default : if ( nfs4_async_handle_error ( task , server , state ) == - EAGAIN ) { rpc_restart_call ( task ) ; return ; } } nfs_refresh_inode ( calldata -> inode , calldata -> res . fattr ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> -> arg . fmode <vul-end> == 0 )\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> : if (! calldata -> arg. open_flags <vul-end> ) break ;\n"
 },
 {
  "id": 807,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_cond_prob_diff_update ( vp9_writer * w , vp9_prob * oldp , <vul-end> const unsigned int ct [ 2 ] ) { <vul-start> const vp9_prob upd = DIFF_UPDATE_PROB ; <vul-end> <vul-start> vp9_prob newp = get_binary_prob ( ct [ 0 ] , ct [ 1 ] ) ; <vul-end> const int savings = vp9_prob_diff_update_savings_search ( ct , * oldp , & newp , upd ) ; assert ( newp >= 1 ) ; if ( savings > 0 ) { <vul-start> vp9_write ( w , 1 , upd ) ; <vul-end> vp9_write_prob_diff_update ( w , newp , * oldp ) ; * oldp = newp ; } else { <vul-start> vp9_write ( w , 0 , upd ) ; <vul-end> } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> void vp9_cond_prob_diff_update ( vpx_writer <vul-end> * w , <vul-start> * w , vpx_prob <vul-end> * oldp , <vul-start> ) { const vpx_prob <vul-end> upd = DIFF_UPDATE_PROB <vul-start> = DIFF_UPDATE_PROB ; vpx_prob <vul-end> newp = get_binary_prob <vul-start> 0 ) { vpx_write <vul-end> ( w , <vul-start> } else { vpx_write <vul-end> ( w ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void vp9_cond_prob_diff_update ( vpx_writer <vul-end> * w, <vul-start> * w, vpx_prob <vul-end> * oldp, <vul-start> ) { const vpx_prob <vul-end> upd = DIFF_UPDATE_PROB <vul-start> = DIFF_UPDATE_PROB ; vpx_prob <vul-end> newp = get_binary_prob <vul-start> 0 ) { vpx_write <vul-end> ( w, <vul-start> } else { vpx_write <vul-end> ( w,\n"
 },
 {
  "id": 808,
  "question": "CWE-326 Code Input Vulnerable Code Is: CWE-326 __be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) { <vul-start> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <vul-end> struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ; <vul-start> net_get_random_once ( & ip6_proxy_idents_hashrnd , <vul-end> sizeof ( ip6_proxy_idents_hashrnd ) ) ; <vul-start> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <vul-end> & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }",
  "golden_answers": [
   "CWE-326 Fixed Code Lines are: <vul-start> skb ) { <vul-end> struct in6_addr buf <vul-start> return 0 ; <vul-end> id = __ipv6_select_ident <vul-start> ( net , <vul-end> & addrs [\n"
  ],
  "generated_answer": "CWE-326 Fixed Code Lines are: <vul-start> skb ) { u32 id <vul-end> ; struct in6_addr <vul-start> return 0 ; spin_lock_bh ( & ip6_proxy_idents_lock <vul-end> ) ; id <vul-start> ( net, & ip6_proxy_idents_lock <vul-end>, & addrs\n"
 },
 {
  "id": 809,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 <vul-start> static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb ) <vul-end> { s -> avctx -> profile = get_bits ( gb , 4 ) ; <vul-start> s -> avctx -> level = get_bits ( gb , 4 ) ; <vul-end> <vul-start> if ( s -> avctx -> profile == 0 && s -> avctx -> level == 8 ) { <vul-end> <vul-start> s -> avctx -> level = 0 ; <vul-end> } return 0 ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> GetBitContext * gb , int * profile , int * level ) { * <vul-end> profile = get_bits <vul-start> 4 ) ; * <vul-end> level = get_bits <vul-start> ; if ( * <vul-end> profile == 0 <vul-start> == 0 && * <vul-end> level == 8 <vul-start> 8 ) { * <vul-end> level = 0\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> GetBitContext * gb, AVRational * const gb_in ) { SPEED_FEATURES * const avctx = s -> avctx ; int profile, level ; <vul-end> profile = get_bits <vul-start> 4 ) ; <vul-end> level = get_bits <vul-start> ; if ( <vul-end> profile == 0 <vul-start> == 0 && <vul-end> level == 8 <vul-start> 8 ) { <vul-end> level = 0\n"
 },
 {
  "id": 810,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 const char * string_of_NPPVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPPVpluginNameString ) ; _ ( NPPVpluginDescriptionString ) ; _ ( NPPVpluginWindowBool ) ; _ ( NPPVpluginTransparentBool ) ; _ ( NPPVjavaClass ) ; _ ( NPPVpluginWindowSize ) ; _ ( NPPVpluginTimerInterval ) ; _ ( NPPVpluginScriptableInstance ) ; _ ( NPPVpluginScriptableIID ) ; _ ( NPPVjavascriptPushCallerBool ) ; _ ( NPPVpluginKeepLibraryInMemory ) ; _ ( NPPVpluginNeedsXEmbed ) ; _ ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ; <vul-start> # undef _ <vul-end> default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPPVpluginScriptableInstance ) ; # undef _ default : str = \"<unknown variable>\" ; break ; } break ; } return str ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> NPPVformValue ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> NPPVformValue ) ; _ ( NPPVpluginRawValue ) ;\n"
 },
 {
  "id": 811,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static MV_REFERENCE_FRAME get_frame_type ( const VP9_COMP * cpi ) { if ( frame_is_intra_only ( & cpi -> common ) ) return INTRA_FRAME ; else if ( cpi -> rc . is_src_frame_alt_ref && cpi -> refresh_golden_frame ) return ALTREF_FRAME ; else if ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) <vul-start> return LAST_FRAME ; <vul-end> else <vul-start> return GOLDEN_FRAME ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> refresh_alt_ref_frame ) return GOLDEN_FRAME <vul-end> ; else return <vul-start> ; else return LAST_FRAME <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> refresh_alt_ref_frame ) return GOLDEN_FRAME <vul-end> ; else return <vul-start> ; else return LAST_FRAME <vul-end> ; }  \n"
 },
 {
  "id": 812,
  "question": "CWE-134 Code Input Vulnerable Code Is: CWE-134 static void zend_throw_or_error ( int fetch_type , zend_class_entry * exception_ce , const char * format , ... ) { va_list va ; char * message = NULL ; va_start ( va , format ) ; zend_vspprintf ( & message , 0 , format , va ) ; if ( fetch_type & ZEND_FETCH_CLASS_EXCEPTION ) { <vul-start> zend_throw_error ( exception_ce , message ) ; <vul-end> } else { zend_error ( E_ERROR , \"%s\" , message ) ; } efree ( message ) ; va_end ( va ) ; }",
  "golden_answers": [
   "CWE-134 Fixed Code Lines are: <vul-start> ( exception_ce , \"%s\" ,\n"
  ],
  "generated_answer": "CWE-134 Fixed Code Lines are: <vul-start> ZEND_FETCH_CLASS_EXCEPTION ) { if ( exception_ce ) { <vul-start> message ) ; } else { zend_throw_error ( exception_ce, message ) ; }\n"
 },
 {
  "id": 813,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb -> len && <vul-start> ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <vul-end> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb ->",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <vul-end> ) put_cmsg (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> & SOF_TIMESTAMPING_OPT_STATS ) && skb -> len && skb -> opt. opt_stats\n"
 },
 {
  "id": 814,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , struct frag_hdr * fhdr , int nhoff ) { struct sk_buff * prev , * next ; struct net_device * dev ; int offset , end ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; if ( fq -> q . last_in & INET_FRAG_COMPLETE ) goto err ; offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; if ( ( unsigned int ) end > IPV6_MAXPLEN ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , ( ( u8 * ) & fhdr -> frag_off - skb_network_header ( skb ) ) ) ; return - 1 ; } if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { const unsigned char * nh = skb_network_header ( skb ) ; skb -> csum = csum_sub ( skb -> csum , csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , 0 ) ) ; } if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { if ( end < fq -> q . len || ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end !=",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> if ( prev && <vul-end> ( FRAG6_CB ( <vul-start> ) - offset <vul-end> > 0 ) <vul-start> > 0 ) goto discard_fq ; if <vul-end> ( next && <vul-start> < end ) goto discard_fq ; <vul-end> FRAG6_CB ( skb <vul-start> - 1 ; discard_fq : fq_kill ( fq ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> } found : int min_frag_off = min_frag_off + 1 ; <vul-start> prev ) { struct ipv6_hdr * prev_hdr = FRAG6_CB ( prev ) ; <vul-start> -> offset + prev_hdr <vul-end> -> len ) <vul-start> - offset ; min_frag_off = prev_hdr -> offset ; <vul-start> ( next && prev_hdr <vul-end> -> offset < <vul-start> offset < end && i < min_frag_off <vul-start> - 1 ; min_frag_off = next_hdr -> offset ;\n"
 },
 {
  "id": 815,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PHPAPI int php_var_unserialize ( UNSERIALIZE_PARAMETER ) { const unsigned char * cursor , * limit , * marker , * start ; zval * * rval_ref ; limit = max ; cursor = * p ; if ( YYCURSOR >= YYLIMIT ) { return 0 ; } if ( var_hash && cursor [ 0 ] != 'R' ) { var_push ( var_hash , rval ) ; } start = cursor ; <vul-start> # line 496 \"ext/standard/var_unserializer.c\" <vul-end> { YYCTYPE yych ; static const unsigned char yybm [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; # line 501 <vul-end> \"ext/standard/var_unserializer.c\" { YYCTYPE <vul-start> : # line 875 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 563 <vul-end> \"ext/standard/var_unserializer.c\" yy4 : <vul-start> ; # line 869 <vul-end> \"ext/standard/var_unserializer.re\" { php_error_docref <vul-start> } # line 612 <vul-end> \"ext/standard/var_unserializer.c\" yy16 : <vul-start> ; # line 717 <vul-end> \"ext/standard/var_unserializer.re\" { size_t <vul-start> ; if ( elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <vul-start> } # line 795 <vul-end> \"ext/standard/var_unserializer.c\" yy25 : <vul-start> ; # line 704 \"ext/standard/var_unserializer.re\" { long elements ; <vul-end> if ( ! <vul-start> rval ) ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } <vul-start> ( UNSERIALIZE_PASSTHRU , elements <vul-end> ) ; } <vul-start> } # line 833 <vul-end> \"ext/standard/var_unserializer.c\" yy32 : <vul-start> ; # line 683 <vul-end> \"ext/standard/var_unserializer.re\" { long <vul-start> } # line 875 <vul-end> \"ext/standard/var_unserializer.c\" yy39 : <vul-start> ; # line 648 <vul-end> \"ext/standard/var_unserializer.re\" { size_t <vul-start> } # line 931 <vul-end> \"ext/standard/var_unserializer.c\" yy46 : <vul-start> ; # line 615 <vul-end> \"ext/standard/var_unserializer.re\" { size_t <vul-start> } # line 985 <vul-end> \"ext/standard/var_unserializer.c\" yy53 : <vul-start> ; # line 605 <vul-end> \"ext/standard/var_unserializer.re\" { # <vul-start> } # line 1083 <vul-end> \"ext/standard/var_unserializer.c\" yy65 : <vul-start> ; # line 590 <vul-end> \"ext/standard/var_unserializer.re\" { * <vul-start> } # line 1157 <vul-end> \"ext/standard/var_unserializer.c\" yy76 : <vul-start> ; # line 563 <vul-end> \"ext/standard/var_unserializer.re\" { # <vul-start> } # line 1211 <vul-end> \"ext/standard/var_unserializer.c\" yy83 : <vul-start> ; # line 556 <vul-end> \"ext/standard/var_unserializer.re\" { * <vul-start> } # line 1226 <vul-end> \"ext/standard/var_unserializer.c\" yy87 : <vul-start> ; # line 549 <vul-end> \"ext/standard/var_unserializer.re\" { * <vul-start> } # line 1236 <vul-end> \"ext/standard/var_unserializer.c\" yy89 : <vul-start> ; # line 526 <vul-end> \"ext/standard/var_unserializer.re\" { long <vul-start> } # line 1282 <vul-end> \"ext/standard/var_unserializer.c\" yy95 : <vul-start> ; # line 505 <vul-end> \"ext/standard/var_unserializer.re\" { long <vul-start> } # line 1326 <vul-end> \"ext/standard/var_unserializer.c\" } # <vul-start> } # line 877 <vul-end> \"ext/standard/var_unserializer.re\" return 0\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; # line 496 <vul-end> \"ext/standard/var_unserializer.c\" { YYCTYPE <vul-start> : # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { return <vul-start> } # line 558 <vul-end> \"ext/standard/var_unserializer.c\" yy4 : <vul-start> ; # line 855 <vul-end> \"ext/standard/var_unserializer.re\" { php_error_docref <vul-start> } # line 607 <vul-end> \"ext/standard/var_unserializer.c\" yy16 : <vul-start> ; # line 855 <vul-end> \"ext/standard/var_unserializer.re\" { size_t <vul-start> } # line 607 <vul-end> \"ext/standard/var_unserializer.c\" yy25 : <vul-start> ; # line 855 <vul-end> \"ext/standard/var_unserializer.re\" { if <vul-start> } # line 607 <vul-end> \"ext/standard/var_unserializer.c\" yy32 : <vul-start> ; # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { long <vul-start> } # line 607 <vul-end> \"ext/standard/var_unserializer.c\" yy39 : <vul-start> ; # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { long <vul-start> } # line 607 <vul-end> \"ext/standard/var_unserializer.c\" yy46 : <vul-start> ; # line 855 <vul-end> \"ext/standard/var_unserializer.re\" { size_t <vul-start> } # line 607 <vul-end> \"ext/standard/var_unserializer.c\" yy53 : <vul-start> ; # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { size_t <vul-start> } # line 607 <vul-end> \"ext/standard/var_unserializer.c\" yy65 : <vul-start> ; # line 861 <vul-end> \"ext/standard/var_unserializer.re\" { # <vul-start> } # line 607 <vul-end> \"ext/standard/var_unserializer.c\" yy76 : <vul-start> ; # line 937 <vul-end> \"ext/standard/var_unserializer.re\" { # <vul-start> } # line 971 <vul-end> \"ext/standard/var_unserializer."
 },
 {
  "id": 816,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void Np_toString ( js_State * J ) { <vul-start> char buf [ 32 ] ; <vul-end> js_Object * self = js_toobject ( J , 0 ) ; int radix = js_isundefined ( J , 1 ) ? 10 : js_tointeger ( J , 1 ) ; if ( self -> type != JS_CNUMBER ) js_typeerror ( J , \"not a number\" ) ; if ( radix == 10 ) { js_pushstring ( J , jsV_numbertostring ( J , buf , self -> u . number ) ) ; return ; } if ( radix < 2 || radix > 36 ) js_rangeerror ( J , \"invalid radix\" ) ; { static const char digits [ ] = \"0123456789abcdefghijklmnopqrstuvwxyz\" ; <vul-start> char buf [ 100 ] ; <vul-end> double number = self -> u . number ; int sign = self -> u . number < 0 ; js_Buffer * sb = NULL ; uint64_t u , limit = ( ( uint64_t ) 1 << 52 ) ; int ndigits , exp , point ; if ( number == 0 ) { js_pushstring ( J , \"0\" ) ; return ; } if ( isnan ( number ) ) { js_pushstring ( J , \"NaN\" ) ; return ; } if ( isinf ( number ) ) { js_pushstring ( J , sign ? \"-Infinity\" : \"Infinity\" ) ; return ; } if ( sign ) number = - number ; exp = 0 ; while ( number * pow ( radix , exp ) > limit ) -- exp ; while ( number *",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> char buf [ 100 <vul-end> ] ; js_Object <vul-start> = \"0123456789abcdefghijklmnopqrstuvwxyz\" ; <vul-end> double number =\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char buf [ 64 <vul-end> ] ; js_Object <vul-start> = \"0123456789abcdefghijklmnopqrstuvwxyz\" ; <vul-end> double number = <vul-start> buf ) ; js_checkstack ( J, 1, \"in function Np_toString\" ) ;\n"
 },
 {
  "id": 817,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 int ipmi_destroy_user ( struct ipmi_user * user ) { <vul-start> _ipmi_destroy_user ( user ) ; <vul-end> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> _ipmi_destroy_user ( user <vul-end> ) ; kref_put\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> user ) { if ( atomic_dec_and_test ( & user -> refcnt ) ) return 0 ;\n"
 },
 {
  "id": 818,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 int lzxd_decompress ( struct lzxd_stream * lzx , off_t out_bytes ) { register unsigned int bit_buffer ; register int bits_left , i = 0 ; unsigned char * i_ptr , * i_end ; register unsigned short sym ; int match_length , length_footer , extra , verbatim_bits , bytes_todo ; int this_run , main_element , aligned_bits , j ; unsigned char * window , * runsrc , * rundest , buf [ 12 ] ; unsigned int frame_size = 0 , end_frame , match_offset , window_posn ; unsigned int R0 , R1 , R2 ; if ( ! lzx || ( out_bytes < 0 ) ) return MSPACK_ERR_ARGS ; if ( lzx -> error ) return lzx -> error ; i = lzx -> o_end - lzx -> o_ptr ; if ( ( off_t ) i > out_bytes ) i = ( int ) out_bytes ; if ( i ) { if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { return lzx -> error = MSPACK_ERR_WRITE ; } lzx -> o_ptr += i ; lzx -> offset += i ; out_bytes -= i ; } if ( out_bytes == 0 ) return MSPACK_ERR_OK ; RESTORE_BITS ; window = lzx -> window ; window_posn = lzx -> window_posn ; R0 = lzx -> R0 ; R1 = lzx -> R1 ; R2 = lzx -> R2 ; end_frame = ( unsigned int ) ( ( lzx -> offset + out_bytes ) / LZX_FRAME_SIZE ) + 1 ; while ( lzx -> frame < end_frame",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> = 1 ; if ( bits_left == 0 ) <vul-start> ( 16 ) <vul-end> ; bits_left =\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> = 1 ; if ( bits_left < 2 ) break ;\n"
 },
 {
  "id": 819,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t httpCheckCharset ( const char_t * s , size_t length , uint_t charset ) { error_t error ; size_t i ; uint8_t c ; uint_t m ; error = NO_ERROR ; for ( i = 0 ; i < length ; i ++ ) { c = ( uint8_t ) s [ i ] ; m = HTTP_CHARSET_OCTET ; if ( iscntrl ( c ) ) m |= HTTP_CHARSET_CTL ; if ( isprint ( c ) && c <= 126 ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_VCHAR ; if ( c == ' ' || c == '\\\\t' ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_LWS ; if ( isalpha ( c ) ) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_ALPHA ; if ( osIsdigit ( c ) ) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_DIGIT ; if ( isxdigit ( c ) ) m |= HTTP_CHARSET_HEX ; if ( c >= 128 ) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_OBS_TEXT ; <vul-start> if ( strchr ( \"!#$%&\\'*+-.^_`|~\" , c ) ) <vul-end> m |= HTTP_CHARSET_TCHAR ; if ( ( m & charset ) == 0 ) error = ERROR_INVALID_SYNTAX ; } return error ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; if ( osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\" ,\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( osStrchr <vul-end> ( \"!#$%&\\'*+-.^_`|~\", <vul-start>, c )!= NULL\n"
 },
 {
  "id": 820,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int __get_data_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh , int create , int flag , pgoff_t * next_pgofs ) { struct f2fs_map_blocks map ; int err ; map . m_lblk = iblock ; map . m_len = bh -> b_size >> inode -> i_blkbits ; map . m_next_pgofs = next_pgofs ; err = f2fs_map_blocks ( inode , & map , create , flag ) ; if ( ! err ) { map_bh ( bh , inode -> i_sb , map . m_pblk ) ; bh -> b_state = ( bh -> b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ; <vul-start> bh -> b_size = map . m_len << inode -> i_blkbits ; <vul-end> } return err ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> -> b_size = ( u64 )\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start>. m_flags ; if ( map. m_len > F2FS_MAX_BLOCKS ) { f2fs_set_bh_flags ( bh, BH_ENOSPC ) ; }\n"
 },
 {
  "id": 821,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static gboolean cosine_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { <vul-start> gint64 offset ; <vul-end> int pkt_len ; char line [ COSINE_LINE_LENGTH ] ; offset = cosine_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; * data_offset = offset ; <vul-start> pkt_len = parse_cosine_rec_hdr ( & wth -> phdr , line , err , err_info ) ; <vul-end> if ( pkt_len == - 1 ) return FALSE ; <vul-start> return parse_cosine_hex_dump ( wth -> fh , & wth -> phdr , pkt_len , <vul-end> <vul-start> wth -> frame_buffer , err , err_info ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { gint64 offset <vul-end> ; char line <vul-start> = offset ; return parse_cosine_packet <vul-end> ( wth -> <vul-start> -> phdr , <vul-end> wth -> frame_buffer <vul-start> wth -> frame_buffer , line\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { gint64 offset <vul-end> ; char line <vul-start> = offset ; if (! <vul-end> parse_cosine_rec_hdr ( & <vul-start>, line, <vul-end> err, err_info <vul-start> return FALSE ; if (! <vul-end> parse_cosine_hex_dump ( wth <vul-start>, err_info ) ) return FALSE ; * data_offset = offset ; return TRUE\n"
 },
 {
  "id": 822,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static krb5_error_code get_matching_data ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , X509 * cert , pkinit_cert_matching_data * * md_out ) { krb5_error_code ret = ENOMEM ; pkinit_cert_matching_data * md = NULL ; krb5_principal * pkinit_sans = NULL , * upn_sans = NULL ; size_t i , j ; <vul-start> char buf [ DN_BUF_LEN ] ; <vul-end> unsigned int bufsize = sizeof ( buf ) ; * md_out = NULL ; md = calloc ( 1 , sizeof ( * md ) ) ; if ( md == NULL ) goto cleanup ; <vul-start> X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , <vul-end> XN_FLAG_SEP_COMMA_PLUS ) ; <vul-start> md -> subject_dn = strdup ( buf ) ; <vul-end> if ( md -> subject_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } <vul-start> X509_NAME_oneline_ex ( X509_get_issuer_name ( cert ) , buf , & bufsize , <vul-end> XN_FLAG_SEP_COMMA_PLUS ) ; <vul-start> md -> issuer_dn = strdup ( buf ) ; <vul-end> if ( md -> issuer_dn == NULL ) { ret = ENOMEM ; goto cleanup ; } ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , j ; * md_out = NULL ; md = calloc ( 1 , sizeof ( <vul-end> * md ) <vul-start> goto cleanup ; ret = rfc2253_name <vul-end> ( X509_get_subject_name ( <vul-start> cert ) , & <vul-end> md -> subject_dn <vul-start> md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <vul-end> ( X509_get_issuer_name ( <vul-start> cert ) , & <vul-end> md -> issuer_dn <vul-start> md -> issuer_dn ) ; if ( ret ) goto cleanup ; <vul-end> ret = crypto_retrieve_X509_sans\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> j ; char * buf, * issuer_dn = NULL ; size_t subject_dn_len = 0 ; size_t issuer_dn_len = 0 <vul-end> ; * md_out <vul-start> goto cleanup ; X509_NAME_oneline <vul-end> ( X509_get_subject_name ( <vul-start> cert ), & subject_dn_len, & issuer_dn_len <vul-end>, XN_FLAG_SEP_COMMA_PLUS ) <vul-start> -> subject_dn = buf? strdup ( buf ) : NULL ; if ( md -> subject_dn <vul-end> == NULL ) <vul-start> cleanup ; } X509_NAME_oneline <vul-end> ( X509_get_issuer_name ( <vul-start> cert ), issuer_dn_len, & issuer_dn_len <vul-end>, XN_FLAG_SEP_COMMA_PLUS ) <vul-start> -> issuer_dn = buf? strdup ( buf ) : NULL ; if ( md -> issuer_dn <vul-end> == NULL )\n"
 },
 {
  "id": 823,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; <vul-start> align_get_bits ( gb ) ; <vul-end> if ( s -> codec_tag == AV_RL32 ( \"WV1F\" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( \"QMP4\" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , \"frame skip %d\\\\n\" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , \"startcode: %3X \" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Object Start\" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , \"Video Object Layer Start\" ) ;",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = 0 ; if ( ctx -> num_frame_workers > 1 ) { av_log ( s -> avctx, AV_LOG_WARNING, \"Too many frame threads\\\\n\" ) ; return AVERROR_INVALIDDATA ; }\n"
 },
 {
  "id": 824,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int cdc_ncm_bind ( struct usbnet * dev , struct usb_interface * intf ) { <vul-start> int ret ; <vul-end> if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ; <vul-start> ret = cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ; <vul-end> <vul-start> usbnet_link_change ( dev , 0 , 0 ) ; <vul-end> return ret ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> intf ) { <vul-end> if ( cdc_ncm_select_altsetting <vul-start> - ENODEV ; return <vul-end> cdc_ncm_bind_common ( dev <vul-start> 0 ) ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> intf ) { struct usbnet_host * hdev = dev -> priv ; int ret ; u8 * data ; int len <vul-end> ; if ( <vul-start> - ENODEV ; data = kmalloc ( CDC_NCM_DATA_ALTSETTING_NCM, GFP_KERNEL ) ; if (! data ) return - ENOMEM ; len = usbnet_align ( dev -> net, len ) ; if (! data ) return - ENOMEM ; hdev = & dev -> interface [ intf -> desc. bNumEndpoints ] ; if (! hdev ) return - ENOMEM ; <vul-start>, CDC_NCM_DATA_ALTSETTING_NCM, len <vul-end> ) ; usbnet_link_change <vul-start> ( dev, data, len <vul-end> ) ; return\n"
 },
 {
  "id": 825,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const ut8 * r_bin_dwarf_parse_comp_unit ( Sdb * s , const ut8 * obuf , RBinDwarfCompUnit * cu , const RBinDwarfDebugAbbrev * da , size_t offset , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf , * buf_end = obuf + ( cu -> hdr . length - 7 ) ; ut64 abbr_code ; size_t i ; if ( cu -> hdr . length > debug_str_len ) { return NULL ; } while ( buf && buf < buf_end && buf >= obuf ) { if ( cu -> length && cu -> capacity == cu -> length ) { r_bin_dwarf_expand_cu ( cu ) ; } buf = r_uleb128 ( buf , buf_end - buf , & abbr_code ) ; if ( abbr_code > da -> length || ! buf ) { return NULL ; } r_bin_dwarf_init_die ( & cu -> dies [ cu -> length ] ) ; if ( ! abbr_code ) { cu -> dies [ cu -> length ] . abbrev_code = 0 ; cu -> length ++ ; buf ++ ; continue ; } cu -> dies [ cu -> length ] . abbrev_code = abbr_code ; cu -> dies [ cu -> length ] . tag = da -> decls [ abbr_code - 1 ] . tag ; abbr_code += offset ; if ( da -> capacity < abbr_code ) { return NULL ; } for ( i = 0 ; i < da -> decls [ abbr_code - 1 ] . length ; i ++ ) { if ( cu ->",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> NULL ; } if ( i >= 1024 ) { eprintf ( \"Warning: invalid abbrev length\\\\n\" ) ; break ; }\n"
 },
 {
  "id": 826,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_calc_ss_err ( YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * dest ) { int i , j ; int Total = 0 ; unsigned char * src = source -> y_buffer ; unsigned char * dst = dest -> y_buffer ; for ( i = 0 ; i < source -> y_height ; i += 16 ) { for ( j = 0 ; j < source -> y_width ; j += 16 ) { unsigned int sse ; <vul-start> Total += vp8_mse16x16 ( src + j , source -> y_stride , dst + j , dest -> y_stride , & sse ) ; <vul-end> } src += 16 * source -> y_stride ; dst += 16 * dest -> y_stride ; } return Total ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; Total += vpx_mse16x16 <vul-end> ( src +\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int sse ; ( void ) <vul-end> vp8_mse16x16 ( src <vul-start> & sse ) ; Total += sse\n"
 },
 {
  "id": 827,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void encode_mb_row ( VP8_COMP * cpi , VP8_COMMON * cm , int mb_row , MACROBLOCK * x , MACROBLOCKD * xd , TOKENEXTRA * * tp , int * segment_counts , int * totalrate ) { int recon_yoffset , recon_uvoffset ; int mb_col ; int ref_fb_idx = cm -> lst_fb_idx ; int dst_fb_idx = cm -> new_fb_idx ; int recon_y_stride = cm -> yv12_fb [ ref_fb_idx ] . y_stride ; int recon_uv_stride = cm -> yv12_fb [ ref_fb_idx ] . uv_stride ; int map_index = ( mb_row * cpi -> common . mb_cols ) ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) const int num_part = ( 1 << cm -> multi_token_partition ) ; TOKENEXTRA * tp_start = cpi -> tok ; vp8_writer * w ; # endif # if CONFIG_MULTITHREAD const int nsync = cpi -> mt_sync_range ; const int rightmost_col = cm -> mb_cols + nsync ; volatile const int * last_row_current_mb_col ; volatile int * current_mb_col = & cpi -> mt_current_mb_col [ mb_row ] ; if ( ( cpi -> b_multi_threaded != 0 ) && ( mb_row != 0 ) ) last_row_current_mb_col = & cpi -> mt_current_mb_col [ mb_row - 1 ] ; else last_row_current_mb_col = & rightmost_col ; # endif # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( num_part > 1 ) w = & cpi -> bc [ 1 + ( mb_row % num_part ) ] ; else w = & cpi -> bc [ 1 ] ; # endif xd -> above_context = cm -> above_context ; xd -> up_available = ( mb_row != 0 ) ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> endif if ( <vul-end> cpi -> current_layer <vul-start> == 0 ) { if <vul-end> ( xd -> <vul-start> mode == ZEROMV && <vul-end> xd -> mode_info_context <vul-start> == LAST_FRAME ) { if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ; if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ; } else { cpi -> consec_zero_last [ map_index + mb_col ] = 0 ; cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) <vul-start> - tp_start ; vp8_pack_tokens <vul-end> ( w ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> endif if ( xd -> mode_info_context -> mbmi. ref_frame == LAST_FRAME && <vul-start> else if ( xd -> mode_info_context -> mbmi. ref_frame == LAST_FRAME &&\n"
 },
 {
  "id": 828,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int sd_e_h ( GWindow gw , GEvent * event ) { struct sd_data * sd = GDrawGetUserData ( gw ) ; if ( sd == NULL ) return ( true ) ; if ( event -> type == et_close ) { SD_DoCancel ( sd ) ; <vul-start> } else if ( event -> type == et_char ) { <vul-end> if ( event -> u . chr . keysym == GK_F1 || event -> u . chr . keysym == GK_Help ) { help ( \"scripting.html\" ) ; return ( true ) ; } return ( false ) ; } else if ( event -> type == et_map ) GDrawRaise ( gw ) ; else if ( event -> type == et_resize ) GDrawRequestExpose ( gw , NULL , false ) ; return ( true ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> type == et_char && event -> u. chr. keysym == GK_F1\n"
 },
 {
  "id": 829,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) \"Parse_thread\" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> buflen , buf_size - 8\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; if ( 0 >= buf_size ) { ret = ih264d_set_error_code ( ps_dec, IVD_ERR_CODE_DECODE_ERR, \"Insufficient input data\" ) ; return ret ; }\n"
 },
 {
  "id": 830,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int crossOriginDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * option , * ovalue , * tok ; route = state -> route ; tok = sclone ( value ) ; while ( ( option = maGetNextArg ( tok , & tok ) ) != 0 ) { <vul-start> option = stok ( option , \" =\\\\t,\" , & ovalue ) ; <vul-end> ovalue = strim ( ovalue , \"\\\\\"\\'\" , MPR_TRIM_BOTH ) ; if ( scaselessmatch ( option , \"origin\" ) ) { route -> corsOrigin = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , \"credentials\" ) ) { route -> corsCredentials = httpGetBoolToken ( ovalue ) ; } else if ( scaselessmatch ( option , \"headers\" ) ) { route -> corsHeaders = sclone ( ovalue ) ; } else if ( scaselessmatch ( option , \"age\" ) ) { route -> corsAge = atoi ( ovalue ) ; } else { mprLog ( \"error appweb config\" , 0 , \"Unknown CrossOrigin option %s\" , option ) ; return MPR_ERR_BAD_SYNTAX ; } } # if KEEP if ( smatch ( route -> corsOrigin , \"*\" ) && route -> corsCredentials ) { mprLog ( \"error appweb config\" , 0 , \"CrossOrigin: Cannot use wildcard Origin if allowing credentials\" ) ; return MPR_ERR_BAD_STATE ; } # endif httpAddRouteMethods ( route , \"OPTIONS\" ) ; route -> flags |= HTTP_ROUTE_CORS ; return 0 ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option ,\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option,\n"
 },
 {
  "id": 831,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 tmsize_t TIFFReadEncodedStrip ( TIFF * tif , uint32 strip , void * buf , tmsize_t size ) { static const char module [ ] = \"TIFFReadEncodedStrip\" ; TIFFDirectory * td = & tif -> tif_dir ; uint32 rowsperstrip ; uint32 stripsperplane ; uint32 stripinplane ; uint16 plane ; uint32 rows ; tmsize_t stripsize ; if ( ! TIFFCheckRead ( tif , 0 ) ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( strip >= td -> td_nstrips ) { TIFFErrorExt ( tif -> tif_clientdata , module , \"%lu: Strip out of range, max %lu\" , ( unsigned long ) strip , ( unsigned long ) td -> td_nstrips ) ; return ( ( tmsize_t ) ( - 1 ) ) ; } rowsperstrip = td -> td_rowsperstrip ; if ( rowsperstrip > td -> td_imagelength ) rowsperstrip = td -> td_imagelength ; <vul-start> stripsperplane = ( ( td -> td_imagelength + rowsperstrip - 1 ) / rowsperstrip ) ; <vul-end> stripinplane = ( strip % stripsperplane ) ; plane = ( uint16 ) ( strip / stripsperplane ) ; rows = td -> td_imagelength - stripinplane * rowsperstrip ; if ( rows > rowsperstrip ) rows = rowsperstrip ; stripsize = TIFFVStripSize ( tif , rows ) ; if ( stripsize == 0 ) return ( ( tmsize_t ) ( - 1 ) ) ; if ( td -> td_compression == COMPRESSION_NONE && size != ( tmsize_t ) ( - 1 ) && size >= stripsize && ! isMapped ( tif ) && ( ( tif -> tif_flags & TIFF_NOREADRAW",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> ; stripsperplane = TIFFhowmany_32_maxuint_compat <vul-end> ( td -> <vul-start> td -> td_imagelength , <vul-end> rowsperstrip ) ;\n"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> stripsperplane = ( size_t ) ( <vul-start> ) / rowsperstrip ) ; if ( stripsperplane > 0xFFFFFFFFU - stripsize ) return ( - 1\n"
 },
 {
  "id": 832,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; <vul-start> int hstartcol ; <vul-end> if ( bufsize > QMFB_SPLITBUFSIZE ) { <vul-start> if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { <vul-end> abort ( ) ; } } if ( numrows >= 2 ) { <vul-start> hstartcol = ( numrows + 1 - parity ) >> 1 ; <vul-end> <vul-start> m = numrows - hstartcol ; <vul-end> n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> m ; int hstartrow <vul-end> ; if ( <vul-start> ( buf = jas_alloc3 <vul-end> ( bufsize , <vul-start> ( bufsize , JPC_QMFB_COLGRPSIZE , <vul-start> 2 ) { hstartrow <vul-end> = ( numrows <vul-start> = numrows - hstartrow <vul-end> ; n = <vul-start> & a [ hstartrow <vul-end> * stride ]\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; int hstartcol ; int num_samples ; int split_bufsize <vul-start> ( buf = jas_alloc3 ( bufsize, numrows, & split_bufsize ) ) { abort ( ) ; } if ( split_bufsize < 0 ) { jas_eprintf ( \"splitbufsize is 0\\\\n\" ) ; abort ( ) ; } <vul-end> if ( numrows <vul-start> 2 ) { num_samples <vul-end> = ( numrows <vul-start> = numrows - num_samples <vul-end> ; n = <vul-start> 1 ; } if ( num_samples > 0 ) { split_bufsize = numrows * stride * JPC_QMFB_COLGRPSIZE ; if ( split_bufsize < 0 ) { jas_eprintf ( \"splitbufsize is 0\\\\n\" ) ; abort ( ) ; } <vul-start> & a [ split_bufsize <vul-end> ] ; srcptr\n"
 },
 {
  "id": 833,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int hugetlbfs_statfs ( struct dentry * dentry , struct kstatfs * buf ) { struct hugetlbfs_sb_info * sbinfo = HUGETLBFS_SB ( dentry -> d_sb ) ; struct hstate * h = hstate_inode ( dentry -> d_inode ) ; buf -> f_type = HUGETLBFS_MAGIC ; buf -> f_bsize = huge_page_size ( h ) ; if ( sbinfo ) { spin_lock ( & sbinfo -> stat_lock ) ; <vul-start> if ( sbinfo -> max_blocks >= 0 ) { <vul-end> <vul-start> buf -> f_blocks = sbinfo -> max_blocks ; <vul-end> <vul-start> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <vul-end> buf -> f_files = sbinfo -> max_inodes ; buf -> f_ffree = sbinfo -> free_inodes ; } spin_unlock ( & sbinfo -> stat_lock ) ; } buf -> f_namelen = NAME_MAX ; return 0 ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ( sbinfo -> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <vul-end> buf -> f_blocks <vul-start> = sbinfo -> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <vul-end> ; buf -> <vul-start> -> f_bfree = free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <vul-end> ; buf ->\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ( sbinfo -> max_inodes <vul-end> >= 0 ) <vul-start> 0 ) { struct hugepage_subpool * spool = subpool_inode_to_pool ( sbinfo -> free_inodes ) ; <vul-start> -> f_blocks = spool <vul-end> -> max_blocks ; <vul-start> -> f_bfree = spool <vul-end> -> free_blocks ;\n"
 },
 {
  "id": 834,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == NULL ) { netdev_warn ( frad , \"Memory squeeze on fr_add_pvc()\\\\n\" ) ; return - ENOBUFS ; } if ( * get_dev_p ( pvc , type ) ) return - EEXIST ; used = pvc_is_used ( pvc ) ; <vul-start> if ( type == ARPHRD_ETHER ) <vul-end> dev = alloc_netdev ( 0 , \"pvceth%d\" , ether_setup ) ; <vul-start> else <vul-end> dev = alloc_netdev ( 0 , \"pvc%d\" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , \"Memory squeeze on fr_pvc()\\\\n\" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) ->",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> == ARPHRD_ETHER ) { <vul-start> ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> == ARPHRD_ETHER ) { if (! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <vul-start> ether_setup ) ; } else { if (! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <vul-end> dev = alloc_netdev\n"
 },
 {
  "id": 835,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ; <vul-start> in_uint16_le ( s , type ) ; <vul-end> in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , \"cliprdr_process(), type=%d, status=%d, length=%d\" , type , status , length ) ; <vul-start> if ( status == CLIPRDR_ERROR ) <vul-end> { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , \"cliprdr_process(), unhandled error (type=%d)\" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , \"cliprdr_process(), unhandled packet type %d\" , type ) ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * data ; struct stream packet = * s ; <vul-start> ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( \"cliprdr_process(), consume of packet from stream would overrun\" , & packet ) ; } if (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * data ; if (! s_check_rem ( s, length ) ) { rdp_protocol_error ( \"cliprdr_process(), consume of cliprdr data from stream would overrun\", s ) ; } <vul-start> length ) ; <vul-end> switch ( type\n"
 },
 {
  "id": 836,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 bool layer_resize ( int layer , int x_size , int y_size ) { int old_height ; int old_width ; struct map_tile * tile ; int tile_width ; int tile_height ; struct map_tile * tilemap ; struct map_trigger * trigger ; struct map_zone * zone ; <vul-start> int x , y , i ; <vul-end> old_width = s_map -> layers [ layer ] . width ; old_height = s_map -> layers [ layer ] . height ; <vul-start> if ( ! ( tilemap = malloc ( x_size * y_size * sizeof ( struct map_tile ) ) ) ) <vul-end> return false ; for ( x = 0 ; x < x_size ; ++ x ) { for ( y = 0 ; y < y_size ; ++ y ) { if ( x < old_width && y < old_height ) { tilemap [ x + y * x_size ] = s_map -> layers [ layer ] . tilemap [ x + y * old_width ] ; } else { tile = & tilemap [ x + y * x_size ] ; tile -> frames_left = tileset_get_delay ( s_map -> tileset , 0 ) ; tile -> tile_index = 0 ; } } } free ( s_map -> layers [ layer ] . tilemap ) ; s_map -> layers [ layer ] . tilemap = tilemap ; s_map -> layers [ layer ] . width = x_size ; s_map -> layers [ layer ] . height = y_size ; tileset_get_size ( s_map -> tileset , & tile_width , & tile_height ) ; s_map -> width = 0",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * zone ; size_t tilemap_size ; <vul-start> . height ; tilemap_size = <vul-end> x_size * y_size <vul-start> struct map_tile ) ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> y, i ; int size_left_in_map = x_size * y_size * sizeof ( struct map_tile ) <vul-start> ( tilemap = safe_calloc ( size_left_in_map <vul-end> ) ) )\n"
 },
 {
  "id": 837,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static unsigned int help ( struct sk_buff * skb , enum ip_conntrack_info ctinfo , unsigned int protoff , unsigned int matchoff , unsigned int matchlen , struct nf_conntrack_expect * exp ) { char buffer [ sizeof ( \"4294967296 65635\" ) ] ; <vul-start> u_int16_t port ; <vul-end> <vul-start> unsigned int ret ; <vul-end> exp -> saved_proto . tcp . port = exp -> tuple . dst . u . tcp . port ; exp -> dir = IP_CT_DIR_REPLY ; exp -> expectfn = nf_nat_follow_master ; for ( port = ntohs ( exp -> saved_proto . tcp . port ) ; port != 0 ; port ++ ) { int ret ; exp -> tuple . dst . u . tcp . port = htons ( port ) ; ret = nf_ct_expect_related ( exp ) ; if ( ret == 0 ) break ; else if ( ret != - EBUSY ) { port = 0 ; break ; } } if ( port == 0 ) { <vul-start> nf_ct_helper_log ( skb , exp -> master , \"all ports in use\" ) ; <vul-end> return NF_DROP ; } <vul-start> ret = nf_nat_mangle_tcp_packet ( skb , exp -> master , ctinfo , <vul-end> protoff , matchoff , matchlen , buffer , strlen ( buffer ) ) ; if ( ret != NF_ACCEPT ) { <vul-start> nf_ct_helper_log ( skb , exp -> master , \"cannot mangle packet\" ) ; <vul-end> nf_ct_unexpect_related ( exp ) ; } return ret ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) ] ; struct nf_conn * ct = exp -> master ; union nf_inet_addr newaddr ; <vul-start> unsigned int ret ; newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 <vul-start> ( skb , ct <vul-end> , \"all ports in use\" ) <vul-start> NF_DROP ; } snprintf ( buffer , sizeof ( buffer ) , \"%u %u\" , ntohl ( newaddr . ip ) , port ) ; pr_debug ( \"nf_nat_irc: inserting \\'%s\\' == %pI4, port %u\\\\n\" , buffer , & newaddr . ip , port ) ; <vul-start> ( skb , ct <vul-end> , ctinfo , <vul-start> ( skb , ct <vul-end> , \"cannot mangle packet\" )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ] ; int ret ; <vul-start> unsigned int port, master_port <vul-start> 0 ) { switch ( exp -> saved_proto. tcp. type ) { case TCP_CT_PORT_IPV4 : master_port = htons ( exp -> master. port ) ; if (! master_port ) { nf_ct_helper_log ( skb, exp -> master, \"invalid TCP port\" ) ; return NF_DROP ; } break ; default : <vul-start> -> master, \"invalid TCP port\" ) ; return NF_DROP ; } <vul-end> return NF_DROP ; <vul-start> NF_DROP ; } ct_priv = container_of ( exp -> master, ctinfo -> master ) ; ret = nf_nat_mangle_tcp_packet ( skb, master_port <vul-end>, ctinfo, <vul-start> NF_ACCEPT ) { goto out ; } out : <vul-end> nf_ct_unexpect_related ( exp\n"
 },
 {
  "id": 838,
  "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 int nfs3svc_decode_readargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readargs * args ) { unsigned int len ; int v ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; <vul-start> args -> count = ntohl ( * p ++ ) ; <vul-end> len = min ( args -> count , max_blocksize ) ; v = 0 ; while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; rqstp -> rq_vec [ v ] . iov_base = page_address ( p ) ; rqstp -> rq_vec [ v ] . iov_len = min_t ( unsigned int , len , PAGE_SIZE ) ; len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; } args -> vlen = v ; <vul-start> return xdr_argsize_check ( rqstp , p ) ; <vul-end> }",
  "golden_answers": [
   "CWE-404 Fixed Code Lines are: <vul-start> p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <vul-start> v ; return 1 <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> offset ) ; if (! xdr_argsize_check ( rqstp, p ) ) return 0 ; <vul-start> v ; return 1 <vul-end> ; }  \n"
 },
 {
  "id": 839,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == ' ' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( \"Too many operands\\\\n\" ) ; return false ; } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == ' ' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , \"lsl\" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , \"lsr\" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , \"asr\" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } <vul-start> if ( op -> operands [ operand",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> } if ( strlen ( token ) > 4 &&\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } if (! strncmp ( token, \"asr\", 3 ) ) { op -> operands [ operand ]. asr = ARM_ASR ; } if (\n"
 },
 {
  "id": 840,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void perf_swevent_overflow ( struct perf_event * event , u64 overflow , <vul-start> int nmi , struct perf_sample_data * data , <vul-end> struct pt_regs * regs ) { struct hw_perf_event * hwc = & event -> hw ; int throttle = 0 ; data -> period = event -> hw . last_period ; if ( ! overflow ) overflow = perf_swevent_set_period ( event ) ; if ( hwc -> interrupts == MAX_INTERRUPTS ) return ; for ( ; overflow ; overflow -- ) { <vul-start> if ( __perf_event_overflow ( event , nmi , throttle , <vul-end> data , regs ) ) { break ; } throttle = 1 ; } }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> u64 overflow , <vul-end> struct perf_sample_data * <vul-start> ( event , <vul-end> throttle , data\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> overflow, int <vul-end> throttle, struct <vul-start> ( event, <vul-end> throttle, data\n"
 },
 {
  "id": 841,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static INLINE void write_buffer_4x4 ( int16_t * output , __m128i * res ) { <vul-end> const __m128i kOne = _mm_set1_epi16 ( 1 ) ; __m128i in01 = _mm_unpacklo_epi64 ( res [ 0 ] , res [ 1 ] ) ; __m128i in23 = _mm_unpacklo_epi64 ( res [ 2 ] , res [ 3 ] ) ; __m128i out01 = _mm_add_epi16 ( in01 , kOne ) ; __m128i out23 = _mm_add_epi16 ( in23 , kOne ) ; out01 = _mm_srai_epi16 ( out01 , 2 ) ; out23 = _mm_srai_epi16 ( out23 , 2 ) ; <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 0 * 8 ) , out01 ) ; <vul-end> <vul-start> _mm_store_si128 ( ( __m128i * ) ( output + 1 * 8 ) , out23 ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> void write_buffer_4x4 ( tran_low_t <vul-end> * output , <vul-start> 2 ) ; store_output ( & out01 , <vul-end> ( output + <vul-start> * 8 ) ) ; store_output ( & out23 , <vul-end> ( output + <vul-start> * 8 ) <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void write_buffer_4x4 ( tran_low_t <vul-end> * output, <vul-start> 2 ) ; _mm_store_si <vul-end> ( ( __m128i <vul-start> out01 ) ; _mm_store_si <vul-end> ( ( __m128i\n"
 },
 {
  "id": 842,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void color_cmyk_to_rgb ( opj_image_t * image ) { float C , M , Y , K ; float sC , sM , sY , sK ; unsigned int w , h , max , i ; w = image -> comps [ 0 ] . w ; h = image -> comps [ 0 ] . h ; <vul-start> if ( image -> numcomps < 4 ) return ; <vul-end> max = w * h ; sC = 1.0F / ( float ) ( ( 1 << image -> comps [ 0 ] . prec ) - 1 ) ; sM = 1.0F / ( float ) ( ( 1 << image -> comps [ 1 ] . prec ) - 1 ) ; sY = 1.0F / ( float ) ( ( 1 << image -> comps [ 2 ] . prec ) - 1 ) ; sK = 1.0F / ( float ) ( ( 1 << image -> comps [ 3 ] . prec ) - 1 ) ; for ( i = 0 ; i < max ; ++ i ) { C = ( float ) ( image -> comps [ 0 ] . data [ i ] ) * sC ; M = ( float ) ( image -> comps [ 1 ] . data [ i ] ) * sM ; Y = ( float ) ( image -> comps [ 2 ] . data [ i ] ) * sY ; K = ( float ) ( image -> comps [ 3 ] . data [ i",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; if ( ( <vul-start> < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , \"%s:%d:color_cmyk_to_rgb\\\\n\\\\tCAN NOT CONVERT\\\\n\" , __FILE__ , __LINE__ ) ; return ; } <vul-end> max = w\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 4 ) return ; if ( w == 0 || h == 0 ) return\n"
 },
 {
  "id": 843,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int vp8_remove_decoder_instances ( struct frame_buffers * fb ) { if ( ! fb -> use_frame_threads ) { VP8D_COMP * pbi = fb -> pbi [ 0 ] ; if ( ! pbi ) return VPX_CODEC_ERROR ; # if CONFIG_MULTITHREAD <vul-start> if ( pbi -> b_multithreaded_rd ) <vul-end> vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ; vp8_decoder_remove_threads ( pbi ) ; # endif remove_decompressor ( pbi ) ; } else { } return VPX_CODEC_OK ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> # if CONFIG_MULTITHREAD <vul-end> vp8_decoder_remove_threads ( pbi\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ( pbi -> b_multithreaded_rd && pbi -> common. mb_rows > 0 <vul-end> ) vp8mt_de_alloc_temp_buffers (\n"
 },
 {
  "id": 844,
  "question": "CWE-494 Code Input Vulnerable Code Is: CWE-494 LONG ValidateSignature ( HWND hDlg , const char * path ) { LONG r ; WINTRUST_DATA trust_data = { 0 } ; WINTRUST_FILE_INFO trust_file = { 0 } ; GUID guid_generic_verify = { 0xaac56b , 0xcd44 , 0x11d0 , { 0x8c , 0xc2 , 0x0 , 0xc0 , 0x4f , 0xc2 , 0x95 , 0xee } } ; char * signature_name ; size_t i , len ; signature_name = GetSignatureName ( path ) ; if ( signature_name == NULL ) { uprintf ( \"PKI: Could not get signature name\" ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; return TRUST_E_NOSIGNATURE ; } for ( i = 0 ; i < ARRAYSIZE ( cert_name ) ; i ++ ) { len = strlen ( cert_name [ i ] ) ; if ( strncmp ( signature_name , cert_name [ i ] , len ) == 0 ) { if ( ( len >= strlen ( signature_name ) ) || isspace ( signature_name [ len ] ) ) break ; } } if ( i >= ARRAYSIZE ( cert_name ) ) { uprintf ( \"PKI: Signature \\'%s\\' is unexpected...\" , signature_name ) ; if ( MessageBoxExU ( hDlg , lmprintf ( MSG_285 , signature_name ) , lmprintf ( MSG_283 ) , MB_YESNO | MB_ICONWARNING | MB_IS_RTL , selected_langid ) != IDYES ) return TRUST_E_EXPLICIT_DISTRUST ; } trust_file . cbStruct = sizeof ( trust_file ) ; trust_file . pcwszFilePath = utf8_to_wchar ( path ) ; if ( trust_file . pcwszFilePath == NULL )",
  "golden_answers": [
   "CWE-494 Fixed Code Lines are: <vul-start> . dwUIChoice = WTD_UI_NONE <vul-end> ; trust_data . <vul-start> pcwszFilePath ) ; switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( \"PKI: File does not appear to be signed: %s\" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( \"PKI: Failed to validate signature: %s\" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; }\n"
  ],
  "generated_answer": "CWE-494 Fixed Code Lines are: <vul-start> ; trust_data. <vul-end> fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN <vul-start> pcwszFilePath ) ; safe_free ( trust_file. pcwszFilePath ) ;\n"
 },
 {
  "id": 845,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; int iskew = imagew - tilew ; uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <vul-start> for ( col = 0 ; col < imagewidth ; col += tw ) { <vul-end> if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , \"Error, can\\'t read tile at %lu %lu\" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf ,",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> col < imagewidth && colb < imagew\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> uint32 col ; if ( nrow > 0 && row < imagelength ) { TIFFError ( TIFFFileName ( in ), \"Error, can only read %u tiles\", ( unsigned long ) row ) ; status = 0 ; goto done ; }\n"
 },
 {
  "id": 846,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 void formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = ' ' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> { if ( l == NULL ) break ; if (\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( rows > c_rows <vul-end> ) { pos\n"
 },
 {
  "id": 847,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; void * pvReturn = NULL ; configASSERT ( pxEnd ) ; vTaskSuspendAll ( ) ; { if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) { <vul-start> if ( xWantedSize > 0 ) <vul-end> { xWantedSize += xHeapStructSize ; if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 ) { <vul-start> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; <vul-end> } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != pxEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + xHeapStructSize ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> xBlockSize = xWantedSize ; prvInsertBlockIntoFreeList ( ( pxNewBlockLink ) ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } xFreeBytesRemaining -= pxBlock -> xBlockSize ; if ( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining ) {",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { if ( ( <vul-start> > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) ) <vul-start> 0x00 ) { if ( ( xWantedSize + <vul-end> ( portBYTE_ALIGNMENT - <vul-start> portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; } else { xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <vul-end> ; } if\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( ( <vul-start> xWantedSize > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) <vul-start> 0x00 ) { if ( ( xWantedSize + <vul-end> ( portBYTE_ALIGNMENT - <vul-start> portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )\n"
 },
 {
  "id": 848,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u2_cur_mb_addr != 0 ) && ( ps_dec -> u4_first_slice_in_pic != 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( \"SH: first_mb_in_slice\" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( \"SH: slice_type\" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } {",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> pv_parse_tu_coeff_data ; } <vul-end> if ( u1_slice_type\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> } ps_dec -> <vul-end> if ( u1_slice_type\n"
 },
 {
  "id": 849,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int mov_read_dref ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) { AVStream * st ; MOVStreamContext * sc ; int entries , i , j ; if ( c -> fc -> nb_streams < 1 ) return 0 ; st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; sc = st -> priv_data ; avio_rb32 ( pb ) ; entries = avio_rb32 ( pb ) ; if ( entries >= UINT_MAX / sizeof ( * sc -> drefs ) ) return AVERROR_INVALIDDATA ; av_free ( sc -> drefs ) ; <vul-start> sc -> drefs = av_mallocz ( entries * sizeof ( * sc -> drefs ) ) ; <vul-end> if ( ! sc -> drefs ) return AVERROR ( ENOMEM ) ; sc -> drefs_count = entries ; for ( i = 0 ; i < sc -> drefs_count ; i ++ ) { MOVDref * dref = & sc -> drefs [ i ] ; uint32_t size = avio_rb32 ( pb ) ; int64_t next = avio_tell ( pb ) + size - 4 ; if ( size < 12 ) return AVERROR_INVALIDDATA ; dref -> type = avio_rl32 ( pb ) ; avio_rb32 ( pb ) ; av_dlog ( c -> fc , \"type %.4s size %d\\\\n\" , ( char * ) & dref -> type , size ) ; if ( dref -> type == MKTAG ( 'a' , 'l' , 'i' , 's' ) && size > 150 ) { uint16_t volume_len , len ; int16_t type ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; sc -> drefs_count = 0 ; sc ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> drefs = av_malloc ( entries, <vul-end> sizeof ( *\n"
 },
 {
  "id": 850,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <vul-end> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ; } else { vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> tx_type , const tran_low_t <vul-end> * input ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> tx_type, const tran_low_t <vul-end> * input,\n"
 },
 {
  "id": 851,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd ) { VP8_COMMON * pc = & pbi -> common ; unsigned int i ; int j ; int filter_level = pc -> filter_level ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; if ( filter_level ) { <vul-start> vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; <vul-end> <vul-start> vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <vul-end> <vul-start> vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <vul-end> for ( j = 1 ; j < pc -> mb_rows ; j ++ ) { <vul-start> vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; <vul-end> <vul-start> vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <vul-end> <vul-start> vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <vul-end> } for ( j = 0 ; j < pc -> mb_rows ; j ++ ) { <vul-start> vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> filter_level ) { memset <vul-end> ( pbi -> <vul-start> 5 ) ; memset <vul-end> ( pbi -> <vul-start> 5 ) ; memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi -> <vul-start> 1 ) ; memset <vul-end> ( pbi -> <vul-start> 1 ) ; memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi -> <vul-start> 16 ) ; memset <vul-end> ( pbi -> <vul-start> 8 ) ; memset <vul-end> ( pbi ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> filter_level ) { memset <vul-end> ( pbi -> <vul-start> 5 ) ; memset <vul-end> ( pbi -> <vul-start> 5 ) ; memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi -> <vul-start> 1 ) ; memset <vul-end> ( pbi -> <vul-start> 1 ) ; memset <vul-end> ( pbi -> <vul-start> ++ ) { memset <vul-end> ( pbi ->\n"
 },
 {
  "id": 852,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int misaligned_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <vul-start> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <vul-end> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } switch ( width_shift ) { case 1 : * ( __u16 * ) & buffer = ( __u16 ) regs -> regs [ srcreg ] ; break ; case 2 : * ( __u32 * ) & buffer = ( __u32 ) regs -> regs [ srcreg ] ; break ; case 3 : buffer = regs -> regs [ srcreg ] ; break ; default : printk ( \"Unexpected width_shift %d in misaligned_store, PC=%08lx\\\\n\" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } } else { __u64 val = regs -> regs [ srcreg ] ; switch ( width_shift ) { case 1 : misaligned_kernel_word_store ( address , val ) ; break",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, address\n"
 },
 {
  "id": 853,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static inline int object_common2 ( UNSERIALIZE_PARAMETER , long elements ) { zval * retval_ptr = NULL ; zval fname ; if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_OBJPROP_PP ( rval ) , elements , 1 ) ) { if ( Z_TYPE_PP ( rval ) == IS_OBJECT ) { zend_hash_clean ( Z_OBJPROP_PP ( rval ) ) ; <vul-start> } <vul-end> ZVAL_NULL ( * rval ) ; return 0 ; } if ( Z_TYPE_PP ( rval ) != IS_OBJECT ) { return 0 ; } if ( Z_OBJCE_PP ( rval ) != PHP_IC_ENTRY && zend_hash_exists ( & Z_OBJCE_PP ( rval ) -> function_table , \"__wakeup\" , sizeof ( \"__wakeup\" ) ) ) { INIT_PZVAL ( & fname ) ; ZVAL_STRINGL ( & fname , \"__wakeup\" , sizeof ( \"__wakeup\" ) - 1 , 0 ) ; BG ( serialize_lock ) ++ ; call_user_function_ex ( CG ( function_table ) , rval , & fname , & retval_ptr , 0 , 0 , 1 , NULL TSRMLS_CC ) ; BG ( serialize_lock ) -- ; } if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; <vul-end> ZVAL_NULL ( *\n"
 },
 {
  "id": 854,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int yyparse ( void * yyscanner , YR_COMPILER * compiler ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , \"Starting parse\\\\n\" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( \"memory exhausted\" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; break ; default : assert ( FALSE ) ; <vul-start> } # line 2371 <vul-end> \"grammar.c\" break ; <vul-start> : # line 834 <vul-end> \"grammar.y\" { if <vul-start> ; break ; default : assert ( FALSE ) ; <vul-start> } # line 2409 <vul-end> \"grammar.c\" break ; <vul-start> : # line 872 <vul-end> \"grammar.y\" { SIZED_STRING <vul-start> } # line 2455 <vul-end> \"grammar.c\" break ; <vul-start> : # line 918 <vul-end> \"grammar.y\" { if <vul-start> } # line 2478 <vul-end> \"grammar.c\" break ; <vul-start> : # line 940 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 2491 <vul-end> \"grammar.c\" break ; <vul-start> : # line 949 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 2504 <vul-end> \"grammar.c\" break ; <vul-start> : # line 958 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 2523 <vul-end> \"grammar.c\" break ; <vul-start> : # line 973 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 2539 <vul-end> \"grammar.c\" break ; <vul-start> : # line 985 <vul-end> \"grammar.y\" { int <vul-start> } # line 2557 <vul-end> \"grammar.c\" break ; <vul-start> : # line 999 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 2574 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1012 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 2589 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1023 <vul-end> \"grammar.y\" { if <vul-start> NULL ; } YYERROR ; } # line 2603 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1033 <vul-end> \"grammar.y\" { int <vul-start> } # line 2637 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1063 <vul-end> \"grammar.y\" { int <vul-start> } # line 2676 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1098 <vul-end> \"grammar.y\" { int <vul-start> } # line 2759 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1177 <vul-end> \"grammar.y\" { int <vul-start> } # line 2793 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1207 <vul-end> \"grammar.y\" { int <vul-start> } # line 2846 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1256 <vul-end> \"grammar.y\" { yr_parser_emit <vul-start> } # line 2856 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1262 <vul-end> \"grammar.y\" { yr_parser_emit <vul-start> } # line 2866 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1268 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 2896 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1294 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 2936 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1330 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 2965 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1355 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 3005 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1391 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3018 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1400 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3031 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1409 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3044 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1418 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3057 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1427 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3070 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1436 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3083 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1445 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3091 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1449 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3099 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1456 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3105 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1457 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3111 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1463 <vul-end> \"grammar.y\" { if <vul-start> } # line 3133 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1485 <vul-end> \"grammar.y\" { if <vul-start> } # line 3149 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1497 <vul-end> \"grammar.y\" { if <vul-start> } # line 3164 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1512 <vul-end> \"grammar.y\" { yr_parser_emit_with_arg <vul-start> } # line 3173 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1518 <vul-end> \"grammar.y\" { yr_parser_emit_with_arg <vul-start> } # line 3184 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1535 <vul-end> \"grammar.y\" { yr_parser_emit_pushes_for_strings <vul-start> } # line 3195 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1542 <vul-end> \"grammar.y\" { yr_parser_emit_pushes_for_strings <vul-start> } # line 3206 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1554 <vul-end> \"grammar.y\" { yr_parser_emit_with_arg <vul-start> } # line 3214 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1558 <vul-end> \"grammar.y\" { yr_parser_emit_with_arg <vul-start> } # line 3222 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1566 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3230 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1570 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3244 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1580 <vul-end> \"grammar.y\" { yywarning <vul-start> } # line 3262 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1594 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3282 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1610 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3296 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1620 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3309 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1629 <vul-end> \"grammar.y\" { SIZED_STRING <vul-start> } # line 3338 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1654 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3354 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1666 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3370 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1678 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3390 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1694 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3406 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1706 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3426 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1722 <vul-end> \"grammar.y\" { if <vul-start> } # line 3475 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1767 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3498 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1786 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3520 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1804 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3542 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1822 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3564 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1840 <vul-end> \"grammar.y\" { compiler <vul-start> } # line 3594 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1866 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3616 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1884 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3630 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1894 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3644 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1904 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3658 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1914 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3672 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1924 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3686 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1934 <vul-end> \"grammar.y\" { CHECK_TYPE <vul-start> } # line 3700 <vul-end> \"grammar.c\" break ; <vul-start> : # line 1944 <vul-end> \"grammar.y\" { ( <vul-start> } # line 3708 <vul-end> \"grammar.c\" break ; <vul-start> ; # line 3712 <vul-end> \"grammar.c\" default :\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; # line 2594 <vul-end> \"grammar.c\" break ; <vul-start> : # line 837 <vul-end> \"grammar.c\" break ; <vul-start> } # line 2594 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2447 <vul-end> \"grammar.y\" { int <vul-start> } # line 2667 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { int <vul-start> } # line 2887 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { int <vul-start> } # line 2887 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { int <vul-start> } # line 2887 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { int <vul-start> } # line 2887 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { yr_parser_reduce_rule_declaration_phase_3 ( yyscanner, rule ) ; yr_free ( ( yyvsp [ - 3 ]. c_string ) ) ; ( yyval. rule ) = rule ; } # line 2887 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { yr_parser_reduce_rule_declaration_phase_4 ( <vul-start> } # line 2887 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 2887 <vul-end> \"grammar.c\" break ; case 70 : # line 2887 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 2887 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } # line 2887 <vul-end> \"grammar.c\" break ; <vul-start> : # line 2887 <vul-end> \"grammar.y\" { YR_FIXUP <vul-start> } #"
 },
 {
  "id": 855,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\\\0' ; count = ( ssize_t ) sscanf ( text +",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , \"UnexpectedEndOfFile\" , image -> filename ) ; break ; }\n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> ; } } if ( EOFBlob ( image )!= MagickFalse ) { ThrowFileException ( exception, CorruptImageError, \"UnexpectedEndOfFile\", image -> filename ) ; break ; }\n"
 },
 {
  "id": 856,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static ssize_t o2nm_node_num_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <vul-start> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <vul-end> unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\\\n' ) ) ) return - EINVAL ; if ( tmp >= O2NM_MAX_NODES ) return - ERANGE ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <vul-start> write_lock ( & cluster -> cl_nodes_lock ) ; <vul-end> if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { cluster -> cl_nodes [ tmp ] = node ; node -> nd_num = tmp ; set_bit ( tmp , cluster -> cl_nodes_bitmap ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; <vul-start> if ( ret ) <vul-end> return ret ; return count ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> o2nm_cluster * cluster <vul-end> ; unsigned long <vul-start> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <vul-start> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> o2nm_cluster * cluster <vul-end> ; unsigned long <vul-start> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if (! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <vul-start> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;\n"
 },
 {
  "id": 857,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_init_mv_probs ( VP9_COMMON * cm ) { <vul-start> cm -> fc . nmvc = default_nmv_context ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> cm -> fc -> <vul-end> nmvc = default_nmv_context\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> cm ) { <vul-end> }    \n"
 },
 {
  "id": 858,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static bool check_client_passwd ( PgSocket * client , const char * passwd ) { char md5 [ MD5_PASSWD_LEN + 1 ] ; const char * correct ; PgUser * user = client -> auth_user ; <vul-start> if ( ! * passwd || ! * user -> passwd ) <vul-end> return false ; switch ( cf_auth_type ) { case AUTH_PLAIN : return strcmp ( user -> passwd , passwd ) == 0 ; case AUTH_CRYPT : correct = crypt ( user -> passwd , ( char * ) client -> tmp_login_salt ) ; return correct && strcmp ( correct , passwd ) == 0 ; case AUTH_MD5 : if ( strlen ( passwd ) != MD5_PASSWD_LEN ) return false ; if ( ! isMD5 ( user -> passwd ) ) pg_md5_encrypt ( user -> passwd , user -> name , strlen ( user -> name ) , user -> passwd ) ; pg_md5_encrypt ( user -> passwd + 3 , ( char * ) client -> tmp_login_salt , 4 , md5 ) ; return strcmp ( md5 , passwd ) == 0 ; } return false ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> if ( ! user ) { slog_error ( client , \"Password packet before auth packet?\" ) ; return false ; } if ( !\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> user -> passwd ) return false ; if ( strlen ( passwd )!= MD5_PASSWD_LEN\n"
 },
 {
  "id": 859,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , * header ; size_t cb1_len , cb2_len , alloc_len ; unsigned char * cb1 , * cb2 ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = json_array_string ( val , 5 ) ; nbit = json_array_string ( val , 6 ) ; ntime = json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { if ( job_id ) free ( job_id ) ; if ( prev_hash ) free ( prev_hash ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; if ( bbversion ) free ( bbversion ) ; if ( nbit ) free ( nbit ) ; if ( ntime ) free ( ntime ) ; goto out ;",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ) ) ) { applog ( LOG_WARNING , \"%s: Failed to convert header to header_bin, got %s\" , __func__ , header ) ; pool_failed ( pool ) ; return false ; } <vul-end> cb1 = (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 128 ) ) { if ( clean ) json_decref ( arr ) ; <vul-start> \"Failed to convert header to header_bin in parse_notify\" ) ; }\n"
 },
 {
  "id": 860,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int build_ntlmssp_auth_blob ( unsigned char * * pbuffer , u16 * buflen , struct cifs_ses * ses , const struct nls_table * nls_cp ) { int rc ; AUTHENTICATE_MESSAGE * sec_blob ; __u32 flags ; unsigned char * tmp ; rc = setup_ntlmv2_rsp ( ses , nls_cp ) ; if ( rc ) { cifs_dbg ( VFS , \"Error %d during NTLMSSP authentication\\\\n\" , rc ) ; * buflen = 0 ; goto setup_ntlmv2_ret ; } * pbuffer = kmalloc ( size_of_ntlmssp_blob ( ses ) , GFP_KERNEL ) ; sec_blob = ( AUTHENTICATE_MESSAGE * ) * pbuffer ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmAuthenticate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | <vul-start> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC ; <vul-end> <vul-start> if ( ses -> server -> sign ) { <vul-end> flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-start> } <vul-end> tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ; sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> LmChallengeResponse . BufferOffset = cpu_to_le32 ( sizeof ( AUTHENTICATE_MESSAGE ) ) ; sec_blob -> LmChallengeResponse . Length = 0 ; sec_blob -> LmChallengeResponse . MaximumLength = 0 ; sec_blob -> NtChallengeResponse . BufferOffset = cpu_to_le32 ( tmp - * pbuffer ) ; if ( ses -> user_name != NULL ) { memcpy ( tmp , ses -> auth_key . response + CIFS_SESS_KEY_SIZE , ses -> auth_key . len - CIFS_SESS_KEY_SIZE ) ; tmp +=",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <vul-start> -> sign ) <vul-end> flags |= NTLMSSP_NEGOTIATE_SIGN <vul-start> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <vul-end> tmp = *\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM <vul-end> ; if ( <vul-start> -> server -> ntlmssp -> <vul-start> |= NTLMSSP_NEGOTIATE_KEY_XCH ; if ( ses -> server -> sign ) flags |= NTLMSSP_NEGOTIATE_SIGN ;\n"
 },
 {
  "id": 861,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <vul-start> if ( roishift == 0 && bgshift == 0 ) { <vul-end> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <vul-start> mask = ( 1 << numbps ) - 1 ; <vul-end> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( \"warning: possibly corrupt code stream\\\\n\" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> if ( roishift < 0 ) { jas_eprintf ( \"warning: forcing negative ROI shift to zero \" \"(bitstream is probably corrupt)\\\\n\" ) ; roishift = 0 ; } if ( roishift <vul-start> mask = ( JAS_CAST ( uint_fast32_t , 1 ) <vul-end> << numbps )\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> uint_fast32_t mask ; jas_matind_t tmp ; <vul-start> <<= bgshift ; tmp = ( jas_matind_t ) ( mag & 1 ) ; mag = JAS_ABS ( tmp ) ; <vul-start> mask = ( tmp <vul-end> << numbps )\n"
 },
 {
  "id": 862,
  "question": "CWE-354 Code Input Vulnerable Code Is: CWE-354 void next_character ( void ) <vul-start> { <vul-end> strlcpy ( cipher , english_alphabet , ENGLISH_ALPHABET_BUF ) ; random_permute_char ( cipher , strlen ( cipher ) ) ; static char CONFIDENTIAL current_word [ CURRENT_WORD_BUF ] ; get_current_word ( current_word ) ; if ( strlen ( current_word ) > 4 ) { memzero ( current_word , sizeof ( current_word ) ) ; recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_SyntaxError , \"Words were not entered correctly. Make sure you are using the substition cipher.\" ) ; layoutHome ( ) ; return ; } CharacterRequest resp ; memset ( & resp , 0 , sizeof ( CharacterRequest ) ) ; resp . word_pos = get_current_word_pos ( ) ; resp . character_pos = strlen ( current_word ) ; msg_write ( MessageType_MessageType_CharacterRequest , & resp ) ; bool auto_completed = false ; if ( strlen ( current_word ) >= 3 ) { auto_completed = attempt_auto_complete ( current_word ) ; } # if DEBUG_LINK if ( auto_completed ) { strlcpy ( auto_completed_word , current_word , CURRENT_WORD_BUF ) ; } else { auto_completed_word [ 0 ] = '\\\\0' ; } # endif format_current_word ( current_word , auto_completed ) ; layout_cipher ( current_word , cipher ) ; memzero ( current_word , sizeof ( current_word ) ) ; }",
  "golden_answers": [
   "CWE-354 Fixed Code Lines are: <vul-start> void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , \"Not in Recovery mode\" ) ; layoutHome ( ) ; return ; }\n"
  ],
  "generated_answer": "CWE-354 Fixed Code Lines are: <vul-start> void ) { if ( recovery_abort ( ) ) fsm_sendFailure ( FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\" ) ; layoutHome ( ) ;\n"
 },
 {
  "id": 863,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 struct _mdi * _WM_ParseNewMus ( uint8_t * mus_data , uint32_t mus_size ) { uint8_t mus_hdr [ ] = { 'M' , 'U' , 'S' , 0x1A } ; uint32_t mus_song_ofs = 0 ; uint32_t mus_song_len = 0 ; uint16_t mus_ch_cnt1 = 0 ; uint16_t mus_ch_cnt2 = 0 ; uint16_t mus_no_instr = 0 ; uint32_t mus_data_ofs = 0 ; uint16_t * mus_mid_instr = NULL ; uint16_t mus_instr_cnt = 0 ; struct _mdi * mus_mdi ; uint32_t mus_divisions = 60 ; float tempo_f = 0.0 ; uint16_t mus_freq = 0 ; float samples_per_tick_f = 0.0 ; <vul-start> uint8_t mus_event [ ] = { 0 , 0 , 0 , 0 } ; <vul-end> uint8_t mus_event_size = 0 ; uint8_t mus_prev_vol [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; uint32_t setup_ret = 0 ; uint32_t mus_ticks = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint16_t pitchbend_tmp = 0 ; if ( mus_size < 17 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , \"File too short\" , 0 ) ; return NULL ; } if ( memcmp ( mus_data , mus_hdr , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MUS , NULL , 0 ) ; return NULL ; } mus_song_len = ( mus_data [ 5 ] << 8 ) | mus_data [ 4 ] ; mus_song_ofs = ( mus_data [ 7 ] << 8",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> = 0.0 ; # define MUS_SZ 4 <vul-start> uint8_t mus_event [ MUS_SZ <vul-start> * ) mus_event , MUS_SZ\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = 0.0 ; float sample_count_f = 0.0 ; float samples_per_tick_f = 0.0 ; <vul-start> 0 ) ; sample_count_f = mus_data [ mus_data_ofs ] ; <vul-start> 2 ] = sample_count_f? <vul-start> [ 2 ] : 0 ; sample_count_f = mus_data [ mus_data_ofs + 1 ] <vul-start> ; mus_event_size = 4 <vul-end> + ( mus_data_ofs <vul-start> + 1 ] + sample_count_f <vul-start> ; mus_event [ 3 ] = 0 ; break ; case 4 + 1 : mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs + 1 ] & 0x0f ) ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 5 : mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs + 1 ] & 0x0f ) ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 5 : mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs + 2 ] & 0x0f ) ; mus_event [ <vul-start> [ 3 ] = 0 ; break ; case 6 : mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs + 1 ] & 0x0f ) ; mus_event [ 2 ] = mus_data [ mus_data_ofs + 2 ] ; mus_event [ 3 ] = 0 ; break ; case 7 : mus_event [ 0 ] = 0x90 | ( mus_data [ mus_data_ofs + 1 ] & 0x0f ) ; mus_event [ 1 ] = 0x0a"
 },
 {
  "id": 864,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { <vul-start> void * dllhandle ; <vul-end> if ( useSystemLib ) Com_Printf ( \"Trying to load \\\\\"%s\\\\\"...\\\\n\" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = \".\" ; Com_Printf ( \"Trying to load \\\\\"%s\\\\\" from \\\\\"%s\\\\\"...\\\\n\" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , \"%s%c%s\" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( \"fs_basepath\" ) ; if ( ! basePath || ! * basePath ) basePath = \".\" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( \"Trying to load \\\\\"%s\\\\\" from \\\\\"%s\\\\\"...\\\\n\" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , \"%s%c%s\" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( \"Loading \\\\\"%s\\\\\" failed\\\\n\" , name ) ; } } return dllhandle ; }",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> * dllhandle ; if ( COM_CompareExtension ( name , \".pk3\" ) ) { Com_Printf ( \"Rejecting DLL named \\\\\"%s\\\\\"\" , name ) ; return NULL ; }\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> void * dllhandle ; if (! COM_CompareExtension ( name, \".dll\" ) ) return NULL\n"
 },
 {
  "id": 865,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int f2fs_set_data_page_dirty ( struct page * page ) { <vul-start> struct address_space * mapping = page -> mapping ; <vul-end> <vul-start> struct inode * inode = mapping -> host ; <vul-end> trace_f2fs_set_page_dirty ( page , DATA ) ; if ( ! PageUptodate ( page ) ) <vul-start> SetPageUptodate ( page ) ; <vul-end> if ( f2fs_is_atomic_file ( inode ) && ! f2fs_is_commit_atomic_write ( inode ) ) { if ( ! IS_ATOMIC_WRITTEN_PAGE ( page ) ) { f2fs_register_inmem_page ( inode , page ) ; return 1 ; } return 0 ; } if ( ! PageDirty ( page ) ) { __set_page_dirty_nobuffers ( page ) ; f2fs_update_dirty_page ( inode , page ) ; return 1 ; } return 0 ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ) { struct <vul-end> inode * inode <vul-start> * inode = page_file_mapping ( page ) <vul-end> -> host ; <vul-start> ) ) SetPageUptodate ( page ) ; if ( PageSwapCache ( page ) ) return __set_page_dirty_nobuffers\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ) { struct inode * inode = page_file_mapping ( page ) <vul-end> ; struct inode <vul-start> * inode = page_inode ( page ) <vul-end> -> host ; <vul-start> SetPageUptodate ( page ) ; if (! PageSwapCache ( page ) && inode -> i_sb -> s_iflags & I_NOEXEC ) { f2fs_set_page_pfree ( page ) ; f2fs_update_dirty_page ( inode, page ) ; return 1 ; } if ( inode -> i_sb -> s_iflags & I_NOEXEC\n"
 },
 {
  "id": 866,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <vul-start> assert ( ( cc % ( bps * stride ) ) == 0 ) ; <vul-end> if ( ! tmp ) <vul-start> return ; <vul-end> _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> fpDiff ( TIFF <vul-start> cc ) ; if <vul-end> ( ( cc <vul-start> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"fpDiff\" , \"%s\" , \"(cc%(bps*stride))!=0\" ) ; return 0 ; } <vul-end> if ( ! <vul-start> tmp ) return 0 <vul-start> cp -- ) return 1 ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> fpDiff ( TIFF <vul-start> cc ) ; if <vul-end> ( ( cc <vul-start> stride ) )!= 0 ) { TIFFErrorExt ( tif -> tif_clientdata, \"fpDiff\", \"%s\", \"(cc%(bps*stride))!=0\" ) ; return 0 ; } <vul-end> if (! <vul-start> tmp ) return 0 <vul-start> cp -- ) return 0 ;\n"
 },
 {
  "id": 867,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <vul-end> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <vul-start> vpx_fixed_buf_t * stats ) { <vul-end> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , \"Failed to get frame stats.\" ) ; while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <vul-start> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <vul-end> const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ; const size_t pkt_size = pkt -> data . twopass_stats . sz ; stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ; memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ; stats -> sz += pkt_size ; } } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> get_frame_stats ( vpx_codec_ctx_t <vul-start> stats ) { int got_pkts = 0 ; <vul-start> NULL ) { got_pkts = 1 ; <vul-start> ; } } return got_pkts ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> get_frame_stats ( vpx_codec_ctx_t <vul-start> int deadline, vpx_fixed_buf_t * stats, int * pkt_out_of_size <vul-end> ) { vpx_codec_iter_t <vul-start> NULL ) { * pkt_out_of_size = <vul-end> pkt -> data <vul-start> -> data. stats_pkt_size ; if ( stats ) { * pkt_out_of_size = pkt -> data. stats_pkt_size <vul-end> ; } } <vul-start> ; } } return 0 ;\n"
 },
 {
  "id": 868,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int logi_dj_ll_raw_request ( struct hid_device * hid , unsigned char reportnum , __u8 * buf , size_t count , unsigned char report_type , int reqtype ) { struct dj_device * djdev = hid -> driver_data ; struct dj_receiver_dev * djrcv_dev = djdev -> dj_receiver_dev ; u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <vul-start> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <vul-end> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ; return ret ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> if ( count > <vul-end> DJREPORT_SHORT_LENGTH - 2\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> < DJREPORT_SHORT_LENGTH - 1 <vul-end> ) count =\n"
 },
 {
  "id": 869,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) { <vul-end> <vul-start> LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ; <vul-end> <vul-start> ( void ) arg2 ; <vul-end> <vul-start> vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd , <vul-end> lf_data -> start , lf_data -> stop , lf_data -> y_only ) ; return 1 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int vp9_loop_filter_worker ( <vul-end> LFWorkerData * const <vul-start> * const lf_data , void * unused ) { <vul-end> ( void ) <vul-start> ( void ) unused <vul-end> ; vp9_loop_filter_rows ( <vul-start> -> cm , lf_data -> planes <vul-end> , lf_data ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int vp9_loop_filter_worker ( ThreadData * td ) { int i ; for ( i = 0 ; i < lf_data -> frame_buffer -> number_rows ; ++ i ) { FrameData * const frame_data = ( FrameData <vul-end> * ) arg1 <vul-start> ) arg1 ; vpx_loop_filter_rows ( & frame_data -> frame_buffer [ i ] <vul-end>, lf_data -> <vul-start> lf_data -> xd -> plane [ i ]. src <vul-start> -> y_only ) ; } } <vul-end> return 1 ;\n"
 },
 {
  "id": 870,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int do_ip_vs_set_ctl ( struct sock * sk , int cmd , void __user * user , unsigned int len ) { int ret ; unsigned char arg [ MAX_ARG_LEN ] ; struct ip_vs_service_user * usvc_compat ; struct ip_vs_service_user_kern usvc ; struct ip_vs_service * svc ; struct ip_vs_dest_user * udest_compat ; struct ip_vs_dest_user_kern udest ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <vul-start> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { <vul-end> pr_err ( \"set_ctl: len %u != %u\\\\n\" , len , set_arglen [ SET_CMDID ( cmd ) ] ) ; return - EINVAL ; } if ( copy_from_user ( arg , user , len ) != 0 ) return - EFAULT ; ip_vs_use_count_inc ( ) ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) { ret = - ERESTARTSYS ; goto out_dec ; } if ( cmd == IP_VS_SO_SET_FLUSH ) { ret = ip_vs_flush ( ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_TIMEOUT ) { ret = ip_vs_set_timeout ( ( struct ip_vs_timeout_user * ) arg ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STARTDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = start_sync_thread ( dm -> state , dm -> mcast_ifn , dm -> syncid ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STOPDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = stop_sync_thread ( dm -> state ) ; goto out_unlock ; } usvc_compat = ( struct ip_vs_service_user",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> - EPERM ; arg [ 0 ] = 0 ;\n"
 },
 {
  "id": 871,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int32 makepol ( QPRS_STATE * state ) { int32 val = 0 , type ; int32 lenval = 0 ; char * strval = NULL ; int32 stack [ STACKDEPTH ] ; int32 lenstack = 0 ; uint16 flag = 0 ; <vul-start> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <vul-end> { switch ( type ) { case VAL : pushval_asis ( state , VAL , strval , lenval , flag ) ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case OPR : if ( lenstack && val == ( int32 ) '|' ) pushquery ( state , OPR , val , 0 , 0 , 0 ) ; else { if ( lenstack == STACKDEPTH ) elog ( ERROR , \"stack too short\" ) ; stack [ lenstack ] = val ; lenstack ++ ; } break ; case OPEN : if ( makepol ( state ) == ERR ) return ERR ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ]",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> = 0 ; check_stack_depth ( ) ;\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> = 0 ; int32 flag2 = 0 ; <vul-start> END ) { if ( lenval > 0 && flag2 == 0 ) flag2 = 1 ;\n"
 },
 {
  "id": 872,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 void process_bitmap_updates ( STREAM s ) { <vul-start> uint16 num_updates ; <vul-end> uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ; <vul-start> logger ( Protocol , Debug , \"%s()\" , __func__ ) ; <vul-end> in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) { <vul-start> in_uint16_le ( s , left ) ; <vul-end> in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , \"process_bitmap_updates(), [%d,%d,%d,%d], [%d,%d], bpp=%d, compression=%d\" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> s ) { <vul-end> int i ; <vul-start> int i ; uint16 num_updates <vul-end> ; in_uint16_le ( <vul-start> ++ ) { process_bitmap_data ( s <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> s ) { int num_updates ; uint16 <vul-end> left, top <vul-start> int i ; struct stream packet = * s ; <vul-start> ++ ) { if (! s_check ( s ) ) { rdp_protocol_error ( \"process_bitmap_updates(), consume of bitmap data from stream would overrun\", & packet ) ; }\n"
 },
 {
  "id": 873,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static expr_ty ast_for_call ( struct compiling * c , const node * n , expr_ty func ) { int i , nargs , nkeywords , ngens ; asdl_seq * args ; asdl_seq * keywords ; expr_ty vararg = NULL , kwarg = NULL ; REQ ( n , arglist ) ; nargs = 0 ; nkeywords = 0 ; ngens = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node * ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == argument ) { if ( NCH ( ch ) == 1 ) nargs ++ ; else if ( TYPE ( CHILD ( ch , 1 ) ) == comp_for ) ngens ++ ; else nkeywords ++ ; } } if ( ngens > 1 || ( ngens && ( nargs || nkeywords ) ) ) { ast_error ( n , \"Generator expression must be parenthesized \" \"if not sole argument\" ) ; return NULL ; } if ( nargs + nkeywords + ngens > 255 ) { ast_error ( n , \"more than 255 arguments\" ) ; return NULL ; } args = asdl_seq_new ( nargs + ngens , c -> c_arena ) ; if ( ! args ) return NULL ; keywords = asdl_seq_new ( nkeywords , c -> c_arena ) ; if ( ! keywords ) return NULL ; nargs = 0 ; nkeywords = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { node",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> int k ; const\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> char * tmp ; if ( TYPE ( CHILD ( n, 0 ) ) == func_body_suite ) return NULL\n"
 },
 {
  "id": 874,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void de_dotdot ( char * file ) { char * cp ; char * cp2 ; int l ; while ( ( cp = strstr ( file , \"//\" ) ) != ( char * ) 0 ) { for ( cp2 = cp + 2 ; * cp2 == '/' ; ++ cp2 ) continue ; ( void ) strcpy ( cp + 1 , cp2 ) ; } while ( strncmp ( file , \"./\" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , \"/./\" ) ) != ( char * ) 0 ) <vul-start> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <vul-end> for ( ; ; ) { while ( strncmp ( file , \"../\" , 3 ) == 0 ) ( void ) memmove ( file , file + 3 , strlen ( file ) - 2 ) ; cp = strstr ( file , \"/../\" ) ; if ( cp == ( char * ) 0 ) break ; for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; ( void ) strcpy ( cp2 + 1 , cp + 4 ) ; } while ( ( l = strlen ( file ) ) > 3 && strcmp ( ( cp = file + l - 3 ) , \"/..\"",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , strlen ( cp <vul-end> ) - 1\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) - 1 ) ; while ( ( cp = strstr ( file, \"/../\" ) )!= ( char * ) 0 ) { for ( cp2 = cp - 1 ; cp2 >= file && * cp2!= '/' ; ++ cp2 ) continue ; ( void ) memmove ( cp2 + 1, cp + 2, strlen ( cp2 )\n"
 },
 {
  "id": 875,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 SPL_METHOD ( Array , unserialize ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; char * buf ; int buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval * pmembers , * pflags = NULL ; HashTable * aht ; long flags ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s\" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } aht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; if ( aht -> nApplyCount > 0 ) { zend_error ( E_WARNING , \"Modification of ArrayObject during sorting is prohibited\" ) ; return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; ALLOC_INIT_ZVAL ( pflags ) ; if ( ! php_var_unserialize ( & pflags , & p , s + buf_len , & var_hash TSRMLS_CC ) || Z_TYPE_P ( pflags ) != IS_LONG ) { goto outexcept ; } var_push_dtor ( & var_hash , & pflags ) ; -- p ; flags = Z_LVAL_P ( pflags ) ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' ) { if ( * p != 'a' && * p != 'O' && * p != 'C' && * p != 'r'",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <vul-end> goto outexcept ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, & var_hash, 0\n"
 },
 {
  "id": 876,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 int pci_emul_alloc_pbar ( struct pci_vdev * pdi , int idx , uint64_t hostbase , enum pcibar_type type , uint64_t size ) { int error ; uint64_t * baseptr , limit , addr , mask , lobits , bar ; <vul-start> assert ( idx >= 0 && idx <= PCI_BARMAX ) ; <vul-end> if ( ( size & ( size - 1 ) ) != 0 ) size = 1UL << flsl ( size ) ; if ( type == PCIBAR_IO ) { if ( size < 4 ) size = 4 ; } else { if ( size < 16 ) size = 16 ; } switch ( type ) { case PCIBAR_NONE : baseptr = NULL ; addr = mask = lobits = 0 ; break ; case PCIBAR_IO : baseptr = & pci_emul_iobase ; limit = PCI_EMUL_IOLIMIT ; mask = PCIM_BAR_IO_BASE ; lobits = PCIM_BAR_IO_SPACE ; break ; <vul-start> case PCIBAR_MEM64 : <vul-end> if ( ! skip_pci_mem64bar_workaround && ( size <= 32 * 1024 * 1024 ) ) { baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 ; break ; } if ( size == 0x100000000UL ) baseptr = & hostbase ; else baseptr = & pci_emul_membase64 ; limit = PCI_EMUL_MEMLIMIT64 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH ; break ; case PCIBAR_MEM32 : baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_BASE ; lobits = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32 ; break ; default : <vul-start> printf ( \"%s: invalid bar type %d\\\\n\" , __func__ ,",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> , bar ; <vul-end> if ( ( <vul-start> case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) { pr_err ( \"%s: invalid bar number %d for MEM64 type\\\\n\" , __func__ , idx ) ; return - 1 ; } <vul-start> ; default : pr_err <vul-end> ( \"%s: invalid bar type %d\\\\n\" , <vul-start> type ) ; return - 1 <vul-end> ; } if <vul-start> PCIBAR_MEM64 ) { <vul-end> pdi -> bar\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start>, bar ; if ( idx > PCI_BARMAX ) return - EINVAL <vul-end> ; if ( <vul-start> break ; case PCIBAR_MEM32 : baseptr = & pci_emul_membase32 ; limit = PCI_EMUL_MEMLIMIT32 ; mask = PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32 ; break ; case <vul-start> ; default : pr_err ( \"%s: invalid bar type %d\\\\n\" <vul-end>, __func__, <vul-start> type ) ; return - EINVAL <vul-end> ; } if <vul-start> PCIBAR_MEM64 ) { if <vul-end> ( idx + <vul-start> <= PCI_BARMAX ) <vul-end> pdi -> bar\n"
 },
 {
  "id": 877,
  "question": "CWE-667 Code Input Vulnerable Code Is: CWE-667 static void * gp_worker_main ( void * pvt ) { struct gp_thread * t = ( struct gp_thread * ) pvt ; struct gp_query * q = NULL ; char dummy = 0 ; int ret ; while ( ! t -> pool -> shutdown ) { gp_debug_set_conn_id ( 0 ) ; pthread_mutex_lock ( & t -> cond_mutex ) ; while ( t -> query == NULL ) { pthread_cond_wait ( & t -> cond_wakeup , & t -> cond_mutex ) ; <vul-start> if ( t -> pool -> shutdown ) { <vul-end> pthread_exit ( NULL ) ; } } q = t -> query ; t -> query = NULL ; pthread_mutex_unlock ( & t -> cond_mutex ) ; gp_debug_set_conn_id ( gp_conn_get_cid ( q -> conn ) ) ; GPDEBUGN ( 3 , \"[status] Handling query input: %p (%zu)\\\\n\" , q -> buffer , q -> buflen ) ; gp_handle_query ( t -> pool , q ) ; GPDEBUGN ( 3 , \"[status] Handling query output: %p (%zu)\\\\n\" , q -> buffer , q -> buflen ) ; pthread_mutex_lock ( & t -> pool -> lock ) ; q -> next = t -> pool -> reply_list ; t -> pool -> reply_list = q ; if ( ! t -> pool -> shutdown ) { LIST_DEL ( t -> pool -> busy_list , t ) ; LIST_ADD ( t -> pool -> free_list , t ) ; } pthread_mutex_unlock ( & t -> pool -> lock ) ; ret = write ( t -> pool -> sig_pipe [ 1 ] , & dummy",
  "golden_answers": [
   "CWE-667 Fixed Code Lines are: <vul-start> shutdown ) { pthread_mutex_unlock ( & t -> cond_mutex ) ;\n"
  ],
  "generated_answer": "CWE-667 Fixed Code Lines are: <vul-start> -> shutdown ) break ; <vul-end> } q =\n"
 },
 {
  "id": 878,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int usbip_recv_xbuff ( struct usbip_device * ud , struct urb * urb ) { int ret ; int size ; if ( ud -> side == USBIP_STUB ) { if ( usb_pipein ( urb -> pipe ) ) return 0 ; size = urb -> transfer_buffer_length ; } else { if ( usb_pipeout ( urb -> pipe ) ) return 0 ; size = urb -> actual_length ; } if ( ! ( size > 0 ) ) return 0 ; <vul-start> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <vul-end> if ( ret != size ) { dev_err ( & urb -> dev -> dev , \"recv xbuf, %d\\\\n\" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; <vul-start> } else { <vul-end> usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } } <vul-start> return ret ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> return 0 ; if ( size > urb -> transfer_buffer_length ) { <vul-end> if ( ud <vul-start> SDEV_EVENT_ERROR_TCP ) ; return 0 ; <vul-start> ; } } ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , \"recv xbuf, %d\\\\n\" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> return 0 ; if ( size < 0 ) { dev_err ( & urb -> dev -> dev, \"recv xbuf size < 0\\\\n\" ) ; return - EINVAL ; } <vul-start> SDEV_EVENT_ERROR_TCP ) ; return ret ; <vul-start> ; } } if ( ret == 0 ) return ret ;\n"
 },
 {
  "id": 879,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags , unsigned int allocated , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = ext4_inode_aio ( inode ) ; ext_debug ( \"ext4_ext_handle_uninitialized_extents: inode %lu, logical \" \"block %llu, max_blocks %u, flags %x, allocated %u\\\\n\" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; trace_ext4_ext_handle_uninitialized_extents ( inode , map , allocated , newblock ) ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) { ret = ext4_split_unwritten_extents ( handle , inode , map , path , flags ) ; if ( ret <= 0 ) goto out ; if ( io ) ext4_set_io_unwritten_flag ( inode , io ) ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) map -> m_flags |= EXT4_MAP_UNINIT ; goto out ; } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) { <vul-start> ret = ext4_convert_unwritten_extents_endio ( handle , inode , <vul-end> path ) ; if ( ret >= 0 ) { ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; err = check_eofblocks_fl ( handle , inode , map -> m_lblk , path , map -> m_len ) ; } else err = ret ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) {",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> , inode , map ,\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) ) { if ( map -> m_flags & EXT4_MAP_NEW &&! ( map -> m_flags & EXT4_MAP_UNINIT ) &&! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) &&! IS_NOQUOTA ( inode ) && ext4_should_dioread_nolock ( inode ) ) { err = ext4_jbd2_file_inode ( handle, inode ) ; if ( err ) goto out2 ; }\n"
 },
 {
  "id": 880,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 av_cold void ff_mpv_idct_init ( MpegEncContext * s ) <vul-start> { <vul-end> ff_idctdsp_init ( & s -> idsp , s -> avctx ) ; if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; } ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> s ) { MpegEncContext * const idsp = s -> idsp ; if (! idsp ) return ;\n"
 },
 {
  "id": 881,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void handle_associated_event ( struct cpu_hw_events * cpuc , int idx , struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc = & event -> hw ; mipspmu_event_update ( event , hwc , idx ) ; data -> period = event -> hw . last_period ; if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ; <vul-start> if ( perf_event_overflow ( event , 0 , data , regs ) ) <vul-end> mipspmu -> disable_event ( idx ) ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ( event , <vul-end> data , regs\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ( event, <vul-end> data, regs\n"
 },
 {
  "id": 882,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static inline int add_post_vars ( zval * arr , post_var_data_t * vars , zend_bool eof TSRMLS_DC ) { uint64_t max_vars = PG ( max_input_vars ) ; vars -> ptr = vars -> str . c ; vars -> end = vars -> str . c + vars -> str . len ; while ( add_post_var ( arr , vars , eof TSRMLS_CC ) ) { if ( ++ vars -> cnt > max_vars ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Input variables exceeded %\" PRIu64 \". \" \"To increase the limit change max_input_vars in php.ini.\" , max_vars ) ; return FAILURE ; } } <vul-start> if ( ! eof ) { <vul-end> memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ; } return SUCCESS ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ( ! eof && vars -> str . c != vars -> ptr\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ; } } <vul-end> return SUCCESS ;\n"
 },
 {
  "id": 883,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 OM_uint32 gss_krb5int_export_lucid_sec_context ( OM_uint32 * minor_status , const gss_ctx_id_t context_handle , const gss_OID desired_object , gss_buffer_set_t * data_set ) { krb5_error_code kret = 0 ; OM_uint32 retval ; krb5_gss_ctx_id_t ctx = ( krb5_gss_ctx_id_t ) context_handle ; void * lctx = NULL ; int version = 0 ; gss_buffer_desc rep ; retval = GSS_S_FAILURE ; * minor_status = 0 ; * data_set = GSS_C_NO_BUFFER_SET ; <vul-start> retval = generic_gss_oid_decompose ( minor_status , <vul-end> GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID , GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH , desired_object , & version ) ; if ( GSS_ERROR ( retval ) ) return retval ; switch ( version ) { case 1 : kret = make_external_lucid_ctx_v1 ( ( krb5_pointer ) ctx , version , & lctx ) ; break ; default : kret = ( OM_uint32 ) KG_LUCID_VERSION ; break ; } if ( kret ) goto error_out ; rep . value = & lctx ; rep . length = sizeof ( lctx ) ; retval = generic_gss_add_buffer_set_member ( minor_status , & rep , data_set ) ; if ( GSS_ERROR ( retval ) ) goto error_out ; error_out : if ( * minor_status == 0 ) * minor_status = ( OM_uint32 ) kret ; return ( retval ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; retval = generic_gss_oid_decompose_ext <vul-end> ( minor_status,\n"
 },
 {
  "id": 884,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; int error ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) return 0 ; cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { error = context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen , & sfe -> nameval [ sfe -> namelen ] ) ; if ( context -> seen_enough ) break ; if ( error ) return error ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ( error ) { kmem_free ( sbuf ) ; <vul-start> return error ; }\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ( error ) { xfs_attr_sf_all ( context ) ; <vul-start> return error ; } <vul-end> cursor -> offset\n"
 },
 {
  "id": 885,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int mailimf_group_parse ( const char * message , size_t length , size_t * indx , struct mailimf_group * * result ) { size_t cur_token ; char * display_name ; struct mailimf_mailbox_list * mailbox_list ; struct mailimf_group * group ; int r ; int res ; <vul-start> cur_token = * indx ; <vul-end> mailbox_list = NULL ; r = mailimf_display_name_parse ( message , length , & cur_token , & display_name ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto err ; } r = mailimf_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_display_name ; } r = mailimf_mailbox_list_parse ( message , length , & cur_token , & mailbox_list ) ; switch ( r ) { case MAILIMF_NO_ERROR : break ; case MAILIMF_ERROR_PARSE : r = mailimf_cfws_parse ( message , length , & cur_token ) ; if ( ( r != MAILIMF_NO_ERROR ) && ( r != MAILIMF_ERROR_PARSE ) ) { <vul-start> res = r ; <vul-end> goto free_display_name ; } break ; default : res = r ; goto free_display_name ; } r = mailimf_semi_colon_parse ( message , length , & cur_token ) ; if ( r != MAILIMF_NO_ERROR ) { res = r ; goto free_mailbox_list ; } group = mailimf_group_new ( display_name , mailbox_list ) ; if ( group == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_mailbox_list ; } * indx = cur_token ; * result = group ; return MAILIMF_NO_ERROR ; free_mailbox_list : if ( mailbox_list != NULL ) { mailimf_mailbox_list_free",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> int res ; clist * list ; <vul-start> res = r ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list )\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> int res ; size_t parse_depth ; <vul-start> ) ) { goto err_display_name <vul-end> ; } break <vul-start> ) ) { goto err_display_name <vul-end> ; } r\n"
 },
 {
  "id": 886,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 void handle_ld_nf ( u32 insn , struct pt_regs * regs ) { int rd = ( ( insn >> 25 ) & 0x1f ) ; int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; unsigned long * reg ; <vul-start> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <vul-end> maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; reg = fetch_reg_addr ( rd , regs ) ; if ( from_kernel || rd < 16 ) { reg [ 0 ] = 0 ; if ( ( insn & 0x780000 ) == 0x180000 ) reg [ 1 ] = 0 ; } else if ( test_thread_flag ( TIF_32BIT ) ) { put_user ( 0 , ( int __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( ( int __user * ) reg ) + 1 ) ; } else { put_user ( 0 , ( unsigned long __user * ) reg ) ; if ( ( insn & 0x780000 ) == 0x180000 ) put_user ( 0 , ( unsigned long __user * ) reg + 1 ) ; } advance ( regs ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , 0\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> * reg ; if ( from_kernel ) return ;\n"
 },
 {
  "id": 887,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void ff_h264_free_tables ( H264Context * h , int free_rbsp ) { int i ; H264Context * hx ; av_freep ( & h -> intra4x4_pred_mode ) ; av_freep ( & h -> chroma_pred_mode_table ) ; av_freep ( & h -> cbp_table ) ; av_freep ( & h -> mvd_table [ 0 ] ) ; av_freep ( & h -> mvd_table [ 1 ] ) ; av_freep ( & h -> direct_table ) ; av_freep ( & h -> non_zero_count ) ; av_freep ( & h -> slice_table_base ) ; h -> slice_table = NULL ; av_freep ( & h -> list_counts ) ; av_freep ( & h -> mb2b_xy ) ; av_freep ( & h -> mb2br_xy ) ; av_buffer_pool_uninit ( & h -> qscale_table_pool ) ; av_buffer_pool_uninit ( & h -> mb_type_pool ) ; av_buffer_pool_uninit ( & h -> motion_val_pool ) ; av_buffer_pool_uninit ( & h -> ref_index_pool ) ; if ( free_rbsp && h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) ff_h264_unref_picture ( h , & h -> DPB [ i ] ) ; <vul-start> av_freep ( & h -> DPB ) ; <vul-end> } else if ( h -> DPB ) { for ( i = 0 ; i < H264_MAX_PICTURE_COUNT ; i ++ ) h -> DPB [ i ] . needs_realloc = 1 ; } h -> cur_pic_ptr = NULL ; for ( i = 0 ; i < H264_MAX_THREADS ; i ++ ) { hx = h -> thread_context [ i ] ; if ( ! hx ) continue ;",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ] ) ; memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ] ) ; av_buffer_pool_uninit ( & h -> DPB ) ;\n"
 },
 {
  "id": 888,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , u16 selector , int seg ) { u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; <vul-start> return __load_segment_descriptor ( ctxt , selector , seg , cpl , false ) ; <vul-end> }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> cpl , false , NULL\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, cpl, true <vul-end> ) ; }\n"
 },
 {
  "id": 889,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , \"OLSRv%i, seq 0x%04x, length %u\" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; <vul-start> ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <vul-end> if ( is_ipv6 ) { msgptr . v6 =",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; if ( is_ipv6 ) { <vul-start> sizeof ( struct olsr_msg6 ) ) ; <vul-end> msgptr . v6 <vul-start> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <vul-start> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <vul-start> 2 ) ; <vul-end> addr_size = 4 <vul-start> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <vul-end> name_entries_valid = 0 <vul-start> name_entries_valid = 0 <vul-end> ; if ( <vul-start> name_entries_valid = 1 <vul-end> ; ND_PRINT (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; if ( length < sizeof ( struct olsr_msg4 ) ) { goto trunc ; } <vul-start> } else { if ( length < 4 ) { goto trunc ; }\n"
 },
 {
  "id": 890,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void mark_commit ( struct commit * c , void * data ) { <vul-start> mark_object ( & c -> object , NULL , NULL , data ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , NULL , <vul-end> data ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> data ) { if ( c -> type == COMMIT_OBJECT )\n"
 },
 {
  "id": 891,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int misaligned_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_sign_extend ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <vul-start> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , address ) ; <vul-end> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } switch ( width_shift ) { case 1 : if ( do_sign_extend ) { regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; } else { regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; } break ; case 2 : regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; break ; case 3 : regs -> regs [ destreg ] = buffer ; break ; default : printk ( \"Unexpected width_shift %d in misaligned_load, PC=%08lx\\\\n\" , width_shift , ( unsigned long )",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, address\n"
 },
 {
  "id": 892,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static struct dst_entry * inet6_csk_route_socket ( struct sock * sk , struct flowi6 * fl6 ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = sk -> sk_protocol ; fl6 -> daddr = sk -> sk_v6_daddr ; fl6 -> saddr = np -> saddr ; fl6 -> flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel ) ; fl6 -> flowi6_oif = sk -> sk_bound_dev_if ; fl6 -> flowi6_mark = sk -> sk_mark ; fl6 -> fl6_sport = inet -> inet_sport ; fl6 -> fl6_dport = inet -> inet_dport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( fl6 ) ) ; <vul-start> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <vul-end> <vul-start> dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ; <vul-end> if ( ! dst ) { dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( ! IS_ERR ( dst ) ) __inet6_csk_dst_store ( sk , dst , NULL , NULL ) ; } return dst ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> ( fl6 , rcu_dereference ( <vul-start> np -> opt ) <vul-start> final ) ; rcu_read_unlock ( ) ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> ( fl6, rcu_dereference ( <vul-start> np -> opt ) <vul-start> final ) ; rcu_read_unlock ( ) ;\n"
 },
 {
  "id": 893,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 <vul-start> static struct desc_struct * get_desc ( unsigned short sel ) <vul-end> { struct desc_ptr gdt_desc = { 0 , 0 } ; unsigned long desc_base ; # ifdef CONFIG_MODIFY_LDT_SYSCALL if ( ( sel & SEGMENT_TI_MASK ) == SEGMENT_LDT ) { <vul-start> struct desc_struct * desc = NULL ; <vul-end> struct ldt_struct * ldt ; sel >>= 3 ; mutex_lock ( & current -> active_mm -> context . lock ) ; ldt = current -> active_mm -> context . ldt ; <vul-start> if ( ldt && sel < ldt -> nr_entries ) <vul-end> <vul-start> desc = & ldt -> entries [ sel ] ; <vul-end> mutex_unlock ( & current -> active_mm -> context . lock ) ; <vul-start> return desc ; <vul-end> } # endif native_store_gdt ( & gdt_desc ) ; desc_base = sel & ~ ( SEGMENT_RPL_MASK | SEGMENT_TI_MASK ) ; if ( desc_base > gdt_desc . size ) <vul-start> return NULL ; <vul-end> return ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start>     static bool get_desc ( <vul-start> struct desc_struct * out , <vul-end> unsigned short sel <vul-start> SEGMENT_LDT ) { bool success = false <vul-end> ; struct ldt_struct <vul-start> -> nr_entries ) { * out = <vul-end> ldt -> entries <vul-start> sel ] ; success = true ; } <vul-start> ) ; return success <vul-end> ; } # <vul-start> size ) return false ; * out = * <vul-end> ( struct desc_struct <vul-start> desc_base ) ; return true ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> unsigned short sel, struct desc_struct * * desc <vul-start> SEGMENT_LDT ) { <vul-end> struct ldt_struct * <vul-start> -> nr_entries ) { if ( desc ) * desc = NULL ; else <vul-end> desc = & <vul-start> sel ] ; } <vul-start> lock ) ; * desc = NULL <vul-end> ; } # <vul-start>. size ) { # ifdef CONFIG_SEC_DEBUG if (! desc ) <vul-end> return NULL ; <vul-start> return NULL ; # else return NULL ; # endif } <vul-start> desc_base ) ; * desc = NULL ;\n"
 },
 {
  "id": 894,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int indenterror ( struct tok_state * tok ) <vul-start> { <vul-end> if ( tok -> alterror ) { tok -> done = E_TABSPACE ; tok -> cur = tok -> inp ; <vul-start> return 1 ; <vul-end> } if ( tok -> altwarning ) { # ifdef PGEN PySys_WriteStderr ( \"inconsistent use of tabs and spaces \" \"in indentation\\\\n\" ) ; # else PySys_FormatStderr ( \"%U: inconsistent use of tabs and spaces \" \"in indentation\\\\n\" , tok -> filename ) ; # endif tok -> altwarning = 0 ; } return 0 ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> * tok ) <vul-end> { tok -> <vul-start> inp ; return ERRORTOKEN <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> tok ) { int is_inconsistent = 0 ; <vul-start> -> inp ; is_inconsistent = 1 ; } if ( is_inconsistent ) { Py_DECREF ( tok -> inp ) ; tok -> inp = tok -> next ;\n"
 },
 {
  "id": 895,
  "question": "CWE-287 Code Input Vulnerable Code Is: CWE-287 static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; struct sockaddr_nl * addr = msg -> msg_name ; u32 dst_pid ; u32 dst_group ; struct sk_buff * skb ; int err ; struct scm_cookie scm ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; if ( NULL == siocb -> scm ) siocb -> scm = & scm ; <vul-start> err = scm_send ( sock , msg , siocb -> scm ) ; <vul-end> if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = - EINVAL ; if ( addr -> nl_family != AF_NETLINK ) goto out ; dst_pid = addr -> nl_pid ; dst_group = ffs ( addr -> nl_groups ) ; err = - EPERM ; if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) goto out ; } else { dst_pid = nlk -> dst_pid ; dst_group = nlk -> dst_group ; } if ( ! nlk -> pid ) { err = netlink_autobind ( sock ) ; if ( err ) goto out ; } err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; err = - ENOBUFS ; skb = alloc_skb ( len , GFP_KERNEL ) ; if ( skb == NULL )",
  "golden_answers": [
   "CWE-287 Fixed Code Lines are: <vul-start> siocb -> scm , true\n"
  ],
  "generated_answer": "CWE-287 Fixed Code Lines are: <vul-start> siocb -> scm, false\n"
 },
 {
  "id": 896,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int tiffcp ( TIFF * in , TIFF * out ) { <vul-start> uint16 bitspersample , samplesperpixel ; <vul-end> <vul-start> uint16 input_compression , input_photometric ; <vul-end> copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , \"tiffcp: %s: Can\\'t copy/convert subsampled image.\\\\n\" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel == 3 )",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> bitspersample , samplesperpixel = 1 <vul-start> input_compression , input_photometric = PHOTOMETRIC_MINISBLACK\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> out ) { uint32 bitspersample, samplesperpixel ; uint16 input_compression, input_photometric ; copyFunc cf ; uint32 width, length ; struct cpTag * p ; <vul-start> ; uint16 input_compression <vul-end> ; CopyField (\n"
 },
 {
  "id": 897,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ssl3_get_cert_verify ( SSL * s ) { EVP_PKEY * pkey = NULL ; unsigned char * p ; int al , ok , ret = 0 ; long n ; int type = 0 , i , j ; X509 * peer ; const EVP_MD * md = NULL ; EVP_MD_CTX mctx ; EVP_MD_CTX_init ( & mctx ) ; n = s -> method -> ssl_get_message ( s , SSL3_ST_SR_CERT_VRFY_A , SSL3_ST_SR_CERT_VRFY_B , - 1 , SSL3_RT_MAX_PLAIN_LENGTH , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; if ( s -> session -> peer != NULL ) { peer = s -> session -> peer ; pkey = X509_get_pubkey ( peer ) ; type = X509_certificate_type ( peer , pkey ) ; } else { peer = NULL ; pkey = NULL ; } if ( s -> s3 -> tmp . message_type != SSL3_MT_CERTIFICATE_VERIFY ) { s -> s3 -> tmp . reuse_message = 1 ; <vul-start> if ( ( peer != NULL ) && ( type & EVP_PKT_SIGN ) ) <vul-end> { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_MISSING_VERIFY_MESSAGE ) ; goto f_err ; } ret = 1 ; goto end ; } if ( peer == NULL ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_NO_CLIENT_CERT_RECEIVED ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } if ( ! ( type & EVP_PKT_SIGN ) ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY , SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE ) ; al = SSL_AD_ILLEGAL_PARAMETER ; goto f_err ; } if ( s -> s3 -> change_cipher_spec ) { SSLerr ( SSL_F_SSL3_GET_CERT_VERIFY",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> ; if ( <vul-end> peer != NULL <vul-start> peer != NULL <vul-end> ) { al\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> ; if ( peer == NULL && <vul-end> type & EVP_PKT_SIGN <vul-start> type & EVP_PKT_SIGN <vul-end> ) { al\n"
 },
 {
  "id": 898,
  "question": "CWE-79 Code Input Vulnerable Code Is: CWE-79 static int php_handler ( request_rec * r ) { php_struct * volatile ctx ; void * conf ; apr_bucket_brigade * volatile brigade ; apr_bucket * bucket ; apr_status_t rv ; request_rec * volatile parent_req = NULL ; TSRMLS_FETCH ( ) ; # define PHPAP_INI_OFF php_apache_ini_dtor ( r , parent_req TSRMLS_CC ) ; conf = ap_get_module_config ( r -> per_dir_config , & php5_module ) ; ctx = SG ( server_context ) ; if ( ctx == NULL || ( ctx && ctx -> request_processed && ! strcmp ( r -> protocol , \"INCLUDED\" ) ) ) { normal : ctx = SG ( server_context ) = apr_pcalloc ( r -> pool , sizeof ( * ctx ) ) ; apr_pool_cleanup_register ( r -> pool , ( void * ) & SG ( server_context ) , php_server_context_cleanup , apr_pool_cleanup_null ) ; ctx -> r = r ; ctx = NULL ; } else { parent_req = ctx -> r ; ctx -> r = r ; } apply_config ( conf ) ; if ( strcmp ( r -> handler , PHP_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SOURCE_MAGIC_TYPE ) && strcmp ( r -> handler , PHP_SCRIPT ) ) { if ( ! AP2 ( xbithack ) || strcmp ( r -> handler , \"text/html\" ) || ! ( r -> finfo . protection & APR_UEXECUTE ) ) { PHPAP_INI_OFF ; return DECLINED ; } } if ( r -> used_path_info == AP_REQ_REJECT_PATH_INFO && r -> path_info && r -> path_info [ 0 ] ) { PHPAP_INI_OFF ; return HTTP_NOT_FOUND ; } if ( !",
  "golden_answers": [
   "CWE-79 Fixed Code Lines are: <vul-start> = 1 ; apr_brigade_cleanup ( brigade ) ;\n"
  ],
  "generated_answer": "CWE-79 Fixed Code Lines are: <vul-start> = 1 ; SG ( request_recycle_env ) ; <vul-start> connection -> bucket_alloc ) ; SG ( request_recycle_env\n"
 },
 {
  "id": 899,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int raptor_turtle_writer_set_option ( raptor_turtle_writer * turtle_writer , raptor_option option , int value ) { if ( value < 0 || ! raptor_option_is_valid_for_area ( option , RAPTOR_OPTION_AREA_TURTLE_WRITER ) ) return 1 ; switch ( option ) { case RAPTOR_OPTION_WRITER_AUTO_INDENT : if ( value ) turtle_writer -> flags |= TURTLE_WRITER_AUTO_INDENT ; else turtle_writer -> flags &= ~ TURTLE_WRITER_AUTO_INDENT ; break ; case RAPTOR_OPTION_WRITER_INDENT_WIDTH : turtle_writer -> indent = value ; break ; case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : break ; case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : <vul-start> case RAPTOR_OPTION_RELATIVE_URIS : <vul-end> case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ; break ; } return 0 ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case\n"
 },
 {
  "id": 900,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void nfnetlink_rcv_batch ( struct sk_buff * skb , struct nlmsghdr * nlh , u_int16_t subsys_id ) { struct sk_buff * oskb = skb ; struct net * net = sock_net ( skb -> sk ) ; const struct nfnetlink_subsystem * ss ; const struct nfnl_callback * nc ; static LIST_HEAD ( err_list ) ; u32 status ; int err ; if ( subsys_id >= NFNL_SUBSYS_COUNT ) return netlink_ack ( skb , nlh , - EINVAL ) ; replay : status = 0 ; skb = netlink_skb_clone ( oskb , GFP_KERNEL ) ; if ( ! skb ) return netlink_ack ( oskb , nlh , - ENOMEM ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) { # ifdef CONFIG_MODULES nfnl_unlock ( subsys_id ) ; request_module ( \"nfnetlink-subsys-%d\" , subsys_id ) ; nfnl_lock ( subsys_id ) ; ss = nfnl_dereference_protected ( subsys_id ) ; if ( ! ss ) # endif { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } } if ( ! ss -> commit || ! ss -> abort ) { nfnl_unlock ( subsys_id ) ; netlink_ack ( oskb , nlh , - EOPNOTSUPP ) ; return kfree_skb ( skb ) ; } while ( skb -> len >= nlmsg_total_size ( 0 ) ) { int msglen , type ; nlh = nlmsg_hdr ( skb ) ; err = 0 ; <vul-start> if ( nlmsg_len ( nlh ) < sizeof ( struct nfgenmsg ) || <vul-end> skb ->",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <vul-start> struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <vul-end> ; } if\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; if ( skb -> len < nlh -> nlmsg_len ||\n"
 },
 {
  "id": 901,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t ssiProcessExecCommand ( HttpConnection * connection , const char_t * tag , size_t length ) { char_t * separator ; char_t * attribute ; char_t * value ; if ( connection -> settings -> cgiCallback == NULL ) return ERROR_INVALID_TAG ; if ( length < 4 || length >= HTTP_SERVER_BUFFER_SIZE ) return ERROR_INVALID_TAG ; osMemcpy ( connection -> buffer , tag + 4 , length - 4 ) ; connection -> buffer [ length - 4 ] = '\\\\0' ; <vul-start> separator = strchr ( connection -> buffer , '=' ) ; <vul-end> if ( ! separator ) return ERROR_INVALID_TAG ; * separator = '\\\\0' ; attribute = strTrimWhitespace ( connection -> buffer ) ; value = strTrimWhitespace ( separator + 1 ) ; if ( value [ 0 ] == '\\\\'' || value [ 0 ] == \\'\\\\\"\\' ) value ++ ; length = osStrlen ( value ) ; if ( length > 0 ) { if ( value [ length - 1 ] == '\\\\'' || value [ length - 1 ] == \\'\\\\\"\\' ) value [ length - 1 ] = '\\\\0' ; } if ( osStrcasecmp ( attribute , \"cgi\" ) && osStrcasecmp ( attribute , \"cmd\" ) && osStrcasecmp ( attribute , \"cmd_argument\" ) ) return ERROR_INVALID_TAG ; if ( osStrlen ( value ) > HTTP_SERVER_CGI_PARAM_MAX_LEN ) return ERROR_INVALID_TAG ; osStrcpy ( connection -> cgiParam , value ) ; return connection -> settings -> cgiCallback ( connection , connection -> cgiParam ) ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; separator = osStrchr <vul-end> ( connection ->\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; separator = osStrchr <vul-end> ( connection ->\n"
 },
 {
  "id": 902,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , \"nreslevels %d is invalid\\\\n\" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } <vul-start> if ( c -> nreslevels < s -> reduction_factor ) <vul-end> <vul-start> c -> nreslevels2decode = 1 ; <vul-end> else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"cblk size invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , \"cblk size > 64\" ) ; return AVERROR_PATCHWELCOME ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , \"extra cblk styles %X\\\\n\" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( &",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> c -> nreslevels <= <vul-end> s -> reduction_factor <vul-start> -> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , \"reduction_factor too large for this bitstream, max is %d\\\\n\" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <vul-end> c -> nreslevels2decode\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> reduction_factor ) { <vul-start> = 1 ; } else { c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; }\n"
 },
 {
  "id": 903,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_segmentation ( VP9_COMP * cpi , <vul-end> struct vp9_write_bit_buffer * wb ) { int i , j ; <vul-start> struct segmentation * seg = & cpi -> common . seg ; <vul-end> vp9_wb_write_bit ( wb , seg -> enabled ) ; if ( ! seg -> enabled ) return ; <vul-start> vp9_wb_write_bit ( wb , seg -> update_map ) ; <vul-end> if ( seg -> update_map ) { <vul-start> vp9_choose_segmap_coding_method ( cpi ) ; <vul-end> for ( i = 0 ; i < SEG_TREE_PROBS ; i ++ ) { const int prob = seg -> tree_probs [ i ] ; const int update = prob != MAX_PROB ; <vul-start> vp9_wb_write_bit ( wb , update ) ; <vul-end> if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } <vul-start> vp9_wb_write_bit ( wb , seg -> temporal_update ) ; <vul-end> if ( seg -> temporal_update ) { for ( i = 0 ; i < PREDICTION_PROBS ; i ++ ) { const int prob = seg -> pred_probs [ i ] ; const int update = prob != MAX_PROB ; <vul-start> vp9_wb_write_bit ( wb , update ) ; <vul-end> if ( update ) vp9_wb_write_literal ( wb , prob , 8 ) ; } } } <vul-start> vp9_wb_write_bit ( wb , seg -> update_data ) ; <vul-end> if ( seg -> update_data ) { <vul-start> vp9_wb_write_bit ( wb , seg -> abs_delta ) ; <vul-end> for ( i = 0 ; i < MAX_SEGMENTS ; i ++ ) { for ( j = 0 ; j < SEG_LVL_MAX ; j ++",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> void encode_segmentation ( VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer <vul-end> * wb ) <vul-start> , j ; const <vul-start> seg = & cm -> seg ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> ) return ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> { vp9_choose_segmap_coding_method ( cm , xd <vul-end> ) ; for <vul-start> != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <vul-end> ( wb , <vul-start> ) ; } vpx_wb_write_bit <vul-end> ( wb , <vul-start> != MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <vul-end> ( wb , <vul-start> } } } vpx_wb_write_bit <vul-end> ( wb , <vul-start> update_data ) { vpx_wb_write_bit <vul-end> ( wb , <vul-start> int active = segfeature_active ( seg , i , j ) ; vpx_wb_write_bit <vul-end> ( wb , <vul-start> int data = get_segdata <vul-end> ( seg , <vul-start> data_max ) ; vpx_wb_write_bit <vul-end> ( wb ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void encode_segmentation ( const VP9_COMMON * cm, const VP9EncoderConfig * oxcf, <vul-end> struct vpx_write_bit_buffer * <vul-start> seg = & cm <vul-end> -> common. <vul-start> ) return ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> update_map ) { vpx_choose_segmap_coding_method ( cm <vul-end> ) ; for <vul-start>!= MAX_PROB ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> ) ; } vpx_wb_write_bit <vul-end> ( wb, <vul-start>!= MAX_PROB ; vpx_wb_write_bit <vul-end> ( wb, <vul-start> } } } vpx_wb_write_bit <vul-end> ( wb, <vul-start> update_data ) { vpx_wb_write_bit <vul-end> ( wb,\n"
 },
 {
  "id": 904,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 <vul-start> void exit_io_context ( void ) <vul-end> { struct io_context * ioc ; <vul-start> task_lock ( current ) ; <vul-end> <vul-start> ioc = current -> io_context ; <vul-end> <vul-start> current -> io_context = NULL ; <vul-end> <vul-start> task_unlock ( current ) ; <vul-end> if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> void exit_io_context ( struct task_struct * task <vul-end> ) { struct <vul-start> ; task_lock ( task <vul-end> ) ; ioc <vul-start> ; ioc = task <vul-end> -> io_context ; <vul-start> -> io_context ; task <vul-end> -> io_context = <vul-start> ; task_unlock ( task <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> void exit_io_context ( struct task_struct * task <vul-end> ) { struct <vul-start> * ioc ; mutex_lock ( & task_mutex <vul-end> ) ; ioc <vul-start> ; ioc = task_current <vul-end> -> io_context ; <vul-start> -> io_context ; task_unlock ( task ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } mutex_unlock ( & task_mutex <vul-end> ) ; } <vul-start> = NULL ; <vul-end> }    \n"
 },
 {
  "id": 905,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int errorLogDirective ( MaState * state , cchar * key , cchar * value ) { MprTicks stamp ; char * option , * ovalue , * tok , * path ; ssize size ; int level , flags , backup ; if ( mprGetCmdlineLogging ( ) ) { mprLog ( \"info appweb config\" , 4 , \"Already logging. Ignoring ErrorLog directive\" ) ; return 0 ; } size = MAXINT ; stamp = 0 ; level = 0 ; backup = 0 ; path = 0 ; flags = 0 ; for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { if ( ! path ) { path = mprJoinPath ( httpGetRouteVar ( state -> route , \"LOG_DIR\" ) , httpExpandRouteVars ( state -> route , option ) ) ; } else { <vul-start> option = stok ( option , \" =\\\\t,\" , & ovalue ) ; <vul-end> ovalue = strim ( ovalue , \"\\\\\"\\'\" , MPR_TRIM_BOTH ) ; if ( smatch ( option , \"size\" ) ) { size = ( ssize ) getnum ( ovalue ) ; } else if ( smatch ( option , \"level\" ) ) { level = atoi ( ovalue ) ; } else if ( smatch ( option , \"backup\" ) ) { backup = atoi ( ovalue ) ; } else if ( smatch ( option , \"anew\" ) ) { flags |= MPR_LOG_ANEW ; } else if ( smatch ( option , \"stamp\" ) ) {",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option ,\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option,\n"
 },
 {
  "id": 906,
  "question": "CWE-77 Code Input Vulnerable Code Is: CWE-77 int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , \"\\\\r\\\\n*** pulse DTR ***\\\\r\\\\n\" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , \"*** FAILED\\\\r\\\\n\" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , \"\\\\r\\\\n*** DTR: %s ***\\\\r\\\\n\" , dtr_up ? \"up\" : \"down\" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , \"\\\\r\\\\n*** baud: %d (%d) ***\\\\r\\\\n\" , opts . baud , newbaud ) ; } else {",
  "golden_answers": [
   "CWE-77 Fixed Code Lines are: <vul-start> xfr_cmd , fname <vul-end> ) ; free\n"
  ],
  "generated_answer": "CWE-77 Fixed Code Lines are: <vul-start> break ; } if ( opts. xfr_cmd == NULL ) { fd_printf ( STO, \"\\\\r\\\\n*** command disabled ***\\\\r\\\\n\" ) ; break ; } <vul-start>, fname, & opts. xfr_ctxt <vul-end> ) ; free\n"
 },
 {
  "id": 907,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void rd_check_segment ( VP8_COMP * cpi , MACROBLOCK * x , BEST_SEG_INFO * bsi , unsigned int segmentation ) { int i ; int const * labels ; int br = 0 ; int bd = 0 ; B_PREDICTION_MODE this_mode ; int label_count ; int this_segment_rd = 0 ; int label_mv_thresh ; int rate = 0 ; int sbr = 0 ; int sbd = 0 ; int segmentyrate = 0 ; vp8_variance_fn_ptr_t * v_fn_ptr ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; ENTROPY_CONTEXT_PLANES t_above_b , t_left_b ; ENTROPY_CONTEXT * ta_b ; ENTROPY_CONTEXT * tl_b ; <vul-start> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <vul-end> <vul-start> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <vul-end> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; ta_b = ( ENTROPY_CONTEXT * ) & t_above_b ; tl_b = ( ENTROPY_CONTEXT * ) & t_left_b ; br = 0 ; bd = 0 ; v_fn_ptr = & cpi -> fn_ptr [ segmentation ] ; labels = vp8_mbsplits [ segmentation ] ; label_count = vp8_mbsplit_count [ segmentation ] ; label_mv_thresh = 1 * bsi -> mvthresh / label_count ; rate = vp8_cost_token ( vp8_mbsplit_tree , vp8_mbsplit_probs , vp8_mbsplit_encodings + segmentation ) ; rate += vp8_cost_mv_ref ( SPLITMV , bsi -> mdcounts ) ; this_segment_rd += RDCOST ( x -> rdmult , x -> rddiv , rate , 0 ) ; br += rate ; for",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * tl_b ; memcpy <vul-end> ( & t_above <vul-start> ) ) ; memcpy <vul-end> ( & t_left <vul-start> * tl_s ; memcpy <vul-end> ( & t_above_s <vul-start> ) ) ; memcpy <vul-end> ( & t_left_s <vul-start> = this_rd ; memcpy <vul-end> ( ta_b , <vul-start> ) ) ; memcpy <vul-end> ( tl_b , <vul-start> ; } } memcpy <vul-end> ( ta , <vul-start> ) ) ; memcpy <vul-end> ( tl ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * tl_b ; memcpy <vul-end> ( & t_above <vul-start> ) ) ; memcpy <vul-end> ( & t_left <vul-start> * tl_b ; memcpy <vul-end> ( & t_above_b\n"
 },
 {
  "id": 908,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int perf_swevent_init ( struct perf_event * event ) { <vul-start> int event_id = event -> attr . config ; <vul-end> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> event ) { u64 <vul-end> event_id = event\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start>. config ; if ( is_software_event ( event ) ) return - ENOENT ;\n"
 },
 {
  "id": 909,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static int em_sysenter ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) return emulate_gp ( ctxt , 0 ) ; <vul-start> if ( ( ctxt -> mode == X86EMUL_MODE_PROT32 ) && ( efer & EFER_LMA ) <vul-end> && ! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) return X86EMUL_UNHANDLEABLE ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; <vul-start> switch ( ctxt -> mode ) { <vul-end> case X86EMUL_MODE_PROT32 : if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; <vul-start> break ; <vul-end> case X86EMUL_MODE_PROT64 : if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; break ; default : break ; } ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF ) ; <vul-start> cs_sel = ( u16 ) msr_data ; <vul-end> cs_sel &= ~ SELECTOR_RPL_MASK ; ss_sel = cs_sel + 8 ; <vul-start> ss_sel &= ~ SELECTOR_RPL_MASK ; <vul-end> <vul-start> if ( ctxt -> mode == X86EMUL_MODE_PROT64 || ( efer & EFER_LMA ) ) { <vul-end> cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel ,",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> ctxt -> mode != X86EMUL_MODE_PROT64 <vul-end> ) && ( <vul-start> msr_data ) ; <vul-end> if ( ( <vul-start> 0 ) ; <vul-end> ctxt -> eflags <vul-start> u16 ) msr_data & <vul-end> ~ SELECTOR_RPL_MASK ; <vul-start> + 8 ; if <vul-end> ( efer & <vul-start> efer & EFER_LMA <vul-end> ) { cs <vul-start> -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 ) <vul-start> VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 )\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> 0 ) ; <vul-end> setup_syscalls_segments ( ctxt <vul-start> msr_data ) ; if (! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt ) ; <vul-start> 0 ) ; <vul-end> ctxt -> eflags <vul-start> EFLG_IF ) ; if (! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt ) ; <vul-start> + 8 ; <vul-end> if ( ctxt <vul-start> ; if ( ( <vul-start> & EFER_LMA ) &&! vendor_intel ( ctxt ) ) return emulate_ud ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT32 ) cs. d = 0 ; cs. l = 1 ; else <vul-end> ops -> set_segment <vul-start> msr_data ) ; <vul-end> ops -> get_msr <vul-start> msr_data ) ; <vul-end> * reg_write ( <vul-start> VCPU_REGS_RSP ) = ( u32 ) msr_data <vul-end> ; return X86EMUL_CONTINUE\n"
 },
 {
  "id": 910,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 json_t * json_object ( void ) { json_object_t * object = jsonp_malloc ( sizeof ( json_object_t ) ) ; if ( ! object ) <vul-start> return NULL ; <vul-end> json_init ( & object -> json , JSON_OBJECT ) ; if ( hashtable_init ( & object -> hashtable ) ) { jsonp_free ( object ) ; return NULL ; } object -> serial = 0 ; object -> visited = 0 ; return & object -> json ; }",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> return NULL ; if ( ! hashtable_seed ) { json_object_seed ( 0 ) ; }\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> return NULL ; object -> json = json_object_init ( ) ; if ( hashtable_init ( & object -> hashtable ) ) { jsonp_free ( object ) ; return NULL ; }\n"
 },
 {
  "id": 911,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void record_recent_object ( struct object * obj , <vul-start> struct strbuf * path , <vul-end> <vul-start> const char * last , <vul-end> void * data ) { sha1_array_append ( & recent_objects , obj -> oid . hash ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * obj , <vul-end> const char * <vul-start> const char * name <vul-end> , void *\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * obj, <vul-end> const char * <vul-start> const char * name <vul-end>, void *\n"
 },
 {
  "id": 912,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; BT_DBG ( \"sock %p sk %p\" , sock , sk ) ; if ( ! hdev ) return - EBADFD ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = AF_BLUETOOTH ; haddr -> hci_dev = hdev -> id ; <vul-start> release_sock ( sk ) ; <vul-end> return 0 ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> -> id ; haddr -> hci_channel = 0 ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> -> id ; haddr -> hci_conn_id = 0 ;\n"
 },
 {
  "id": 913,
  "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static int udf_readdir ( struct file * file , struct dir_context * ctx ) { struct inode * dir = file_inode ( file ) ; struct udf_inode_info * iinfo = UDF_I ( dir ) ; struct udf_fileident_bh fibh = { . sbh = NULL , . ebh = NULL } ; struct fileIdentDesc * fi = NULL ; struct fileIdentDesc cfi ; int block , iblock ; loff_t nf_pos ; int flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint16_t liu ; uint8_t lfi ; loff_t size = udf_ext0_offset ( dir ) + dir -> i_size ; struct buffer_head * tmp , * bha [ 16 ] ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; int i , num , ret = 0 ; struct extent_position epos = { NULL , 0 , { 0 , 0 } } ; if ( ctx -> pos == 0 ) { if ( ! dir_emit_dot ( file , ctx ) ) return 0 ; ctx -> pos = 1 ; } nf_pos = ( ctx -> pos - 1 ) << 2 ; if ( nf_pos >= size ) goto out ; fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) { ret = - ENOMEM ; goto out ; } if ( nf_pos == 0 ) nf_pos = udf_ext0_offset ( dir ) ; fibh . soffset = fibh . eoffset = nf_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( iinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) {",
  "golden_answers": [
   "CWE-17 Fixed Code Lines are: <vul-start> , nameptr , lfi , fname , UDF_NAME_LEN <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start>, nameptr, lfi, fname, UDF_NAME_LEN <vul-end> ) ; if\n"
 },
 {
  "id": 914,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_dequant_idct_add_uv_block_mmx ( short * q , short * dq , unsigned char * dstu , unsigned char * dstv , int stride , char * eobs ) { int i ; for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstu , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <vul-start> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <vul-end> } if ( eobs [ 1 ] > 1 ) vp8_dequant_idct_add_mmx ( q + 16 , dq , dstu + 4 , stride ) ; else if ( eobs [ 1 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 16 ] * dq [ 0 ] , dstu + 4 , stride , dstu + 4 , stride ) ; <vul-start> vpx_memset ( q + 16 , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <vul-end> } q += 32 ; dstu += 4 * stride ; eobs += 2 ; } for ( i = 0 ; i < 2 ; i ++ ) { if ( eobs [ 0 ] > 1 ) vp8_dequant_idct_add_mmx ( q , dq , dstv , stride ) ; else if ( eobs [ 0 ] == 1 ) { vp8_dc_only_idct_add_mmx ( q [ 0",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> stride ) ; memset <vul-end> ( q , <vul-start> stride ) ; memset <vul-end> ( q + <vul-start> stride ) ; memset <vul-end> ( q , <vul-start> stride ) ; memset <vul-end> ( q +\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> stride ) ; memset <vul-end> ( q, <vul-start> stride ) ; memset <vul-end> ( q + <vul-start> stride ) ; memset <vul-end> ( q + <vul-start> stride ) ; memset <vul-end> ( q +\n"
 },
 {
  "id": 915,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , \"r\" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , \"cannot open CSR file!\\\\n\" ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { fprintf ( stderr , \"could not read file length!\\\\n\" ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <vul-start> if ( sscanf ( l_line , \"%u %u %u\" , o_row_count , o_column_count , o_element_count ) == 3 ) { <vul-end> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <vul-end> { * o_column_idx\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( 3 == <vul-start>, o_element_count ) && 0!= * o_row_count && 0!= * o_column_count && 0!= * o_element_count ) <vul-end> { * o_column_idx\n"
 },
 {
  "id": 916,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int main ( int argc , char * * argv ) { const char command0 [ ] = { 0x00 , 0x00 } ; char command1 [ ] = \"\\\\x01\\\\x00urn:schemas-upnp-org:device:InternetGatewayDevice\" ; char command2 [ ] = \"\\\\x02\\\\x00uuid:fc4ec57e-b051-11db-88f8-0060085db3f6::upnp:rootdevice\" ; const char command3 [ ] = { 0x03 , 0x00 } ; char command3compat [ ] = \"\\\\x03\\\\x00ssdp:all\" ; char command4 [ ] = \"\\\\x04\\\\x00test:test:test\" ; const char bad_command [ ] = { 0xff , 0xff } ; const char overflow [ ] = { 0x01 , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff } ; <vul-start> const char command5 [ ] = { 0x05 , 0x00 } ; <vul-end> int s ; int i ; void * tmp ; unsigned char * resp = NULL ; size_t respsize = 0 ; unsigned char buf [ 4096 ] ; ssize_t n ; int total = 0 ; const char * sockpath = \"/var/run/minissdpd.sock\" ; for ( i = 0 ; i < argc - 1 ; i ++ ) { if ( 0 == strcmp ( argv [ i ] , \"-s\" ) ) sockpath = argv [ ++ i ] ; } command1 [ 1 ] = sizeof ( command1 ) - 3 ; command2 [ 1 ] = sizeof ( command2 ) - 3 ; command3compat [ 1 ] = sizeof ( command3compat ) - 3 ; command4 [ 1 ] = sizeof ( command4 ) - 3 ; s = connect_unix_socket ( sockpath ) ; n = SENDCOMMAND ( command0 , sizeof ( command0 ) ) ; n",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> 0x05 , 0x00 } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f <vul-start> n ) ; if ( n == 0 ) { <vul-start> s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( \"Response received %d bytes\\\\n\" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; const char command6 [ ] = { 0x06, 0x00 } ; const char <vul-start> n ) ; n = recv ( s, buf, sizeof ( buf ) ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } command6 [ 0 ] = 0 ; <vul-start> ) ; return n + 1 <vul-end> ; }  \n"
 },
 {
  "id": 917,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 void * vips_malloc ( VipsObject * object , size_t size ) { void * buf ; <vul-start> buf = g_malloc ( size ) ; <vul-end> if ( object ) { g_signal_connect ( object , \"postclose\" , G_CALLBACK ( vips_malloc_cb ) , buf ) ; object -> local_memory += size ; } return ( buf ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; buf = g_malloc0 <vul-end> ( size )\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> * buf ; size_t res ; if ( size > 0 ) { if ( size < 0 ) { return ( NULL ) ; } res <vul-end> = g_malloc ( <vul-start> size ) ; if ( res == 0 ) { g_warning ( \"Failed to allocate %zu bytes\", size ) ; return ( NULL ) ; }\n"
 },
 {
  "id": 918,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) { int i ; struct commit * commit ; struct strbuf base ; strbuf_init ( & base , PATH_MAX ) ; while ( ( commit = get_revision ( revs ) ) != NULL ) { if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ; show_commit ( commit , data ) ; } for ( i = 0 ; i < revs -> pending . nr ; i ++ ) { struct object_array_entry * pending = revs -> pending . objects + i ; struct object * obj = pending -> item ; const char * name = pending -> name ; const char * path = pending -> path ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ; if ( obj -> type == OBJ_TAG ) { obj -> flags |= SEEN ; <vul-start> show_object ( obj , NULL , name , data ) ; <vul-end> continue ; } if ( ! path ) path = \"\" ; if ( obj -> type == OBJ_TREE ) { process_tree ( revs , ( struct tree * ) obj , show_object , & base , path , data ) ; continue ; } if ( obj -> type == OBJ_BLOB ) { process_blob ( revs , ( struct blob * ) obj , show_object , <vul-start> NULL , path , data ) ; <vul-end> continue ; } die ( \"unknown pending object %s (%s)\" , oid_to_hex (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( obj , <vul-end> name , data <vul-start> , show_object , & base <vul-end> , path ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> |= SEEN ; if ( name [ 0 ] == '\\\\0' ) { strbuf_addch ( & base,'' ) ; } <vul-start>, show_object, & base, path, data ) ; continue ; } if ( obj -> type == OBJ_COMMENT ) { obj -> flags |= SEEN ; if ( name [ 0 ] == '\\\\0' ) { strbuf_addch ( & base,'' ) ; } <vul-end> continue ; }\n"
 },
 {
  "id": 919,
  "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static void f_parser ( lua_State * L , void * ud ) { int i ; Proto * tf ; Closure * cl ; struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p -> z ) ; luaC_checkGC ( L ) ; <vul-start> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <vul-end> & p -> buff , p -> name ) ; cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; cl -> l . p = tf ; for ( i = 0 ; i < tf -> nups ; i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ; setclvalue ( L , L -> top , cl ) ; incr_top ( L ) ; }",
  "golden_answers": [
   "CWE-17 Fixed Code Lines are: <vul-start> tf = ( <vul-end> luaY_parser ) (\n"
  ],
  "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> ] )? luaU_undump : luaY_parser ) ( L, p -> z, <vul-end> & p ->\n"
 },
 {
  "id": 920,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 void update_process_times ( int user_tick ) { struct task_struct * p = current ; account_process_tick ( p , user_tick ) ; run_local_timers ( ) ; rcu_sched_clock_irq ( user_tick ) ; # ifdef CONFIG_IRQ_WORK if ( in_irq ( ) ) irq_work_tick ( ) ; # endif scheduler_tick ( ) ; if ( IS_ENABLED ( CONFIG_POSIX_TIMERS ) ) run_posix_cpu_timers ( ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ( ) ; this_cpu_add ( net_rand_state . s1 , rol32 ( jiffies , 24 ) + user_tick ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ( ) ; # ifdef CONFIG_IS_ENABLED ( CONFIG_POSIX_TIMERS ) && defined ( CONFIG_CPU_TIMER_CONVERT ) if ( IS_ENABLED ( CONFIG_CPU_TIMER_CONVERT ) ) posix_cpu_timers ( ) ; # endif\n"
 },
 {
  "id": 921,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_skip_fractional_mv_step ( MACROBLOCK * mb , BLOCK * b , BLOCKD * d , int_mv * bestmv , int_mv * ref_mv , int error_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvcost [ 2 ] , int * distortion , unsigned int * sse ) { ( void ) b ; ( void ) d ; ( void ) ref_mv ; ( void ) error_per_bit ; ( void ) vfp ; <vul-start> ( void ) mvcost ; <vul-end> ( void ) distortion ; ( void ) sse ; bestmv -> as_mv . row <<= 3 ; bestmv -> as_mv . col <<= 3 ; return 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( void ) mb ; ( void )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( void ) <vul-end> sse ; bestmv\n"
 },
 {
  "id": 922,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , \"%s unable to load config file; attempting to transcode legacy file.\" , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , \"%s unable to transcode legacy file, starting unconfigured.\" , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( LOG_TAG , \"%s unable to allocate a config object.\" , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } <vul-start> alarm_timer = alarm_new ( ) ; <vul-end> if ( ! alarm_timer ) { LOG_ERROR ( LOG_TAG , \"%s unable to create alarm.\" , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) ; } btif_config_devcache_cleanup ( ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ; } btif_config_set_delay ( config, DEFAULT_DELAY ) ;\n"
 },
 {
  "id": 923,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ; <vul-start> int groups_per_flex = 0 ; <vul-end> size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; <vul-start> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <vul-end> <vul-start> if ( groups_per_flex < 2 ) { <vul-end> sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , \"not enough memory for %u flex groups\" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] .",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> ext4_group_t flex_group ; unsigned <vul-start> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <vul-start> -> s_log_groups_per_flex ; <vul-end> flex_group_count = (\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ext4_group_t flex_group ; unsigned int <vul-end> groups_per_flex = 0 <vul-start> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 2 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <vul-start> -> s_log_groups_per_flex ; <vul-end> flex_group_count = (\n"
 },
 {
  "id": 924,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int32_t scsi_send_command ( SCSIRequest * req , uint8_t * buf ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; int32_t len ; uint8_t command ; <vul-start> uint8_t * outbuf ; <vul-end> int rc ; <vul-start> command = buf [ 0 ] ; <vul-end> outbuf = ( uint8_t * ) r -> iov . iov_base ; DPRINTF ( \"Command: lun=%d tag=0x%x data=0x%02x\" , req -> lun , req -> tag , buf [ 0 ] ) ; # ifdef DEBUG_SCSI { int i ; for ( i = 1 ; i < r -> req . cmd . len ; i ++ ) { printf ( \" 0x%02x\" , buf [ i ] ) ; } printf ( \"\\\\n\" ) ; } # endif switch ( command ) { case TEST_UNIT_READY : case INQUIRY : case MODE_SENSE : case MODE_SENSE_10 : case RESERVE : case RESERVE_10 : case RELEASE : case RELEASE_10 : case START_STOP : case ALLOW_MEDIUM_REMOVAL : case READ_CAPACITY_10 : case READ_TOC : case GET_CONFIGURATION : case SERVICE_ACTION_IN_16 : case VERIFY_10 : <vul-start> rc = scsi_disk_emulate_command ( r , outbuf ) ; <vul-end> if ( rc < 0 ) { return 0 ; } r -> iov . iov_len = rc ; break ; case SYNCHRONIZE_CACHE : bdrv_acct_start ( s -> bs , & r -> acct , 0 , BDRV_ACCT_FLUSH ) ; r -> req . aiocb = bdrv_aio_flush ( s -> bs , scsi_flush_complete , r ) ; if (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> uint8_t command ; <vul-end> int rc ; <vul-start> [ 0 ] <vul-end> ; DPRINTF ( <vul-start> scsi_disk_emulate_command ( r <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> uint8_t command ; <vul-end> int rc ; <vul-start> command = buf <vul-end> ; DPRINTF ( <vul-start> scsi_disk_emulate_command ( r <vul-end> ) ; if <vul-start> 0 ) { goto fail <vul-end> ; } r\n"
 },
 {
  "id": 925,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , \"Seems not to be a TNEF file\\\\n\" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( \"TNEF Key: %hx\\\\n\" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( a -> type == szMAPI_BINARY && a -> <vul-start> else if ( a -> type == szMAPI_BINARY &&\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> name == MAPI_BODY_HTML && a -> len > 0 <vul-start> name == MAPI_RTF_COMPRESSED && a -> len > 0\n"
 },
 {
  "id": 926,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int matchCurrentInput ( const InString * input , int pos , const widechar * passInstructions , int passIC ) { int k ; int kk = pos ; <vul-start> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <vul-end> if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ; return 1 ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> + 2 ; ( ( <vul-start> + 1 ] ) && ( kk < input -> length ) )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = pos ; if ( passIC < 2 || passIC > 16 ) return 0 ;\n"
 },
 {
  "id": 927,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; <vul-start> int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <vul-end> int hexdump ; <vul-start> int offset , subobj_type , subobj_len , total_subobj_len ; <vul-end> int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , \"LMP version %u packet not supported\" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , \"LMPv%u %s Message, length: %u\" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , \"unknown (%u)\" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\tLMPv%u, msg-type: %s, Flags: [%s], length: %u\" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , \"unknown, type: %u\" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , \"none\" , lmp_com_header -> flags ) , tlen ) ) ; <vul-start> tptr += sizeof ( const struct lmp_common_header ) ; <vul-end> tlen -= sizeof ( const struct",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> * obj_tptr ; u_int <vul-end> tlen , lmp_obj_len <vul-start> int hexdump ; u_int offset ; u_int <vul-end> link_type ; union <vul-start> ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , \" (too short)\" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , \" (too long)\" ) ) ; tlen = len ; } <vul-start> & 0x7f ; <vul-end> ND_PRINT ( ( <vul-start> ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , \" (too short)\" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , \" (not a multiple of 4)\" ) ) ; return ; } <vul-start> case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Link-ID: %s (0x%08x)\" \"\\\\n\\\\t    Remote Link-ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: [%s]\" , bittok2str ( lmp_obj_te_link_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; <vul-end> ND_PRINT ( ( <vul-start> \"\\\\n\\\\t    Local Link-ID: %s (0x%08x)\" \"\\\\n\\\\t    Remote Link-ID: %s (0x%08x)\" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: [%s]\" , bittok2str ( lmp_obj_te_link_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Link-ID: %u (0x%08x)\" \"\\\\n\\\\t    Remote Link-ID: %u (0x%08x)\" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( <vul-end> obj_tptr + 8 <vul-start> ; break ; <vul-end> default : hexdump <vul-start> case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } <vul-start> , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Interface ID: %s (0x%08x)\" \"\\\\n\\\\t    Remote Interface ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: [%s]\" , bittok2str ( lmp_obj_data_link_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Interface ID: %s (0x%08x)\" \"\\\\n\\\\t    Remote Interface ID: %s (0x%08x)\" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: [%s]\" , bittok2str ( lmp_obj_data_link_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Interface ID: %u (0x%08x)\" \"\\\\n\\\\t    Remote Interface ID: %u (0x%08x)\" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Flags: %s\" , bittok2str ( lmp_obj_begin_verify_flag_values , \"none\" , <vul-start> ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Verify Interval: %u\" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Data links: %u\" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Encoding type: %s\" , tok2str ( gmpls_encoding_values , \"Unknown\" , * ( obj_tptr + <vul-end> 8 ) ) <vul-start> ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Verify Transport Mechanism: %u (0x%x)%s\" , <vul-end> EXTRACT_16BITS ( obj_tptr <vul-start> ( obj_tptr + 10 ) , <vul-end> EXTRACT_16BITS ( obj_tptr <vul-start> ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? \" (Payload test messages capable)\" : \"\" <vul-end> ) ) ; <vul-start> ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Transmission Rate: %.3f Mbps\" , <vul-end> bw . f <vul-start> ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Wavelength: %u\" , EXTRACT_32BITS ( obj_tptr + 16 <vul-end> ) ) ) <vul-start> = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Verify Dead Interval: %u\" \"\\\\n\\\\t    Verify Transport Response: %u\" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; <vul-end> default : hexdump <vul-start> break ; case LMP_OBJ_VERIFY_ID <vul-end> : switch ( <vul-start> case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Verify ID: %u\" , EXTRACT_32BITS ( obj_tptr <vul-end> ) ) ) <vul-start> break ; case LMP_OBJ_CHANNEL_STATUS <vul-end> : switch ( <vul-start> ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Active: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? \"Allocated\" : \"Non-allocated\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Direction: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? \"Transmit\" : \"Receive\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Channel Status: %s (%u)\" , tok2str ( lmp_obj_channel_status_values , \"Unknown\" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %s (0x%08x)\" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Active: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? \"Allocated\" : \"Non-allocated\" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Direction: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? \"Transmit\" : \"Receive\" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Channel Status: %s (%u)\" , tok2str ( lmp_obj_channel_status_values , \"Unknown\" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %u (0x%08x)\" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Active: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? \"Allocated\" : \"Non-allocated\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Direction: %s (%u)\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? \"Transmit\" : \"Receive\" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t    Channel Status: %s (%u)\" , tok2str ( lmp_obj_channel_status_values , \"Unknown\" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } <vul-end> break ; default <vul-start> break ; case LMP_OBJ_CHANNEL_STATUS_REQ <vul-end> : switch ( <vul-start> ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %s (0x%08x)\" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t    Interface ID: %u (0x%08x)\" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } <vul-end> break ; default <vul-start> break ; case LMP_OBJ_ERROR_CODE <vul-end> : switch ( <vul-start> ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Error Code: %s\" , bittok2str ( lmp_obj_begin_verify_error_values , \"none\" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t    Error Code: %s\" , bittok2str ( lmp_obj_link_summary_error_values , \"none\" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; <vul-end> default : hexdump <vul-start> break ; case LMP_OBJ_SERVICE_CONFIG <vul-end> : switch ( <vul-start> ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t Flags: %s\" <vul-end> , bittok2str ( <vul-start> , bittok2str ( lmp_obj_service_config_sp_flag_values <vul-end> , \"none\" , <vul-start> , \"none\" , EXTRACT_8BITS ( obj_tptr ) <vul-end> ) ) ) <vul-start> , \"\\\\n\\\\t  UNI Version: %u\" , EXTRACT_8BITS ( obj_tptr + 1 ) <vul-end> ) ) ; <vul-start> case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Link Type: %s (%u)\" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , \"Unknown\" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , \"\\\\n\\\\t Signal Type: %s (%u)\" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , \"Unknown\" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , \"\\\\n\\\\t Signal Type: %s (%u)\" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , \"Unknown\" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t Transparency: %s\" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Contiguous Concatenation Types: %s\" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Minimum NCC: %u\" , <vul-end> EXTRACT_16BITS ( obj_tptr <vul-start> EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Maximum NCC: %u\" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Minimum NVC:%u\" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t Maximum NVC:%u\" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t    Local Interface ID: %s (0x%08x)\" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t Transparency Flags: %s\" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , \"none\" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t TCM Monitoring Flags: %s\" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , \"none\" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , \" (not correct for object)\" ) ) ; break ; } ND_PRINT ( ( ndo , \"\\\\n\\\\t Diversity: Flags: %s\" <vul-end> , bittok2str ( <vul-start> , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values <vul-end> , \"none\" , <vul-start> , \"none\" , EXTRACT_8BITS ( obj_tptr + 3 ) <vul-end> ) ) )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> * obj_tptr ; unsigned <vul-start> int tlen, <vul-end> lmp_obj_len, lmp_obj_ctype <vul-start> & 0x7f ; ND_TCHECK_16BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_UNMD_RMT : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_2 : ND_TCHECK_16BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_RMT : ND_TCHECK_16BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_TE_LINK : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_UNMD_RMT : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_1 : ND_TCHECK_16BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_2 : ND_TCHECK_16BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_HELLO : ND_TCHECK_32BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_IPV6_RMT : ND_TCHECK_16BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_UNMD_LOC : ND_TCHECK_16BITS ( obj_tptr ) ; <vul-start> case LMP_CTYPE_UNMD_RMT : ND_TCHECK_16BITS ( obj_tptr ) ;\n"
 },
 {
  "id": 928,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static void findoprnd ( ITEM * ptr , int32 * pos ) <vul-start> { <vul-end> if ( ptr [ * pos ] . type == VAL || ptr [ * pos ] . type == VALTRUE ) { ptr [ * pos ] . left = 0 ; ( * pos ) ++ ; } else if ( ptr [ * pos ] . val == ( int32 ) '!' ) { ptr [ * pos ] . left = 1 ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; } else { ITEM * curitem = & ptr [ * pos ] ; int32 tmp = * pos ; ( * pos ) ++ ; findoprnd ( ptr , pos ) ; curitem -> left = * pos - tmp ; findoprnd ( ptr , pos ) ; } }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> pos ) { check_stack_depth ( ) ;\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> pos ) { check_stack_depth ( ) ;\n"
 },
 {
  "id": 929,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int phar_verify_signature ( php_stream * fp , size_t end_of_phar , php_uint32 sig_type , char * sig , int sig_len , char * fname , char * * signature , int * signature_len , char * * error ) { int read_size , len ; zend_off_t read_len ; unsigned char buf [ 1024 ] ; php_stream_rewind ( fp ) ; switch ( sig_type ) { case PHAR_SIG_OPENSSL : { # ifdef PHAR_HAVE_OPENSSL BIO * in ; EVP_PKEY * key ; EVP_MD * mdtype = ( EVP_MD * ) EVP_sha1 ( ) ; EVP_MD_CTX md_ctx ; # else int tempsig ; # endif zend_string * pubkey = NULL ; char * pfile ; php_stream * pfp ; # ifndef PHAR_HAVE_OPENSSL if ( ! zend_hash_str_exists ( & module_registry , \"openssl\" , sizeof ( \"openssl\" ) - 1 ) ) { if ( error ) { spprintf ( error , 0 , \"openssl not loaded\" ) ; } return FAILURE ; } # endif spprintf ( & pfile , 0 , \"%s.pubkey\" , fname ) ; pfp = php_stream_open_wrapper ( pfile , \"rb\" , 0 , NULL ) ; efree ( pfile ) ; if ( ! pfp || ! ( pubkey = php_stream_copy_to_mem ( pfp , PHP_STREAM_COPY_ALL , 0 ) ) || ! ZSTR_LEN ( pubkey ) ) { if ( pfp ) { php_stream_close ( pfp ) ; } if ( error ) { spprintf ( error , 0 , \"openssl public key could not be read\" ) ; } return FAILURE ; } php_stream_close ( pfp ) ; # ifndef PHAR_HAVE_OPENSSL tempsig = sig_len ; if",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> PHP_SHA512_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , \"broken signature\" ) ; } return FAILURE ; } <vul-start> PHP_SHA256_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , \"broken signature\" ) ; } return FAILURE ; } <vul-start> PHP_SHA1_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , \"broken signature\" ) ; } return FAILURE ; } <vul-start> PHP_MD5_CTX context ; if ( sig_len < sizeof ( digest <vul-end> ) ) { <vul-start> FAILURE ; } PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , \"broken signature\" ) ; } return FAILURE ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> PHP_SHA512_CTX context ; if (! <vul-start> & context ) ) { return FAILURE ; } <vul-end> read_len = end_of_phar <vul-start> context ) ; if (! context. ctx ) { return FAILURE ; }\n"
 },
 {
  "id": 930,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int mct_u232_port_probe ( struct usb_serial_port * port ) { <vul-start> struct mct_u232_private * priv ; <vul-end> priv = kzalloc ( sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; <vul-start> priv -> read_urb = port -> serial -> port [ 1 ] -> interrupt_in_urb ; <vul-end> priv -> read_urb -> context = port ; spin_lock_init ( & priv -> lock ) ; usb_set_serial_port_data ( port , priv ) ; return 0 ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ) { struct usb_serial * serial = port -> serial ; struct <vul-start> * priv ; if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , \"expected endpoint missing\\\\n\" ) ; return - ENODEV ; } <vul-start> -> read_urb = <vul-end> serial -> port\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> port ) { struct usb_serial * serial = port -> serial ; <vul-start> -> read_urb = serial <vul-end> -> port [\n"
 },
 {
  "id": 931,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static netdev_tx_t veth_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct net_device * rcv = NULL ; struct veth_priv * priv , * rcv_priv ; struct veth_net_stats * stats , * rcv_stats ; int length ; priv = netdev_priv ( dev ) ; rcv = priv -> peer ; rcv_priv = netdev_priv ( rcv ) ; stats = this_cpu_ptr ( priv -> stats ) ; rcv_stats = this_cpu_ptr ( rcv_priv -> stats ) ; if ( ! ( rcv -> flags & IFF_UP ) ) goto tx_drop ; if ( dev -> features & NETIF_F_NO_CSUM ) skb -> ip_summed = rcv_priv -> ip_summed ; length = skb -> len + ETH_HLEN ; if ( dev_forward_skb ( rcv , skb ) != NET_RX_SUCCESS ) goto rx_drop ; stats -> tx_bytes += length ; stats -> tx_packets ++ ; rcv_stats -> rx_bytes += length ; rcv_stats -> rx_packets ++ ; return NETDEV_TX_OK ; tx_drop : kfree_skb ( skb ) ; stats -> tx_dropped ++ ; return NETDEV_TX_OK ; rx_drop : <vul-start> kfree_skb ( skb ) ; <vul-end> rcv_stats -> rx_dropped ++ ; return NETDEV_TX_OK ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ; rx_drop : <vul-end> rcv_stats -> rx_dropped\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ; rx_drop : if ( unlikely (! pskb_is_gso ( skb ) ) )\n"
 },
 {
  "id": 932,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <vul-start> int is_rf64 = ! strncmp ( fourcc , \"RF64\" , 4 ) , got_ds64 = 0 ; <vul-end> int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( \"can\\'t handle .WAV files larger than 4 GB (non-standard)!\" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , \"WAVE\" , 4 ) ) ) { error_line ( \"%s is not a valid .WAV file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) , got_ds64 = 0 , format_chunk <vul-start> , format ; if ( format_chunk ++ ) { error_line ( \"%s is not a valid .WAV file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int is_rf64 = ( <vul-start>, 4 ) ) == 0 <vul-start> { int is_rf64 = ( <vul-end>! strncmp ( <vul-start>, 4 ) ) == 0\n"
 },
 {
  "id": 933,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <vul-start> rq = blk_mq_tag_to_rq ( tags , off + bit ) ; <vul-end> fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> { rq = tags -> rqs [ <vul-end> off + bit <vul-start> off + bit ] <vul-end> ; fn (\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> { rq = <vul-end> fn ( rq\n"
 },
 {
  "id": 934,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void build_tree_distribution ( VP9_COMP * cpi , TX_SIZE tx_size , <vul-start> vp9_coeff_stats * coef_branch_ct ) { <vul-end> <vul-start> vp9_coeff_probs_model * coef_probs = cpi -> frame_coef_probs [ tx_size ] ; <vul-end> vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ; unsigned int ( * eob_branch_ct ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { vp9_tree_probs_from_distribution ( vp9_coef_tree , coef_branch_ct [ i ] [ j ] [ k ] [ l ] , coef_counts [ i ] [ j ] [ k ] [ l ] ) ; coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 1 ] = eob_branch_ct [ i ] [ j ] [ k ] [ l ] - coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 0 ] ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) coef_probs [ i ] [ j ] [ k ] [ l ] [ m ] = get_binary_prob ( coef_branch_ct [ i ] [ j ]",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> vp9_coeff_stats * coef_branch_ct , <vul-end> vp9_coeff_probs_model * coef_probs <vul-start> vp9_coeff_probs_model * coef_probs ) { vp9_coeff_count * coef_counts <vul-start> = cpi -> td . rd_counts . <vul-end> coef_counts [ tx_size\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vp9_coeff_stats * coef_branch_ct, vpx_coeff_probs_model * coef_probs <vul-start> tx_size ] ; if ( coef_probs == NULL ) { return ; }\n"
 },
 {
  "id": 935,
  "question": "CWE-255 Code Input Vulnerable Code Is: CWE-255 static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ; <vul-start> assert ( name ) ; <vul-end> r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; if ( r < 0 ) return log_warning_errno ( errno , \"Failed to %s UTF-8 kbdmode on %s: %m\" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? \"\\\\033%G\" : \"\\\\033%@\" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , \"Failed to %s UTF-8 term processing on %s: %m\" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { SET_FLAG ( tc . c_iflag , IUTF8 , utf8 ) ; r = tcsetattr ( fd , TCSANOW , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , \"Failed to %s iutf8 flag on %s: %m\" , enable_disable ( utf8 ) , name ) ; log_debug ( \"UTF-8 kbdmode %sd on %s\" , enable_disable ( utf8 ) , name ) ; return 0 ; }",
  "golden_answers": [
   "CWE-255 Fixed Code Lines are: <vul-start> ; assert ( name ) ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_warning_errno ( r , \"Virtual console %s is not in K_XLATE or K_UNICODE: %m\" , name ) ; return 0 ; } else if ( r < 0 ) return log_warning_errno ( r , \"Failed to verify kbdmode on %s: %m\" ,\n"
  ],
  "generated_answer": "CWE-255 Fixed Code Lines are: <vul-start> { } ; if ( name == NULL ) return log_warning_errno ( errno, \"Invalid input string %s\", name ) ; <vul-end> r = ioctl\n"
 },
 {
  "id": 936,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int setupLookaside ( sqlite3 * db , void * pBuf , int sz , int cnt ) { # ifndef SQLITE_OMIT_LOOKASIDE void * pStart ; if ( sqlite3LookasideUsed ( db , 0 ) > 0 ) { return SQLITE_BUSY ; } if ( db -> lookaside . bMalloced ) { sqlite3_free ( db -> lookaside . pStart ) ; } sz = ROUNDDOWN8 ( sz ) ; if ( sz <= ( int ) sizeof ( LookasideSlot * ) ) sz = 0 ; if ( cnt < 0 ) cnt = 0 ; if ( sz == 0 || cnt == 0 ) { sz = 0 ; pStart = 0 ; } else if ( pBuf == 0 ) { sqlite3BeginBenignMalloc ( ) ; <vul-start> pStart = sqlite3Malloc ( sz * cnt ) ; <vul-end> sqlite3EndBenignMalloc ( ) ; if ( pStart ) cnt = sqlite3MallocSize ( pStart ) / sz ; } else { pStart = pBuf ; } db -> lookaside . pStart = pStart ; db -> lookaside . pInit = 0 ; db -> lookaside . pFree = 0 ; db -> lookaside . sz = ( u16 ) sz ; if ( pStart ) { int i ; LookasideSlot * p ; assert ( sz > ( int ) sizeof ( LookasideSlot * ) ) ; db -> lookaside . nSlot = cnt ; p = ( LookasideSlot * ) pStart ; for ( i = cnt - 1 ; i >= 0 ; i -- ) { p -> pNext = db -> lookaside . pInit",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ( sz * ( sqlite3_int64 )\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; pStart = sqlite3Malloc64 <vul-end> ( sz *\n"
 },
 {
  "id": 937,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int su3000_frontend_attach ( struct dvb_usb_adapter * d ) <vul-end> { u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x02 ; <vul-end> <vul-start> obuf [ 2 ] = 1 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> msleep ( 300 ) ; <vul-end> obuf [ 0 ] = 0xe ; <vul-start> obuf [ 1 ] = 0x83 ; <vul-end> <vul-start> obuf [ 2 ] = 0 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> obuf [ 1 ] = 0x83 ; obuf [ 2 ] = 1 ; <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> <vul-start> err ( \"command 0x0e transfer failed.\" ) ; <vul-end> obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( \"command 0x0e transfer failed.\" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; msleep ( 300 ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> 2 ] = 0 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> 2 ] = 1 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data [ 0 ] = 0x51 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <vul-end> , 1 , <vul-start> ) err ( <vul-end> \"command 0x51 transfer failed.\" ) ; <vul-start> \"command 0x51 transfer failed.\" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <vul-end> -> fe_adap [ <vul-start> & d -> <vul-end> i2c_adap ) ; <vul-start> ; if ( adap <vul-end> -> fe_adap [ <vul-start> ( ts2020_attach , adap <vul-end> -> fe_adap [ <vul-start> , & d <vul-end> -> i2c_adap )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data <vul-end> [ 2 ] <vul-start> 2 ] = 1 ; if ( dvb_usb_generic_rw ( d -> dev, state -> data, 3, ibuf, 1, 0 ) < 0 ) err ( \"command 0x0e data mutex failed.\" ) ; mutex_unlock ( & d -> data_mutex ) ; <vul-end> if ( dvb_usb_generic_rw <vul-start> ( d -> data_mutex ) ; adap <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x02 ; state -> data <vul-end> [ 2 ] <vul-start> = 1 ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> = 0 ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> = 1 ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> = 1 ; state -> data <vul-end> [ 0 ] <vul-start> = 1 ; state -> data [ 1 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev, state -> data, 1, ibuf, 1, 0 ) < 0 ) err ( \"command 0x0e data mutex failed.\" ) ; adap <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> = 0 ; state -> data <vul-end> [ 0 ] <vul-start> = 0 ; state -> data [ 1 ] = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> = 1 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d -> dev, state -> data, 1, ibuf"
 },
 {
  "id": 938,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int sock_close ( struct inode * inode , struct file * filp ) { <vul-start> sock_release ( SOCKET_I ( inode ) ) ; <vul-end> return 0 ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> filp ) { __sock_release <vul-end> ( SOCKET_I ( <vul-start> ( inode ) , inode\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> filp ) { struct sock * sk = <vul-end> SOCKET_I ( inode <vul-start> ( inode ) ; struct sock * sk = SOCKET_I ( inode ) ; mutex_unlock ( & sk -> i_mutex ) ; sock_release ( sk\n"
 },
 {
  "id": 939,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int ipxitf_ioctl ( unsigned int cmd , void __user * arg ) { int rc = - EINVAL ; struct ifreq ifr ; int val ; switch ( cmd ) { case SIOCSIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface_definition f ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; rc = - EINVAL ; if ( sipx -> sipx_family != AF_IPX ) break ; f . ipx_network = sipx -> sipx_network ; memcpy ( f . ipx_device , ifr . ifr_name , sizeof ( f . ipx_device ) ) ; memcpy ( f . ipx_node , sipx -> sipx_node , IPX_NODE_LEN ) ; f . ipx_dlink_type = sipx -> sipx_type ; f . ipx_special = sipx -> sipx_special ; if ( sipx -> sipx_action == IPX_DLTITF ) rc = ipxitf_delete ( & f ) ; else rc = ipxitf_create ( & f ) ; break ; } case SIOCGIFADDR : { struct sockaddr_ipx * sipx ; struct ipx_interface * ipxif ; struct net_device * dev ; rc = - EFAULT ; if ( copy_from_user ( & ifr , arg , sizeof ( ifr ) ) ) break ; sipx = ( struct sockaddr_ipx * ) & ifr . ifr_addr ; dev = __dev_get_by_name ( & init_net , ifr . ifr_name ) ; rc = - ENODEV ; if ( ! dev ) break ; ipxif = ipxitf_find_using_phys ( dev , ipx_map_frame_type ( sipx -> sipx_type",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <vul-start> - EFAULT ; <vul-end> ipxitf_put ( ipxif <vul-start> ( ipxif ) <vul-end> ; break ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; ipxitf_put ( ipxif ) ; <vul-start> arg, & sipx -> sipx_ifr, sizeof ( sipx -> sipx_ifr <vul-end> ) ) ) <vul-start> ) break ; <vul-end> rc = 0\n"
 },
 {
  "id": 940,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_32 ( dst_reg ) ; coerce_reg_to_32 ( & src_reg ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> break ; } <vul-end> dst_reg -> smin_value <vul-start> = S64_MAX ; <vul-end> if ( src_known\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> break ; } switch ( opcode ) { case BPF_ADD : if ( src_known ) { __mark_reg_unknown ( dst_reg ) ; break ; } case BPF_SUB : if ( src_known ) { __mark_reg_unknown ( dst_reg ) ; break ; } <vul-start> S64_MAX ; } break ; case BPF_AND : if ( src_known ) { __mark_reg_unknown ( dst_reg ) ; break ; }\n"
 },
 {
  "id": 941,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , <vul-start> vpx_codec_enc_cfg_t * cfg , <vul-end> vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; <vul-start> else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) <vul-end> res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } <vul-start> if ( ctx -> priv ) <vul-end> ctx -> priv -> iface = ctx -> iface ; } return SAVE_STATUS ( ctx , res ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * iface , const <vul-start> ( flags & <vul-end> VPX_CODEC_USE_PSNR ) && <vul-start> ) ; } <vul-end> } return SAVE_STATUS\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * iface, const <vul-start> ( flags & <vul-end> VPX_CODEC_USE_PSNR ) && <vul-start> ) ; } <vul-end> } return SAVE_STATUS\n"
 },
 {
  "id": 942,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int decode_cblk ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * codsty , Jpeg2000T1Context * t1 , Jpeg2000Cblk * cblk , int width , int height , int bandpos ) { int passno = cblk -> npasses , pass_t = 2 , bpno = cblk -> nonzerobits - 1 , y ; int clnpass_cnt = 0 ; int bpass_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_BYPASS ; <vul-start> int vert_causal_ctx_csty_symbol = codsty -> cblk_style & JPEG2000_CBLK_VSC ; <vul-end> for ( y = 0 ; y < height ; y ++ ) memset ( t1 -> data [ y ] , 0 , width * sizeof ( * * t1 -> data ) ) ; if ( ! cblk -> length ) return 0 ; for ( y = 0 ; y < height + 2 ; y ++ ) memset ( t1 -> flags [ y ] , 0 , ( width + 2 ) * sizeof ( * * t1 -> flags ) ) ; cblk -> data [ cblk -> length ] = 0xff ; cblk -> data [ cblk -> length + 1 ] = 0xff ; ff_mqc_initdec ( & t1 -> mqc , cblk -> data ) ; while ( passno -- ) { switch ( pass_t ) { case 0 : decode_sigpass ( t1 , width , height , bpno + 1 , bandpos , bpass_csty_symbol && ( clnpass_cnt >= 4 ) , vert_causal_ctx_csty_symbol ) ; break ; case 1 : decode_refpass ( t1 , width , height , bpno + 1 ) ; if ( bpass_csty_symbol && clnpass_cnt >= 4 )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> & JPEG2000_CBLK_VSC ; if ( width < 0 || height < 0 || width >= height ) return 0 ; if ( width >= 4 || height >= 4 ) return 0 ;\n"
 },
 {
  "id": 943,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride , <vul-start> int uv_block_size , <vul-end> int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) { const int which_mv = 0 ; const MV mv = { mv_row , mv_col } ; const InterpKernel * const kernel = <vul-start> vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ; <vul-end> enum mv_precision mv_precision_uv ; int uv_stride ; <vul-start> if ( uv_block_size == 8 ) { <vul-end> uv_stride = ( stride + 1 ) >> 1 ; mv_precision_uv = MV_PRECISION_Q4 ; } else { uv_stride = stride ; mv_precision_uv = MV_PRECISION_Q3 ; } <vul-start> vp9_build_inter_predictor ( y_mb_ptr , stride , <vul-end> & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ; vp9_build_inter_predictor ( u_mb_ptr , uv_stride , <vul-start> & pred [ 256 ] , uv_block_size , <vul-end> & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; vp9_build_inter_predictor ( v_mb_ptr , uv_stride , <vul-start> & pred [ 512 ] , uv_block_size , <vul-end> & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> stride , int uv_block_width , int uv_block_height <vul-end> , int mv_row <vul-start> const kernel = vp9_filter_kernels [ <vul-end> xd -> mi <vul-start> mbmi . interp_filter ] <vul-end> ; enum mv_precision <vul-start> ; if ( uv_block_width <vul-end> == 8 ) <vul-start> MV_PRECISION_Q3 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; return ; } # endif <vul-start> 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <vul-end> , which_mv , <vul-start> 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <vul-end> , which_mv ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, int uv_block_size, int uv_filter_size <vul-start> const kernel = vp9_filter_kernels [ <vul-end> xd -> mi <vul-start>. interp_filter ] <vul-end> ; enum mv_precision <vul-start> int uv_stride ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { mv_row = MV_PRECISION_Q4 ; break ; } # endif if ( uv_block_size == 8 ) { uv_stride = ( stride + 1 ) >> 1 ; mv_precision_uv = MV_PRECISION_Q3 ; } else { uv_stride = stride ; mv_precision_uv = MV_PRECISION_Q4 ; } <vul-end> vp9_build_inter_predictor ( y_mb_ptr <vul-start> MV_PRECISION_Q3 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { uv_stride = ( stride + 1 ) >> 1 ; mv_precision_uv = MV_PRECISION_HIGHBITDEPTH ; } else { uv_stride = stride ; mv_precision_uv = MV_PRECISION_Q3 ; } # else vp9_build_inter_predictor ( y_mb_ptr, stride, & pred [ 0 ], 16, & mv, scale, 16, 16, which_mv, kernel, MV_PRECISION_Q3, x, y ) ; vp9_build_inter_predictor ( u_mb_ptr, uv_stride, & pred [ 256 ], uv_block_size, & mv, scale, uv_block_size, uv_block_size, which_mv, kernel, mv_precision_uv, x, y ) ; vp9_build_inter_predictor ( v_mb_ptr, uv_stride, & pred [ 512 ], uv_block_size, & mv, scale, uv_block_size, uv_block_size, which_mv, kernel, mv_precision_uv, x, y ) ; } # else vp9_build_inter_predictor ( y_mb_ptr, uv_stride, & pred [ 0 ], 16, & mv, scale, 16, 16"
 },
 {
  "id": 944,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static __forceinline void draw_line ( float * output , int x0 , int y0 , int x1 , int y1 , int n ) { int dy = y1 - y0 ; int adx = x1 - x0 ; int ady = abs ( dy ) ; int base ; int x = x0 , y = y0 ; int err = 0 ; int sy ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( adx < DIVTAB_DENOM && ady < DIVTAB_NUMER ) { if ( dy < 0 ) { base = - integer_divide_table [ ady ] [ adx ] ; sy = base - 1 ; } else { base = integer_divide_table [ ady ] [ adx ] ; sy = base + 1 ; } } else { base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; } # else base = dy / adx ; if ( dy < 0 ) sy = base - 1 ; else sy = base + 1 ; # endif ady -= abs ( base ) * adx ; if ( x1 > n ) x1 = n ; if ( x < x1 ) { <vul-start> LINE_OP ( output [ x ] , inverse_db_table [ y ] ) ; <vul-end> for ( ++ x ; x < x1 ; ++ x ) { err += ady ; if ( err >= adx ) { err -= adx ; y += sy ; } else y += base ; <vul-start> LINE_OP (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> inverse_db_table [ y & 255 <vul-start> inverse_db_table [ y & 255\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> x1 ) { # ifdef STB_VORBIS_HIGHBITDEPTH if ( y < 16 ) { y = 16 ; } # endif <vul-start> += base ; # ifdef STB_VORBIS_HIGHBITDEPTH if ( y < 16 ) { y = 16 ; } # endif <vul-start> += base ; # ifdef STB_VORBIS_HIGHBITDEPTH if ( y < 16 ) { y = 16 ; } # endif\n"
 },
 {
  "id": 945,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static struct mobj * alloc_ta_mem ( size_t size ) { # ifdef CFG_PAGED_USER_TA return mobj_paged_alloc ( size ) ; # else struct mobj * mobj = mobj_mm_alloc ( mobj_sec_ddr , size , & tee_mm_sec_ddr ) ; <vul-start> if ( mobj ) <vul-end> <vul-start> memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; <vul-end> return mobj ; # endif }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> ( mobj ) { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; <vul-start> , 0 , ROUNDUP ( size , granularity ) ) ; } <vul-end> return mobj ;\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ( mobj ) { <vul-start> size ) ; }\n"
 },
 {
  "id": 946,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int read_escaped_char ( yyscan_t yyscanner , uint8_t * escaped_char ) { char text [ 4 ] = { 0 , 0 , 0 , 0 } ; text [ 0 ] = '\\\\\\\\' ; text [ 1 ] = RE_YY_INPUT ( yyscanner ) ; <vul-start> if ( text [ 1 ] == EOF ) <vul-end> return 0 ; if ( text [ 1 ] == 'x' ) { text [ 2 ] = RE_YY_INPUT ( yyscanner ) ; <vul-start> if ( text [ 2 ] == EOF ) <vul-end> return 0 ; text [ 3 ] = RE_YY_INPUT ( yyscanner ) ; <vul-start> if ( text [ 3 ] == EOF ) <vul-end> return 0 ; } * escaped_char = escaped_char_value ( text ) ; return 1 ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ] == EOF || text [ 1 ] == 0 <vul-start> ; if ( ! isxdigit ( <vul-start> [ 2 ] ) <vul-end> ) return 0 <vul-start> ; if ( ! isxdigit ( <vul-start> [ 3 ] ) <vul-end> ) return 0\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ; if ( ( text [ 1 ] == EOF ) || ( text [ 1 ] == 'x' ) ) <vul-end> return 0 ; <vul-start> ; if ( ( text [ 2 ] == EOF ) || ( text [ 3 ] == EOF ) <vul-end> return 0 ; <vul-start> ; if ( ( text [ 3 ] == EOF ) || ( text [ 3 ] == 'x' ) ) <vul-end> return 0 ;\n"
 },
 {
  "id": 947,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , \"forward_search_range: str: %d, end: %d, s: %d, range: %d\\\\n\" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; if ( q >= end ) return 0 ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p =",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <vul-start> low ) ; }\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ONIG_INFINITE_DISTANCE ) { if ( p >= end ) return 0 ; <vul-start> str ), p - reg -> dmax <vul-end> ) ; }\n"
 },
 {
  "id": 948,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent * extent = NULL ; unsigned long page = 0 ; char * kbuf , * pos , * next_line ; ssize_t ret = - EINVAL ; mutex_lock ( & id_map_mutex ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! ns_capable ( ns , cap_setid ) ) goto out ; ret = - ENOMEM ; page = __get_free_page ( GFP_TEMPORARY ) ; kbuf = ( char * ) page ; if ( ! page ) goto out ; ret = - EINVAL ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) goto out ; ret = - EFAULT ; if ( copy_from_user ( kbuf , buf , count ) ) goto out ; kbuf [ count ] = '\\\\0' ; ret = - EINVAL ; pos = kbuf ; new_map . nr_extents = 0 ; for ( ; pos ; pos = next_line ) { extent = & new_map . extent [ new_map . nr_extents ] ; next_line = strchr ( pos , '\\\\n' ) ; if ( next_line ) { * next_line = '\\\\0' ; next_line ++",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ! new_idmap_permitted ( file ,\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, & new_map, true\n"
 },
 {
  "id": 949,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int amqp_handle_input ( amqp_connection_state_t state , amqp_bytes_t received_data , amqp_frame_t * decoded_frame ) { size_t bytes_consumed ; void * raw_frame ; decoded_frame -> frame_type = 0 ; if ( received_data . len == 0 ) { return AMQP_STATUS_OK ; } if ( state -> state == CONNECTION_STATE_IDLE ) { state -> state = CONNECTION_STATE_HEADER ; } bytes_consumed = consume_data ( state , & received_data ) ; if ( state -> inbound_offset < state -> target_size ) { return ( int ) bytes_consumed ; } raw_frame = state -> inbound_buffer . bytes ; switch ( state -> state ) { case CONNECTION_STATE_INITIAL : if ( memcmp ( raw_frame , \"AMQP\" , 4 ) == 0 ) { decoded_frame -> frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER ; decoded_frame -> channel = 0 ; decoded_frame -> payload . protocol_header . transport_high = amqp_d8 ( amqp_offset ( raw_frame , 4 ) ) ; decoded_frame -> payload . protocol_header . transport_low = amqp_d8 ( amqp_offset ( raw_frame , 5 ) ) ; decoded_frame -> payload . protocol_header . protocol_version_major = amqp_d8 ( amqp_offset ( raw_frame , 6 ) ) ; decoded_frame -> payload . protocol_header . protocol_version_minor = amqp_d8 ( amqp_offset ( raw_frame , 7 ) ) ; return_to_idle ( state ) ; return ( int ) bytes_consumed ; } case CONNECTION_STATE_HEADER : { amqp_channel_t channel ; amqp_pool_t * channel_pool ; <vul-start> channel = amqp_d16 ( amqp_offset ( raw_frame , 1 ) ) ; <vul-end> <vul-start> state -> target_size = <vul-end> <vul-start> amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) + HEADER_SIZE + FOOTER_SIZE ; <vul-end> if ( ( size_t ) state",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * channel_pool ; uint32_t frame_size ; <vul-start> ) ) ; frame_size = amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) ; if ( frame_size >= INT32_MAX ) { return AMQP_STATUS_BAD_AMQP_DATA ; } <vul-start> -> target_size = frame_size <vul-end> + HEADER_SIZE +\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * channel_pool ; size_t target_size ; <vul-start> ) ) ; target_size = <vul-end> amqp_d32 ( amqp_offset <vul-start>, 3 ) ; if ( target_size < HEADER_SIZE + FOOTER_SIZE ) { return AMQP_STATUS_BAD_AMQP_DATA ; } state -> target_size = target_size <vul-end> ; if (\n"
 },
 {
  "id": 950,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void file_add_mapi_attrs ( File * file , MAPI_Attr * * attrs ) { int i ; for ( i = 0 ; attrs [ i ] ; i ++ ) { MAPI_Attr * a = attrs [ i ] ; if ( a -> num_values ) { switch ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME : <vul-start> if ( file -> name ) XFREE ( file -> name ) ; <vul-end> file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ : <vul-start> file -> len = a -> values [ 0 ] . len ; <vul-end> if ( file -> data ) XFREE ( file -> data ) ; file -> data = CHECKED_XMALLOC ( unsigned char , file -> len ) ; memmove ( file -> data , a -> values [ 0 ] . data . buf , file -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : <vul-start> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <vul-end> file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> mime_type , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; case MAPI_ATTACH_CONTENT_ID : <vul-start> if ( file -> content_id ) XFREE ( file -> content_id ) ; <vul-end> file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <vul-start> case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <vul-start> case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <vul-start> case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> file -> name!= NULL ) <vul-end> file -> name <vul-start> file -> name = strdup ( ( char * ) a -> values [ 0 ]. data. buf ) ; file -> name <vul-start> case MAPI_ATTACH_DATA_OBJ : if ( file -> data!= NULL ) <vul-end> file -> data <vul-start> file -> mime_type!= NULL ) <vul-end> file -> mime_type <vul-start> file -> content_id!= NULL ) <vul-end> file -> content_id <vul-start> -> name ) { <vul-start> name ) ; file -> name = strdup ( ( char * ) a -> values [ 0 ]. data. buf ) ; } <vul-start> case MAPI_ATTACH_DATA_OBJ : if ( file -> data!= NULL ) <vul-start> -> len ) ; file -> data = CHECKED_XMALLOC ( unsigned char, file -> len ) ; memmove ( file -> data, a -> values [ 0 ]. data. buf, file -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : if ( file -> mime_type!= NULL ) <vul-start> case MAPI_ATTACH_CONTENT_ID : if ( file -> content_id!= NULL )\n"
 },
 {
  "id": 951,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static bool LookupModMask ( struct xkb_context * ctx , const void * priv , xkb_atom_t field , enum expr_value_type type , xkb_mod_mask_t * val_rtrn ) { const char * str ; xkb_mod_index_t ndx ; const LookupModMaskPriv * arg = priv ; const struct xkb_mod_set * mods = arg -> mods ; enum mod_type mod_type = arg -> mod_type ; if ( type != EXPR_TYPE_INT ) return false ; str = xkb_atom_text ( ctx , field ) ; <vul-start> if ( istreq ( str , \"all\" ) ) { <vul-end> * val_rtrn = MOD_REAL_MASK_ALL ; return true ; } if ( istreq ( str , \"none\" ) ) { * val_rtrn = 0 ; return true ; } ndx = XkbModNameToIndex ( mods , field , mod_type ) ; if ( ndx == XKB_MOD_INVALID ) return false ; * val_rtrn = ( 1u << ndx ) ; return true ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ; if ( ! str ) return false ; if (\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ; if ( str == NULL ) return false ; if (\n"
 },
 {
  "id": 952,
  "question": "CWE-770 Code Input Vulnerable Code Is: CWE-770 WORD32 ihevcd_create ( iv_obj_t * ps_codec_obj , void * pv_api_ip , void * pv_api_op ) { <vul-start> ihevcd_cxa_create_op_t * ps_create_op ; <vul-end> WORD32 ret ; codec_t * ps_codec ; <vul-start> ps_create_op = ( ihevcd_cxa_create_op_t * ) pv_api_op ; <vul-end> ps_create_op -> s_ivd_create_op_t . u4_error_code = 0 ; <vul-start> ret = ihevcd_allocate_static_bufs ( & ps_codec_obj , pv_api_ip , pv_api_op ) ; <vul-end> <vul-start> if ( ( IV_FAIL == ret ) && ( NULL != ps_codec_obj ) ) <vul-end> { <vul-start> ihevcd_free_static_bufs ( ps_codec_obj ) ; <vul-end> ps_create_op -> s_ivd_create_op_t . u4_error_code = IVD_MEM_ALLOC_FAILED ; ps_create_op -> s_ivd_create_op_t . u4_error_code = 1 << IVD_FATALERROR ; return IV_FAIL ; } ps_codec = ( codec_t * ) ps_codec_obj -> pv_codec_handle ; ret = ihevcd_init ( ps_codec ) ; TRACE_INIT ( NULL ) ; STATS_INIT ( ) ; return ret ; }",
  "golden_answers": [
   "CWE-770 Fixed Code Lines are: <vul-start> pv_api_op ) { ihevcd_cxa_create_ip_t * ps_create_ip ; <vul-start> * ps_codec ; ps_create_ip = ( ihevcd_cxa_create_ip_t * ) pv_api_ip ; <vul-start> = 0 ; ps_codec_obj = NULL ; <vul-start> ) ; if <vul-end> ( IV_FAIL == <vul-start> == ret ) { if <vul-end> ( NULL != <vul-start> != ps_codec_obj ) { if ( ps_codec_obj -> pv_codec_handle <vul-start> ps_codec_obj ) ; } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , ps_codec_obj ) ; } }\n"
  ],
  "generated_answer": "CWE-770 Fixed Code Lines are: <vul-start> pv_api_op ) { <vul-end> codec_t * ps_codec <vul-start> * ps_codec ; <vul-end> ret = ihevcd_allocate_static_bufs <vul-start> = ihevcd_allocate_static_bufs ( <vul-end> pv_codec_obj, pv_api_ip <vul-start> ; if ( <vul-end> IV_FAIL == ret <vul-start> == ret ) { if ( ps_codec_obj ) { if ( ps_codec_obj -> pv_codec_handle <vul-end> ) { ihevcd_free_static_bufs <vul-start> ps_codec_obj ) ; } else { return IV_FAIL ; } } ret = 0 ;\n"
 },
 {
  "id": 953,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static gboolean netscreen_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <vul-start> int pkt_len ; <vul-end> <vul-start> char line [ NETSCREEN_LINE_LENGTH ] ; <vul-end> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) { return FALSE ; } if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <vul-start> pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir , <vul-end> cap_dst , err , err_info ) ; <vul-start> if ( pkt_len == - 1 ) <vul-end> return FALSE ; if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ; return TRUE ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> err_info ) { <vul-end> char line [ <vul-start> line [ NETSCREEN_LINE_LENGTH <vul-end> ] ; if <vul-start> FALSE ; } return parse_netscreen_packet ( wth -> random_fh , phdr , buf <vul-end> , line , <vul-start> , line , <vul-end> err , err_info <vul-start> err_info ) ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> err_info ) { <vul-end> char line [ <vul-start> line [ NETSCREEN_LINE_LENGTH <vul-end> ] ; if <vul-start> FALSE ; } if (! parse_netscreen_packet <vul-end> ( phdr, <vul-start> ( phdr, <vul-end> buf, err <vul-start> err_info ) ) <vul-end> return FALSE ;\n"
 },
 {
  "id": 954,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void * checked_xcalloc ( size_t num , size_t size ) { <vul-start> alloc_limit_assert ( \"checked_xcalloc\" , ( num * size ) ) ; <vul-end> return xcalloc ( num , size ) ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <vul-start> \"checked_xcalloc\" , ( res <vul-end> ) ) ;\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> size ) { size_t res ; if ( check_mul_overflow ( num, size, & res ) ) abort ( ) ; <vul-start> ( \"checked_xcalloc\", res <vul-end> ) ; return\n"
 },
 {
  "id": 955,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int read_public_key ( RSA * rsa ) { int r ; sc_path_t path ; sc_file_t * file ; u8 buf [ 2048 ] , * p = buf ; size_t bufsize , keysize ; r = select_app_df ( ) ; if ( r ) return 1 ; sc_format_path ( \"I1012\" , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r ) { fprintf ( stderr , \"Unable to select public key file: %s\\\\n\" , sc_strerror ( r ) ) ; return 2 ; } <vul-start> bufsize = file -> size ; <vul-end> sc_file_free ( file ) ; r = sc_read_binary ( card , 0 , buf , bufsize , 0 ) ; if ( r < 0 ) { fprintf ( stderr , \"Unable to read public key file: %s\\\\n\" , sc_strerror ( r ) ) ; return 2 ; } bufsize = r ; do { if ( bufsize < 4 ) return 3 ; keysize = ( p [ 0 ] << 8 ) | p [ 1 ] ; if ( keysize == 0 ) break ; if ( keysize < 3 ) return 3 ; if ( p [ 2 ] == opt_key_num ) break ; p += keysize ; bufsize -= keysize ; } while ( 1 ) ; if ( keysize == 0 ) { printf ( \"Key number %d not found.\\\\n\" , opt_key_num ) ; return 2 ; } return parse_public_key ( p , keysize , rsa ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> } bufsize = MIN ( <vul-start> file -> size , sizeof buf )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } bufsize = MIN ( <vul-start> file -> size, sizeof buf )\n"
 },
 {
  "id": 956,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 boolean parse_config_line ( origbuf ) char * origbuf ; { # if defined ( MICRO ) && ! defined ( NOCWD_ASSUMPTIONS ) static boolean ramdisk_specified = FALSE ; # endif # ifdef SYSCF int n , src = iflags . parse_config_file_src ; # endif char * bufp , buf [ 4 * BUFSZ ] ; uchar translate [ MAXPCHARS ] ; int len ; boolean retval = TRUE ; <vul-start> mungspaces ( strcpy ( buf , origbuf ) ) ; <vul-end> bufp = find_optparam ( buf ) ; if ( ! bufp ) { config_error_add ( \"Not a config statement, missing \\'=\\'\" ) ; return FALSE ; } ++ bufp ; if ( * bufp == ' ' ) ++ bufp ; if ( match_varname ( buf , \"OPTIONS\" , 4 ) ) { bufp = find_optparam ( origbuf ) ; ++ bufp ; if ( ! parseoptions ( bufp , TRUE , TRUE ) ) retval = FALSE ; } else if ( match_varname ( buf , \"AUTOPICKUP_EXCEPTION\" , 5 ) ) { add_autopickup_exception ( bufp ) ; } else if ( match_varname ( buf , \"BINDINGS\" , 4 ) ) { if ( ! parsebindings ( bufp ) ) retval = FALSE ; } else if ( match_varname ( buf , \"AUTOCOMPLETE\" , 5 ) ) { parseautocomplete ( bufp , TRUE ) ; } else if ( match_varname ( buf , \"MSGTYPE\" , 7 ) ) { if ( ! msgtype_parse_add ( bufp ) ) retval = FALSE ; # ifdef NOCWD_ASSUMPTIONS } else if ( match_varname ( buf , \"HACKDIR\" ,",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> = TRUE ; while ( * origbuf == ' ' || * origbuf == '\\\\t' ) ++ origbuf ; ( void ) strncpy ( buf , origbuf , sizeof buf - 1 ) ; buf [ sizeof buf - 1 ] = '\\\\0' ; mungspaces ( buf <vul-end> ) ; bufp\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> = TRUE ; if ( strlen ( origbuf ) >= PATHLEN ) { config_error_add ( \"Not a config statement, too long\" ) ; return FALSE ; }\n"
 },
 {
  "id": 957,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int simulate_llsc ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == LL ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <vul-start> 1 , 0 , regs , 0 ) ; <vul-end> return simulate_ll ( regs , opcode ) ; } if ( ( opcode & OPCODE ) == SC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <vul-start> 1 , 0 , regs , 0 ) ; <vul-end> return simulate_sc ( regs , opcode ) ; } return - 1 ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> PERF_COUNT_SW_EMULATION_FAULTS , 1 <vul-end> , regs , <vul-start> , 1 , <vul-end> regs , 0\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, 0 <vul-start>, 1, <vul-end> regs, 0 <vul-start>, 1, <vul-end> regs, 0\n"
 },
 {
  "id": 958,
  "question": "CWE-863 Code Input Vulnerable Code Is: CWE-863 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\\\n' ) ; if ( next_line ) { * next_line = '\\\\0' ; next_line ++ ; if ( * next_line == '\\\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos =",
  "golden_answers": [
   "CWE-863 Fixed Code Lines are: <vul-start> & new_map ) <vul-end> ) goto out <vul-start> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;\n"
  ],
  "generated_answer": "CWE-863 Fixed Code Lines are: <vul-start>, & new_map, false <vul-start> - EPERM ; memset ( & new_map, 0, sizeof ( new_map ) ) ;\n"
 },
 {
  "id": 959,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ; <vul-start> int pixel_ptr = 0 ; <vul-end> int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , \"First chunk byte is 0x%02x instead of 0xe1\\\\n\" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , \"MOV chunk size != encoded chunk size; using MOV chunk size\\\\n\" ) ; chunk_size = s -> size ; total_blocks = ( ( s -> avctx -> width + 3 ) / 4 ) * ( ( s -> avctx -> height + 3 ) / 4 ) ; while ( stream_ptr < chunk_size ) { opcode = s -> buf [ stream_ptr ++ ] ; n_blocks = ( opcode &",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int pixel_ptr = - 4 <vul-end> ; int block_ptr <vul-start> -- ) { ADVANCE_BLOCK ( ) <vul-start> row_inc ; } <vul-end> } break ; <vul-start> -- ) { ADVANCE_BLOCK ( ) ; <vul-start> row_inc ; } <vul-end> } break ; <vul-start> ) return ; ADVANCE_BLOCK ( ) ; <vul-start> row_inc ; } <vul-end> break ; default\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; int pixel_ptr = 0 ; int block_ptr <vul-start> -- ) { if ( stream_ptr + pixel_ptr >= chunk_size ) break ; <vul-start> row_inc ; } if ( block_ptr >= chunk_size ) break ; <vul-start> row_inc ; } if ( block_ptr >= chunk_size ) break ;\n"
 },
 {
  "id": 960,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <vul-start> Jpeg2000Prec * prec = band -> prec + precno ; <vul-end> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <vul-start> av_freep ( & band -> prec ) ; <vul-end> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ++ ) { if ( band -> prec ) { <vul-start> ) ; } }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ++ ) { if ( prec -> zerobits || prec -> cblkincl || prec -> cblk ) { <vul-start> ) ; } }\n"
 },
 {
  "id": 961,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> cJSON * cJSON_CreateFloatArray ( double * numbers , int count ) <vul-end> { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ; <vul-start> for ( i = 0 ; a && i < count ; ++ i ) { <vul-end> <vul-start> n = cJSON_CreateFloat ( numbers [ i ] ) ; <vul-end> <vul-start> if ( ! i ) <vul-end> a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cJSON_CreateFloatArray ( const float <vul-end> * numbers , <vul-start> < count ; i ++ <vul-end> ) { n <vul-start> { n = cJSON_CreateNumber <vul-end> ( numbers [ <vul-start> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cJSON_CreateFloatArray ( const double * const <vul-end> numbers, int <vul-start> < count ; i ++ <vul-end> ) { n <vul-start> { n = cJSON_CreateNumber <vul-end> ( numbers [ <vul-start> ] ) ; if (! n ) { cJSON_Delete ( a ) ; return 0 ; }\n"
 },
 {
  "id": 962,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void nlmclnt_unlock_callback ( struct rpc_task * task , void * data ) { struct nlm_rqst * req = data ; u32 status = ntohl ( req -> a_res . status ) ; if ( RPC_ASSASSINATED ( task ) ) goto die ; if ( task -> tk_status < 0 ) { dprintk ( \"lockd: unlock failed (err = %d)\\\\n\" , - task -> tk_status ) ; <vul-start> goto retry_rebind ; <vul-end> } if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay ( task , NLMCLNT_GRACE_WAIT ) ; goto retry_unlock ; } if ( status != NLM_LCK_GRANTED ) printk ( KERN_WARNING \"lockd: unexpected unlock status: %d\\\\n\" , status ) ; die : return ; retry_rebind : nlm_rebind_host ( req -> a_host ) ; retry_unlock : rpc_restart_call ( task ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> tk_status ) ; switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <vul-start> goto retry_rebind ; }\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ) ; goto retry_unlock <vul-end> ; } if\n"
 },
 {
  "id": 963,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( \"Wrong FIT format: not a flattened device tree (err=%d)\\\\n\" , ret ) ; return - ENOEXEC ; } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; <vul-start> if ( ret ) { <vul-end> log_debug ( \"FIT check error %d\\\\n\" , ret ) ; <vul-start> return - EINVAL ; <vul-end> } } if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { log_debug ( \"Wrong FIT format: no description\\\\n\" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( \"Wrong FIT format: no timestamp\\\\n\" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( \"Wrong FIT format: no images parent node\\\\n\" ) ; return - ENOENT ; } return 0 ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ( ret ) ret = - EINVAL ; if ( ! ret && CONFIG_IS_ENABLED ( FIT_SIGNATURE ) ) { ret = fdt_check_no_at ( fit , 0 ) ; if ( ret ) <vul-start> ) ; return ret ; } } if ( ret ) { log_debug ( \"FIT check error %d\\\\n\" , ret ) ; return ret <vul-end> ; } }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> if ( ret < 0 && ret!= - EINVAL <vul-start> return - EINVAL ; } else if ( ret == 0 ) { log_debug ( \"FIT check error %d (err=%d)\\\\n\", ret, - EINVAL )\n"
 },
 {
  "id": 964,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; <vul-start> unsigned int link_count ; <vul-end> bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , \"(ino %ld) failed !bh\\\\n\" , inode -> i_ino ) ; make_bad_inode ( inode ) ; return ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , \"(ino %ld) failed ident=%d\\\\n\" , inode -> i_ino , ident ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { <vul-start> struct buffer_head * nbh = NULL ; <vul-end> struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; <vul-start> if (",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> int link_count ; unsigned int indirections = 0 ; reread : <vul-start> ) { struct <vul-end> kernel_lb_addr loc ; <vul-start> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <vul-end> , & loc <vul-start> & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , \"too many ICBs in ICB hierarchy\" \" (max %d supported)\\\\n\" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <vul-end> ( inode ) <vul-start> return ; } goto reread <vul-end> ; } }\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> unsigned int link_count ; struct buffer_head * nbh = NULL <vul-start> ibh ) { <vul-end> struct indirectEntry * <vul-start> extLocation ) ; if ( ie -> indirectICB. extLength ) { if ( <vul-end> ( nbh = <vul-start> ( nbh ) ; } else if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > sbi -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) { if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto make_bad_inode ; } else { if ( inode -> i_size < 0 || inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) { make_bad_inode ( inode ) ; return ; } } brelse ( ibh )\n"
 },
 {
  "id": 965,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <vul-start> float * w = get_window ( f , n ) ; <vul-end> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , n ) ; if ( w == NULL ) return 0\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> previous_length ; double <vul-end> * w =\n"
 },
 {
  "id": 966,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int bmpr_read_rle ( struct iwbmprcontext * rctx ) { int retval = 0 ; if ( ! ( rctx -> compression == IWBMP_BI_RLE8 && rctx -> bitcount == 8 ) && ! ( rctx -> compression == IWBMP_BI_RLE4 && rctx -> bitcount == 4 ) ) { iw_set_error ( rctx -> ctx , \"Compression type incompatible with image type\" ) ; <vul-start> } <vul-end> if ( rctx -> topdown ) { <vul-start> iw_set_error ( rctx -> ctx , \"Compression not allowed with top-down images\" ) ; <vul-end> } rctx -> img -> imgtype = IW_IMGTYPE_RGBA ; rctx -> img -> bit_depth = 8 ; rctx -> img -> bpr = iw_calc_bytesperrow ( rctx -> width , 32 ) ; rctx -> img -> pixels = ( iw_byte * ) iw_malloc_large ( rctx -> ctx , rctx -> img -> bpr , rctx -> img -> height ) ; if ( ! rctx -> img -> pixels ) goto done ; if ( ! bmpr_read_rle_internal ( rctx ) ) goto done ; if ( ! bmpr_has_transparency ( rctx -> img ) ) { bmpr_strip_alpha ( rctx -> img ) ; } retval = 1 ; done : return retval ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> \"Compression type incompatible with image type\" ) ; goto done ; <vul-start> , \"Compression not allowed with top-down images\" ) ; goto done\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> \"Compression type incompatible with image type\" ) ; goto done ; <vul-start>, \"Compression not allowed with top-down images\" ) ; goto done\n"
 },
 {
  "id": 967,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; <vul-start> int err = 0 ; <vul-end> if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; int err = 0 ; msg -> msg_namelen\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> err = 0 ; msg -> msg_namelen = 0\n"
 },
 {
  "id": 968,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; <vul-start> uint32 num_properties = GETINT32 ( buf + idx ) ; <vul-end> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ;",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <vul-start> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <vul-start> += 4 ; assert ( v -> len + idx <= len ) ; <vul-start> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> 4 ) ; size_t def_len = 0 ; <vul-start> len ) ; def_len = ( a -> name & GUID_EXISTS_FLAG )? v -> len : 0 ; <vul-start> ) unicode_to_utf8 ( def_len <vul-end>, buf +\n"
 },
 {
  "id": 969,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) { <vul-start> VP9_COMMON * const cm = & pbi -> common ; <vul-end> const uint8_t * bit_reader_end = NULL ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; <vul-start> const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ; <vul-end> <vul-start> TileBuffer tile_buffers [ 1 << 6 ] ; <vul-end> int n ; int final_worker = - 1 ; assert ( tile_cols <= ( 1 << 6 ) ) ; assert ( tile_rows == 1 ) ; ( void ) tile_rows ; if ( pbi -> num_tile_workers == 0 ) { <vul-start> const int num_threads = pbi -> oxcf . max_threads & ~ 1 ; <vul-end> int i ; CHECK_MEM_ERROR ( cm , pbi -> tile_workers , <vul-start> vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; <vul-end> for ( i = 0 ; i < num_threads ; ++ i ) { <vul-start> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <vul-end> ++ pbi -> num_tile_workers ; <vul-start> vp9_worker_init ( worker ) ; <vul-end> CHECK_MEM_ERROR ( cm , worker -> data1 , vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ; CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ; <vul-start> if ( i",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> pbi -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <vul-start> ( pbi -> <vul-end> max_threads & ~ <vul-start> tile_buffers [ 1 ] [ 1 <vul-start> = pbi -> <vul-end> max_threads & ~ <vul-start> pbi -> tile_workers ) ) ) ; assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info <vul-start> i ) { VPxWorker <vul-end> * const worker <vul-start> -> num_tile_workers ; winterface -> init ( worker <vul-end> ) ; if <vul-start> 1 && ! winterface -> reset <vul-end> ( worker ) <vul-start> n ) { VPxWorker * const worker = & <vul-start> [ n ] ; winterface -> sync ( worker ) ; worker -> <vul-end> hook = ( <vul-start> hook = ( VPxWorkerHook <vul-end> ) tile_worker_hook ; <vul-start> ) tile_worker_hook ; worker -> data1 = & pbi -> tile_worker_data [ n ] ; worker -> data2 = & pbi -> tile_worker_info [ n ] ; } memset <vul-end> ( cm -> <vul-start> aligned_mi_cols ) ; memset <vul-end> ( cm -> <vul-start> aligned_mi_cols ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ; tile_buffers [ 0 ] [ group_end ] = largest ; group_start = group_end + 1 ; } } if ( ! cm -> frame_parallel_decoding_mode ) { int i ; for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_zero ( tile_data -> counts ) ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VPxWorker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ; tile_data -> pbi = pbi ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( tile , cm , 0 , buf -> col ) ; vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || <vul-end> n == tile_cols <vul-start> tile_cols - 1 ) { winterface -> execute <vul-end> ( worker ) <vul-start> } else { winterface -> launch <vul-end> ( worker ) <vul-start> i ) { VPxWorker <vul-end> * const worker <vul-start> corrupted |= ! winterface -> sync <vul-end> ( worker ) <vul-start> ; bit_reader_end = vpx_reader_find_end <vul-end> ( & tile_data <vul-start> - 1 ; } if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) { for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> data_end ) { const int max_workers = pbi -> oxcf. max_workers ; const int tile_workers = 1 << 6 ; TileBuffer tile_buffers [ 1 << 6 ] ; int n ; int final_worker = - 1 ; <vul-start> int num_workers = MAX ( max_workers <vul-end>, tile_cols ) <vul-start> tile_cols ) ; <vul-end> assert ( tile_cols <vul-start> 0 ) { int i ; for ( i = 0 ; i < num_workers ; ++ i ) { VP9Worker * const worker = & pbi -> tile_workers [ i ] ; ++ pbi -> num_tile_workers ; vp9_worker_init ( worker ) ; CHECK_MEM_ERROR ( cm, worker -> data1, vpx_memalign ( 32, sizeof ( TileWorkerData ) ) ) ; CHECK_MEM_ERROR ( cm, worker -> data2, vpx_malloc ( sizeof ( TileInfo ) ) ) ; if ( i < num_workers - 1 ) { vpx_internal_error ( & cm -> error, VPX_CODEC_ERROR, \"Tile decoder thread creation failed\" ) ; } } } for ( n = 0 ; n < num_workers ; ++ n ) { VP9Worker * const worker = & pbi -> tile_workers [ n ] ; const <vul-start> int num_threads = MIN ( num_workers, tile_cols ) ; TileBuffer * const tile_buffers = <vul-end> pbi -> tile_workers <vul-start> pbi -> tile_workers ; for ( i = 0 ; i < num_workers ; ++ i ) { vp9_worker_init ( worker ) ; CHECK_MEM_ERROR ( cm, worker -> data1, vpx_memalign ( 32, sizeof ( TileWorkerData ) ) ) ; CHECK_MEM_ERROR ( cm, worker -> data2, vpx_malloc ( sizeof ( TileInfo ) ) ) ; if ( i < tile_cols - 1 ) { <vul-end> vp9_worker_launch ( worker <vul-start> vp9_worker_sync ( worker ) ; } } } vpx_memset ( cm -> above_context, 0, sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ; vpx_memset ( cm -> seg"
 },
 {
  "id": 970,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void exit_io_context ( void ) { struct io_context * ioc ; task_lock ( current ) ; ioc = current -> io_context ; current -> io_context = NULL ; task_unlock ( current ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; <vul-start> put_io_context ( ioc ) ; <vul-end> } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ioc ) ; } <vul-start> ) ; } <vul-end>      \n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ioc ) ; } <vul-start> ) ; } <vul-end>      \n"
 },
 {
  "id": 971,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 void CLASS parse_minolta ( int base ) { int save , tag , len , offset , high = 0 , wide = 0 , i , c ; short sorder = order ; fseek ( ifp , base , SEEK_SET ) ; if ( fgetc ( ifp ) || fgetc ( ifp ) - 'M' || fgetc ( ifp ) - 'R' ) return ; order = fgetc ( ifp ) * 0x101 ; <vul-start> offset = base + get4 ( ) + 8 ; <vul-end> while ( ( save = ftell ( ifp ) ) < offset ) { for ( tag = i = 0 ; i < 4 ; i ++ ) tag = tag << 8 | fgetc ( ifp ) ; len = get4 ( ) ; <vul-start> switch ( tag ) <vul-end> { case 0x505244 : fseek ( ifp , 8 , SEEK_CUR ) ; high = get2 ( ) ; wide = get2 ( ) ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . makernotes . sony . prd_ImageHeight = get2 ( ) ; imgdata . makernotes . sony . prd_ImageWidth = get2 ( ) ; fseek ( ifp , 1L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_RawBitDepth = ( ushort ) fgetc ( ifp ) ; imgdata . makernotes . sony . prd_StorageMethod = ( ushort ) fgetc ( ifp ) ; fseek ( ifp , 4L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_BayerPattern = ( ushort ) fgetc ( ifp ) ; # endif break ; # ifdef LIBRAW_LIBRARY_BUILD case",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> + 8 ; # ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ; # endif <vul-start> ( ) ; if ( len < 0 ) return ;\n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> * 0x101 ; if ( order > MAX_Bayer_SIZE ) return ; <vul-start> ( ) ; if ( len > MAX_Bayer_SIZE ) return ;\n"
 },
 {
  "id": 972,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 void _modinit ( module_t * m ) { service_named_bind_command ( \"chanserv\" , & cs_flags ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> cs_flags ) ; add_bool_conf_item ( \"ANOPE_FLAGS_COMPAT\" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( \"nick_can_register\" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( \"user_can_register\" ) ; hook_add_user_can_register ( check_registration_keywords ) ;\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> cs_flags ) ; hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( \"ANOPE_FLAGS_COMPAT\", & chansvs. me -> conf_table ) ;\n"
 },
 {
  "id": 973,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; <vul-start> if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) <vul-end> { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; <vul-start> if ( ! ps_dec -> u1_first_slice_in_stream ) <vul-end> { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec ->",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> WORD32 ret ; UNUSED ( u1_is_idr_slice ) ; <vul-start> = u2_frame_num ; <vul-end> { WORD32 i\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( <vul-end> ps_dec -> ps_dec_err_status <vul-start> ps_dec -> ps_dec_err_status == REJECT_CUR_PIC <vul-end> ) { ih264d_err_pic_dispbuf_mgr <vul-start> } if ( <vul-end> ps_dec -> ps_dec_err_status <vul-start> ps_dec -> ps_dec_err_status == REJECT_CUR_PIC <vul-end> ) { ih264d_err_pic_dispbuf_mgr\n"
 },
 {
  "id": 974,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ; <vul-start> err = - EINVAL ; <vul-end> if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &=",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> err = - <vul-end> EALREADY ; if <vul-start> - EINVAL ; spin_lock ( & po -> bind_lock ) ; if ( po -> running && <vul-end> match -> type <vul-start> ; } } spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; }\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> err = - EALREADY ; if ( po -> fanout ) goto out ; err = - <vul-start> ; } } <vul-end> if ( err\n"
 },
 {
  "id": 975,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> static inline struct enamemem * <vul-end> lookup_bytestring ( netdissect_options * ndo , register const u_char * bs , const unsigned int nlen ) { <vul-start> struct enamemem * tp ; <vul-end> register u_int i , j , k ; if ( nlen >= 6 ) { k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; i = ( bs [ 4 ] << 8 ) | bs [ 5 ] ; } else if ( nlen >= 4 ) { k = ( bs [ 0 ] << 8 ) | bs [ 1 ] ; j = ( bs [ 2 ] << 8 ) | bs [ 3 ] ; i = 0 ; } else i = j = k = 0 ; tp = & bytestringtable [ ( i ^ j ) & ( HASHNAMESIZE - 1 ) ] ; <vul-start> while ( tp -> e_nxt ) <vul-end> if ( tp -> e_addr0 == i && <vul-start> tp -> e_addr1 == j && <vul-end> <vul-start> tp -> e_addr2 == k && <vul-end> <vul-start> memcmp ( ( const char * ) bs , ( const char * ) ( tp -> e_bs ) , nlen ) == 0 ) <vul-end> return tp ; else <vul-start> tp = tp -> e_nxt ; <vul-end> tp -> e_addr0 = i ; tp -> e_addr1 = j ; tp -> e_addr2 = k ; tp -> e_bs = ( u_char * )",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> static inline struct bsnamemem <vul-end> * lookup_bytestring ( <vul-start> ) { struct bsnamemem <vul-end> * tp ; <vul-start> ( tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes <vul-end> && tp -> <vul-start> && tp -> bs_addr0 == i <vul-end> && tp -> <vul-start> && tp -> bs_addr1 == j && tp -> bs_addr2 <vul-end> == k && <vul-start> ( tp -> bs_bytes <vul-end> ) , nlen <vul-start> = tp -> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes <vul-end> = ( u_char <vul-start> ( tp -> bs_bytes <vul-end> == NULL ) <vul-start> ( tp -> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt <vul-end> = ( struct <vul-start> = ( struct bsnamemem <vul-end> * ) calloc <vul-start> ( tp -> bs_nxt <vul-end> == NULL )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>     static inline bs_t <vul-end> * lookup_bytestring ( <vul-start> ) { struct bs_t <vul-end> * tp ; <vul-start> ) ] ; if ( tp -> e_bs == NULL ) return NULL ; <vul-start> == i && ( <vul-start> tp -> e_addr1 & 0xffff ) <vul-start> == j && ( <vul-start> tp -> e_addr2 & 0xffff ) <vul-start> == k && ( tp -> e_bs & 0xffff ) == 0 ) return tp ; tp = & bs_to_mem ( tp, nlen ) <vul-end> ; if ( <vul-start> tp ; else if ( tp -> e_bs == NULL ) return NULL ; <vul-start> = tp -> e_bs <vul-end> ; tp ->\n"
 },
 {
  "id": 976,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <vul-end> int stride , int eob ) { if ( tx_type == DCT_DCT ) vp9_idct4x4_add ( input , dest , stride , eob ) ; else vp9_iht4x4_16_add ( input , dest , stride , tx_type ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> tx_type , const tran_low_t <vul-end> * input ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> tx_type, const tran_low_t <vul-end> * input,\n"
 },
 {
  "id": 977,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) { char * buffer = NULL ; int n = 0 ; FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( \"\" , cl , NULL ) ; <vul-start> if ( length > 0 ) { <vul-end> <vul-start> buffer = malloc ( ( uint64_t ) length + 1 ) ; <vul-end> if ( buffer != NULL ) { if ( ( n = rfbReadExact ( cl , ( char * ) buffer , length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( \"rfbProcessFileTransferReadBuffer: read\" ) ; rfbCloseClient ( cl ) ; if ( buffer != NULL ) free ( buffer ) ; return NULL ; } buffer [ length ] = 0 ; } } return buffer ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> if ( length == SIZE_MAX ) { rfbErr ( \"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\" , ( unsigned int ) length ) ; rfbCloseClient ( cl ) ; return NULL ; } if ( length <vul-start> malloc ( ( size_t <vul-end> ) length +\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> if ( length >= 1 <vul-end> ) { buffer <vul-start> = malloc ( <vul-end> length + 1\n"
 },
 {
  "id": 978,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 <vul-start> static int mptctl_do_reset ( unsigned long arg ) <vul-end> { struct mpt_ioctl_diag_reset __user * urinfo = ( void __user * ) arg ; <vul-start> struct mpt_ioctl_diag_reset krinfo ; <vul-end> MPT_ADAPTER * iocp ; if ( copy_from_user ( & krinfo , urinfo , sizeof ( struct mpt_ioctl_diag_reset ) ) ) { printk ( KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \" \"Unable to copy mpt_ioctl_diag_reset struct @ %p\\\\n\" , __FILE__ , __LINE__ , urinfo ) ; <vul-start> return - EFAULT ; <vul-end> } if ( mpt_verify_adapter ( krinfo . hdr . iocnum , & iocp ) < 0 ) { printk ( KERN_DEBUG MYNAM \"%s@%d::mptctl_do_reset - ioc%d not found!\\\\n\" , __FILE__ , __LINE__ , krinfo . hdr . iocnum ) ; return - ENODEV ; } dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\\\n\" , iocp -> name ) ) ; if ( mpt_HardResetHandler ( iocp , CAN_SLEEP ) != 0 ) { printk ( MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\\\n\" , iocp -> name , __FILE__ , __LINE__ ) ; return - 1 ; } return 0 ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_do_reset ( MPT_ADAPTER * iocp , <vul-start> struct mpt_ioctl_diag_reset krinfo <vul-end> ; if ( <vul-start> return - EFAULT <vul-end> ; } dctlprintk\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_do_reset ( MPT_ADAPTER * iocp, <vul-start> struct mpt_ioctl_diag_reset krinfo <vul-end> ; if ( <vul-start> return - EFAULT <vul-end> ; } dctlprintk\n"
 },
 {
  "id": 979,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , \"failed to apply delta: base size does not match given data\" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , \"failed to apply delta: base size does not match given data\" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { <vul-start> size_t off = 0 , len = 0 ; <vul-end> # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) * delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> len = 0 , end <vul-start> ADD_DELTA if ( GIT_ADD_SIZET_OVERFLOW ( & end , off , len ) || base_len < end <vul-end> || res_sz <\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> off = 0 ; size_t <vul-end> len = 0 <vul-start> # undef ADD_DELTA size_t max_size = 0, min_size = 0, max_size = 0 ; if ( base_len < off + len || res_sz < len || max_size > max_size ) goto fail ; <vul-start> off + len && res_sz < max_size\n"
 },
 {
  "id": 980,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; <vul-start> int ret = 0 ; <vul-end> bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; <vul-start> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <vul-end> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; <vul-start> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <vul-end> i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * bh ; unsigned int table_len ; <vul-start> -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , \"error loading logical volume descriptor: \" \"Partition table too long (%u > %lu)\\\\n\" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <vul-start> && offset < table_len <vul-end> ; i ++\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * bh ; unsigned int map_table_len ; <vul-start> TAG_IDENT_LVD ) ; if ( le32_to_cpu ( lvd -> mapTableLength ) > sbi -> s_max_partition_map_len ) goto out_bh ; <vul-start> bh -> b_data <vul-end> ; for ( <vul-start> = 0 ; offset < le32_to_cpu ( lvd -> mapTableLength ) && <vul-start> -> s_partitions && ( <vul-start> -> mapTableLength ) )\n"
 },
 {
  "id": 981,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_vaq_frame_setup ( VP9_COMP * cpi ) { VP9_COMMON * cm = & cpi -> common ; <vul-start> struct segmentation * seg = & cm -> seg ; <vul-end> const double base_q = vp9_convert_qindex_to_q ( cm -> base_qindex ) ; const int base_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ; int i ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; <vul-start> vp9_clear_system_state ( ) ; <vul-end> <vul-start> for ( i = ENERGY_MIN ; i <= ENERGY_MAX ; i ++ ) { <vul-end> <vul-start> int qindex_delta , segment_rdmult ; <vul-end> <vul-start> if ( Q_RATIO ( i ) == 1 ) { <vul-end> RDMULT_RATIO ( i ) = 1 ; continue ; } <vul-start> qindex_delta = vp9_compute_qdelta ( & cpi -> rc , base_q , base_q * Q_RATIO ( i ) ) ; <vul-end> <vul-start> vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q , qindex_delta ) ; <vul-end> <vul-start> vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ; <vul-end> <vul-start> segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta + <vul-end> cm -> y_dc_delta_q ) ; RDMULT_RATIO ( i ) = ( double ) segment_rdmult / base_rdmult ; } } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> cm -> seg <vul-end> ; int i <vul-start> = SEGMENT_DELTADATA ; vpx_clear_system_state <vul-end> ( ) ; <vul-start> ( i = 0 ; i < MAX_SEGMENTS ; ++ i <vul-end> ) { int <vul-start> { int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , rate_ratio [ i ] , cm -> bit_depth ) <vul-end> ; if ( <vul-start> ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( rate_ratio [ i ] == 1.0 ) { <vul-end> continue ; } <vul-start> continue ; } <vul-end> vp9_set_segdata ( seg <vul-start> ( seg , i <vul-end> , SEG_LVL_ALT_Q , <vul-start> ( seg , i <vul-end> , SEG_LVL_ALT_Q ) <vul-start> SEG_LVL_ALT_Q ) ; <vul-end> } } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> cm -> seg ; int qindex_delta, segment_rdmult <vul-start> = SEGMENT_DELTADATA ; for ( qindex_delta = ENERGY_MIN ; qindex_delta <= ENERGY_MAX ; qindex_delta ++ <vul-end> ) { int <vul-start> ) { int <vul-end> segment_rdmult ; if <vul-start> ; if ( qindex_delta == ENERGY_MIN ) { RDMULT_RATIO ( i ) = ENERGY_MAX <vul-end> ; continue ; <vul-start> continue ; } vpx_set_segdata <vul-end> ( seg, <vul-start> i ), SEG_LVL_ALT_Q <vul-end>, qindex_delta ) <vul-start> qindex_delta ) ; segfeature <vul-end> ( seg, <vul-start> ( cpi, qindex_delta + cm -> y_dc_delta_q ) ; RDMULT_RATIO ( i ) = segment_rdmult <vul-end> / base_rdmult ;\n"
 },
 {
  "id": 982,
  "question": "CWE-78 Code Input Vulnerable Code Is: CWE-78 static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) { static char cmd [ BUF_SIZE ] ; <vul-start> char * method = manager -> method ; <vul-end> int i ; <vul-start> build_config ( working_dir , server ) ; <vul-end> if ( server -> method ) method = server -> method ; memset ( cmd , 0 , BUF_SIZE ) ; snprintf ( cmd , BUF_SIZE , <vul-start> \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\" , <vul-end> <vul-start> executable , method , manager -> manager_address , <vul-end> <vul-start> working_dir , server -> port , working_dir , server -> port ) ; <vul-end> if ( manager -> acl != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , \" --acl %s\" , manager -> acl ) ; } if ( manager -> timeout != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , \" -t %s\" , manager -> timeout ) ; } # ifdef HAVE_SETRLIMIT if ( manager -> nofile ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , \" -n %d\" , manager -> nofile ) ; } # endif if ( manager -> user != NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len , BUF_SIZE - len , \" -a %s\" , manager -> user ) ; } if ( manager -> verbose",
  "golden_answers": [
   "CWE-78 Fixed Code Lines are: <vul-start> BUF_SIZE ] ; int i ; int port ; port = atoi ( server -> port ) <vul-end> ; build_config ( <vul-start> ( working_dir , manager , server ) <vul-end> ; memset ( <vul-start> , BUF_SIZE , \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\" <vul-end> , executable , <vul-start> , executable , <vul-end> manager -> manager_address <vul-start> , working_dir , <vul-end> port , working_dir <vul-start> , working_dir , <vul-end> port ) ;\n"
  ],
  "generated_answer": "CWE-78 Fixed Code Lines are: <vul-start> ] ; char method [ ] = { 0 } <vul-end> ; int i <vul-start> ; build_config ( working_dir, server ) ; if ( server -> method ) method = server -> method ; else if ( manager -> method ) method = manager -> method ; else if ( manager -> method ) method = \"none\" <vul-end> ; memset ( <vul-start>, BUF_SIZE, \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\" <vul-end>, executable, <vul-start>, executable, manager -> manager_address <vul-end>, working_dir, <vul-start> server -> port ) ; snprintf ( cmd, len, BUF_SIZE - len, \"  --acl %s\", manager -> acl ) ; } if ( manager -> timeout!= NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len, BUF_SIZE - len, \" -t %s\", manager -> timeout ) ; } if ( server -> user!= NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len, BUF_SIZE - len, \" -a %s\", manager -> user ) ; } if ( manager -> verbose ) { int len = strlen ( cmd ) ; snprintf ( cmd + len, BUF_SIZE - len, \" --user %s\", manager -> user ) ; } if ( manager -> verbose ) { int len = strlen ( cmd ) ; snprintf ( cmd + len, BUF_SIZE - len, \" --verbose %s\", manager -> verbose ) ; } if ( manager -> user == NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len, BUF_SIZE - len, \" --user %s\", manager -> user ) ; } if ( manager -> verbose ) { int len = strlen ( cmd ) ; snprintf ( cmd + len, BUF_SIZE - len, \" --umask %d\", manager -> mask ) ; } if ( manager -> umask!= NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd + len, BUF_SIZE - len, \" --umask %d\", manager -> umask ) ; } if ( manager -> timeout!= NULL ) { int len = strlen ( cmd ) ; snprintf ( cmd"
 },
 {
  "id": 983,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int caif_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int copied = 0 ; int target ; int err = 0 ; long timeo ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> err = - EAGAIN ; if ( sk -> sk_state == CAIF_CONNECTING ) goto out ; caif_read_lock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { int chunk ; struct sk_buff * skb ; lock_sock ( sk ) ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; caif_check_flow_release ( sk ) ; if ( skb == NULL ) { if ( copied >= target ) goto unlock ; err = sock_error ( sk ) ; if ( err ) goto unlock ; err = - ECONNRESET ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) goto unlock ; err = - EPIPE ; if ( sk -> sk_state != CAIF_CONNECTED ) goto unlock ; if ( sock_flag ( sk , SOCK_DEAD ) ) goto unlock ; release_sock ( sk ) ; err = - EAGAIN ; if ( ! timeo ) break ; caif_read_unlock ( sk ) ; timeo = caif_stream_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno (",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> goto out ; <vul-end> err = -\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> goto out ; <vul-end> err = -\n"
 },
 {
  "id": 984,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ; <vul-start> if ( ! net_eq ( net , & init_net ) ) <vul-end> return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_DGRAM : if ( protocol == 0 || protocol == PF_AX25 ) protocol = AX25_P_TEXT ; break ; case SOCK_SEQPACKET : switch ( protocol ) { case 0 : case PF_AX25 : protocol = AX25_P_TEXT ; break ; case AX25_P_SEGMENT : # ifdef CONFIG_INET case AX25_P_ARP : case AX25_P_IP : # endif # ifdef CONFIG_NETROM case AX25_P_NETROM : # endif # ifdef CONFIG_ROSE case AX25_P_ROSE : # endif return - ESOCKTNOSUPPORT ; # ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM : if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) return - ESOCKTNOSUPPORT ; break ; # endif # ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE : if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) return - ESOCKTNOSUPPORT ; # endif default : break ; } break ; case SOCK_RAW : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - ENOMEM ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol =",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * ax25 ; int ret ;\n"
 },
 {
  "id": 985,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void sas_revalidate_domain ( struct work_struct * work ) { int res = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; struct sas_ha_struct * ha = port -> ha ; struct domain_device * ddev = port -> port_dev ; mutex_lock ( & ha -> disco_mutex ) ; if ( test_bit ( SAS_HA_ATA_EH_ACTIVE , & ha -> state ) ) { SAS_DPRINTK ( \"REVALIDATION DEFERRED on port %d, pid:%d\\\\n\" , port -> id , task_pid_nr ( current ) ) ; goto out ; } clear_bit ( DISCE_REVALIDATE_DOMAIN , & port -> disc . pending ) ; SAS_DPRINTK ( \"REVALIDATING DOMAIN on port %d, pid:%d\\\\n\" , port -> id , task_pid_nr ( current ) ) ; if ( ddev && ( ddev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE || ddev -> dev_type == SAS_EDGE_EXPANDER_DEVICE ) ) res = sas_ex_revalidate_domain ( ddev ) ; SAS_DPRINTK ( \"done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\\\n\" , port -> id , task_pid_nr ( current ) , res ) ; out : mutex_unlock ( & ha -> disco_mutex ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> disco_mutex ) ; sas_probe_devices ( port ) ;\n"
 },
 {
  "id": 986,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void ffs_user_copy_worker ( struct work_struct * work ) { struct ffs_io_data * io_data = container_of ( work , struct ffs_io_data , work ) ; int ret = io_data -> req -> status ? io_data -> req -> status : io_data -> req -> actual ; <vul-start> if ( io_data -> read && ret > 0 ) { <vul-end> use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && <vul-start> ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) <vul-end> eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ; <vul-start> usb_ep_free_request ( io_data -> ep , io_data -> req ) ; <vul-end> io_data -> kiocb -> private = NULL ; if ( io_data -> read ) kfree ( io_data -> to_free ) ; kfree ( io_data -> buf ) ; kfree ( io_data ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> -> actual ; bool kiocb_has_eventfd = <vul-end> io_data -> kiocb <vul-start> ki_flags & IOCB_EVENTFD ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd <vul-end> ) eventfd_signal ( <vul-start> -> req ) <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ( io_data ->! io_data -> read && io_data -> req -> length == 0 && io_data -> ffs -> ffs_eventfd ) { if <vul-end> ( io_data -> <vul-start> IOCB_EVENTFD ) ) { struct usb_request * req = io_data -> req ; struct ffs_context * ctx ; ctx = io_data -> ffs -> ctx ; ret = usb_ep_submit_request ( io_data -> ep, io_data -> req, GFP_KERNEL ) ; if (! ctx ) { ret = - ENOMEM ; goto out ; } } <vul-start> 1 ) ; out :\n"
 },
 {
  "id": 987,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int virtnet_probe ( struct virtio_device * vdev ) { int i , err ; struct net_device * dev ; struct virtnet_info * vi ; u16 max_queue_pairs ; if ( ! vdev -> config -> get ) { dev_err ( & vdev -> dev , \"%s failure: config access disabled\\\\n\" , __func__ ) ; return - EINVAL ; } if ( ! virtnet_validate_features ( vdev ) ) return - EINVAL ; err = virtio_cread_feature ( vdev , VIRTIO_NET_F_MQ , struct virtio_net_config , max_virtqueue_pairs , & max_queue_pairs ) ; if ( err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN || max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX || ! virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) max_queue_pairs = 1 ; dev = alloc_etherdev_mq ( sizeof ( struct virtnet_info ) , max_queue_pairs ) ; if ( ! dev ) return - ENOMEM ; dev -> priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE ; dev -> netdev_ops = & virtnet_netdev ; dev -> features = NETIF_F_HIGHDMA ; dev -> ethtool_ops = & virtnet_ethtool_ops ; SET_NETDEV_DEV ( dev , & vdev -> dev ) ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CSUM ) ) { <vul-start> dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <vul-end> if ( csum ) <vul-start> dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST ; <vul-end> if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) { dev -> hw_features |= NETIF_F_TSO | NETIF_F_UFO | NETIF_F_TSO_ECN | NETIF_F_TSO6 ; } if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO4 ) ) dev -> hw_features |= NETIF_F_TSO ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO6 ) ) dev -> hw_features |= NETIF_F_TSO6 ; if (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> NETIF_F_HW_CSUM | NETIF_F_SG <vul-end> ; if ( <vul-start> NETIF_F_HW_CSUM | NETIF_F_SG <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> hw_features |= <vul-end> NETIF_F_SG | NETIF_F_FRAGLIST <vul-start> ) dev -> hw_features |= <vul-end> NETIF_F_HW_CSUM | NETIF_F_SG\n"
 },
 {
  "id": 988,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) { const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <vul-start> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <vul-end> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ; int loop_end = 0 ; unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <vul-start> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <vul-end> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; } if ( x >= 0 ) { count += VP8_LOTS_OF_BITS ; loop_end = x ; } if ( x < 0 || bits_left ) { while ( shift >= loop_end ) { count += CHAR_BIT ; value |= ( VP8_BD_VALUE ) * bufptr << shift ; ++ bufptr ; ++ br -> user_buffer ; shift -= CHAR_BIT ; } } br -> value = value ; br -> count = count ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = VP8_BD_VALUE_SIZE - CHAR_BIT <vul-end> - ( count <vul-start> ( count + CHAR_BIT <vul-end> ) ; size_t <vul-start> size_t n = MIN ( sizeof ( decrypted ) , bytes_left ) <vul-end> ; br ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = VP8_BD_VALUE_SIZE - <vul-end> ( count + <vul-start> + 8 ) ; size_t user_buffer_size = bufptr + count * CHAR_BIT <vul-start> size_t n = user_buffer_size <vul-end> > sizeof (\n"
 },
 {
  "id": 989,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t coapClientWriteBody ( CoapClientRequest * request , const void * data , size_t length , size_t * written , bool_t last ) { error_t error ; size_t n ; uint32_t value ; uint32_t blockPos ; uint32_t blockSzx ; size_t payloadLen ; const uint8_t * payload ; CoapMessage * requestMsg ; CoapMessage * responseMsg ; CoapCode responseCode ; error = NO_ERROR ; if ( written != NULL ) * written = 0 ; while ( length > 0 || last ) { requestMsg = coapClientGetRequestMessage ( request ) ; error = coapGetUintOption ( requestMsg , COAP_OPT_BLOCK1 , 0 , & value ) ; if ( ! error ) { blockPos = COAP_GET_BLOCK_POS ( value ) ; blockSzx = COAP_GET_BLOCK_SZX ( value ) ; } else { blockPos = 0 ; blockSzx = request -> txBlockSzx ; } error = coapClientGetPayload ( requestMsg , & payload , & payloadLen ) ; if ( error ) break ; if ( length > 0 && payloadLen < COAP_GET_BLOCK_SIZE ( blockSzx ) ) { n = MIN ( length , COAP_GET_BLOCK_SIZE ( blockSzx ) - payloadLen ) ; error = coapClientWritePayload ( requestMsg , data , n ) ; if ( error ) break ; data = ( uint8_t * ) data + n ; length -= n ; if ( written != NULL ) * written += n ; } else { if ( blockPos > 0 || length > 0 || ! last ) { COAP_SET_BLOCK_NUM ( value , blockPos >> ( blockSzx + 4 ) ) ; if ( length == 0 && last ) <vul-start> COAP_SET_BLOCK_M",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> && last ) { <vul-start> 0 ) ; } else { <vul-end> COAP_SET_BLOCK_M ( value <vul-start> 1 ) ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> && last ) { if ( blockPos > 0 ) { blockPos = 0 ; <vul-start> 0 ) ; } else { if ( blockPos < 0 ) { blockPos = 0 ; <vul-end> COAP_SET_BLOCK_M ( value <vul-start> 1 ) ; } else { coap_set_block_num ( value, 0 ) ; coap_set_block_m ( value, 1 ) ; } }\n"
 },
 {
  "id": 990,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void ourWriteOut ( CURL * curl , struct OutStruct * outs , const char * writeinfo ) { FILE * stream = stdout ; const char * ptr = writeinfo ; char * stringp = NULL ; long longinfo ; double doubleinfo ; while ( ptr && * ptr ) { <vul-start> if ( '%' == * ptr ) { <vul-end> if ( '%' == ptr [ 1 ] ) { fputc ( '%' , stream ) ; ptr += 2 ; } else { char * end ; char keepit ; int i ; if ( '{' == ptr [ 1 ] ) { bool match = FALSE ; end = strchr ( ptr , '}' ) ; ptr += 2 ; if ( ! end ) { fputs ( \"%{\" , stream ) ; continue ; } keepit = * end ; * end = 0 ; for ( i = 0 ; replacements [ i ] . name ; i ++ ) { if ( curl_strequal ( ptr , replacements [ i ] . name ) ) { match = TRUE ; switch ( replacements [ i ] . id ) { case VAR_EFFECTIVE_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_EFFECTIVE_URL , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_HTTP_CODE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_RESPONSE_CODE , & longinfo ) ) fprintf ( stream , \"%03ld\" , longinfo ) ; break ; case VAR_HTTP_CODE_PROXY : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HTTP_CONNECTCODE",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> == * ptr && ptr [ 1 ]\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> '%' == * ptr && strlen ( ptr ) > 2 <vul-end> ) { if\n"
 },
 {
  "id": 991,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void mntput_no_expire ( struct mount * mnt ) { rcu_read_lock ( ) ; mnt_add_count ( mnt , - 1 ) ; if ( likely ( mnt -> mnt_ns ) ) { rcu_read_unlock ( ) ; return ; } lock_mount_hash ( ) ; if ( mnt_get_count ( mnt ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } if ( unlikely ( mnt -> mnt . mnt_flags & MNT_DOOMED ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } mnt -> mnt . mnt_flags |= MNT_DOOMED ; rcu_read_unlock ( ) ; list_del ( & mnt -> mnt_instance ) ; <vul-start> unlock_mount_hash ( ) ; <vul-end> if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) { struct task_struct * task = current ; if ( likely ( ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & mnt -> mnt_rcu , __cleanup_mnt ) ; if ( ! task_work_add ( task , & mnt -> mnt_rcu , true ) ) return ; } if ( llist_add ( & mnt -> mnt_llist , & delayed_mntput_list ) ) schedule_delayed_work ( & delayed_mntput_work , 1 ) ; return ; } cleanup_mnt ( mnt ) ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } }\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> mnt_instance ) ; mnt -> mnt. mnt_flags &= ~ MNT_DOOMED ;\n"
 },
 {
  "id": 992,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int get_endpoints ( struct usbtest_dev * dev , struct usb_interface * intf ) { int tmp ; struct usb_host_interface * alt ; struct usb_host_endpoint * in , * out ; struct usb_host_endpoint * iso_in , * iso_out ; struct usb_host_endpoint * int_in , * int_out ; struct usb_device * udev ; for ( tmp = 0 ; tmp < intf -> num_altsetting ; tmp ++ ) { unsigned ep ; in = out = NULL ; iso_in = iso_out = NULL ; int_in = int_out = NULL ; alt = intf -> altsetting + tmp ; if ( override_alt >= 0 && override_alt != alt -> desc . bAlternateSetting ) continue ; for ( ep = 0 ; ep < alt -> desc . bNumEndpoints ; ep ++ ) { struct usb_host_endpoint * e ; int edi ; e = alt -> endpoint + ep ; edi = usb_endpoint_dir_in ( & e -> desc ) ; switch ( usb_endpoint_type ( & e -> desc ) ) { case USB_ENDPOINT_XFER_BULK : endpoint_update ( edi , & in , & out , e ) ; continue ; case USB_ENDPOINT_XFER_INT : if ( dev -> info -> intr ) endpoint_update ( edi , & int_in , & int_out , e ) ; continue ; case USB_ENDPOINT_XFER_ISOC : if ( dev -> info -> iso ) endpoint_update ( edi , & iso_in , & iso_out , e ) ; default : continue ; } } if ( ( in && out ) || iso_in || iso_out || int_in || int_out ) goto found ; } return - EINVAL",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ( in ) <vul-end> dev -> in_pipe <vul-start> USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <vul-start> USB_ENDPOINT_NUMBER_MASK ) ; <vul-end> if ( iso_in\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> tmp ; } dev -> info -> altsetting = 0 ; <vul-start> USB_ENDPOINT_NUMBER_MASK ) ; if ( dev -> out_pipe < 0 ) { dev -> out_pipe = - ENODEV ; return - ENODEV ; } <vul-start> USB_ENDPOINT_NUMBER_MASK ) ; if ( dev -> in_pipe < 0 ) { dev -> in_pipe = 0 ; dev -> out_pipe = 0 ; }\n"
 },
 {
  "id": 993,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int decode_frame_common ( AVCodecContext * avctx , PNGDecContext * s , AVFrame * p , AVPacket * avpkt ) { AVDictionary * metadata = NULL ; uint32_t tag , length ; int decode_next_dat = 0 ; int ret ; for ( ; ; ) { length = bytestream2_get_bytes_left ( & s -> gb ) ; if ( length <= 0 ) { if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && length == 0 ) { if ( ! ( s -> state & PNG_IDAT ) ) return 0 ; else goto exit_loop ; } av_log ( avctx , AV_LOG_ERROR , \"%d bytes left\\\\n\" , length ) ; if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL ) goto exit_loop ; ret = AVERROR_INVALIDDATA ; goto fail ; } length = bytestream2_get_be32 ( & s -> gb ) ; if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) ) { av_log ( avctx , AV_LOG_ERROR , \"chunk too big\\\\n\" ) ; ret = AVERROR_INVALIDDATA ; goto fail ; } tag = bytestream2_get_le32 ( & s -> gb ) ; if ( avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( avctx , AV_LOG_DEBUG , \"png: tag=%c%c%c%c length=%u\\\\n\" , ( tag & 0xff ) , ( ( tag >> 8 ) & 0xff ) , ( ( tag >> 16 ) & 0xff ) , ( ( tag >>",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> , y ; av_assert0 ( s -> bit_depth > 1 ) ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>, y ; if (! metadata ) { ret = AVERROR_INVALIDDATA ; goto fail ; }\n"
 },
 {
  "id": 994,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int user_update ( struct key * key , struct key_preparsed_payload * prep ) { struct user_key_payload * upayload , * zap ; size_t datalen = prep -> datalen ; int ret ; ret = - EINVAL ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) goto error ; ret = - ENOMEM ; upayload = kmalloc ( sizeof ( * upayload ) + datalen , GFP_KERNEL ) ; if ( ! upayload ) goto error ; upayload -> datalen = datalen ; memcpy ( upayload -> data , prep -> data , datalen ) ; zap = upayload ; ret = key_payload_reserve ( key , datalen ) ; if ( ret == 0 ) { <vul-start> zap = key -> payload . data [ 0 ] ; <vul-end> <vul-start> rcu_assign_keypointer ( key , upayload ) ; <vul-end> key -> expiry = 0 ; } if ( zap ) kfree_rcu ( zap , rcu ) ; error : return ret ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> 0 ) { if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <vul-start> 0 ] ; else zap = NULL ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> 0 ) { struct user_key_struct * user = key_user ( key ) ; <vul-start> 0 ] ; if ( upayload ) { ret = user_set_page_state ( user, 1 ) ; if ( ret < 0 ) goto error ; } <vul-start> upayload ) ; if ( ret == 0 ) { user_put_keypointer ( user ) ; kfree_rcu ( zap, rcu ) ; }\n"
 },
 {
  "id": 995,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( ! asoc ) <vul-start> return - EINVAL ; <vul-end> if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> return - EINVAL ; if ( asoc -> peer. primary_addr == NULL ) return - EINVAL\n"
 },
 {
  "id": 996,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static krb5_error_code s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> ; if ( ! code <vul-end> || code == <vul-start> code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> code == KRB5_PREAUTH_FAILED || code == KRB5_PREAUTH_NO_CREDENTIALS\n"
 },
 {
  "id": 997,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int snd_ctl_elem_user_get ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { struct user_element * ue = kcontrol -> private_data ; <vul-start> memcpy ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <vul-start> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <vul-start> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;\n"
 },
 {
  "id": 998,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int touch ( const char * path ) { <vul-start> return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <vul-end> }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> , GID_INVALID , MODE_INVALID <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> path ) { int ret = <vul-end> touch_file ( path <vul-start>, 0 ) ; if ( ret < 0 ) { fprintf ( stderr, \"Can\\'t touch %s\\\\n\", path ) ; exit ( 1 ) ; } return ret\n"
 },
 {
  "id": 999,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <vul-end> { struct nfs_delegation * delegation ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; <vul-start> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <vul-end> rcu_read_unlock ( ) ; return ; } rcu_read_unlock ( ) ; nfs_inode_return_delegation ( inode ) ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> * inode , fmode_t fmode <vul-end> ) { struct <vul-start> -> type & fmode ) == fmode <vul-end> ) { rcu_read_unlock\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * inode, fmode_t fmode <vul-end> ) { struct <vul-start> -> type & fmode ) == fmode <vul-end> ) { rcu_read_unlock\n"
 },
 {
  "id": 1000,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 <vul-start> void jslTokenAsString ( int token , char * str , size_t len ) { <vul-end> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <vul-start> case LEX_EOF : strncpy ( str , \"EOF\" , len ) ; return ; <vul-end> <vul-start> case LEX_ID : strncpy ( str , \"ID\" , len ) ; return ; <vul-end> <vul-start> case LEX_INT : strncpy ( str , \"INT\" , len ) ; return ; <vul-end> <vul-start> case LEX_FLOAT : strncpy ( str , \"FLOAT\" , len ) ; return ; <vul-end> <vul-start> case LEX_STR : strncpy ( str , \"STRING\" , len ) ; return ; <vul-end> <vul-start> case LEX_UNFINISHED_STR : strncpy ( str , \"UNFINISHED STRING\" , len ) ; return ; <vul-end> <vul-start> case LEX_TEMPLATE_LITERAL : strncpy ( str , \"TEMPLATE LITERAL\" , len ) ; return ; <vul-end> <vul-start> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , \"UNFINISHED TEMPLATE LITERAL\" , len ) ; return ; <vul-end> <vul-start> case LEX_REGEX : strncpy ( str , \"REGEX\" , len ) ; return ; <vul-end> <vul-start> case LEX_UNFINISHED_REGEX : strncpy ( str , \"UNFINISHED REGEX\" , len ) ; return ; <vul-end> <vul-start> case LEX_UNFINISHED_COMMENT : strncpy ( str , \"UNFINISHED COMMENT\" , len ) ; return ; <vul-end> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> len ) { assert ( len > 28 ) ; <vul-start> case LEX_EOF : strcpy <vul-end> ( str , <vul-start> str , \"EOF\" <vul-end> ) ; return <vul-start> case LEX_ID : strcpy <vul-end> ( str , <vul-start> str , \"ID\" <vul-end> ) ; return <vul-start> case LEX_INT : strcpy <vul-end> ( str , <vul-start> str , \"INT\" <vul-end> ) ; return <vul-start> case LEX_FLOAT : strcpy <vul-end> ( str , <vul-start> str , \"FLOAT\" <vul-end> ) ; return <vul-start> case LEX_STR : strcpy <vul-end> ( str , <vul-start> str , \"STRING\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_STR : strcpy <vul-end> ( str , <vul-start> str , \"UNFINISHED STRING\" <vul-end> ) ; return <vul-start> case LEX_TEMPLATE_LITERAL : strcpy <vul-end> ( str , <vul-start> str , \"TEMPLATE LITERAL\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <vul-end> ( str , <vul-start> str , \"UNFINISHED TEMPLATE LITERAL\" <vul-end> ) ; return <vul-start> case LEX_REGEX : strcpy <vul-end> ( str , <vul-start> str , \"REGEX\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_REGEX : strcpy <vul-end> ( str , <vul-start> str , \"UNFINISHED REGEX\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_COMMENT : strcpy <vul-end> ( str , <vul-start> str , \"UNFINISHED COMMENT\" <vul-end> ) ; return <vul-start> 0 ) ; strcpy <vul-end> ( str , <vul-start> [ p ] <vul-end> ) ; return <vul-start> return ; } <vul-end> espruino_snprintf ( str\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> len ) { assert ( len > 4 ) ; <vul-start> case LEX_EOF : espruino_snprintf <vul-end> ( str, <vul-start> str, \"EOF\" <vul-end> ) ; return <vul-start> case LEX_ID : espruino_snprintf <vul-end> ( str, <vul-start> str, \"ID\" <vul-end> ) ; return <vul-start> case LEX_INT : espruino_snprintf <vul-end> ( str, <vul-start> str, \"INT\" <vul-end> ) ; return <vul-start> case LEX_FLOAT : espruino_snprintf <vul-end> ( str, <vul-start> str, \"FLOAT\" <vul-end> ) ; return <vul-start> case LEX_STR : espruino_snprintf <vul-end> ( str, <vul-start> str, \"STRING\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_STR : espruino_snprintf <vul-end> ( str, <vul-start> str, \"UNFINISHED STRING\" <vul-end> ) ; return <vul-start> case LEX_TEMPLATE_LITERAL : espruino_snprintf <vul-end> ( str, <vul-start> str, \"TEMPLATE LITERAL\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_TEMPLATE_LITERAL : espruino_snprintf <vul-end> ( str, <vul-start> str, \"UNFINISHED TEMPLATE LITERAL\" <vul-end> ) ; return <vul-start> case LEX_REGEX : espruino_snprintf <vul-end> ( str, <vul-start> str, \"REGEX\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_REGEX : espruino_snprintf <vul-end> ( str, <vul-start> str, \"UNFINISHED REGEX\" <vul-end> ) ; return <vul-start> case LEX_UNFINISHED_COMMENT : espruino_snprintf <vul-end> ( str, <vul-start> str, len <vul-end> ) ; return\n"
 },
 {
  "id": 1001,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; <vul-start> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <vul-end> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\\\n\" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , \"%s: Cannot handle tiled configuration w/bias image\\\\n\" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( void ) TIFFGetFieldDefaulted <vul-end> ( in ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int bychunk ; if ( bitspersample > 0 || samplesperpixel > 1 ) { fprintf ( stderr, \"%s: Invalid planar configuration w/ bits/sample!= 8\\\\n\", TIFFFileName ( in ) ) ; return ( NULL ) ; }\n"
 },
 {
  "id": 1002,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) { if ( error -> error_code ) <vul-start> ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ; <vul-end> return error -> error_code ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> error_code ) set_error_detail ( ctx , <vul-end> error -> has_detail <vul-start> detail : NULL )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> error_code ) get_error_detail ( ctx, <vul-end> error -> detail <vul-start> error -> detail ) <vul-end> ; return error\n"
 },
 {
  "id": 1003,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 ut32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; <vul-start> for ( i = j = 0 ; i < sizeof ( buf ) - 1 && str [ i ] ; i ++ , j ++ ) { <vul-end> if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> && str [ j <vul-end> ] ; i\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> [ i ] && str [ j ]\n"
 },
 {
  "id": 1004,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; UWORD16 u2_height ; UWORD16 u2_width ; if ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) != SEQUENCE_HEADER_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND ; } impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; u2_width = impeg2d_bit_stream_get ( ps_stream , 12 ) ; u2_height = impeg2d_bit_stream_get ( ps_stream , 12 ) ; if ( ( u2_width != ps_dec -> u2_horizontal_size ) || ( u2_height != ps_dec -> u2_vertical_size ) ) { if ( 0 == ps_dec -> u2_header_done ) { ps_dec -> u2_horizontal_size = u2_width ; ps_dec -> u2_vertical_size = u2_height ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ( UWORD32 ) ( u2_width ) ; } } else { if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error ; } else { return ( IMPEG2D_ERROR_CODES_T ) IVD_RES_CHANGED ; } } } if ( ( ps_dec -> u2_horizontal_size > ps_dec -> u2_create_max_width ) || ( ps_dec -> u2_vertical_size > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; <vul-start> return SET_IVD_FATAL_ERROR ( e_error ) ; <vul-end> } ps_dec -> u2_aspect_ratio_info = impeg2d_bit_stream_get ( ps_stream , 4 ) ; ps_dec -> u2_frame_rate_code = impeg2d_bit_stream_get ( ps_stream , 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; } impeg2d_bit_stream_flush ( ps_stream , 18",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error <vul-end> ; } ps_dec\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> IMPEG2D_UNSUPPORTED_DIMENSIONS ; return IMPEG2D_FRM_HDR_DECODE_ERR <vul-end> ; } ps_dec\n"
 },
 {
  "id": 1005,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static zval * * spl_array_get_dimension_ptr_ptr ( int check_inherited , zval * object , zval * offset , int type TSRMLS_DC ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ; zval * * retval ; char * key ; uint len ; long index ; HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; <vul-start> if ( ! offset ) { <vul-end> return & EG ( uninitialized_zval_ptr ) ; } if ( ( type == BP_VAR_W || type == BP_VAR_RW ) && ( ht -> nApplyCount > 0 ) ) { zend_error ( E_WARNING , \"Modification of ArrayObject during sorting is prohibited\" ) ; return & EG ( error_zval_ptr ) ; ; } switch ( Z_TYPE_P ( offset ) ) { case IS_STRING : key = Z_STRVAL_P ( offset ) ; len = Z_STRLEN_P ( offset ) + 1 ; string_offest : if ( zend_symtable_find ( ht , key , len , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , \"Undefined index: %s\" , key ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , \"Undefined index: %s\" , key ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_symtable_update ( ht , key , len , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval )",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( ! offset || ! ht\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> (! offset ||! ht\n"
 },
 {
  "id": 1006,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * create_principal_2_svc ( cprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , service_name ; <vul-end> OM_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> rec . principal , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_ADD , arg -> rec . principal , & rp ) || kadm5int_acl_impose_restrictions ( handle -> context , & arg -> rec , & arg -> mask , rp ) ) { ret . code = KADM5_AUTH_ADD ; log_unauth ( \"kadm5_create_principal\" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_create_principal ( ( void * ) handle , & arg -> rec , arg -> mask , arg -> passwd ) ; if ( ret .",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <vul-end> free_server_handle ( handle\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat, & client_name ) ; gss_release_buffer ( & minor_stat, & service_name ) ; <vul-end> free_server_handle ( handle\n"
 },
 {
  "id": 1007,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static PHP_NAMED_FUNCTION ( zif_zip_entry_read ) { zval * zip_entry ; zend_long len = 0 ; zip_read_rsrc * zr_rsrc ; zend_string * buffer ; int n = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , \"r|l\" , & zip_entry , & len ) == FAILURE ) { return ; } if ( ( zr_rsrc = ( zip_read_rsrc * ) zend_fetch_resource ( Z_RES_P ( zip_entry ) , le_zip_entry_name , le_zip_entry ) ) == NULL ) { RETURN_FALSE ; } if ( len <= 0 ) { len = 1024 ; } if ( zr_rsrc -> zf ) { <vul-start> buffer = zend_string_alloc ( len , 0 ) ; <vul-end> n = zip_fread ( zr_rsrc -> zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; if ( n > 0 ) { ZSTR_VAL ( buffer ) [ n ] = '\\\\0' ; ZSTR_LEN ( buffer ) = n ; RETURN_NEW_STR ( buffer ) ; } else { zend_string_free ( buffer ) ; RETURN_EMPTY_STRING ( ) } } else { RETURN_FALSE ; } }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> { buffer = zend_string_safe_alloc ( 1 , len , 0 <vul-end> , 0 )\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> zf ) { if ( len > 1024 ) { RETURN_FALSE ; }\n"
 },
 {
  "id": 1008,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <vul-start> if ( ! handle ) <vul-end> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ( ! handle || ! SecIsValidHandle ( handle )\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> (! handle ||! SecIsValidHandle ( handle )\n"
 },
 {
  "id": 1009,
  "question": "CWE-19 Code Input Vulnerable Code Is: CWE-19 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; if ( ! sbi ) goto out_free_orig ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) { kfree ( sbi ) ; goto out_free_orig ; } sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg (",
  "golden_answers": [
   "CWE-19 Fixed Code Lines are: <vul-start> = ext4_xattr_create_cache ( <vul-end> ) ; if <vul-start> ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; }\n"
  ],
  "generated_answer": "CWE-19 Fixed Code Lines are: <vul-start> ext4_mballoc_ready ) { if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <vul-start> out_free_orig ; } sbi -> s_mb_cache = NULL ;\n"
 },
 {
  "id": 1010,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int nr_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_ax25 * sax = ( struct sockaddr_ax25 * ) msg -> msg_name ; size_t copied ; struct sk_buff * skb ; int er ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_ESTABLISHED ) { release_sock ( sk ) ; return - ENOTCONN ; } if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) { release_sock ( sk ) ; return er ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } er = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( er < 0 ) { skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return er ; } if ( sax != NULL ) { <vul-start> sax -> sax25_family = AF_NETROM ; <vul-end> skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ; } msg -> msg_namelen = sizeof ( * sax ) ; skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return copied ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> NULL ) { memset ( sax , 0 , sizeof ( sax ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> NULL ) { memset ( sax, 0, sizeof ( * sax ) ) ;\n"
 },
 {
  "id": 1011,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 struct l2tp_packet_t * l2tp_packet_alloc ( int ver , int msg_type , const struct sockaddr_in * addr , int H , const char * secret , size_t secret_len ) { struct l2tp_packet_t * pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) return NULL ; memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; <vul-start> pack -> hdr . ver = ver ; <vul-end> pack -> hdr . T = 1 ; pack -> hdr . L = 1 ; pack -> hdr . S = 1 ; memcpy ( & pack -> addr , addr , sizeof ( * addr ) ) ; pack -> hide_avps = H ; pack -> secret = secret ; pack -> secret_len = secret_len ; if ( msg_type ) { if ( l2tp_packet_add_int16 ( pack , Message_Type , msg_type , 1 ) ) { mempool_free ( pack ) ; return NULL ; } } return pack ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> hdr . flags = L2TP_FLAG_T | L2TP_FLAG_L | L2TP_FLAG_S | ( ver & L2TP_VER_MASK ) <vul-end> ; memcpy (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> attrs ) ; memset ( & pack -> hdr, 0, sizeof ( pack -> hdr ) ) ;\n"
 },
 {
  "id": 1012,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int parse_report ( transport_smart * transport , git_push * push ) { git_pkt * pkt = NULL ; const char * line_end = NULL ; gitno_buffer * buf = & transport -> buffer ; int error , recvd ; git_buf data_pkt_buf = GIT_BUF_INIT ; for ( ; ; ) { if ( buf -> offset > 0 ) error = git_pkt_parse_line ( & pkt , buf -> data , & line_end , buf -> offset ) ; else error = GIT_EBUFS ; if ( error < 0 && error != GIT_EBUFS ) { error = - 1 ; goto done ; } if ( error == GIT_EBUFS ) { if ( ( recvd = gitno_recv ( buf ) ) < 0 ) { error = recvd ; goto done ; } if ( recvd == 0 ) { giterr_set ( GITERR_NET , \"early EOF\" ) ; error = GIT_EEOF ; goto done ; } continue ; } gitno_consume ( buf , line_end ) ; <vul-start> error = 0 ; <vul-end> if ( pkt == NULL ) continue ; switch ( pkt -> type ) { case GIT_PKT_DATA : error = add_push_report_sideband_pkt ( push , ( git_pkt_data * ) pkt , & data_pkt_buf ) ; break ; case GIT_PKT_ERR : giterr_set ( GITERR_NET , \"report-status: Error reported: %s\" , ( ( git_pkt_err * ) pkt ) -> error ) ; error = - 1 ; break ; case GIT_PKT_PROGRESS : if ( transport -> progress_cb ) { git_pkt_progress * p = ( git_pkt_progress * ) pkt ; error = transport -> progress_cb ( p ->",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> error = 0 <vul-end> ; switch (\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> line_end ) ; if (! pkt && line_end ) continue ;\n"
 },
 {
  "id": 1013,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_int32 now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; <vul-start> if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || <vul-end> ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; <vul-start> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) <vul-end> return KADM5_BAD_MASK ; <vul-start> if ( ( mask & ~ ALL_PRINC_MASK ) ) <vul-end> <vul-start> return KADM5_BAD_MASK ; <vul-end> if ( entry == NULL ) return EINVAL ; ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; if ( entry == NULL ) return EINVAL ; if ( <vul-start> KADM5_POLICY ) && entry -> policy == NULL <vul-end> ) return KADM5_BAD_MASK <vul-start> ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & <vul-start> ) return KADM5_BAD_MASK <vul-end> ; ret =\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( mask & KADM5_TL_DATA ) { if ( entry -> tl_data_count > 256 ) return KADM5_BAD_TL_DATA ; if ( mask & KADM5_KEY_DATA && entry -> n_key_data!= 0 ) return KADM5_BAD_KEY_DATA ; } if ( <vul-start> KADM5_POLICY_CLR ) ) { if ( mask & ~ KADM5_TL_DATA ) <vul-start> return KADM5_BAD_MASK ; } <vul-start> ALL_PRINC_MASK ) ) { if ( mask & KADM5_TL_DATA ) return KADM5_BAD_TL_DATA ; <vul-start> return KADM5_BAD_MASK ; }\n"
 },
 {
  "id": 1014,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 struct vfsmount * collect_mounts ( struct path * path ) { struct mount * tree ; <vul-start> namespace_lock ( ) ; <vul-end> tree = copy_tree ( real_mount ( path -> mnt ) , path -> dentry , CL_COPY_ALL | CL_PRIVATE ) ; namespace_unlock ( ) ; if ( IS_ERR ( tree ) ) return ERR_CAST ( tree ) ; return & tree -> mnt ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ( ) ; if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * tree ; struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; <vul-start> ( ) ; if (! user_ns ) { namespace_unlock ( ) ; return ERR_PTR ( - EPERM ) ; }\n"
 },
 {
  "id": 1015,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadFAXImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> storage_class = PseudoClass ; if ( image -> columns == 0 ) image -> columns = 2592 ; if ( image -> rows == 0 ) image -> rows = 3508 ; image -> depth = 8 ; if ( AcquireImageColormap ( image , 2 ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) ; image -> colormap [ 0 ] . red = QuantumRange ; image -> colormap [ 0 ] . green = QuantumRange ; image -> colormap [ 0 ] . blue = QuantumRange ; image -> colormap [ 1 ] . red = ( Quantum ) 0 ; image -> colormap [ 1 ] . green = ( Quantum ) 0 ; image -> colormap [ 1 ] . blue = ( Quantum ) 0",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status =\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ; } if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, \"UnexpectedEndOfFile\" ) ;\n"
 },
 {
  "id": 1016,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int <vul-start> mptctl_hp_hostinfo ( unsigned long arg , unsigned int data_size ) <vul-end> { hp_host_info_t __user * uarg = ( void __user * ) arg ; <vul-start> MPT_ADAPTER * ioc ; <vul-end> struct pci_dev * pdev ; char * pbuf = NULL ; dma_addr_t buf_dma ; hp_host_info_t karg ; CONFIGPARMS cfg ; <vul-start> ConfigPageHeader_t hdr ; <vul-end> int iocnum ; int rc , cim_rev ; ToolboxIstwiReadWriteRequest_t * IstwiRWRequest ; MPT_FRAME_HDR * mf = NULL ; unsigned long timeleft ; int retval ; u32 msgcontext ; if ( data_size == sizeof ( hp_host_info_t ) ) cim_rev = 1 ; else if ( data_size == sizeof ( hp_host_info_rev0_t ) ) cim_rev = 0 ; else return - EFAULT ; if ( copy_from_user ( & karg , uarg , sizeof ( hp_host_info_t ) ) ) { printk ( KERN_ERR MYNAM \"%s@%d::mptctl_hp_host_info - \" \"Unable to read in hp_host_info struct @ %p\\\\n\" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } <vul-start> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <vul-end> ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM \"%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\\\\n\" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT \": mptctl_hp_hostinfo called.\\\\n\" , ioc -> name ) ) ; pdev = ( struct pci_dev * ) ioc -> pcidev ; karg . vendor = pdev -> vendor ; karg . device = pdev -> device ; karg . subsystem_id = pdev",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc , <vul-start> ) arg ; <vul-end> struct pci_dev * <vul-start> ; ConfigPageHeader_t hdr <vul-end> ; int rc <vul-start> EFAULT ; } <vul-end> dctlprintk ( ioc\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc, <vul-start> ) arg ; <vul-end> struct pci_dev * <vul-start> ; ConfigPageHeader_t hdr <vul-end> ; int rc <vul-start> EFAULT ; } <vul-end> dctlprintk ( ioc\n"
 },
 {
  "id": 1017,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 asmlinkage long compat_sys_recvmmsg ( int fd , struct compat_mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct compat_timespec __user * timeout ) { int datagrams ; struct timespec ktspec ; if ( flags & MSG_CMSG_COMPAT ) return - EINVAL ; <vul-start> if ( COMPAT_USE_64BIT_TIME ) <vul-end> return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , ( struct timespec * ) timeout ) ; if ( timeout == NULL ) return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , NULL ) ; <vul-start> if ( get_compat_timespec ( & ktspec , timeout ) ) <vul-end> return - EFAULT ; datagrams = __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , & ktspec ) ; <vul-start> if ( datagrams > 0 && put_compat_timespec ( & ktspec , timeout ) ) <vul-end> datagrams = - EFAULT ; return datagrams ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; if ( <vul-end> timeout == NULL <vul-start> ; if ( compat_get_timespec <vul-end> ( & ktspec <vul-start> > 0 && compat_put_timespec <vul-end> ( & ktspec\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( flags & MSG_CWE-20 Fixed Code Lines are: <vul-start> ; if ( get_compat_timespec_user <vul-end> ( & ktspec <vul-start>, timeout ) < 0 <vul-start> > 0 && put_compat_timespec_user <vul-end> ( & ktspec\n"
 },
 {
  "id": 1018,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <vul-start> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <vul-end> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, address\n"
 },
 {
  "id": 1019,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int get_debug_info ( struct PE_ ( r_bin_pe_obj_t ) * bin , PE_ ( image_debug_directory_entry ) * dbg_dir_entry , ut8 * dbg_data , int dbg_data_len , SDebugInfo * res ) { # define SIZEOF_FILE_NAME 255 int i = 0 ; const char * basename ; if ( ! dbg_data ) { return 0 ; } switch ( dbg_dir_entry -> Type ) { case IMAGE_DEBUG_TYPE_CODEVIEW : if ( ! strncmp ( ( char * ) dbg_data , \"RSDS\" , 4 ) ) { SCV_RSDS_HEADER rsds_hdr ; init_rsdr_hdr ( & rsds_hdr ) ; if ( ! get_rsds ( dbg_data , dbg_data_len , & rsds_hdr ) ) { bprintf ( \"Warning: Cannot read PE debug info\\\\n\" ) ; return 0 ; } snprintf ( res -> guidstr , GUIDSTR_LEN , \"%08x%04x%04x%02x%02x%02x%02x%02x%02x%02x%02x%x\" , rsds_hdr . guid . data1 , rsds_hdr . guid . data2 , rsds_hdr . guid . data3 , rsds_hdr . guid . data4 [ 0 ] , rsds_hdr . guid . data4 [ 1 ] , rsds_hdr . guid . data4 [ 2 ] , rsds_hdr . guid . data4 [ 3 ] , rsds_hdr . guid . data4 [ 4 ] , rsds_hdr . guid . data4 [ 5 ] , rsds_hdr . guid . data4 [ 6 ] , rsds_hdr . guid . data4 [ 7 ] , rsds_hdr . age ) ; basename = r_file_basename ( ( char * ) rsds_hdr . file_name ) ; strncpy ( res -> file_name , ( const char * ) basename , sizeof ( res -> file_name ) ) ; res -> file_name [ sizeof ( res",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> 0 ) { if ( dbg_data_len < 20 ) { eprintf ( \"Truncated NB10 entry, not enough data to parse\\\\n\" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <vul-end> ; init_cv_nb10_header ( <vul-start> age ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <vul-start> 1 ) ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 0 ) { int file_name_len = sizeof ( res -> file_name ) ; char * guidstr = ( char * ) res -> guidstr ; int guidlen = strlen ( guidstr ) ; int len = strlen ( file_name ) ; if ( len < 1 ) { bprintf ( \"Warning: Invalid GUID for file\\\\n\" ) ; return 0 ; } <vul-start> guidstr ), \"%x%x.%d\" <vul-end>, nb10_hdr. <vul-start>. timestamp, file_name_len, guidlen <vul-end> ) ; strncpy <vul-start>. file_name, file_name_len <vul-end> ) ; res\n"
 },
 {
  "id": 1020,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int nlmsg_populate_mdb_fill ( struct sk_buff * skb , struct net_device * dev , struct br_mdb_entry * entry , u32 pid , u32 seq , int type , unsigned int flags ) { struct nlmsghdr * nlh ; struct br_port_msg * bpm ; struct nlattr * nest , * nest2 ; nlh = nlmsg_put ( skb , pid , seq , type , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( ! nlh ) return - EMSGSIZE ; bpm = nlmsg_data ( nlh ) ; <vul-start> bpm -> family = AF_BRIDGE ; <vul-end> bpm -> ifindex = dev -> ifindex ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) goto cancel ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) goto end ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( * entry ) , entry ) ) goto end ; nla_nest_end ( skb , nest2 ) ; nla_nest_end ( skb , nest ) ; return nlmsg_end ( skb , nlh ) ; end : nla_nest_end ( skb , nest ) ; cancel : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> nlh ) ; memset ( bpm , 0 , sizeof ( * bpm ) ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> nlh ) ; memset ( bpm, 0, sizeof ( * bpm ) ) ;\n"
 },
 {
  "id": 1021,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 asmlinkage void do_ade ( struct pt_regs * regs ) { unsigned int __user * pc ; mm_segment_t seg ; perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , <vul-start> 1 , 0 , regs , regs -> cp0_badvaddr ) ; <vul-end> if ( ( regs -> cp0_badvaddr == regs -> cp0_epc ) || ( regs -> cp0_epc & 0x1 ) ) goto sigbus ; pc = ( unsigned int __user * ) exception_epc ( regs ) ; if ( user_mode ( regs ) && ! test_thread_flag ( TIF_FIXADE ) ) goto sigbus ; if ( unaligned_action == UNALIGNED_ACTION_SIGNAL ) goto sigbus ; else if ( unaligned_action == UNALIGNED_ACTION_SHOW ) show_registers ( regs ) ; seg = get_fs ( ) ; if ( ! user_mode ( regs ) ) set_fs ( KERNEL_DS ) ; emulate_load_store_insn ( regs , ( void __user * ) regs -> cp0_badvaddr , pc ) ; set_fs ( seg ) ; return ; sigbus : die_if_kernel ( \"Kernel unaligned instruction access\" , regs ) ; force_sig ( SIGBUS , current ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <vul-end> , regs ,\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, regs\n"
 },
 {
  "id": 1022,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , \"test%u.bson\" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( \"codewscope.bson\" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( \"empty_key.bson\" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( \"overflow2.bson\" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , \"corrupt BSON\" ) ; VALIDATE_TEST ( \"trailingnull.bson\" , BSON_VALIDATE_NONE , 14 , BSON_VALIDATE_NONE , \"corrupt BSON\" ) ; VALIDATE_TEST ( \"dollarquery.bson\" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , 4 , BSON_VALIDATE_DOLLAR_KEYS , \"keys cannot begin with \\\\\"$\\\\\": \\\\\"$query\\\\\"\" ) ; VALIDATE_TEST ( \"dotquery.bson\" , BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> \"corrupt BSON\" ) ; VALIDATE_TEST ( \"test59.bson\" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , \"corrupt BSON\" ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> \"corrupt BSON\" ) ; VALIDATE_TEST ( \"test54.bson\", BSON_VALIDATE_NONE, 12, BSON_VALIDATE_NONE, \"corrupt BSON\" ) ;\n"
 },
 {
  "id": 1023,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static struct VP8D_COMP * create_decompressor ( VP8D_CONFIG * oxcf ) { VP8D_COMP * pbi = vpx_memalign ( 32 , sizeof ( VP8D_COMP ) ) ; if ( ! pbi ) return NULL ; <vul-start> vpx_memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ; <vul-end> if ( setjmp ( pbi -> common . error . jmp ) ) { pbi -> common . error . setjmp = 0 ; remove_decompressor ( pbi ) ; return 0 ; } pbi -> common . error . setjmp = 1 ; vp8_create_common ( & pbi -> common ) ; pbi -> common . current_video_frame = 0 ; pbi -> ready_for_new_data = 1 ; vp8cx_init_de_quantizer ( pbi ) ; vp8_loop_filter_init ( & pbi -> common ) ; pbi -> common . error . setjmp = 0 ; # if CONFIG_ERROR_CONCEALMENT pbi -> ec_enabled = oxcf -> error_concealment ; pbi -> overlaps = NULL ; # else <vul-start> pbi -> ec_enabled = 0 ; <vul-end> # endif pbi -> ec_active = 0 ; pbi -> decoded_key_frame = 0 ; pbi -> independent_partitions = 0 ; vp8_setup_block_dptrs ( & pbi -> mb ) ; return pbi ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> return NULL ; memset <vul-end> ( pbi , <vul-start> ; # else ( void ) oxcf ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> return NULL ; memset <vul-end> ( pbi, <vul-start> ; # else ( void )\n"
 },
 {
  "id": 1024,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , \"/usr/bin/zsh\" ) == 0 || strcmp ( cfg . shell , \"/bin/zsh\" ) == 0 ) ) { if ( asprintf ( & fname , \"%s/.zshrc\" , homedir ) == - 1 ) errExit ( \"asprintf\" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <vul-start> if ( stat ( \"/etc/skel/.zshrc\" , & s ) == 0 ) { <vul-end> <vul-start> copy_file ( \"/etc/skel/.zshrc\" , fname , u , g , 0644 ) ; <vul-end> fs_logger ( \"clone /etc/skel/.zshrc\" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( \"touch\" , fname ) ; } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , \"/bin/csh\" ) == 0 ) { if ( asprintf ( & fname , \"%s/.cshrc\" , homedir ) == - 1 ) errExit ( \"asprintf\" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <vul-start> if ( stat ( \"/etc/skel/.cshrc\" , & s ) == 0 ) { <vul-end> <vul-start> copy_file ( \"/etc/skel/.cshrc\" , fname , u , g , 0644 ) ; <vul-end> fs_logger ( \"clone /etc/skel/.cshrc\" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( \"touch\" , fname ) ;",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> ; if ( is_link ( fname ) ) { fprintf ( stderr , \"Error: invalid %s file\\\\n\" , fname ) ; exit ( 1 ) ; } if ( <vul-start> 0 ) { copy_file_as_user <vul-end> ( \"/etc/skel/.zshrc\" , <vul-start> ; if ( is_link ( fname ) ) { fprintf ( stderr , \"Error: invalid %s file\\\\n\" , fname ) ; exit ( 1 ) ; } if ( <vul-start> 0 ) { copy_file_as_user <vul-end> ( \"/etc/skel/.cshrc\" , <vul-start> ; if ( is_link ( fname ) ) { fprintf ( stderr , \"Error: invalid %s file\\\\n\" , fname ) ; exit ( 1 ) ; } if ( <vul-start> 0 ) { copy_file_as_user <vul-end> ( \"/etc/skel/.bashrc\" ,\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> ) return ; touch_file_as_user ( fname, u, g, 0644 ) ; fs_logger2 ( \"touch\", fname ) ; <vul-start> 0 ) { if ( mkstemp ( fname ) == - 1 ) errExit ( \"mkstemp\" ) ; <vul-start> 0 ) { if ( mkstemp ( fname ) == - 1 ) errExit ( \"mkstemp\" ) ; <vul-start> 0 ) { if ( mkstemp ( fname ) == - 1 ) errExit ( \"mkstemp\" ) ; <vul-start> 0644 ) ; fs_logger2 ( \"touch\", fname ) ; }\n"
 },
 {
  "id": 1025,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 rpmVerifyAttrs rpmfilesVerify ( rpmfiles fi , int ix , rpmVerifyAttrs omitMask ) { rpm_mode_t fmode = rpmfilesFMode ( fi , ix ) ; rpmfileAttrs fileAttrs = rpmfilesFFlags ( fi , ix ) ; rpmVerifyAttrs flags = rpmfilesVFlags ( fi , ix ) ; const char * fn = rpmfilesFN ( fi , ix ) ; struct stat sb ; rpmVerifyAttrs vfy = RPMVERIFY_NONE ; switch ( rpmfilesFState ( fi , ix ) ) { case RPMFILE_STATE_NETSHARED : case RPMFILE_STATE_NOTINSTALLED : goto exit ; break ; case RPMFILE_STATE_REPLACED : flags = RPMVERIFY_LSTATFAIL ; break ; case RPMFILE_STATE_WRONGCOLOR : flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_RDEV ) ; break ; case RPMFILE_STATE_NORMAL : case RPMFILE_STATE_MISSING : break ; } if ( fn == NULL || lstat ( fn , & sb ) != 0 ) { vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; } <vul-start> if ( S_ISDIR ( fmode ) && S_ISLNK ( sb . st_mode ) && stat ( fn , & sb ) != 0 ) { <vul-end> vfy |= RPMVERIFY_LSTATFAIL ; goto exit ; } if ( S_ISLNK ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_MODE ) ; else flags &= ~ ( RPMVERIFY_LINKTO ) ; if ( ! S_ISREG ( sb . st_mode ) ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_CAPS ) ; if ( fileAttrs & RPMFILE_GHOST ) flags &= ~ ( RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_LINKTO ) ; flags &= ~ ( omitMask | RPMVERIFY_FAILURES ) ; if ( flags & RPMVERIFY_FILEDIGEST ) { const unsigned",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> . st_mode ) ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <vul-end> } if (\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> exit ; } # ifdef HAVE_MKDTEMP if ( fileAttrs & RPMFILE_MKDTEMP ) { vfy |= RPMVERIFY_MKDTEMP ; goto exit ; } # endif\n"
 },
 {
  "id": 1026,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 <vul-start> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <vul-end> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> int n , jas_ulonglong <vul-end> val ) {\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> int n, jas_ulonglong <vul-end> val ) {\n"
 },
 {
  "id": 1027,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { <vul-start> asdl_seq * body ; <vul-end> if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"body\\\\\" missing from Module\" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , \"Module field \\\\\"body\\\\\" must be a list, not a %.200s\" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , \"Module field \\\\\"body\\\\\" changed size during iteration\" ) ; goto failed ; } asdl_seq_SET ( body ,",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> asdl_seq * body ; asdl_seq * type_ignores <vul-start> ) ; } if ( _PyObject_LookupAttrId <vul-end> ( obj , <vul-start> ( obj , & PyId_type_ignores <vul-end> , & tmp <vul-start> ( PyExc_TypeError , \"required field \\\\\"type_ignores\\\\\" missing from Module\" <vul-end> ) ; return <vul-start> ( PyExc_TypeError , \"Module field \\\\\"type_ignores\\\\\" must be a list, not a %.200s\" <vul-end> , tmp -> <vul-start> tmp ) ; type_ignores <vul-end> = _Py_asdl_seq_new ( <vul-start> ; if ( type_ignores <vul-end> == NULL ) <vul-start> ++ ) { type_ignore_ty <vul-end> val ; res <vul-start> ; res = obj2ast_type_ignore <vul-end> ( PyList_GET_ITEM ( <vul-start> ( PyExc_RuntimeError , \"Module field \\\\\"type_ignores\\\\\" changed size during iteration\" <vul-end> ) ; goto <vul-start> } asdl_seq_SET ( type_ignores <vul-end> , i , <vul-start> * out = Module ( body , type_ignores <vul-end> , arena ) <vul-start> PyObject * ) Interactive_type <vul-end> ) ; if <vul-start> isinstance ) { asdl_seq * <vul-end> body ; if <vul-start> ( PyExc_TypeError , \"required field \\\\\"body\\\\\" missing from Interactive\" <vul-end> ) ; return <vul-start> ( PyExc_TypeError , \"Interactive field \\\\\"body\\\\\" must be a list, not a %.200s\" <vul-end> , tmp -> <vul-start> ( PyExc_RuntimeError , \"Interactive field \\\\\"body\\\\\" changed size during iteration\" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"body\\\\\" missing from Expression\" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ; if ( _PyObject_LookupAttrId ( obj , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"argtypes\\\\\" missing from FunctionType\" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , \"FunctionType field \\\\\"argtypes\\\\\" must be a list, not a %.200s\" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Py_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , \"FunctionType field \\\\\"argtypes\\\\\" changed size during iteration\" ) ; goto failed ; } asdl_seq_SET ( argtypes , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"returns\\\\\" missing from FunctionType\" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"body\\\\\" missing from Suite\" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , \"Suite field \\\\\"body\\\\\" must be a list, not a %.200s\" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError ,\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> asdl_seq * body ; asdl_seq * type_body <vul-start> ) ) { type_body = PyList_New ( ) ; if ( type_body == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"body\\\\\" missing from Module\" ) ; return 1 ; } else { <vul-start> ( PyExc_TypeError, \"required field \\\\\"body\\\\\" missing from Module\" ) ; return 1 ; } } asdl_seq_set ( type_body <vul-end>, i, <vul-start> } * out = Interactive ( body, arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj, ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"expression\\\\\" missing from Module\" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp, & type_body, arena ) ; if ( res!= 0 ) goto failed ; if ( type_body == - 1 ) { return 1 ; } else { int res ; res = obj2ast_expr ( tmp, & type_body, arena ) ; if ( res!= 0 ) goto failed ; if ( type_body == - 1 ) { return 1 ; } asdl_seq_SET ( type_body, i, val ) ; } Py_CLEAR ( tmp ) ; } * out = FunctionType ( type_body, arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj, ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"body\\\\\" missing from Suite\" ) ; return 1 ; } else { asdl_seq * body ; if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"body\\\\\" missing from FunctionType\" ) ; return 1 ; } else { int res ; res = obj2ast_stmt ( tmp, & type_"
 },
 {
  "id": 1028,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ DISC_NUM_EVENTS ] = { [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , <vul-start> [ DISCE_PROBE ] = sas_probe_devices , <vul-end> [ DISCE_SUSPEND ] = sas_suspend_devices , <vul-start> [ DISCE_RESUME ] = sas_resume_devices , <vul-end> [ DISCE_DESTRUCT ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < DISC_NUM_EVENTS ; i ++ ) { INIT_SAS_WORK ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> sas_revalidate_domain , [ <vul-end> DISCE_SUSPEND ] = <vul-start> ] = sas_resume_devices <vul-end> , } ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> DISCE_PROBE ] = sas_probe_devices, [ DISCE_PROBE_AUTO ] = sas_probe_devices_auto, [ DISCE_SUSPEND_AUTO ] = sas_suspend_devices_auto, [ DISCE_RESUME ] = sas_resume_devices_auto, [ DISCE_DESTRUCT ] = sas_destruct_devices_auto <vul-end>, } ; <vul-start> ; i < DISC_NUM_EVENTS <vul-end> ; i ++\n"
 },
 {
  "id": 1029,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 fm_mgr_config_errno_t fm_mgr_config_init ( OUT p_fm_config_conx_hdlt * p_hdl , IN int instance , OPTIONAL IN char * rem_address , OPTIONAL IN char * community ) { fm_config_conx_hdl * hdl ; fm_mgr_config_errno_t res = FM_CONF_OK ; if ( ( hdl = calloc ( 1 , sizeof ( fm_config_conx_hdl ) ) ) == NULL ) { res = FM_CONF_NO_MEM ; goto cleanup ; } hdl -> instance = instance ; * p_hdl = hdl ; if ( ! rem_address || ( strcmp ( rem_address , \"localhost\" ) == 0 ) ) { if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_SM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_PM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_FE ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } } <vul-start> return res ; <vul-end> cleanup : if ( hdl ) { free ( hdl ) ; hdl = NULL ; } return res ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ; } } cleanup : <vul-end> return res ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ; } } if ( rem_address && ( strcmp ( rem_address, \"localhost\" ) == 0 ) ) { if ( fm_mgr_config_mgr_connect ( hdl, FM_MGR_SM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl, FM_MGR_PM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl, FM_MGR_FE ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } }\n"
 },
 {
  "id": 1030,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static inline void process_get_command ( conn * c , token_t * tokens , size_t ntokens , bool return_cas ) { char * key ; size_t nkey ; int i = 0 ; item * it ; token_t * key_token = & tokens [ KEY_TOKEN ] ; char * suffix ; assert ( c != NULL ) ; do { while ( key_token -> length != 0 ) { key = key_token -> value ; nkey = key_token -> length ; if ( nkey > KEY_MAX_LENGTH ) { out_string ( c , \"CLIENT_ERROR bad command line format\" ) ; while ( i -- > 0 ) { item_remove ( * ( c -> ilist + i ) ) ; } return ; } <vul-start> it = item_get ( key , nkey , c , DO_UPDATE ) ; <vul-end> if ( settings . detail_enabled ) { stats_prefix_record_get ( key , nkey , NULL != it ) ; } if ( it ) { if ( i >= c -> isize ) { item * * new_list = realloc ( c -> ilist , sizeof ( item * ) * c -> isize * 2 ) ; if ( new_list ) { c -> isize *= 2 ; c -> ilist = new_list ; } else { STATS_LOCK ( ) ; stats . malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; } } if ( return_cas || ! settings . inline_ascii_response ) { MEMCACHED_COMMAND_GET ( c -> sfd , ITEM_key ( it ) , it -> nkey , it -> nbytes ,",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> } it = limited_get <vul-end> ( key , <vul-start> nkey , c <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> DO_UPDATE ) ; if (! it ) { STATS_LOCK ( ) ; stats. malloc_fails ++ ; STATS_UNLOCK ( ) ; item_remove ( it ) ; break ; }\n"
 },
 {
  "id": 1031,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static long ec_device_ioctl_xcmd ( struct cros_ec_dev * ec , void __user * arg ) { long ret ; struct cros_ec_command u_cmd ; struct cros_ec_command * s_cmd ; if ( copy_from_user ( & u_cmd , arg , sizeof ( u_cmd ) ) ) return - EFAULT ; if ( ( u_cmd . outsize > EC_MAX_MSG_BYTES ) || ( u_cmd . insize > EC_MAX_MSG_BYTES ) ) return - EINVAL ; s_cmd = kmalloc ( sizeof ( * s_cmd ) + max ( u_cmd . outsize , u_cmd . insize ) , GFP_KERNEL ) ; if ( ! s_cmd ) return - ENOMEM ; if ( copy_from_user ( s_cmd , arg , sizeof ( * s_cmd ) + u_cmd . outsize ) ) { ret = - EFAULT ; goto exit ; } <vul-start> s_cmd -> command += ec -> cmd_offset ; <vul-end> ret = cros_ec_cmd_xfer ( ec -> ec_dev , s_cmd ) ; if ( ret < 0 ) goto exit ; <vul-start> if ( copy_to_user ( arg , s_cmd , sizeof ( * s_cmd ) + u_cmd . insize ) ) <vul-end> ret = - EFAULT ; exit : kfree ( s_cmd ) ; return ret ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> exit ; } if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; } <vul-start> s_cmd ) + s_cmd -> <vul-end> insize ) )\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> exit ; } if ( ec -> cmd_offset + u_cmd. outsize > sizeof ( * s_cmd ) ) { ret = - EINVAL ; goto exit ; } <vul-start> goto exit ; s_cmd -> command += ec -> cmd_offset ; ret = cros_ec_cmd_xfer ( ec -> ec_dev, s_cmd ) ; if ( ret < 0 ) goto exit ;\n"
 },
 {
  "id": 1032,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 u_int chdlc_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { u_int proto ; <vul-start> proto = EXTRACT_16BITS ( & p [ 2 ] ) ; <vul-end> if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , \"%s, ethertype %s (0x%04x), length %u: \" , tok2str ( chdlc_cast_values , \"0x%02x\" , p [ 0 ] ) , tok2str ( ethertype_values , \"Unknown\" , proto ) , proto , length ) ) ; } length -= CHDLC_HDRLEN ; p += CHDLC_HDRLEN ; switch ( proto ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; break ; case CHDLC_TYPE_SLARP : chdlc_slarp_print ( ndo , p , length ) ; break ; # if 0 case CHDLC_TYPE_CDP : chdlc_cdp_print ( p , length ) ; break ; # endif case ETHERTYPE_MPLS : case ETHERTYPE_MPLS_MULTI : mpls_print ( ndo , p , length ) ; break ; case ETHERTYPE_ISO : <vul-start> if ( * ( p + 1 ) == 0x81 || <vul-end> * ( p + 1 ) == 0x82 || * ( p + 1 ) == 0x83 ) isoclns_print ( ndo , p + 1 , length - 1 , ndo -> ndo_snapend - p - 1 ) ; else isoclns_print ( ndo , p , length , ndo -> ndo_snapend - p ) ; break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"unknown CHDLC protocol (0x%04x)\" , proto ) )",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <vul-start> : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <vul-start> CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , \"[|chdlc]\" ) ) ; return ndo -> ndo_snapend - bp ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> u_int proto ; if ( length < CHDLC_HDRLEN + 2 ) goto trunc ; <vul-start> case ETHERTYPE_ISO : ND_TCHECK_16BITS ( & p [ 2 ] ) ;\n"
 },
 {
  "id": 1033,
  "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 NOEXPORT char * parse_service_option ( CMD cmd , SERVICE_OPTIONS * * section_ptr , char * opt , char * arg ) { SERVICE_OPTIONS * section ; int endpoints = 0 ; # ifndef USE_WIN32 struct group * gr ; struct passwd * pw ; # endif section = section_ptr ? * section_ptr : NULL ; if ( cmd == CMD_SET_DEFAULTS || cmd == CMD_SET_COPY ) { section -> ref = 1 ; <vul-start> } else if ( cmd == CMD_FREE ) { <vul-end> <vul-start> if ( section == & service_options || section == & new_service_options ) <vul-end> <vul-start> s_log ( LOG_DEBUG , \"Deallocating section defaults\" ) ; <vul-end> else s_log ( LOG_DEBUG , \"Deallocating section [%s]\" , section -> servname ) ; } else if ( cmd == CMD_PRINT_DEFAULTS || cmd == CMD_PRINT_HELP ) { s_log ( LOG_NOTICE , \" \" ) ; s_log ( LOG_NOTICE , \"Service-level options:\" ) ; } switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; name_list_dup ( & section -> local_addr . names , new_service_options . local_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> local_addr . names ) ; str_free ( section -> local_addr . addr ) ; str_free ( section -> local_fd ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , \"accept\" ) ) break ; section -> option . accept =",
  "golden_answers": [
   "CWE-295 Fixed Code Lines are: <vul-start> = 1 ; if ( section == & service_options ) s_log ( LOG_ERR , \"INTERNAL ERROR: Initializing deployed section defaults\" ) ; else if ( section == & new_service_options ) s_log ( LOG_INFO , \"Initializing inetd mode configuration\" ) ; else s_log ( LOG_INFO , \"Initializing service [%s]\" , section -> servname ) ; <vul-start> == & service_options ) s_log ( LOG_DEBUG , \"Deallocating deployed section defaults\" ) ; else if ( <vul-end> section == & <vul-start> ( LOG_DEBUG , \"Deallocating temporary section defaults\" <vul-end> ) ; else <vul-start> break ; } # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> security_level = - 1 ; break ; case CMD_SET_COPY : section -> security_level = new_service_options . security_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , \"securityLevel\" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 5 ) return \"Illegal security level\" ; section -> security_level = tmp_int ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , \"%-22s = %d\" , \"securityLevel\" , DEFAULT_SECURITY_LEVEL ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , \"%-22s = set the security level\" , \"securityLevel\" ) ; break ; } # endif <vul-start> \"verify\" ) ; <vul-end> break ; } <vul-start> == & service_options || section == & new_service_options\n"
  ],
  "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> = 1 ; section -> option. client = NULL ; <vul-start> section == & new_service_options ) { <vul-end> s_log ( LOG_DEBUG <vul-start> \"Deallocating section defaults\" ) ; section -> ref = 1 ; } <vul-start> case CMD_SET_VALUE : if ( section -> ref ) section -> option. client = str_dup_detached ( arg ) ; else <vul-start> & new_service_options ) { <vul-start> \"Deallocating section defaults\" ) ; section -> ref = 1 ; } <vul-start> case CMD_PRINT_DEFAULTS : if ( section -> ref ) section -> option. client = str_dup_detached ( arg ) ; else <vul-start> case CMD_PRINT_HELP : if ( section -> ref ) section -> option. client = NULL ; else <vul-start> section -> ref ) section -> option. client = NULL ; else <vul-end> section -> ref <vul-start> = 1 ; <vul-end> break ; case <vul-start> break ; case CMD_PRINT_DEFAULTS : if ( section -> ref ) section -> option. verifyChain = 1 ; name_list_append ( & section -> check_email, new_service_options. check_email ) ; break ; case\n"
 },
 {
  "id": 1034,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int userns_install ( struct nsproxy * nsproxy , void * ns ) { struct user_namespace * user_ns = ns ; struct cred * cred ; if ( user_ns == current_user_ns ( ) ) return - EINVAL ; <vul-start> if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) <vul-end> return - EINVAL ; if ( ! ns_capable ( user_ns , CAP_SYS_ADMIN ) ) return - EPERM ; cred = prepare_creds ( ) ; if ( ! cred ) return - ENOMEM ; put_user_ns ( cred -> user_ns ) ; set_cred_user_ns ( cred , get_user_ns ( user_ns ) ) ; return commit_creds ( cred ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; if (! current_chrooted ( ) ||\n"
 },
 {
  "id": 1035,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int btrfs_scrub_dev ( struct btrfs_fs_info * fs_info , u64 devid , u64 start , u64 end , struct btrfs_scrub_progress * progress , int readonly , int is_dev_replace ) { struct scrub_ctx * sctx ; int ret ; struct btrfs_device * dev ; unsigned int nofs_flag ; if ( btrfs_fs_closing ( fs_info ) ) return - EINVAL ; if ( fs_info -> nodesize > BTRFS_STRIPE_LEN ) { btrfs_err ( fs_info , \"scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails\" , fs_info -> nodesize , BTRFS_STRIPE_LEN ) ; return - EINVAL ; } if ( fs_info -> sectorsize != PAGE_SIZE ) { btrfs_err_rl ( fs_info , \"scrub: size assumption sectorsize != PAGE_SIZE (%d != %lu) fails\" , fs_info -> sectorsize , PAGE_SIZE ) ; return - EINVAL ; } if ( fs_info -> nodesize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK || fs_info -> sectorsize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK ) { btrfs_err ( fs_info , \"scrub: size assumption nodesize and sectorsize <= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails\" , fs_info -> nodesize , SCRUB_MAX_PAGES_PER_BLOCK , fs_info -> sectorsize , SCRUB_MAX_PAGES_PER_BLOCK ) ; return - EINVAL ; } sctx = scrub_setup_ctx ( fs_info , is_dev_replace ) ; if ( IS_ERR ( sctx ) ) return PTR_ERR ( sctx ) ; mutex_lock ( & fs_info -> fs_devices -> device_list_mutex ) ; <vul-start> dev = btrfs_find_device ( fs_info -> fs_devices , devid , NULL , NULL ) ; <vul-end> if ( ! dev || ( test_bit ( BTRFS_DEV_STATE_MISSING , & dev -> dev_state ) && ! is_dev_replace ) ) { mutex_unlock ( & fs_info -> fs_devices -> device_list_mutex",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> NULL , NULL , true\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> NULL, NULL, true\n"
 },
 {
  "id": 1036,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; <vul-start> for ( i = 0 ; i < len ; i ++ ) { <vul-end> if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { <vul-start> szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; <vul-end> j ++ ; szLine [ i ] &= 0xbf ; } <vul-start> else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { <vul-end> <vul-start> szLineConv [ j ] = szLine [ i ] ; <vul-end> i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { <vul-start> szLineConv [ j ] = szLine [ i ] ; <vul-end> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( (",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> i < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j <vul-end> ++ ) { <vul-start> 0x80 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <vul-start> ; } else break ; } else <vul-start> 0xc0 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <vul-end> } else if <vul-start> 0xe0 ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <vul-end> } else if <vul-start> 0xf0 ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <vul-end> } else { <vul-start> ; } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <vul-end> szLineConv [ j\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> szLine ) ; if ( len > 1024 ) return NULL ; <vul-start> 0x80 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> else if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; if ( <vul-start> 0xc0 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> 0xe0 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> 0xf0 ) { if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; <vul-start> ; } } if ( j >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;\n"
 },
 {
  "id": 1037,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; <vul-start> if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) <vul-end> return - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; return 0 ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ) != ulen || replay_esn -> bmp_len != up -> bmp_len\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( ulen > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; if (\n"
 },
 {
  "id": 1038,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 <vul-start> int sctp_verify_asconf ( const struct sctp_association * asoc , <vul-end> <vul-start> struct sctp_paramhdr * param_hdr , void * chunk_end , <vul-end> struct sctp_paramhdr * * errp ) { <vul-start> sctp_addip_param_t * asconf_param ; <vul-end> union sctp_params param ; <vul-start> int length , plen ; <vul-end> <vul-start> param . v = ( sctp_paramhdr_t * ) param_hdr ; <vul-end> while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param . p -> length ) ; * errp = param . p ; if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ; switch ( param . p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ; plen = ntohs ( asconf_param -> param_hdr . length ) ; if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ; break ; default : break ; } param . v += WORD_ROUND ( length ) ; } if ( param . v != chunk_end ) return 0 ; return 1 ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start>       bool <vul-end> sctp_verify_asconf ( const <vul-start> asoc , struct sctp_chunk * chunk , bool addr_param_needed <vul-end> , struct sctp_paramhdr <vul-start> errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <vul-end> ; union sctp_params <vul-start> sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <vul-end> param . v <vul-start> param . v != chunk -> chunk_end ) return false ; return true <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> asoc, struct sctp_addip_chunkhdr_t * addip, int param_len, void * addip_end, int <vul-end> * errp ) <vul-start> errp ) { int length ; int plen ; <vul-start> sctp_addip_param_t * asconf_param = NULL <vul-start>, plen ; if ( param_len < sizeof ( sctp_addip_param_t ) ) return 0 ; * addip = addip ; <vul-start> * ) param_hdr ; if ( param. v < addip -> param_hdr. length ) return 0\n"
 },
 {
  "id": 1039,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void __local_bh_enable ( unsigned int cnt ) { <vul-start> lockdep_assert_irqs_disabled ( ) ; <vul-end> if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; <vul-start> preempt_count_sub ( cnt ) ; <vul-end> }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> { lockdep_assert_irqs_disabled ( ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <vul-start> _RET_IP_ ) ; __preempt_count_sub <vul-end> ( cnt )\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> cnt ) { <vul-end> if ( softirq_count <vul-start> _RET_IP_ ) ; lockdep_assert_irqs_disabled ( ) ; __local_bh_enable ( cnt <vul-end> ) ; }\n"
 },
 {
  "id": 1040,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 hsm_com_errno_t unix_client_connect ( hsm_com_client_hdl_t * hdl ) { int fd , len ; struct sockaddr_un unix_addr ; <vul-start> if ( ( fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ) < 0 ) <vul-end> { return HSM_COM_ERROR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; if ( strlen ( hdl -> c_path ) >= sizeof ( unix_addr . sun_path ) ) { <vul-start> close ( fd ) ; <vul-end> return HSM_COM_PATH_ERR ; } snprintf ( unix_addr . sun_path , sizeof ( unix_addr . sun_path ) , \"%s\" , hdl -> c_path ) ; len = SUN_LEN ( & unix_addr ) ; unlink ( unix_addr . sun_path ) ; if ( bind ( fd , ( struct sockaddr * ) & unix_addr , len ) < 0 ) { <vul-start> unlink ( hdl -> c_path ) ; <vul-end> close ( fd ) ; return HSM_COM_BIND_ERR ; } if ( chmod ( unix_addr . sun_path , S_IRWXU ) < 0 ) { <vul-start> unlink ( hdl -> c_path ) ; <vul-end> close ( fd ) ; return HSM_COM_CHMOD_ERR ; } memset ( & unix_addr , 0 , sizeof ( unix_addr ) ) ; unix_addr . sun_family = AF_UNIX ; strncpy ( unix_addr . sun_path , hdl -> s_path , sizeof ( unix_addr . sun_path ) ) ; unix_addr . sun_path [ sizeof ( unix_addr . sun_path ) - 1 ] = 0 ; len = SUN_LEN ( & unix_addr ) ; if ( connect ( fd , ( struct sockaddr * )",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> sockaddr_un unix_addr ; hsm_com_errno_t res = HSM_COM_OK ; <vul-start> ) ) { res = HSM_COM_PATH_ERR ; goto cleanup <vul-end> ; } snprintf <vul-start> 0 ) { res = HSM_COM_BIND_ERR ; goto cleanup ; <vul-end> } if ( <vul-start> 0 ) { res = HSM_COM_CHMOD_ERR ; goto cleanup <vul-end> ; } memset <vul-start> 0 ) { res = HSM_COM_CONX_ERR ; goto cleanup <vul-end> ; } hdl <vul-start> = HSM_COM_C_STATE_IN ; res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ( fd = TEMP_FAILURE_RETRY ( <vul-start> SOCK_STREAM, 0 ) <vul-start> ) ) { TEMP_FAILURE_RETRY ( <vul-start> close ( fd ) <vul-start> 0 ) { TEMP_FAILURE_RETRY ( <vul-start> hdl -> c_path ) <vul-start> 0 ) { TEMP_FAILURE_RETRY ( <vul-start> hdl -> c_path )\n"
 },
 {
  "id": 1041,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int luaG_traceexec ( lua_State * L , const Instruction * pc ) { CallInfo * ci = L -> ci ; lu_byte mask = L -> hookmask ; <vul-start> int counthook ; <vul-end> if ( ! ( mask & ( LUA_MASKLINE | LUA_MASKCOUNT ) ) ) { ci -> u . l . trap = 0 ; return 0 ; } pc ++ ; ci -> u . l . savedpc = pc ; counthook = ( -- L -> hookcount == 0 && ( mask & LUA_MASKCOUNT ) ) ; if ( counthook ) resethookcount ( L ) ; else if ( ! ( mask & LUA_MASKLINE ) ) return 1 ; if ( ci -> callstatus & CIST_HOOKYIELD ) { ci -> callstatus &= ~ CIST_HOOKYIELD ; return 1 ; } if ( ! isIT ( * ( ci -> u . l . savedpc - 1 ) ) ) L -> top = ci -> top ; if ( counthook ) luaD_hook ( L , LUA_HOOKCOUNT , - 1 , 0 , 0 ) ; if ( mask & LUA_MASKLINE ) { <vul-start> const Proto * p = ci_func ( ci ) -> p ; <vul-end> int npci = pcRel ( pc , p ) ; if ( npci == 0 || <vul-start> pc <= L -> oldpc || <vul-end> <vul-start> changedline ( p , pcRel ( L -> oldpc , p ) , npci ) ) { <vul-end> int newline = luaG_getfuncline ( p , npci ) ; luaD_hook ( L , LUA_HOOKLINE , newline , 0 , 0 ) ;",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> -> hookmask ; const Proto * p = ci_func ( ci ) -> p ; int counthook ; int oldpc = ( L -> oldpc < p -> sizecode ) ? L -> oldpc : 0 <vul-end> ; if ( <vul-start> LUA_MASKLINE ) { <vul-end> int npci = <vul-start> || pc <= invpcRel ( oldpc , p ) <vul-end> || changedline ( <vul-start> ( p , oldpc <vul-end> , npci ) <vul-start> -> oldpc = npci <vul-end> ; } if\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; int counthook ; const Proto * p <vul-start> LUA_MASKLINE ) { <vul-end> int npci = <vul-start> 0 || pc < <vul-end> L -> oldpc <vul-start> -> oldpc || pcRel ( p, pcRel ( <vul-end> L -> oldpc <vul-start>, p ) <vul-end> ) ) { <vul-start> ) ; } if ( pc < ci -> oldpc ) { luaD_throw ( L, LUA_YIELD ) ; } ci -> oldpc = pc ;\n"
 },
 {
  "id": 1042,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 <vul-start> static void sample_hbp_handler ( struct perf_event * bp , int nmi , <vul-end> struct perf_sample_data * data , struct pt_regs * regs ) { printk ( KERN_INFO \"%s value is changed\\\\n\" , ksym_name ) ; dump_stack ( ) ; printk ( KERN_INFO \"Dump stack from sample_hbp_handler\\\\n\" ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> perf_event * bp <vul-end> , struct perf_sample_data\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> perf_event * bp <vul-end>, struct perf_sample_data\n"
 },
 {
  "id": 1043,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void test_modules ( ) { assert_true_rule ( <vul-start> \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.one + 1 == tests.constants.two \\\\\\n }\" , <vul-end> NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.foo == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.empty == \\\\\"\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.empty() == \\\\\"\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[1].i == 1 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[0].i == 1 or true \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.integer_array[0] == 0 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.integer_array[1] == 1 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_array[0] == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_array[2] == \\\\\"baz\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_dict[\\\\\"foo\\\\\"] == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_dict[\\\\\"bar\\\\\"] == \\\\\"bar\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1,2) == 3 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> { assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.one + 1 == tests.constants.two \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.foo == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.empty == \\\\\"\\\\\"  \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.empty() == \\\\\"\\\\\"  \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.struct_array[1].i == 1 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.struct_array[0].i == 1 or true \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[0] == 0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[1] == 1 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_array[0] == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_array[2] == \\\\\"baz\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_dict[\\\\\"foo\\\\\"] == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_dict[\\\\\"bar\\\\\"] == \\\\\"bar\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.isum(1,2) == 3 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.isum(1,2,3) == 6 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.foobar(1) == tests.foobar(1) \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.foobar(1) != tests.foobar(2) \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.length(\\\\\"dummy\\\\\") == 5 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.struct_array[0].i == 1 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.isum(1,1) == 3 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo/,\\\\\"foo\\\\\") == 3 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo/,\\\\\"bar\\\\\") == -1\\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo.bar/i,\\\\\"FOO\\\\\\\\nBAR\\\\\") == -1\\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo.bar/is,\\\\\"FOO\\\\\\\\nBAR\\\\\") == 7\\\\\\n      }\" <vul-end> , NULL )\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> { assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[0].i == 1 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1) == 3 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.01.0) == 3.0 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.length(\\\\\"dummy\\\\\") == 5 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[0].i == 1 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1) == 3 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.fsum(1.01.0) == 3.0 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.length(\\\\\"dummy\\\\\") == 5 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[0].i == 1 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1) == 3 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(2) == 3 \\\\\\n"
 },
 {
  "id": 1044,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static int misaligned_fpu_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <vul-start> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <vul-end> srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo = 0xffffffffUL , bufhi = 0xffffffffUL ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } switch ( width_shift ) { case 2 : buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; break ; case 3 : if ( do_paired_load ) { buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; #",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start>, 1, <vul-end> regs, address\n"
 },
 {
  "id": 1045,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int fallocate_chunk ( struct inode * inode , loff_t offset , loff_t len , int mode ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct buffer_head * dibh ; int error ; <vul-start> u64 start = offset >> PAGE_CACHE_SHIFT ; <vul-end> unsigned int start_offset = offset & ~ PAGE_CACHE_MASK ; <vul-start> u64 end = ( offset + len - 1 ) >> PAGE_CACHE_SHIFT ; <vul-end> pgoff_t curr ; struct page * page ; unsigned int end_offset = ( offset + len ) & ~ PAGE_CACHE_MASK ; unsigned int from , to ; if ( ! end_offset ) end_offset = PAGE_CACHE_SIZE ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) goto out ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } curr = start ; offset = start << PAGE_CACHE_SHIFT ; from = start_offset ; to = PAGE_CACHE_SIZE ; while ( curr <= end ) { page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ; if ( unlikely ( ! page ) ) { error = - ENOMEM ; goto out ; } if ( curr == end ) to = end_offset ; error = write_empty_blocks ( page , from , to , mode ) ; if ( ! error && offset + to > inode -> i_size && <vul-start> ! ( mode & FALLOC_FL_KEEP_SIZE ) )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int error ; unsigned int nr_blks ; sector_t lblock <vul-end> = offset >> <vul-start> = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <vul-end> ( offset + <vul-start> offset + len <vul-end> > inode -> <vul-start> FALLOC_FL_KEEP_SIZE ) ) <vul-end> i_size_write ( inode <vul-start> , offset + len ) ; <vul-end> mark_inode_dirty ( inode <vul-start> mark_inode_dirty ( inode <vul-end> ) ; out <vul-start> ; out : brelse ( dibh ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int error ; unsigned int do_copy = 0 ; <vul-start> end = ( u64 ) ( <vul-start> ) >> PAGE_CACHE_SHIFT ; unsigned int do_copy = 1 <vul-start> -> i_size && ( do_copy || <vul-start> & FALLOC_FL_KEEP_SIZE ) ) <vul-start> { i_size_write ( inode, offset + to ) ; do_copy = 0 <vul-end> ; } unlock_page <vul-start> 0 ; } if ( do_copy ) { fs_err ( inode -> i_sb, KERNEL_DS, \"Failed to change inode size to %lu\\\\n\", inode -> i_ino ) ; } <vul-start> ; out : if ( do_copy ) fs_err ( inode -> i_sb, KERNEL_DS, \"Failed to write to file: %s\\\\n\", strerror ( error ) ) ;\n"
 },
 {
  "id": 1046,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , p + offset + 3 , <vul-end> tim . length <vul-start> - 3 ) ; offset += <vul-end> tim . length <vul-start> length - 3 ; length -= <vul-end> tim . length <vul-start> - 3 ; <vul-end> if ( !\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -= 3 ; if ( length < 3 + tim. length ) return 0 ; <vul-start>, p + <vul-end> tim. length <vul-start> tim. length <vul-end> ; if (\n"
 },
 {
  "id": 1047,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 __init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <vul-start> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; x86_pmu. <vul-end> extra_regs = intel_snb_extra_regs <vul-start> ; x86_pmu. <vul-end> extra_regs = intel_snb_extra_regs\n"
 },
 {
  "id": 1048,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void ih264d_init_decoder ( void * ps_dec_params ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ps_dec_params ; dec_slice_params_t * ps_cur_slice ; <vul-start> pocstruct_t * ps_prev_poc , * ps_cur_poc ; <vul-end> ih264d_free_dynamic_bufs ( ps_dec ) ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_dec -> init_done = 0 ; ps_dec -> u4_num_cores = 1 ; ps_dec -> u2_pic_ht = ps_dec -> u2_pic_wd = 0 ; ps_dec -> u1_separate_parse = DEFAULT_SEPARATE_PARSE ; ps_dec -> u4_app_disable_deblk_frm = 0 ; ps_dec -> i4_degrade_type = 0 ; ps_dec -> i4_degrade_pics = 0 ; ps_dec -> i4_app_skip_mode = IVD_SKIP_NONE ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; memset ( ps_dec -> ps_pps , 0 , ( ( sizeof ( dec_pic_params_t ) ) * MAX_NUM_PIC_PARAMS ) ) ; memset ( ps_dec -> ps_sps , 0 , ( ( sizeof ( dec_seq_params_t ) ) * MAX_NUM_SEQ_PARAMS ) ) ; ps_dec -> p_DeblockPicture [ 0 ] = ih264d_deblock_picture_non_mbaff ; ps_dec -> p_DeblockPicture [ 1 ] = ih264d_deblock_picture_mbaff ; ps_dec -> s_cab_dec_env . pv_codec_handle = ps_dec ; ps_dec -> u4_num_fld_in_frm = 0 ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ps_dec ; ps_dec -> ps_sei -> u1_is_valid = 0 ; ps_dec -> ps_cur_pps = NULL ; ps_dec -> ps_cur_sps = NULL ; ps_dec -> u1_init_dec_flag = 0 ; ps_dec -> u1_first_slice_in_stream = 1 ; ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_last_pic_not_decoded = 0 ; ps_dec -> u4_app_disp_width = 0 ; ps_dec -> i4_header_decoded = 0 ; ps_dec -> u4_total_frames_decoded = 0 ; ps_dec -> i4_error_code = 0 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag = 0 ; ps_dec ->",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> , * ps_cur_poc ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, * ps_cur_poc ; ps_dec -> u4_first_slice_in_pic = 0\n"
 },
 {
  "id": 1049,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , \"DSD \" , 4 ) ) { error_line ( \"%s is not a valid .DFF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( \"%s is not a valid .DFF file (by total size)!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( \"file header indicated length = %lld\" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( \"%s is not a valid .DFF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( \"%s is not a valid.DFF file!\", infilename ) ; return WAVPACK_SOFT_ERROR ; } buff\n"
 },
 {
  "id": 1050,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = -",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <vul-start> ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE )\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> goto out_unlock ; WARN_ON (! ( vma -> vm_flags & VM_MAYWRITE ) ) ; <vul-start>. ctx && ( <vul-start>!= ctx ) || ( vma -> vm_flags & VM_MAYWRITE ) )\n"
 },
 {
  "id": 1051,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8_hex_search ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvsadcost [ 2 ] , int * mvcost [ 2 ] , int_mv * center_mv ) { MV hex [ 6 ] = { { - 1 , - 2 } , { 1 , - 2 } , { 2 , 0 } , { 1 , 2 } , { - 1 , 2 } , { - 2 , 0 } } ; MV neighbors [ 4 ] = { { 0 , - 1 } , { - 1 , 0 } , { 1 , 0 } , { 0 , 1 } } ; int i , j ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int br , bc ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; unsigned char * base_offset ; unsigned char * this_offset ; int k = - 1 ; int all_in ; int best_site = - 1 ; int hex_range = 127 ; int dia_range = 8 ; int_mv fcenter_mv ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv .",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> >> 3 ; ( void ) mvcost ; <vul-start> this_offset , in_what_stride <vul-end> ) + mvsad_err_cost <vul-start> 8 ; # else ( void ) search_param ; # <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER <vul-start> this_offset , in_what_stride <vul-end> ) ; CHECK_BETTER\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> >> 3 ; # if CONFIG_VP8_HIGHBITDEPTH if ( x -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vfp -> highbd_clamp_mv ( ref_mv, x -> mv_col_min, x -> mv_col_max, x -> mv_row_min, x -> mv_row_max ) ; } else { vfp -> highbd_clamp_mv ( ref_mv, x -> mv_col_min, x -> mv_col_max, x -> mv_row_min, x -> mv_row_max ) ; } # else <vul-start> bestsad ) ; # endif <vul-start>. col ; # if CONFIG_VP8_HIGHBITDEPTH if ( x -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <vul-start> bestsad ) ; } else { vfp -> highbd_clamp_mv ( ref_mv, x -> mv_col_min, x -> mv_col_max, x -> mv_row_min, x -> mv_row_max ) ; } else { vfp -> highbd_clamp_mv ( ref_mv, x -> mv_col_min, x -> mv_col_max, x -> mv_row_min, x -> mv_row_max ) ; } # else vfp -> sdf ( what, what_stride, this_offset, in_what_stride, bestsad ) ; # endif <vul-start>. col ; # if CONFIG_VP8_HIGHBITDEPTH if ( x -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <vul-start> bestsad ) ; } else { vfp -> sdf ( what, what_stride, this_offset, in_what_stride, bestsad ) ; } # else vfp -> sdf ( what, what_stride, this_offset, in_what_stride, bestsad ) ; # endif <vul-start>. col ; # if CONFIG_VP8_HIGHBITDEPTH if ( x -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <vul-start> bestsad ) ; } else {"
 },
 {
  "id": 1052,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void exif_mnote_data_olympus_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataOlympus * n = ( ExifMnoteDataOlympus * ) en ; ExifShort c ; size_t i , tcount , o , o2 , datao = 6 , base = 0 ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteDataOlympus\" , \"Short MakerNote\" ) ; return ; } o2 = 6 + n -> offset ; if ( CHECKOVERFLOW ( o2 , buf_size , 10 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteDataOlympus\" , \"Short MakerNote\" ) ; return ; } n -> version = exif_mnote_data_olympus_identify_variant ( buf + o2 , buf_size - o2 ) ; switch ( n -> version ) { case olympusV1 : case sanyoV1 : case epsonV1 : exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteDataOlympus\" , \"Parsing Olympus/Sanyo/Epson maker note v1...\" ) ; if ( buf [ o2 + 6 ] == 1 ) n -> order = EXIF_BYTE_ORDER_INTEL ; else if ( buf [ o2 + 6 + 1 ] == 1 ) n -> order = EXIF_BYTE_ORDER_MOTOROLA ; o2 += 8 ; c = exif_get_short ( buf + o2 , n -> order ) ; if ( ( ! ( c & 0xFF ) ) && ( c > 0x500 ) ) { if ( n -> order == EXIF_BYTE_ORDER_INTEL ) { n -> order = EXIF_BYTE_ORDER_MOTOROLA ; } else { n -> order = EXIF_BYTE_ORDER_INTEL ; } } break ; case olympusV2",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteOlympusEntry ) ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> size_t s ; memset ( & n -> entries [ tcount ], 0, sizeof ( MnoteOlympusEntry ) ) ;\n"
 },
 {
  "id": 1053,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t allocate %lu bytes of memory for \" \"t2p_readwrite_pdf_image, %s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , buffer , t2p -> tiff_datasize ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, buffer, bufferoffset, <vul-end> i, t2p\n"
 },
 {
  "id": 1054,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_txfm_probs ( VP9_COMMON * cm , vp9_writer * w ) { <vul-end> vp9_write_literal ( w , MIN ( cm -> tx_mode , ALLOW_32X32 ) , 2 ) ; if ( cm -> tx_mode >= ALLOW_32X32 ) <vul-start> vp9_write_bit ( w , cm -> tx_mode == TX_MODE_SELECT ) ; <vul-end> if ( cm -> tx_mode == TX_MODE_SELECT ) { int i , j ; unsigned int ct_8x8p [ TX_SIZES - 3 ] [ 2 ] ; unsigned int ct_16x16p [ TX_SIZES - 2 ] [ 2 ] ; unsigned int ct_32x32p [ TX_SIZES - 1 ] [ 2 ] ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <vul-start> tx_counts_to_branch_counts_8x8 ( cm -> counts . tx . p8x8 [ i ] , ct_8x8p ) ; <vul-end> for ( j = 0 ; j < TX_SIZES - 3 ; j ++ ) <vul-start> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p8x8 [ i ] [ j ] , ct_8x8p [ j ] ) ; <vul-end> } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { <vul-start> tx_counts_to_branch_counts_16x16 ( cm -> counts . tx . p16x16 [ i ] , ct_16x16p ) ; <vul-end> for ( j = 0 ; j < TX_SIZES - 2 ; j ++ ) <vul-start> vp9_cond_prob_diff_update ( w , & cm -> fc . tx_probs . p16x16 [ i ] [ j ] , <vul-end> ct_16x16p [ j ] ) ; } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cm , vpx_writer * w , FRAME_COUNTS * counts ) { vpx_write_literal <vul-end> ( w , <vul-start> >= ALLOW_32X32 ) vpx_write_bit <vul-end> ( w , <vul-start> { tx_counts_to_branch_counts_8x8 ( counts -> <vul-end> tx . p8x8 <vul-start> cm -> fc -> <vul-end> tx_probs . p8x8 <vul-start> { tx_counts_to_branch_counts_16x16 ( counts -> <vul-end> tx . p16x16 <vul-start> cm -> fc -> <vul-end> tx_probs . p16x16 <vul-start> { tx_counts_to_branch_counts_32x32 ( counts -> <vul-end> tx . p32x32 <vul-start> cm -> fc -> <vul-end> tx_probs . p32x32\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cm, vpx_writer * w ) { VP9_COMMON * const tx_counts = cm -> fc. tx_probs ; vpx_write_literal <vul-end> ( w, <vul-start> >= ALLOW_32X32 ) vpx_write_bit <vul-end> ( w, <vul-start> TX_MODE_SELECT ) ; if ( cm -> tx_mode == TX_MODE_SELECT ) { int i, j ; unsigned int ct_8x8p [ 2 ] = { 0 } ; unsigned int ct_16x16p [ 2 ] = { 0 } ; const VP9_COMMON * const cm_prev_tx_p8 = ( cm -> fc. tx_probs. p8x8 [ 0 ] >> 8 ) + cm -> fc. tx_probs. p8x8 [ 1 ] ; const int ct_32x32p [ TX_SIZES - 1 ] = ( cm -> fc. tx_probs. p16x16 [ 0 ] >> 16 ) + cm -> fc. tx_probs. p16x16 [ 1 ] ; int ctx = w -> priv ; ctx = & tx_counts -> ctx [ ctx ] ; <vul-start> cm -> fc -> <vul-end> tx_probs. p8x8 <vul-start> j ], ct_8x8p [ j ], ct_8x8p [ 2 ] <vul-end> ) ; } <vul-start> cm -> fc -> <vul-end> tx_probs. p16x16 <vul-start> j ], ct_16x16p [ j ], ct_32x32p [ j ] ) ; } for ( i = 0 ; i < TX_SIZE_CONTEXTS ; i ++ ) { tx_counts_to_branch_counts_16x16 ( cm_prev_tx_p16 [ i ], <vul-start> j ], ct_16x16p [ j ], ct_32x32p [ j ] ) ; for ( j = 0 ; j < TX_SIZES - 2 ; j ++ ) vp9_cond_prob_diff_update ( w, & fc -> <vul-end> tx_probs. p16x16 <vul-start> j ], ct_16x16p [ j ], ct_32x32p [ j ], ct_16x16p [ j ] ) ; } for ( i = 0 ; i < TX_"
 },
 {
  "id": 1055,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int netlink_dump ( struct sock * sk ) { struct netlink_sock * nlk = nlk_sk ( sk ) ; struct netlink_callback * cb ; struct sk_buff * skb = NULL ; struct nlmsghdr * nlh ; <vul-start> int len , err = - ENOBUFS ; <vul-end> int alloc_min_size ; int alloc_size ; mutex_lock ( nlk -> cb_mutex ) ; if ( ! nlk -> cb_running ) { err = - EINVAL ; goto errout_skb ; } if ( atomic_read ( & sk -> sk_rmem_alloc ) >= sk -> sk_rcvbuf ) goto errout_skb ; cb = & nlk -> cb ; alloc_min_size = max_t ( int , cb -> min_dump_alloc , NLMSG_GOODSIZE ) ; if ( alloc_min_size < nlk -> max_recvmsg_len ) { alloc_size = nlk -> max_recvmsg_len ; skb = alloc_skb ( alloc_size , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; } if ( ! skb ) { alloc_size = alloc_min_size ; skb = alloc_skb ( alloc_size , GFP_KERNEL ) ; } if ( ! skb ) goto errout_skb ; skb_reserve ( skb , skb_tailroom ( skb ) - alloc_size ) ; netlink_skb_set_owner_r ( skb , sk ) ; len = cb -> dump ( skb , cb ) ; if ( len > 0 ) { mutex_unlock ( nlk -> cb_mutex ) ; if ( sk_filter ( sk , skb ) ) kfree_skb ( skb ) ; else __netlink_sendskb ( sk , skb ) ; return 0 ; } nlh = nlmsg_put_answer ( skb , cb , NLMSG_DONE , sizeof ( len ) , NLM_F_MULTI ) ; if ( ! nlh ) goto",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> * nlh ; struct module * module ; <vul-start> = false ; module = cb -> module ; skb = cb -> skb ; <vul-start> ; module_put ( <vul-end> module ) ; <vul-start> ; consume_skb ( <vul-end> skb ) ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> * nlh ; struct module * module ; <vul-start> = false ; <vul-end> module_put ( cb <vul-start> cb_mutex ) ; consume_skb ( cb -> skb ) ; <vul-start> module ) ; <vul-end> mutex_unlock ( nlk <vul-start> cb_mutex ) ; <vul-end> return 0 ;\n"
 },
 {
  "id": 1056,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ; <vul-start> assert ( n >= 0 && n < 32 ) ; <vul-end> v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } <vul-end> v = 0\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } <vul-end> v = 0\n"
 },
 {
  "id": 1057,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 generic_ret * chpass_principal_2_svc ( chpass_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <vul-start> gss_buffer_desc client_name , <vul-end> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) ) { ret . code = chpass_principal_wrapper_3 ( ( void * ) handle , arg -> princ , FALSE , 0 , NULL , arg -> pass ) ; } else if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_CHANGEPW , arg -> princ , NULL ) ) { ret . code = kadm5_chpass_principal ( ( void * ) handle , arg -> princ , arg -> pass ) ; } else { log_unauth ( \"kadm5_chpass_principal\" , prime_arg , & client_name , &",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <vul-end> free_server_handle ( handle\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <vul-end> ; OM_uint32 minor_stat <vul-start> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat, & client_name ) ; gss_release_buffer ( & minor_stat, & service_name ) ; <vul-end> free_server_handle ( handle\n"
 },
 {
  "id": 1058,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; <vul-start> DEFINE_WAKE_Q ( wake_q ) ; <vul-end> if ( ! IS_ENABLED ( CONFIG_FUTEX_PI ) && requeue_pi ) return - ENOSYS ; if ( requeue_pi ) { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( refill_pi_state_cache ( ) ) return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; } hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked (",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * next ; if ( unlikely (! access_ok ( VERIFY_READ, uaddr1, sizeof ( uaddr1 ) ) ) return - EFAULT ;\n"
 },
 {
  "id": 1059,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; <vul-start> krb5_key_data * key_data ; <vul-end> if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; <vul-start> if ( key_data_in == NULL ) <vul-end> goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno =",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> krb5_key_data * key_data = NULL ; if ( n_key_data < <vul-end> 0 ) return <vul-start> ; if ( key_data <vul-end> == NULL ) <vul-start> = 0 ; ret [ i ] != NULL <vul-end> ; i ++ <vul-start> i ++ ) <vul-end> free ( ret\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> = 0 ; int have_key_data = 0 ; <vul-start> key_data_in == NULL || n_key_data == 0 <vul-start> NULL ) { if ( have_key_data ) { for ( i = 0 ; i <= num_versions ; i ++ ) { if ( ret [ i ]!= NULL ) free ( ret [ i ] ) ; } } <vul-start> i ++ ) { if ( ret [ i ]!= NULL && ret [ i ] -> bv_len!= 0 ) free ( ret [ i ] -> bv_val ) ; } <vul-end> free ( ret\n"
 },
 {
  "id": 1060,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 bool initiate_stratum ( struct pool * pool ) { char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; bool ret = false , recvd = false ; json_error_t err ; int n2size ; if ( ! setup_stratum_curl ( pool ) ) goto out ; resend : if ( pool -> sessionid ) sprintf ( s , \"{\\\\\"id\\\\\": %d, \\\\\"method\\\\\": \\\\\"mining.subscribe\\\\\", \\\\\"params\\\\\": [\\\\\"%s\\\\\"]}\" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , \"{\\\\\"id\\\\\": %d, \\\\\"method\\\\\": \\\\\"mining.subscribe\\\\\", \\\\\"params\\\\\": []}\" , swork_id ++ ) ; if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) { applog ( LOG_DEBUG , \"Failed to send s in initiate_stratum\" ) ; goto out ; } if ( ! socket_full ( pool , true ) ) { applog ( LOG_DEBUG , \"Timed out waiting for response in initiate_stratum\" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , \"JSON decode failed(%d): %s\" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , \"result\" ) ; err_val = json_object_get ( val , \"error\" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; if ( n2size < 1 ) <vul-end> { applog (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; if ( n2size < 1 ) <vul-end> { applog (\n"
 },
 {
  "id": 1061,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <vul-start> int contentlen = 0 ; <vul-end> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != ' ' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != ' ' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , ' ' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ;",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> printparam pp ; unsigned <vul-end> contentlen = 0 <vul-start> sb ++ ; sscanf ( sb , \"%u\" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <vul-end> ; } else <vul-start> & pp , \"<form method=\\\\\"POST\\\\\" action=\\\\\"/U\\\\\" enctype=\\\\\"application/x-www-form-urlencoded\\\\\"><textarea cols=\\\\\"80\\\\\" rows=\\\\\"30\\\\\" name=\\\\\"conffile\\\\\">\" <vul-end> ) ; while <vul-start> 'U' : { unsigned <vul-end> l = 0 <vul-start> ! writable || ! contentlen || <vul-start> } while ( l < contentlen && <vul-start> ) buf , ( contentlen - l ) > <vul-start> LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <vul-start> l ) ; if ( ! l ) { if ( i < 9 || <vul-end> strncasecmp ( buf <vul-start> error ) { buf [ i ] = 0 ; <vul-start> l += i <vul-end> ; } if\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; int contentlen = 0 ; int max_tktlen <vul-start> sb ++ ; if ( contentlen > MAX_TKTLEN ) { myfree ( buf ) ; RETURN ( 701 ) ; } <vul-start> ; contentlen = strtol <vul-end> ( sb, <vul-start> ( sb, & max_tktlen, 0, 10 ) ; if ( contentlen > max_tktlen ) { myfree ( buf ) ; RETURN ( 701 ) ; } <vul-end> } else if\n"
 },
 {
  "id": 1062,
  "question": "CWE-354 Code Input Vulnerable Code Is: CWE-354 void recovery_cipher_init ( bool passphrase_protection , bool pin_protection , const char * language , const char * label , bool _enforce_wordlist , uint32_t _auto_lock_delay_ms , uint32_t _u2f_counter , bool _dry_run ) { enforce_wordlist = _enforce_wordlist ; dry_run = _dry_run ; if ( ! dry_run ) { if ( pin_protection ) { if ( ! change_pin ( ) ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_ActionCancelled , \"PINs do not match\" ) ; layoutHome ( ) ; return ; } } else { storage_setPin ( \"\" ) ; } storage_setPassphraseProtected ( passphrase_protection ) ; storage_setLanguage ( language ) ; storage_setLabel ( label ) ; storage_setAutoLockDelayMs ( _auto_lock_delay_ms ) ; storage_setU2FCounter ( _u2f_counter ) ; } else if ( ! pin_protect ( \"Enter Your PIN\" ) ) { layoutHome ( ) ; return ; } if ( ! confirm ( ButtonRequestType_ButtonRequest_Other , dry_run ? \"Recovery Dry Run\" : \"Recovery\" , \"When entering your recovery seed, use the substitution cipher \" \"and check that each word shows up correctly on the screen.\" ) ) { fsm_sendFailure ( FailureType_Failure_ActionCancelled , \"Recovery cancelled\" ) ; if ( ! dry_run ) storage_reset ( ) ; layoutHome ( ) ; return ; } memset ( mnemonic , 0 , sizeof ( mnemonic ) / sizeof ( char ) ) ; awaiting_character = true ; <vul-start> next_character ( ) ; <vul-end> }",
  "golden_answers": [
   "CWE-354 Fixed Code Lines are: <vul-start> = true ; recovery_started = true ;\n"
  ],
  "generated_answer": "CWE-354 Fixed Code Lines are: <vul-start> = true ; recovery_started = true ;\n"
 },
 {
  "id": 1063,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void btu_exec_tap_fd_read ( void * p_param ) { struct pollfd ufd ; int fd = ( int ) p_param ; if ( fd == INVALID_FD || fd != btpan_cb . tap_fd ) return ; for ( int i = 0 ; i < PAN_POOL_MAX && btif_is_enabled ( ) && btpan_cb . flow ; i ++ ) { BT_HDR * buffer = ( BT_HDR * ) GKI_getpoolbuf ( PAN_POOL_ID ) ; if ( ! buffer ) { BTIF_TRACE_WARNING ( \"%s unable to allocate buffer for packet.\" , __func__ ) ; break ; } buffer -> offset = PAN_MINIMUM_OFFSET ; buffer -> len = GKI_get_buf_size ( buffer ) - sizeof ( BT_HDR ) - buffer -> offset ; UINT8 * packet = ( UINT8 * ) buffer + sizeof ( BT_HDR ) + buffer -> offset ; if ( ! btpan_cb . congest_packet_size ) { <vul-start> ssize_t ret = read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ; <vul-end> switch ( ret ) { case - 1 : BTIF_TRACE_ERROR ( \"%s unable to read from driver: %s\" , __func__ , strerror ( errno ) ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; case 0 : BTIF_TRACE_WARNING ( \"%s end of file reached.\" , __func__ ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; default : btpan_cb . congest_packet_size = ret ; break ; } } memcpy ( packet , btpan_cb . congest_packet",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ssize_t ret = TEMP_FAILURE_RETRY ( <vul-start> btpan_cb . congest_packet ) <vul-start> ; if ( TEMP_FAILURE_RETRY ( <vul-start> 1 , 0 )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ssize_t ret = TEMP_FAILURE_RETRY ( <vul-start> ) ) ) ) <vul-start> ; if ( TEMP_FAILURE_RETRY ( <vul-start> 1, 0 )\n"
 },
 {
  "id": 1064,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void skb_complete_tx_timestamp ( struct sk_buff * skb , struct skb_shared_hwtstamps * hwtstamps ) { struct sock * sk = skb -> sk ; if ( ! skb_may_tx_timestamp ( sk , false ) ) return ; if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; <vul-start> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <vul-end> sock_put ( sk ) ; } }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> sk , SCM_TSTAMP_SND , false\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, sk, SCM_TSTAMP_SND_TX <vul-end> ) ; sock_put\n"
 },
 {
  "id": 1065,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; <vul-start> if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { <vul-end> rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ; if ( dumpable != SUID_DUMP_USER && <vul-end> ! ptrace_has_cap (\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> dumpable &&! ptrace_may_see_dir ( task -> nsproxy -> ptrace_dir, mode ) &&!\n"
 },
 {
  "id": 1066,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int kvm_iommu_unmap_memslots ( struct kvm * kvm ) { int idx ; struct kvm_memslots * slots ; struct kvm_memory_slot * memslot ; idx = srcu_read_lock ( & kvm -> srcu ) ; slots = kvm_memslots ( kvm ) ; kvm_for_each_memslot ( memslot , slots ) <vul-start> kvm_iommu_put_pages ( kvm , memslot -> base_gfn , memslot -> npages ) ; <vul-end> srcu_read_unlock ( & kvm -> srcu , idx ) ; return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> , slots ) kvm_iommu_unmap_pages <vul-end> ( kvm , <vul-start> kvm , memslot <vul-end> ) ; srcu_read_unlock\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, slots ) kvm_iommu_unmap_pages <vul-end> ( kvm,\n"
 },
 {
  "id": 1067,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 INTERNAL void vterm_allocator_free ( VTerm * vt , void * ptr ) <vul-start> { <vul-end> ( * vt -> allocator -> free ) ( ptr , vt -> allocdata ) ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ptr ) { if ( ptr )\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ptr ) { if ( vt -> allocator == NULL ) return ;\n"
 },
 {
  "id": 1068,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { GradFunContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int p , direct ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { direct = 0 ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } <vul-start> for ( p = 0 ; p < 4 && in -> data [ p ] ; p ++ ) { <vul-end> int w = inlink -> w ; int h = inlink -> h ; int r = s -> radius ; if ( p ) { w = s -> chroma_w ; h = s -> chroma_h ; r = s -> chroma_r ; } if ( FFMIN ( w , h ) > 2 * r ) filter ( s , out -> data [ p ] , in -> data [ p ] , w , h , out -> linesize [ p ] , in -> linesize [ p ] , r ) ; else if ( out -> data [ p ] != in -> data [ p ] ) av_image_copy_plane ( out -> data [ p ] , out -> linesize [ p ] , in ->",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> [ p ] && in -> linesize [ p ]\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> [ p ] && in -> linesize [ p ]\n"
 },
 {
  "id": 1069,
  "question": "CWE-426 Code Input Vulnerable Code Is: CWE-426 static void usage ( void ) { fprintf ( stderr , \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\\\n\" <vul-start> \" [-t life] [command [arg ...]]\\\\n\" <vul-end> \" ssh-agent [-c | -s] -k\\\\n\" ) ; exit ( 1 ) ; }",
  "golden_answers": [
   "CWE-426 Fixed Code Lines are: <vul-start> stderr , \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\\\n\" \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\\\n\" <vul-end> \"       ssh-agent [-c | -s] -k\\\\n\" ) ;\n"
  ],
  "generated_answer": "CWE-426 Fixed Code Lines are: <vul-start>, \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\\\n\" \" [-t life] [command [arg...]]\\\\n\" <vul-end> \"ssh-agent [-c | -s] -k\\\\n\" ) ;\n"
 },
 {
  "id": 1070,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state ) <vul-end> { struct file * filp ; int ret ; <vul-start> if ( nd -> intent . open . flags & FMODE_EXEC ) { <vul-end> ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ; if ( ret < 0 ) goto out_close ; } filp = lookup_instantiate_filp ( nd , path -> dentry , NULL ) ; if ( ! IS_ERR ( filp ) ) { struct nfs_open_context * ctx ; ctx = nfs_file_open_context ( filp ) ; ctx -> state = state ; return 0 ; } ret = PTR_ERR ( filp ) ; out_close : <vul-start> nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; <vul-end> return ret ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> nfs4_state * state , fmode_t fmode <vul-start> ; if ( fmode <vul-end> & FMODE_EXEC ) <vul-start> , state , fmode & ( FMODE_READ | FMODE_WRITE ) <vul-end> ) ; return\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> nfs4_state * state, fmode_t fmode <vul-start> int ret ; fmode |= <vul-end> nd -> intent <vul-start>. open. fmode ; <vul-end> filp = lookup_instantiate_filp <vul-start>, state, fmode <vul-end> ) ; return\n"
 },
 {
  "id": 1071,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 <vul-start> static int getnum ( const char * * fmt , int df ) { <vul-end> if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; <vul-start> do { <vul-end> a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> int getnum ( lua_State * L , <vul-start> ; do { if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) luaL_error ( L , \"integral size overflow\" ) ;\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> int df ) { if ( * * fmt == 0 ) return 0 ; <vul-end> if (! <vul-start> ; do { if ( a >= 10 * 1024 ) return 0 ;\n"
 },
 {
  "id": 1072,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> |= MSG_TRUNC ; <vul-end> lock_sock ( sk\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> |= MSG_TRUNC ; <vul-end> lock_sock ( sk\n"
 },
 {
  "id": 1073,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int crypto_report_comp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_comp rcomp ; <vul-start> strlcpy ( rcomp . type , \"compression\" , sizeof ( rcomp . type ) ) ; <vul-end> if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> crypto_report_comp rcomp ; strncpy <vul-end> ( rcomp .\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> crypto_report_comp rcomp ; strncpy <vul-end> ( rcomp.\n"
 },
 {
  "id": 1074,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) { <vul-start> u_int16_t offset = 22 , buf_out_len = 0 ; <vul-end> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <vul-start> offset += 4 + len ; <vul-end> if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <vul-start> if ( client_hash ) { <vul-end> <vul-start> offset += 4 ; <vul-end> if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> client_hash ) { u_int32_t <vul-end> offset = 22 <vul-start> ] ) ; if ( len > UINT32_MAX - 4 - offset ) goto invalid_payload ; <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; if <vul-start> ] ) ; offset += 4 ; <vul-start> client_hash ) { <vul-end> if ( ( <vul-start> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <vul-end> len ; #\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> offset = 22 ; u_int16_t <vul-end> buf_out_len = 0 <vul-start> ] ) ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> ] ) ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> client_hash ) { if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> += 4 ; if ( ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ], ( const char * ) & packet -> payload [ offset ], len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t_t * ) & packet -> payload [ offset ] ) ; <vul-start> += 4 ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> ] ) ; offset += 4 ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> client_hash ) { if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> ] ) ; offset += 4 ; if ( offset + sizeof ( u_int16_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> ] ) ; offset += 4 ; if ( offset + sizeof ( u_int16_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <vul-start> += len ; if ( offset + sizeof ( u_int16_t ) >= packet -> payload_packet_len ) goto invalid_payload ; "
 },
 {
  "id": 1075,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <vul-start> pipe_buf_get ( ipipe , ibuf ) ; <vul-end> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> 1 ) ; if ( ! <vul-start> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <vul-end> obuf = opipe\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> 1 ) ; if (! <vul-start>, ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <vul-end> obuf = opipe\n"
 },
 {
  "id": 1076,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int get_task_ioprio ( struct task_struct * p ) { int ret ; ret = security_task_getioprio ( p ) ; if ( ret ) goto out ; ret = IOPRIO_PRIO_VALUE ( IOPRIO_CLASS_NONE , IOPRIO_NORM ) ; <vul-start> if ( p -> io_context ) <vul-end> ret = p -> io_context -> ioprio ; <vul-start> out : <vul-end> return ret ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> IOPRIO_NORM ) ; task_lock ( p ) ; <vul-start> -> ioprio ; task_unlock ( p ) ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> -> io_context ) { if (! ( p -> flags & PF_EXITING ) ) ret = - ESRCH ; else <vul-start> -> ioprio ; }\n"
 },
 {
  "id": 1077,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 void fe_netjoin_init ( void ) { settings_add_bool ( \"misc\" , \"hide_netsplit_quits\" , TRUE ) ; settings_add_int ( \"misc\" , \"netjoin_max_nicks\" , 10 ) ; join_tag = - 1 ; printing_joins = FALSE ; read_settings ( ) ; signal_add ( \"setup changed\" , ( SIGNAL_FUNC ) read_settings ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> read_settings ) ; signal_add ( \"server disconnected\" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> read_settings ) ; signal_add ( \"setup\", ( SIGNAL_FUNC ) fe_netjoin_init ) ;\n"
 },
 {
  "id": 1078,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_bilinear_predict4x4_neon ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) { uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 , d6u8 ; uint8x8_t d26u8 , d27u8 , d28u8 , d29u8 , d30u8 ; <vul-start> uint32x2_t d28u32 , d29u32 , d30u32 ; <vul-end> uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 0 ) ; src_ptr += src_pixels_per_line ; d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 1 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 0 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 1 ) ; src_ptr += src_pixels_per_line ; d30u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d30u32 , 0 ) ; d28u8 = vreinterpret_u8_u32 ( d28u32 ) ; d29u8 = vreinterpret_u8_u32 ( d29u32 ) ; d30u8 = vreinterpret_u8_u32 ( d30u32 ) ; } else { d2u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d3u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d4u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d5u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , d30u8 ; uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { uint32x2_t d28u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d29u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d30u32 = vdup_n_u32 ( 0 ) ; <vul-end> d28u32 = vld1_lane_u32 <vul-start> = vdup_n_u8 ( <vul-end> bifilter4_coeff [ xoffset <vul-start> = vdup_n_u8 ( <vul-end> bifilter4_coeff [ xoffset\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> d30u8 ; uint32x2_t d0u32, d1u32, d2u32 ; uint32x2_t <vul-start> d5u8 ) ; d0u32 = vshrq_n_u32 ( ( uint8_t * ) src_ptr, d28u32, 1 ) ; d1u32 = vshrq_n_u32 ( ( uint8_t * ) src_ptr, d29u32, 1 ) ; <vul-start> = vdup_n_u8 ( <vul-end> bifilter4_coeff [ xoffset <vul-start> = vdup_n_u8 ( <vul-end> bifilter4_coeff [ xoffset\n"
 },
 {
  "id": 1079,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <vul-start> bpf_map_inc ( map , true ) ; <vul-end> fdput ( f ) ; return map ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> return map ; map =\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> return map ; if (! bpf_map_readonly ( map ) ) { struct bpf_prog * prog = bpf_map_prog ( map ) ; if (! prog ) bpf_map_inc ( map, false ) ; else bpf_map_put ( map ) ; }\n"
 },
 {
  "id": 1080,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static inline void VectorClamp ( DDSVector4 * value ) { <vul-start> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <vul-end> <vul-start> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <vul-end> <vul-start> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <vul-end> <vul-start> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <vul-end> }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> -> x = MagickMin <vul-end> ( 1.0f , <vul-start> ( 1.0f , MagickMax <vul-end> ( 0.0f , <vul-start> -> y = MagickMin <vul-end> ( 1.0f , <vul-start> ( 1.0f , MagickMax <vul-end> ( 0.0f , <vul-start> -> z = MagickMin <vul-end> ( 1.0f , <vul-start> ( 1.0f , MagickMax <vul-end> ( 0.0f , <vul-start> -> w = MagickMin <vul-end> ( 1.0f , <vul-start> ( 1.0f , MagickMax <vul-end> ( 0.0f ,\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> x = MagickMin <vul-end> ( 1.0f, <vul-start> ( 1.0f, MagickMax <vul-end> ( 0.0f, <vul-start> -> y = MagickMin <vul-end> ( 1.0f, <vul-start> ( 1.0f, MagickMax <vul-end> ( 0.0f, <vul-start> -> z = MagickMin <vul-end> ( 1.0f, <vul-start> ( 1.0f, MagickMax <vul-end> ( 0.0f, <vul-start> -> w = MagickMin <vul-end> ( 1.0f, <vul-start> ( 1.0f, MagickMax <vul-end> ( 0.0f,\n"
 },
 {
  "id": 1081,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static void change_port_settings ( struct tty_struct * tty , struct edgeport_port * edge_port , struct ktermios * old_termios ) { struct device * dev = & edge_port -> port -> dev ; struct ump_uart_config * config ; int baud ; unsigned cflag ; int status ; int port_number = edge_port -> port -> port_number ; config = kmalloc ( sizeof ( * config ) , GFP_KERNEL ) ; if ( ! config ) { tty -> termios = * old_termios ; return ; } cflag = tty -> termios . c_cflag ; config -> wFlags = 0 ; config -> wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT ; config -> wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR ; config -> bUartMode = ( __u8 ) ( edge_port -> bUartMode ) ; switch ( cflag & CSIZE ) { case CS5 : config -> bDataBits = UMP_UART_CHAR5BITS ; dev_dbg ( dev , \"%s - data bits = 5\\\\n\" , __func__ ) ; break ; case CS6 : config -> bDataBits = UMP_UART_CHAR6BITS ; dev_dbg ( dev , \"%s - data bits = 6\\\\n\" , __func__ ) ; break ; case CS7 : config -> bDataBits = UMP_UART_CHAR7BITS ; dev_dbg ( dev , \"%s - data bits = 7\\\\n\" , __func__ ) ; break ; default : case CS8 : config -> bDataBits = UMP_UART_CHAR8BITS ; dev_dbg ( dev , \"%s - data bits = 8\\\\n\" , __func__ ) ; break ; } if ( cflag & PARENB ) { if ( cflag & PARODD ) { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_ODDPARITY ; dev_dbg ( dev , \"%s -",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> ; } else { baud = min ( baud , 461550 ) ; <vul-start> baud ) ; }\n"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> ; } else { if ( baud < 115200 ) { dev_err ( dev, \"%s - baud rate cannot be zero\\\\n\", __func__ ) ; baud = 115200 ; } <vul-start> baud ) ; }\n"
 },
 {
  "id": 1082,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 struct timespec ns_to_timespec ( const s64 nsec ) { <vul-start> struct timespec ts ; <vul-end> if ( ! nsec ) return ( struct timespec ) { 0 , 0 } ; <vul-start> ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ; <vul-end> <vul-start> if ( unlikely ( nsec < 0 ) ) <vul-end> <vul-start> set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ; <vul-end> return ts ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> struct timespec ts ; s32 rem <vul-start> . tv_sec = div_s64_rem <vul-end> ( nsec , <vul-start> NSEC_PER_SEC , & rem <vul-end> ) ; if <vul-start> ( unlikely ( rem <vul-end> < 0 ) <vul-start> 0 ) ) { <vul-end> ts . tv_sec <vul-start> ts . tv_sec -- ; rem += NSEC_PER_SEC ; } <vul-end> ts . tv_nsec <vul-start> ts . tv_nsec = rem <vul-end> ; return ts\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> struct timespec ts ; u32 rem <vul-start> 0 } ; rem <vul-end> = div_long_long_rem_signed ( <vul-start> NSEC_PER_SEC, & rem ) ; if ( unlikely ( rem <vul-end> < 0 ) <vul-start> 0 ) ) return ERR_PTR ( rem ) ; <vul-start>. tv_sec, rem <vul-end> ) ; return\n"
 },
 {
  "id": 1083,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ; <vul-start> long timeo ; <vul-end> lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; long timeo ; msg -> msg_namelen = 0\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; long timeo ; msg -> msg_namelen = 0\n"
 },
 {
  "id": 1084,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int CIFSFindNext ( const int xid , struct cifs_tcon * tcon , __u16 searchHandle , struct cifs_search_info * psrch_inf ) { TRANSACTION2_FNEXT_REQ * pSMB = NULL ; TRANSACTION2_FNEXT_RSP * pSMBr = NULL ; T2_FNEXT_RSP_PARMS * parms ; char * response_data ; int rc = 0 ; <vul-start> int bytes_returned , name_len ; <vul-end> __u16 params , byte_count ; cFYI ( 1 , \"In FindNext\" ) ; if ( psrch_inf -> endOfSearch ) return - ENOENT ; rc = smb_init ( SMB_COM_TRANSACTION2 , 15 , tcon , ( void * * ) & pSMB , ( void * * ) & pSMBr ) ; if ( rc ) return rc ; params = 14 ; byte_count = 0 ; pSMB -> TotalDataCount = 0 ; pSMB -> MaxParameterCount = cpu_to_le16 ( 8 ) ; pSMB -> MaxDataCount = cpu_to_le16 ( ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) & 0xFFFFFF00 ) ; pSMB -> MaxSetupCount = 0 ; pSMB -> Reserved = 0 ; pSMB -> Flags = 0 ; pSMB -> Timeout = 0 ; pSMB -> Reserved2 = 0 ; pSMB -> ParameterOffset = cpu_to_le16 ( offsetof ( struct smb_com_transaction2_fnext_req , SearchHandle ) - 4 ) ; pSMB -> DataCount = 0 ; pSMB -> DataOffset = 0 ; pSMB -> SetupCount = 1 ; pSMB -> Reserved3 = 0 ; pSMB -> SubCommand = cpu_to_le16 ( TRANS2_FIND_NEXT ) ; pSMB -> SearchHandle = searchHandle ; pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) ) ; pSMB -> InformationLevel = cpu_to_le16 ( psrch_inf -> info_level ) ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; int bytes_returned ; unsigned int <vul-end> name_len ; __u16\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; int bytes_returned = 0\n"
 },
 {
  "id": 1085,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int kill_something_info ( int sig , struct siginfo * info , pid_t pid ) { int ret ; if ( pid > 0 ) { rcu_read_lock ( ) ; ret = kill_pid_info ( sig , info , find_vpid ( pid ) ) ; rcu_read_unlock ( ) ; return ret ; <vul-start> } <vul-end> read_lock ( & tasklist_lock ) ; if ( pid != - 1 ) { ret = __kill_pgrp_info ( sig , info , pid ? find_vpid ( - pid ) : task_pgrp ( current ) ) ; } else { int retval = 0 , count = 0 ; struct task_struct * p ; for_each_process ( p ) { if ( task_pid_vnr ( p ) > 1 && ! same_thread_group ( p , current ) ) { int err = group_send_sig_info ( sig , info , p ) ; ++ count ; if ( err != - EPERM ) retval = err ; } } ret = count ? retval : - ESRCH ; } read_unlock ( & tasklist_lock ) ; return ret ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ret ; } if ( pid == INT_MIN ) return - ESRCH ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ret ; } else if ( pid == - 1 ) { if ( info -> si_code == SIGILL ) return - ESRCH ; return - EPERM ; }\n"
 },
 {
  "id": 1086,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { <vul-start> int32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; <vul-end> if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ms ) { uint32_t <vul-end> nestsize = ( <vul-start> nestsize = ( uint32_t <vul-end> ) ms ->\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ms ) { uint32_t <vul-end> nestsize = ( <vul-start> nestsize = ( uint32_t <vul-end> ) ms ->\n"
 },
 {
  "id": 1087,
  "question": "CWE-352 Code Input Vulnerable Code Is: CWE-352 static HttpResponse create_HttpResponse ( Socket_T S ) { HttpResponse res = NULL ; NEW ( res ) ; res -> S = S ; res -> status = SC_OK ; res -> outputbuffer = StringBuffer_create ( 256 ) ; res -> is_committed = false ; res -> protocol = SERVER_PROTOCOL ; res -> status_msg = get_status_string ( SC_OK ) ; <vul-start> return res ; <vul-end> }",
  "golden_answers": [
   "CWE-352 Fixed Code Lines are: <vul-start> SC_OK ) ; Util_getToken ( res -> token ) ;\n"
  ],
  "generated_answer": "CWE-352 Fixed Code Lines are: <vul-start> SC_OK ) ; res -> proxy_url = get_proxy_url ( SERVER_PROTOCOL ) ;\n"
 },
 {
  "id": 1088,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static TX_SIZE read_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , TX_MODE tx_mode , <vul-end> <vul-start> BLOCK_SIZE bsize , int allow_select , vp9_reader * r ) { <vul-end> const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ; if ( allow_select && tx_mode == TX_MODE_SELECT && bsize >= BLOCK_8X8 ) return read_selected_tx_size ( cm , xd , max_tx_size , r ) ; else return MIN ( max_tx_size , tx_mode_to_biggest_tx_size [ tx_mode ] ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * xd , <vul-end> int allow_select , <vul-start> int allow_select , vpx_reader <vul-end> * r ) <vul-start> r ) { TX_MODE tx_mode = cm -> tx_mode ; BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> TX_SIZE read_tx_size ( const VP9_COMMON * const cm, const MACROBLOCKD * const <vul-end> xd, TX_MODE <vul-start> int allow_select, vpx_reader <vul-end> * r )\n"
 },
 {
  "id": 1089,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ MNT_WRITE_HOLD ; <vul-start> atomic_inc ( & sb -> s_active ) ; <vul-end> mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; br_write_unlock ( & vfsmount_lock ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ~ MNT_WRITE_HOLD ; if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ~ MNT_WRITE_HOLD ; mnt -> mnt. mnt_flags |= MNT_UNPRIVILEGED ;\n"
 },
 {
  "id": 1090,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 int add_mibdir ( const char * dirname ) { <vul-start> FILE * ip ; <vul-end> const char * oldFile = File ; char * * filenames ; int count = 0 ; int filename_count , i ; <vul-start> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <vul-end> char * token ; char space ; char newline ; struct stat dir_stat , idx_stat ; char tmpstr [ 300 ] ; char tmpstr1 [ 300 ] ; # endif DEBUGMSGTL ( ( \"parse-mibs\" , \"Scanning directory %s\\\\n\" , dirname ) ) ; <vul-start> # if ! ( defined ( WIN32 ) || defined ( cygwin ) ) <vul-end> token = netsnmp_mibindex_lookup ( dirname ) ; if ( token && stat ( token , & idx_stat ) == 0 && stat ( dirname , & dir_stat ) == 0 ) { if ( dir_stat . st_mtime < idx_stat . st_mtime ) { DEBUGMSGTL ( ( \"parse-mibs\" , \"The index is good\\\\n\" ) ) ; if ( ( ip = fopen ( token , \"r\" ) ) != NULL ) { fgets ( tmpstr , sizeof ( tmpstr ) , ip ) ; while ( fscanf ( ip , \"%127s%c%299[^\\\\n]%c\" , token , & space , tmpstr , & newline ) == 4 ) { if ( space != ' ' || newline != '\\\\n' ) { snmp_log ( LOG_ERR , \"add_mibdir: strings scanned in from %s/%s \" \"are too large. count = %d\\\\n \" , dirname , \".index\" , count ) ; break ; } snprintf ( tmpstr1 , sizeof ( tmpstr1",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> dirname ) { <vul-end> const char * <vul-start> , i ; <vul-end> DEBUGMSGTL ( ( <vul-start> ) ) ; <vul-end> filename_count = scan_directory <vul-start> 0 ) { <vul-end> for ( i <vul-start> , '/' ) <vul-end> ) == 0 <vul-start> File = oldFile <vul-end> ; free (\n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> dirname ) { <vul-end> char * token <vul-start>, i ; <vul-end> DEBUGMSGTL ( ( <vul-start> ) ) ; <vul-end> token = netsnmp_mibindex_lookup <vul-start> 0 ) { <vul-end> for ( i <vul-start> ++ ) { char * tmpstr ; tmpstr = <vul-end> filenames [ i <vul-start> i ], strrchr ( filenames [ i ], '/' ) ; if ( tmpstr && * tmpstr ) count ++ ; if ( add_mibfile ( tmpstr, <vul-start> ) ; } <vul-end> free ( filenames <vul-start> ) ; } <vul-end> return ( count\n"
 },
 {
  "id": 1091,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static int read_data ( void * opaque , uint8_t * buf , int buf_size ) { struct playlist * v = opaque ; HLSContext * c = v -> parent -> priv_data ; int ret , i ; <vul-start> int just_opened = 0 ; <vul-end> restart : if ( ! v -> needed ) return AVERROR_EOF ; if ( ! v -> input ) { int64_t reload_interval ; struct segment * seg ; if ( v -> ctx && v -> ctx -> nb_streams ) { v -> needed = 0 ; for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { v -> needed = 1 ; break ; } } } if ( ! v -> needed ) { av_log ( v -> parent , AV_LOG_INFO , \"No longer receiving playlist %d\\\\n\" , v -> index ) ; return AVERROR_EOF ; } reload_interval = default_reload_interval ( v ) ; reload : <vul-start> if ( ! v -> finished && <vul-end> av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { av_log ( v -> parent , AV_LOG_WARNING , \"Failed to reload playlist %d\\\\n\" , v -> index ) ; return ret ; } reload_interval = v -> target_duration / 2 ; } if ( v -> cur_seq_no < v -> start_seq_no ) { av_log ( NULL , AV_LOG_WARNING , \"skipping",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> ; int just_opened = 0 ; int reload_count <vul-start> ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;\n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> just_opened = 0 ; int64_t start_time <vul-start> ; reload : start_time = av_gettime_relative ( ) ; if ( v -> finished && ( v -> cur_seq_no - v -> start_seq_no ) > start_time ) { av_log ( v -> parent, AV_LOG_WARNING, \"Not going to reload playlist %d\\\\n\", v -> index ) ; v -> cur_seq_no += 1 ; goto reload ; } <vul-start> -> finished && ( <vul-start> -> init_sec_data_len ) && (! v -> finished && ( v -> cur_seq_no - v -> start_seq_no ) )\n"
 },
 {
  "id": 1092,
  "question": "CWE-862 Code Input Vulnerable Code Is: CWE-862 static int rename_in_ns ( int pid , char * oldname , char * * newnamep ) { <vul-start> int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ; <vul-end> bool grab_newname = false ; ofd = lxc_preserve_ns ( getpid ( ) , \"net\" ) ; if ( ofd < 0 ) { <vul-start> fprintf ( stderr , \"Failed opening network namespace path for \\'%d\\'.\" , getpid ( ) ) ; <vul-end> <vul-start> return - 1 ; <vul-end> } fd = lxc_preserve_ns ( pid , \"net\" ) ; if ( fd < 0 ) { <vul-start> fprintf ( stderr , \"Failed opening network namespace path for \\'%d\\'.\" , pid ) ; <vul-end> <vul-start> return - 1 ; <vul-end> } <vul-start> if ( setns ( fd , 0 ) < 0 ) { <vul-end> fprintf ( stderr , \"setns to container network namespace\\\\n\" ) ; goto out_err ; } <vul-start> close ( fd ) ; fd = - 1 ; <vul-end> if ( ! * newnamep ) { grab_newname = true ; * newnamep = VETH_DEF_NAME ; <vul-start> if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) { <vul-end> fprintf ( stderr , \"failed to get netdev index\\\\n\" ) ; goto out_err ; } } <vul-start> if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) { <vul-end> fprintf ( stderr , \"Error %d renaming netdev %s to %s in container\\\\n\" , ret , oldname , * newnamep ) ; goto out_err ; } if ( grab_newname ) { <vul-start>",
  "golden_answers": [
   "CWE-862 Fixed Code Lines are: <vul-start> newnamep ) { uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <vul-end> = - 1 <vul-start> 1 , ret <vul-end> ; bool grab_newname <vul-start> 0 ) { usernic_error ( <vul-end> \"Failed opening network namespace path for \\'%d\\'.\" , getpid <vul-start> ) ; return fret <vul-end> ; } fd <vul-start> 0 ) { usernic_error ( <vul-end> \"Failed opening network namespace path for \\'%d\\'.\" , pid <vul-start> pid ) ; goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( \"Failed to retrieve real, effective, and saved \" \"user IDs: %s\\\\n\" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <vul-end> setns ( fd <vul-start> ( fd , CLONE_NEWNET ) ; <vul-end> close ( fd <vul-start> fd ) ; fd = - 1 ; if ( ret < 0 ) { usernic_error ( \"Failed to setns() to the network namespace of \" \"the container with PID %d: %s.\\\\n\" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( \"Failed to drop privilege by setting effective \" \"user id and real user id to %d, and saved user \" \"ID to 0: %s.\\\\n\" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <vul-end> if ( ! <vul-start> = VETH_DEF_NAME ; ifindex = if_nametoindex ( oldname ) ; <vul-start> if ( ! ifindex ) { usernic_error ( \"Failed to get netdev index: %s.\\\\n\" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( \"Error %d renaming netdev %s to %s in container.\\\\n\" , ret , <vul-end> oldname , * <vul-start> * newnamep ) ; goto do_full_cleanup <vul-end> ; } if <vul-start> [ IFNAMSIZ ] ; char <vul-end> * namep = <vul-start> ) ) { usernic_error ( \"Failed to get new netdev name: %s.\\\\n\" , strerror ( errno ) ) ; goto do_full_cleanup <vul-end> ; } * <vul-start> newnamep ) goto do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( \"Failed to restore privilege by setting effective \" \"user id to %d, real user id to %d, and saved user \" \"ID to %d: %s.\\\\n\" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <vul-end> setns ( ofd <vul-start> ( ofd , CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( \"Failed to setns() to original network namespace \" \"of PID %d: %s.\\\\n\" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( <vul-end> ofd ) ; <vul-start> ) ; return fret <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-862 Fixed Code Lines are: <vul-start> newnamep ) { struct lxc_netdev * netdev = NULL ; int <vul-end> ofd = - <vul-start> 0 ) { return ofd <vul-end> ; } fd <vul-start> ) ) ; <vul-end> } fd = <vul-start> 0 ) { return fd <vul-end> ; } if <vul-start> pid ) ; <vul-end> } if ( <vul-start> ( fd, CL_UNPRIVILEGED <vul-end> ) < 0 <vul-start> out_err ; } <vul-end> if (! <vul-start> ) ) { return - 1 <vul-end> ; } } <vul-start> * newnamep ) ; if (! newname ) { fprintf ( stderr, \"Error %d renaming netdev %s to %s in container\\\\n\", ret, oldname, * newnamep ) ; goto out_err ; } if ( lxc_setns ( ofd, 0, & netdev ) < 0 ) { <vul-start> ( stderr, \"Error setting network namespace to unpriv\\\\n\" <vul-end> ) ; goto <vul-start> ) ; goto out_err ; } close ( fd ) ; netdev = NULL <vul-end> ; } if <vul-start> grab_newname ) { if (! newname ) { fprintf ( stderr, \"Error setting network dev name to %s in container\\\\n\", newname ) ; goto out_err ; } <vul-end> fprintf ( stderr <vul-start> ( stderr, \"Error setting network dev name to %s in container\\\\n\", newname ) ; goto out_err ; } if ( ofd >= 0 ) close ( ofd ) ; if ( fd >= 0 ) <vul-end> fprintf ( stderr <vul-start> ( stderr, \"Error setting network dev name to %s in container\\\\n\", newname ) ; <vul-end> out_err : if <vul-start> ( ofd, 0 <vul-end> ) < 0 <vul-start> ofd ) ; <vul-end> fprintf ( stderr\n"
 },
 {
  "id": 1093,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void silk_NLSF_stabilize ( opus_int16 * NLSF_Q15 , const opus_int16 * NDeltaMin_Q15 , const opus_int L ) { opus_int i , I = 0 , k , loops ; opus_int16 center_freq_Q15 ; opus_int32 diff_Q15 , min_diff_Q15 , min_center_Q15 , max_center_Q15 ; silk_assert ( NDeltaMin_Q15 [ L ] >= 1 ) ; for ( loops = 0 ; loops < MAX_LOOPS ; loops ++ ) { min_diff_Q15 = NLSF_Q15 [ 0 ] - NDeltaMin_Q15 [ 0 ] ; I = 0 ; for ( i = 1 ; i <= L - 1 ; i ++ ) { diff_Q15 = NLSF_Q15 [ i ] - ( NLSF_Q15 [ i - 1 ] + NDeltaMin_Q15 [ i ] ) ; if ( diff_Q15 < min_diff_Q15 ) { min_diff_Q15 = diff_Q15 ; I = i ; } } diff_Q15 = ( 1 << 15 ) - ( NLSF_Q15 [ L - 1 ] + NDeltaMin_Q15 [ L ] ) ; if ( diff_Q15 < min_diff_Q15 ) { min_diff_Q15 = diff_Q15 ; I = L ; } if ( min_diff_Q15 >= 0 ) { return ; } if ( I == 0 ) { NLSF_Q15 [ 0 ] = NDeltaMin_Q15 [ 0 ] ; } else if ( I == L ) { NLSF_Q15 [ L - 1 ] = ( 1 << 15 ) - NDeltaMin_Q15 [ L ] ; } else { min_center_Q15 = 0 ; for ( k = 0 ; k < I ; k ++ ) { min_center_Q15 += NDeltaMin_Q15 [ k ] ; } min_center_Q15 += silk_RSHIFT ( NDeltaMin_Q15 [ I ] , 1",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> i ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) <vul-end> ) ; NLSF_Q15\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> i ] = silk_min_int <vul-end> ( NLSF_Q15 [\n"
 },
 {
  "id": 1094,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_dequant_idct_add_c ( short * input , short * dq , unsigned char * dest , int stride ) { int i ; for ( i = 0 ; i < 16 ; i ++ ) { input [ i ] = dq [ i ] * input [ i ] ; } vp8_short_idct4x4llm_c ( input , dest , stride , dest , stride ) ; <vul-start> vpx_memset ( input , 0 , 32 ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> stride ) ; memset <vul-end> ( input ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> stride ) ; memset <vul-end> ( input,\n"
 },
 {
  "id": 1095,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 bool_t enc624j600IrqHandler ( NetInterface * interface ) { bool_t flag ; uint16_t status ; flag = FALSE ; <vul-start> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ; <vul-end> <vul-start> status = enc624j600ReadReg ( interface , ENC624J600_REG_EIR ) ; <vul-end> <vul-start> if ( ( status & EIR_LINKIF ) != 0 ) <vul-end> { <vul-start> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_LINKIE ) ; <vul-end> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <vul-start> if ( ( status & EIR_PKTIF ) != 0 ) <vul-end> { <vul-start> enc624j600ClearBit ( interface , ENC624J600_REG_EIE , EIE_PKTIE ) ; <vul-end> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <vul-start> if ( ( status & ( EIR_TXIF | EIR_TXABTIF ) ) != 0 ) <vul-end> { <vul-start> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <vul-end> flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } <vul-start> enc624j600SetBit ( interface , ENC624J600_REG_EIE , EIE_INTIE ) ; <vul-end> return flag ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE <vul-end> ) ; status <vul-start> ( interface , ENC624J600_EIR <vul-end> ) ; if <vul-start> ( status & ENC624J600_EIR_LINKIF <vul-end> ) != 0 <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_LINKIE <vul-end> ) ; interface <vul-start> ( status & ENC624J600_EIR_PKTIF <vul-end> ) != 0 <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_PKTIE <vul-end> ) ; interface <vul-start> status & ( ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <vul-end> ) ) != <vul-start> ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <vul-end> ) ; flag <vul-start> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE <vul-end> ) ; return\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( interface, ENC624J600_EIE, ENC624J600_EIE_INTIE <vul-end> ) ; status <vul-start> ( interface, ENC624J600_EIR <vul-end> ) ; if <vul-start> ( status & ENC624J600_EIR_LINKIF <vul-end> )!= 0 <vul-start> ( interface, ENC624J600_EIE, ENC624J600_EIE_LINKIE <vul-end> ) ; interface <vul-start> ( status & ENC624J600_EIE_PKTIF <vul-end> )!= 0 <vul-start> ( interface, ENC624J600_EIE, ENC624J600_EIE_PKTIE <vul-end> ) ; interface <vul-start> ( status & ENC624J600_EIE_TXIF | ENC624J600_EIE_TXABTIF <vul-end> ) )!= <vul-start> ( interface, ENC624J600_EIR, ENC624J600_EIR_TXIF | ENC624J600_EIE_TXABTIF <vul-end> ) ; flag <vul-start> ( interface, ENC624J600_EIE, ENC624J600_EIE_INTIE <vul-end> ) ; return\n"
 },
 {
  "id": 1096,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet_sk ( sk ) -> inet_daddr != LOOPBACK4_IPV6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } } <vul-start> opt = xchg ( & inet6_sk ( sk ) -> opt , opt ) ; <vul-end> sk_dst_reset ( sk ) ; return opt ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> = xchg ( ( __force struct ipv6_txoptions * * )\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; } } if ( opt ) atomic_set ( & opt -> refcnt, 1 ) ;\n"
 },
 {
  "id": 1097,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || <vul-start> s -> cur_pic . field_picture || <vul-end> s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; }",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> cur_pic . field_picture <vul-end> ) return 0\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> -> cur_pic. f_pic <vul-end> || s ->\n"
 },
 {
  "id": 1098,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int atusb_get_and_show_build ( struct atusb * atusb ) { struct usb_device * usb_dev = atusb -> usb_dev ; <vul-start> char build [ ATUSB_BUILD_SIZE + 1 ] ; <vul-end> <vul-start> int ret ; <vul-end> ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_BUILD , ATUSB_REQ_FROM_DEV , 0 , 0 , build , ATUSB_BUILD_SIZE , 1000 ) ; if ( ret >= 0 ) { build [ ret ] = 0 ; dev_info ( & usb_dev -> dev , \"Firmware: build %s\\\\n\" , build ) ; } <vul-start> return ret ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> usb_dev ; char * build <vul-end> ; int ret <vul-start> ; int ret ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <vul-start> ) ; } kfree ( build ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> usb_dev ; char * build ; int ret ; build = kmalloc ( ATUSB_BUILD_SIZE, GFP_KERNEL ) ; if (! build ) return - ENOMEM <vul-end> ; ret = <vul-start> ) ; } kfree ( build ) ;\n"
 },
 {
  "id": 1099,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; <vul-start> int col_offset , end_col_offset ; <vul-end> if ( ( ps = PyParser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) <vul-start> ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; <vul-end> # endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; col_offset = - 1 ; int lineno ; const char * line_start ; type = PyTokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; len = ( a != NULL && b != NULL ) ? b - a : 0 ; str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , end_col_offset ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } <vul-start> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS <vul-start> } if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( <vul-start> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> col_offset, end_col_offset ; int has_type_comment = 0 <vul-start> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; has_type_comment = * flags & PyPARSE_TYPE_COMMENTS <vul-start> -> p_tree ; if ( has_type_comment ) { <vul-start> = NULL ; }\n"
 },
 {
  "id": 1100,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 int do_adjtimex ( struct timex * txc ) { <vul-start> long mtemp , save_adjust , rem ; <vul-end> s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> mtemp , save_adjust <vul-end> ; s64 freq_adj <vul-start> ; time_offset = div_s64 <vul-end> ( time_offset , <vul-start> time_offset , NTP_INTERVAL_FREQ <vul-end> ) ; time_offset\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> txc ) { s64 <vul-end> save_adjust, rem <vul-start> ; time_offset = div_u64_rem_signed <vul-end> ( time_offset, <vul-start> time_offset, NTP_INTERVAL_FREQ <vul-end> ) ; time_offset\n"
 },
 {
  "id": 1101,
  "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static struct super_block * alloc_super ( struct file_system_type * type , int flags ) { struct super_block * s = kzalloc ( sizeof ( struct super_block ) , GFP_USER ) ; static const struct super_operations default_op ; int i ; if ( ! s ) return NULL ; if ( security_sb_alloc ( s ) ) goto fail ; <vul-start> # ifdef CONFIG_SMP <vul-end> s -> s_files = alloc_percpu ( struct list_head ) ; if ( ! s -> s_files ) goto fail ; <vul-start> for_each_possible_cpu ( i ) <vul-end> INIT_LIST_HEAD ( per_cpu_ptr ( s -> s_files , i ) ) ; # else INIT_LIST_HEAD ( & s -> s_files ) ; # endif for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 ) goto fail ; <vul-start> lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , <vul-end> & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; <vul-start> if ( list_lru_init ( & s -> s_dentry_lru ) ) <vul-end> goto fail ; <vul-start> if ( list_lru_init ( & s -> s_inode_lru ) ) <vul-end> goto",
  "golden_answers": [
   "CWE-17 Fixed Code Lines are: <vul-start> goto fail ; for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 <vul-end> ) goto fail <vul-start> goto fail ; lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; if ( list_lru_init ( & s -> s_dentry_lru ) <vul-end> ) goto fail <vul-start> goto fail ; <vul-end> if ( list_lru_init <vul-start> & s -> s_inode_lru <vul-end> ) ) goto <vul-start> goto fail ; <vul-end> INIT_LIST_HEAD ( &\n"
  ],
  "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> goto fail ; <vul-end> s -> s_files <vul-start> goto fail ; <vul-end> for ( i <vul-start> goto fail ; s -> s_inodes. count = 0 ; <vul-start> & s -> s_inode_lru <vul-end> ) ) goto\n"
 },
 {
  "id": 1102,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static FILE * open_log_file ( void ) { <vul-start> if ( log_fp ) <vul-end> return log_fp ; log_fp = fopen ( log_file , \"a+\" ) ; if ( log_fp == NULL ) { <vul-start> if ( daemon_mode == FALSE ) { <vul-end> printf ( \"Warning: Cannot open log file \\'%s\\' for writing\\\\n\" , log_file ) ; <vul-start> } <vul-end> return NULL ; } ( void ) fcntl ( fileno ( log_fp ) , F_SETFD , FD_CLOEXEC ) ; return log_fp ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> void ) { int fh ; struct stat st ; if ( log_fp ) return log_fp ; if ( ( fh = open ( log_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) { if ( daemon_mode == FALSE ) printf ( \"Warning: Cannot open log file \\'%s\\' for writing\\\\n\" , log_file ) ; return NULL ; } log_fp = fdopen ( fh <vul-end> , \"a+\" ) <vul-start> == FALSE ) <vul-end> printf ( \"Warning: Cannot open log file \\'%s\\' for writing\\\\n\" <vul-start> log_file ) ; return NULL ; } if ( ( fstat ( fh , & st ) ) == - 1 ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( \"Warning: Cannot fstat log file \\'%s\\'\\\\n\" , log_file ) ; return NULL ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( \"Warning: log file \\'%s\\' has an invalid mode\\\\n\" , log_file ) ; <vul-end> return NULL ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> { if (! daemon_mode <vul-end> ) { printf <vul-start> { if ( log_file!= NULL ) <vul-end> printf ( \"Warning: Cannot open log file \\'%s\\' for writing\\\\n\" <vul-start> log_file ) ; <vul-end> return NULL ;\n"
 },
 {
  "id": 1103,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ; <vul-start> markold ( g , g -> survival , g -> reallyold ) ; <vul-end> markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , g -> allgc <vul-end> , g ->\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> GCSpropagate ) ; luaD_checkstack ( g, 1, \"youngcollection\" ) ;\n"
 },
 {
  "id": 1104,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int af9005_identify_state ( struct usb_device * udev , struct dvb_usb_device_properties * props , struct dvb_usb_device_description * * desc , int * cold ) { int ret ; u8 reply , * buf ; buf = kmalloc ( FW_BULKOUT_SIZE + 2 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; ret = af9005_boot_packet ( udev , FW_CONFIG , & reply , buf , FW_BULKOUT_SIZE + 2 ) ; if ( ret ) goto err ; deb_info ( \"result of FW_CONFIG in identify state %d\\\\n\" , reply ) ; if ( reply == 0x01 ) * cold = 1 ; else if ( reply == 0x02 ) * cold = 0 ; else <vul-start> return - EIO ; <vul-end> deb_info ( \"Identify state cold = %d\\\\n\" , * cold ) ; err : kfree ( buf ) ; return ret ; }",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> 0 ; else ret = <vul-end> - EIO ; <vul-start> - EIO ; if ( ! ret )\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> 0 ; else { kfree ( buf ) ; <vul-start> - EIO ; }\n"
 },
 {
  "id": 1105,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int cg_write ( const char * path , const char * buf , size_t size , off_t offset , struct fuse_file_info * fi ) { struct fuse_context * fc = fuse_get_context ( ) ; char * localbuf = NULL ; struct cgfs_files * k = NULL ; struct file_info * f = ( struct file_info * ) fi -> fh ; bool r ; if ( f -> type != LXC_TYPE_CGFILE ) { fprintf ( stderr , \"Internal error: directory cache info used in cg_write\\\\n\" ) ; return - EIO ; } if ( offset ) return 0 ; if ( ! fc ) return - EIO ; localbuf = alloca ( size + 1 ) ; localbuf [ size ] = '\\\\0' ; memcpy ( localbuf , buf , size ) ; if ( ( k = cgfs_get_key ( f -> controller , f -> cgroup , f -> file ) ) == NULL ) { size = - EINVAL ; goto out ; } if ( ! fc_may_access ( fc , f -> controller , f -> cgroup , f -> file , O_WRONLY ) ) { size = - EACCES ; goto out ; } if ( strcmp ( f -> file , \"tasks\" ) == 0 || strcmp ( f -> file , \"/tasks\" ) == 0 || strcmp ( f -> file , \"/cgroup.procs\" ) == 0 || strcmp ( f -> file , \"cgroup.procs\" ) == 0 ) <vul-start> r = do_write_pids ( fc -> pid , f -> controller , f -> cgroup , f -> file ,",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> -> pid , fc -> uid ,\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> == 0 ) { if (! caller_may_see_dir ( f -> pid, f -> controller, f -> cgroup, f -> file ) ) { size = - ENOENT ; goto out ; } <vul-start> localbuf ) ; } else { r = cgfs_set_value ( f -> controller, f -> cgroup, f -> file, localbuf ) ; }\n"
 },
 {
  "id": 1106,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 int sc_file_set_sec_attr ( sc_file_t * file , const u8 * sec_attr , size_t sec_attr_len ) { u8 * tmp ; if ( ! sc_file_valid ( file ) ) { return SC_ERROR_INVALID_ARGUMENTS ; } <vul-start> if ( sec_attr == NULL ) { <vul-end> if ( file -> sec_attr != NULL ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return 0 ; } tmp = ( u8 * ) realloc ( file -> sec_attr , sec_attr_len ) ; if ( ! tmp ) { if ( file -> sec_attr ) free ( file -> sec_attr ) ; file -> sec_attr = NULL ; file -> sec_attr_len = 0 ; return SC_ERROR_OUT_OF_MEMORY ; } file -> sec_attr = tmp ; memcpy ( file -> sec_attr , sec_attr , sec_attr_len ) ; file -> sec_attr_len = sec_attr_len ; return 0 ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> sec_attr == NULL || sec_attr_len\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> } if ( file ->\n"
 },
 {
  "id": 1107,
  "question": "CWE-89 Code Input Vulnerable Code Is: CWE-89 static CURLcode pop3_parse_url_path ( struct connectdata * conn ) { struct pop3_conn * pop3c = & conn -> proto . pop3c ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <vul-start> pop3c -> mailbox = curl_easy_unescape ( data , path , 0 , NULL ) ; <vul-end> <vul-start> if ( ! pop3c -> mailbox ) <vul-end> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }",
  "golden_answers": [
   "CWE-89 Fixed Code Lines are: <vul-start> . path ; return Curl_urldecode <vul-end> ( data , <vul-start> , 0 , & <vul-end> pop3c -> mailbox <vul-start> pop3c -> mailbox , NULL , TRUE ) <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-89 Fixed Code Lines are: <vul-start>. path ; char * mailbox <vul-end> = curl_easy_unescape ( <vul-start> ; if (! mailbox ) return CURLE_OUT_OF_MEMORY ; if ( <vul-start> pop3c -> mailbox ) return CURLE_OK ; if (! mailbox\n"
 },
 {
  "id": 1108,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( \"ping_unhash(isk=%p,isk->num=%u)\\\\n\" , isk , isk -> inet_num ) ; if ( sk_hashed ( sk ) ) { write_lock_bh ( & ping_table . lock ) ; hlist_nulls_del ( & sk -> sk_nulls_node ) ; <vul-start> sock_put ( sk ) ; <vul-end> isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; write_unlock_bh ( & ping_table . lock ) ; } }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> sk_nulls_node ) ; isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ), sk -> sk_prot, - 1 ) ; <vul-start> sock_put ( sk <vul-end> ) ; }\n"
 },
 {
  "id": 1109,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) { AVStream * stream = ist -> st ; AVCodecParameters * par ; AVCodecContext * dec_ctx ; char val_str [ 128 ] ; const char * s ; AVRational sar , dar ; AVBPrint pbuf ; const AVCodecDescriptor * cd ; int ret = 0 ; const char * profile = NULL ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; print_int ( \"index\" , stream -> index ) ; par = stream -> codecpar ; dec_ctx = ist -> dec_ctx ; if ( cd = avcodec_descriptor_get ( par -> codec_id ) ) { print_str ( \"codec_name\" , cd -> name ) ; if ( ! do_bitexact ) { print_str ( \"codec_long_name\" , cd -> long_name ? cd -> long_name : \"unknown\" ) ; } } else { print_str_opt ( \"codec_name\" , \"unknown\" ) ; if ( ! do_bitexact ) { print_str_opt ( \"codec_long_name\" , \"unknown\" ) ; } } if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( \"profile\" , profile ) ; else { if ( par -> profile != FF_PROFILE_UNKNOWN ) { char profile_num [ 12 ] ; snprintf ( profile_num , sizeof ( profile_num ) , \"%d\" , par -> profile ) ; print_str ( \"profile\" , profile_num ) ; } else print_str_opt ( \"profile\" , \"unknown\" ) ; } s = av_get_media_type_string",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ) ) ; print_primaries ( w , <vul-end> par -> color_primaries <vul-start> par -> color_primaries <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( par -> pixel_aspect_ratio!= AVCOL_PRI_UNSPECIFIED ) print_str ( \"pixel_aspect_ratio\", av_pixel_aspect_name ( par -> pixel_aspect_ratio ) ) ; if ( par ->\n"
 },
 {
  "id": 1110,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int get_task_ioprio ( struct task_struct * p ) { int ret ; ret = security_task_getioprio ( p ) ; if ( ret ) goto out ; ret = IOPRIO_PRIO_VALUE ( IOPRIO_CLASS_NONE , IOPRIO_NORM ) ; <vul-start> if ( p -> io_context ) <vul-end> ret = p -> io_context -> ioprio ; <vul-start> out : <vul-end> return ret ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> IOPRIO_NORM ) ; task_lock ( p ) ; <vul-start> -> ioprio ; task_unlock ( p ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> -> io_context ) { if (! ret ) <vul-start> -> ioprio ; }\n"
 },
 {
  "id": 1111,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int privsep_preauth ( Authctxt * authctxt ) { int status , r ; pid_t pid ; struct ssh_sandbox * box = NULL ; pmonitor = monitor_init ( ) ; pmonitor -> m_pkex = & active_state -> kex ; if ( use_privsep == PRIVSEP_ON ) box = ssh_sandbox_init ( ) ; pid = fork ( ) ; if ( pid == - 1 ) { fatal ( \"fork of unprivileged child failed\" ) ; } else if ( pid != 0 ) { debug2 ( \"Network child is on pid %ld\" , ( long ) pid ) ; pmonitor -> m_pid = pid ; if ( have_agent ) { r = ssh_get_authentication_socket ( & auth_sock ) ; if ( r != 0 ) { error ( \"Could not get agent socket: %s\" , ssh_err ( r ) ) ; have_agent = 0 ; } } if ( box != NULL ) ssh_sandbox_parent_preauth ( box , pid ) ; monitor_child_preauth ( authctxt , pmonitor ) ; <vul-start> monitor_sync ( pmonitor ) ; <vul-end> while ( waitpid ( pid , & status , 0 ) < 0 ) { if ( errno == EINTR ) continue ; pmonitor -> m_pid = - 1 ; fatal ( \"%s: waitpid: %s\" , __func__ , strerror ( errno ) ) ; } privsep_is_preauth = 0 ; pmonitor -> m_pid = - 1 ; if ( WIFEXITED ( status ) ) { if ( WEXITSTATUS ( status ) != 0 ) fatal ( \"%s: preauth child exited with status %d\" , __func__ , WEXITSTATUS ( status ) ) ; } else",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> pmonitor ) ; <vul-end> while ( waitpid\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> pmonitor ) ; <vul-end> while ( waitpid\n"
 },
 {
  "id": 1112,
  "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 NOEXPORT char * pgsql_server ( CLI * c , SERVICE_OPTIONS * opt , const PHASE phase ) { uint8_t buffer [ 8 ] , ssl_ok [ 1 ] = { 'S' } ; <vul-start> ( void ) opt ; <vul-end> if ( phase != PROTOCOL_EARLY ) <vul-start> return NULL ; <vul-end> memset ( buffer , 0 , sizeof buffer ) ; s_read ( c , c -> local_rfd . fd , buffer , sizeof buffer ) ; <vul-start> if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { <vul-end> <vul-start> s_log ( LOG_ERR , \"PostgreSQL client did not request TLS, rejecting\" ) ; <vul-end> throw_exception ( c , 1 ) ; } <vul-start> s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ; <vul-end> return NULL ; }",
  "golden_answers": [
   "CWE-295 Fixed Code Lines are: <vul-start> 'S' } ; static const uint8_t gss_request [ 8 ] = { 0 , 0 , 0 , 8 , 0x04 , 0xd2 , 0x16 , 0x30 } ; static const uint8_t gss_response [ 62 ] = { 'E' , 0 , 0 , 0 , 61 , 'S' , 'E' , 'R' , 'R' , 'O' , 'R' , 0 , 'C' , 'X' , 'X' , '0' , '0' , '0' , 0 , 'M' , 'S' , 'S' , 'L' , ' ' , 'e' , 'x' , 'p' , 'e' , 'c' , 't' , 'e' , 'd' , ' ' , 'b' , 'u' , 't' , ' ' , 'n' , 'o' , 't' , ' ' , 'r' , 'e' , 'q' , 'u' , 'e' , 's' , 't' , 'e' , 'd' , ' ' , 'b' , 'y' , ' ' , 'c' , 'l' , 'i' , 'e' , 'n' , 't' , 0 , 0 } ; <vul-start> ) return NULL ; s_log ( LOG_DEBUG , \"Started server-side psql protcol negotiation\" ) <vul-start> ; if ( ! <vul-start> ( buffer , gss_request , sizeof gss_request <vul-end> ) ) { <vul-start> { s_log ( LOG_INFO , \"GSSAPI encryption requested, rejecting gracefully\" ) ; <vul-end> s_write ( c <vul-start> . fd , gss_response , sizeof gss_response ) ; throw_exception ( c , 2 ) ; } if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { s_log ( LOG_ERR , \"PostgreSQL client did not request TLS, rejecting\" ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_DEBUG , \"SSLRequest received\" ) ; s_write ( c , c -> local_wfd . fd ,\n"
  ],
  "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> 'S' } ; int ret ; <vul-start> PROTOCOL_EARLY ) return NULL ; if ( c -> remote_wfd. fd < 0 ) throw_exception ( c, 1 ) <vul-end> ; memset ( <vul-start> buffer ) ; ret = <vul-end> safe_memcmp ( buffer <vul-start> ssl_request, sizeof buffer <vul-end> ) ; if <vul-start> ( LOG_ERR, \"PostgreSQL client did not request TLS, rejecting\" <vul-end> ) ; throw_exception <vul-start> ) ; } if ( ret!= sizeof ssl_ok ) { s_log ( LOG_ERR, \"PostgreSQL client did not request TLS, rejecting\" ) ; throw_exception ( c, 1 ) ; } <vul-start>, sizeof ssl_ok ) ; close ( c -> remote_wfd. fd\n"
 },
 {
  "id": 1113,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 <vul-start> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <vul-end> { <vul-start> get_page ( buf -> page ) ; <vul-end> }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start>       bool <vul-end> generic_pipe_buf_get ( struct <vul-start> buf ) { return try_get_page <vul-end> ( buf ->\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>       int <vul-end> generic_pipe_buf_get ( struct <vul-start> buf ) { return - ENOMEM <vul-end> ; }  \n"
 },
 {
  "id": 1114,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void set_segmentation_map ( VP8_COMP * cpi , unsigned char * segmentation_map ) { <vul-start> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <vul-end> cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> segmentation_map ) { memcpy <vul-end> ( cpi ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> segmentation_map ) { memcpy <vul-end> ( cpi ->\n"
 },
 {
  "id": 1115,
  "question": "CWE-78 Code Input Vulnerable Code Is: CWE-78 static int bin_symbols ( RCore * r , int mode , ut64 laddr , int va , ut64 at , const char * name , bool exponly , const char * args ) { RBinInfo * info = r_bin_get_info ( r -> bin ) ; RList * entries = r_bin_get_entries ( r -> bin ) ; RBinSymbol * symbol ; RBinAddr * entry ; RListIter * iter ; bool firstexp = true ; bool printHere = false ; int i = 0 , lastfs = 's' ; bool bin_demangle = r_config_get_i ( r -> config , \"bin.demangle\" ) ; if ( ! info ) { return 0 ; } if ( args && * args == '.' ) { printHere = true ; } bool is_arm = info && info -> arch && ! strncmp ( info -> arch , \"arm\" , 3 ) ; const char * lang = bin_demangle ? r_config_get ( r -> config , \"bin.lang\" ) : NULL ; RList * symbols = r_bin_get_symbols ( r -> bin ) ; r_spaces_push ( & r -> anal -> meta_spaces , \"bin\" ) ; if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( \"[\" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ; } else if ( ! at && exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( \"fs exports\\\\n\" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? \"\" : \"[Exports]\\\\n\" ) ; }",
  "golden_answers": [
   "CWE-78 Fixed Code Lines are: <vul-start> { r_cons_printf ( \"\\\\\"k bin/pe/%s/%d=%s.%s\\\\\"\\\\n\" <vul-end> , module , <vul-start> { r_cons_printf ( \"\\\\\"k bin/pe/%s/%d=%s\\\\\"\\\\n\" <vul-end> , module ,\n"
  ],
  "generated_answer": "CWE-78 Fixed Code Lines are: <vul-start> { r_cons_printf ( \"[|ss|ss] %s[%d]\\\\n\" <vul-end>, module, <vul-start> { r_cons_printf ( \"[|ss|ss] %s[%d]\\\\n\" <vul-end>, module,\n"
 },
 {
  "id": 1116,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static int <vul-start> cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) <vul-end> { int sock ; cib_remote_opaque_t * private = cib -> variant_opaque ; <vul-start> struct sockaddr_in addr ; <vul-end> int rc = 0 ; <vul-start> char * server = private -> server ; <vul-end> int ret_ga ; struct addrinfo * res ; struct addrinfo hints ; xmlNode * answer = NULL ; xmlNode * login = NULL ; static struct mainloop_fd_callbacks cib_fd_callbacks = <vul-start> { <vul-end> <vul-start> . dispatch = cib_remote_dispatch , <vul-end> <vul-start> . destroy = cib_remote_connection_destroy , <vul-end> } ; connection -> socket = 0 ; connection -> session = NULL ; <vul-start> sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ; <vul-end> if ( sock == - 1 ) { crm_perror ( LOG_ERR , \"Socket creation failed\" ) ; return - 1 ; } bzero ( & hints , sizeof ( struct addrinfo ) ) ; hints . ai_flags = AI_CANONNAME ; hints . ai_family = AF_INET ; hints . ai_socktype = SOCK_RAW ; if ( hints . ai_family == AF_INET6 ) { hints . ai_protocol = IPPROTO_ICMPV6 ; } else { hints . ai_protocol = IPPROTO_ICMP ; } crm_debug ( \"Looking up %s\" , server ) ; ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ; if ( ret_ga ) { crm_err ( \"getaddrinfo: %s\" , gai_strerror ( ret_ga ) ) ; close ( sock ) ; return - 1 ; } if ( res -> ai_canonname ) { server = res -> ai_canonname ; } crm_debug ( \"Got",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> remote_connection_s * connection , gboolean event_channel <vul-start> -> variant_opaque ; <vul-end> int rc = <vul-start> = 0 ; int disconnected = 0 <vul-end> ; xmlNode * <vul-start> mainloop_fd_callbacks cib_fd_callbacks = { 0 , } ; cib_fd_callbacks <vul-end> . dispatch = <vul-start> . dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ; cib_fd_callbacks <vul-end> . destroy = <vul-start> destroy = cib_remote_connection_destroy <vul-end> ; connection -> <vul-start> ; sock = crm_remote_tcp_connect ( private -> server , private -> port ) ; if ( sock <= 0 ) { crm_perror ( LOG_ERR , \"remote tcp connection to %s:%d failed\" , private -> server , private -> port ) ; } connection -> socket = sock ; <vul-end> if ( connection <vul-start> # ifdef HAVE_GNUTLS_GNUTLS_H if ( remote_gnutls_credentials_init == FALSE ) { <vul-start> anon_cred_c ) ; remote_gnutls_credentials_init = TRUE ; } connection -> session = crm_create_anon_tls_session <vul-end> ( sock , <vul-start> sock , GNUTLS_CLIENT , anon_cred_c ) ; if ( crm_initiate_client_tls_handshake ( connection -> session , DEFAULT_CLIENT_HANDSHAKE_TIMEOUT ) != 0 ) { crm_err ( \"Session creation for %s:%d failed\" , private -> <vul-end> server , private <vul-start> port ) ; gnutls_deinit ( * connection -> session ) ; gnutls_free ( connection -> session ) ; connection -> session = NULL <vul-end> ; cib_tls_close ( <vul-start> login ) ; <vul-end> crm_recv_remote_msg ( connection <vul-start> -> session , & connection -> recv_buf , <vul-start> connection -> encrypted , - 1 , & disconnected ) ; if ( disconnected ) { rc = - ENOTCONN ; } answer = crm_parse_remote_buffer ( & connection -> recv_buf <vul-start> ; } } free_xml ( answer ) ; answer = NULL ; <vul-start> cib ) ; return rc ; } crm_trace ( \"remote client connection established\" ) <vul-end> ; connection ->\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> int cib_tls_signon ( int sock, <vul-start> -> variant_opaque ; <vul-end> char * server <vul-start> private -> server <vul-end> ; int ret_ga <vul-start> cib_fd_callbacks = { 0, } ; connection -> socket = sock ; connection -> source = mainloop_add_fd ( \"cib-remote\", G_PRIORITY_HIGH, connection -> socket, cib, & cib_fd_callbacks ) ; if ( connection -> socket < 0 ) { crm_perror ( LOG_ERR, \"Socket creation failed\" ) ; return - 1 ; } <vul-end> connection -> session <vul-start> destroy = cib_remote_connection_destroy <vul-end> ; return - <vul-start> = NULL ; <vul-end> return - EPROTONOSUPPORT <vul-start> # ifdef HAVE_GNUTLS_GNUTLS_H connection -> session = GUINT_TO_POINTER ( sock ) ; <vul-start> login ) ; if (! private -> server ) { <vul-start> -> session, private -> encrypted ) ; crm_log_xml_trace ( answer, \"Reply\" ) ; <vul-start>!= 0 ) <vul-end> cib_tls_close ( cib <vul-start> cib ) ; <vul-end> return - 1 <vul-start> 1 ; } <vul-end> } else {\n"
 },
 {
  "id": 1117,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif numSamples = pWTIntFrame -> numSamples ; if ( numSamples <= 0 ) { <vul-start> ALOGE ( \"b/26366256\" ) ; <vul-end> return ; } pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ALOGE ( \"b/26366256\" ) ; android_errorWriteLog ( 0x534e4554 , \"26366256\"\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ALOGE ( \"b/26366256\" ) ; android_errorWriteLog ( 0x534e4554, \"26366256\"\n"
 },
 {
  "id": 1118,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 size_t cdf_count_chain ( const cdf_sat_t * sat , cdf_secid_t sid , size_t size ) { size_t i , j ; <vul-start> cdf_secid_t maxsector = ( cdf_secid_t ) ( sat -> sat_len * size ) ; <vul-end> DPRINTF ( ( \"Chain:\" ) ) ; for ( j = i = 0 ; sid >= 0 ; i ++ , j ++ ) { DPRINTF ( ( \" %d\" , sid ) ) ; if ( j >= CDF_LOOP_LIMIT ) { DPRINTF ( ( \"Counting chain loop limit\" ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } <vul-start> if ( sid > maxsector ) { <vul-end> DPRINTF ( ( \"Sector %d > %d\\\\n\" , sid , maxsector ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } sid = CDF_TOLE4 ( ( uint32_t ) sat -> sat_tab [ sid ] ) ; } if ( i == 0 ) { DPRINTF ( ( \" none, sid: %d\\\\n\" , sid ) ) ; return ( size_t ) - 1 ; } DPRINTF ( ( \"\\\\n\" ) ) ; return i ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( cdf_secid_t ) ( <vul-start> * size ) / sizeof ( maxsector ) ) <vul-start> if ( sid >= maxsector ) { DPRINTF ( ( \"Sector %d >= %d\\\\n\" <vul-end> , sid ,\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> j ; cdf_secid_t maxsector ; if ( size > CDF_LOOP_LIMIT ) { DPRINTF ( ( \"Counting chain loop limit\" ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; } <vul-start> maxsector ) { DPRINTF ( ( \"Sector %d > %d\\\\n\", sid, maxsector ) ) ; errno = EFTYPE ; return ( size_t ) - 1 ; }\n"
 },
 {
  "id": 1119,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static ssize_t aio_setup_vectored_rw ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t * len , struct iovec * * iovec , <vul-start> bool compat ) <vul-end> { ssize_t ret ; * nr_segs = * len ; # ifdef CONFIG_COMPAT if ( compat ) ret = compat_rw_copy_check_uvector ( rw , ( struct compat_iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; else # endif ret = rw_copy_check_uvector ( rw , ( struct iovec __user * ) buf , * nr_segs , UIO_FASTIOV , * iovec , iovec ) ; if ( ret < 0 ) return ret ; * len = ret ; <vul-start> return 0 ; <vul-end> }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> , bool compat , struct iov_iter * iter <vul-start> = ret ; iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, bool compat, struct iov_iter * iter ) { ssize_t ret ; * nr_segs = * len ; if (! access_ok ( VERIFY_READ, buf, * nr_sec, * iovec ) ) return - EFAULT <vul-end> ; # ifdef <vul-start> = ret ; if (! compat && iter_iovec_iter_ok ( iter, * nr_segs, * iovec ) ) return - EFAULT ;\n"
 },
 {
  "id": 1120,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int compile_length_bag_node ( BagNode * node , regex_t * reg ) { int len ; int tlen ; if ( node -> type == BAG_OPTION ) return compile_length_option_node ( node , reg ) ; if ( NODE_BAG_BODY ( node ) ) { tlen = compile_length_tree ( NODE_BAG_BODY ( node ) , reg ) ; if ( tlen < 0 ) return tlen ; } else tlen = 0 ; switch ( node -> type ) { case BAG_MEMORY : # ifdef USE_CALL if ( node -> m . regnum == 0 && NODE_IS_CALLED ( node ) ) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; return len ; } if ( NODE_IS_CALLED ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN ; if ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ) len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH ) ; else len += ( NODE_IS_RECURSION ( node ) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END ) ; } else if ( NODE_IS_RECURSION ( node ) ) { len = SIZE_OP_MEMORY_START_PUSH ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC ) ; } else # endif { if ( MEM_STATUS_AT0 ( reg -> bt_mem_start , node -> m . regnum ) ) len = SIZE_OP_MEMORY_START_PUSH ; else len = SIZE_OP_MEMORY_START ; len += tlen + ( MEM_STATUS_AT0 ( reg -> bt_mem_end , node -> m . regnum ) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END ) ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <vul-start> ) ) { <vul-end> tlen = compile_length_tree\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> } if ( len < 0 ) return len ; if ( <vul-start> ) ) { int v ; v = onig_positive_int_multiply ( reg -> bt_mem_end, node -> m. regnum ) ; if ( v < 0 ) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE ; len = v + SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END ; <vul-start> len += SIZE_OP_JUMP + v\n"
 },
 {
  "id": 1121,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int handle_wrmsr ( struct kvm_vcpu * vcpu ) { struct msr_data msr ; u32 ecx = vcpu -> arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( vcpu -> arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( vcpu -> arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; <vul-start> if ( vmx_set_msr ( vcpu , & msr ) != 0 ) { <vul-end> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( vcpu ) ; return 1 ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; if ( kvm_set_msr <vul-end> ( vcpu ,\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( kvm_set_msr <vul-end> ( vcpu,\n"
 },
 {
  "id": 1122,
  "question": "CWE-74 Code Input Vulnerable Code Is: CWE-74 static int smtp_open ( struct Connection * conn , bool esmtp ) { int rc ; if ( mutt_socket_open ( conn ) ) return - 1 ; rc = smtp_get_resp ( conn ) ; if ( rc != 0 ) return rc ; rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; # ifdef USE_SSL enum QuadOption ans = MUTT_NO ; if ( conn -> ssf ) ans = MUTT_NO ; else if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( Capabilities & SMTP_CAP_STARTTLS ) && ( ( ans = query_quadoption ( C_SslStarttls , _ ( \"Secure connection with TLS?\" ) ) ) == MUTT_ABORT ) ) { return - 1 ; } if ( ans == MUTT_YES ) { if ( mutt_socket_send ( conn , \"STARTTLS\\\\r\\\\n\" ) < 0 ) return SMTP_ERR_WRITE ; <vul-start> rc = smtp_get_resp ( conn ) ; <vul-end> if ( rc != 0 ) return rc ; if ( mutt_ssl_starttls ( conn ) ) { mutt_error ( _ ( \"Could not negotiate TLS connection\" ) ) ; return - 1 ; } rc = smtp_helo ( conn , esmtp ) ; if ( rc != 0 ) return rc ; } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! ( Capabilities & SMTP_CAP_AUTH ) ) { mutt_error ( _ ( \"SMTP server does not support authentication\" ) ) ; return - 1 ; } return smtp_auth ( conn ) ; } return 0 ; }",
  "golden_answers": [
   "CWE-74 Fixed Code Lines are: <vul-start> rc = smtp_get_resp ( conn ) ; mutt_socket_empty\n"
  ],
  "generated_answer": "CWE-74 Fixed Code Lines are: <vul-start> return SMTP_ERR_WRITE ; mutt_socket_empty ( conn ) ;\n"
 },
 {
  "id": 1123,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 void fe_netjoin_deinit ( void ) { while ( joinservers != NULL ) netjoin_server_remove ( joinservers -> data ) ; if ( join_tag != - 1 ) { g_source_remove ( join_tag ) ; signal_remove ( \"print starting\" , ( SIGNAL_FUNC ) sig_print_starting ) ; } signal_remove ( \"setup changed\" , ( SIGNAL_FUNC ) read_settings ) ; <vul-start> signal_remove ( \"message quit\" , ( SIGNAL_FUNC ) msg_quit ) ; <vul-end> signal_remove ( \"message join\" , ( SIGNAL_FUNC ) msg_join ) ; signal_remove ( \"message irc mode\" , ( SIGNAL_FUNC ) msg_mode ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ; signal_remove ( \"server disconnected\" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove (\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ( SIGNAL_FUNC ) msg_print_stop <vul-end> ) ; signal_remove\n"
 },
 {
  "id": 1124,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 <vul-start> static int may_create_in_sticky ( struct dentry * const dir , <vul-end> struct inode * const inode ) { if ( ( ! sysctl_protected_fifos && S_ISFIFO ( inode -> i_mode ) ) || ( ! sysctl_protected_regular && S_ISREG ( inode -> i_mode ) ) || <vul-start> likely ( ! ( dir -> d_inode -> i_mode & S_ISVTX ) ) || <vul-end> <vul-start> uid_eq ( inode -> i_uid , dir -> d_inode -> i_uid ) || <vul-end> uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return 0 ; <vul-start> if ( likely ( dir -> d_inode -> i_mode & 0002 ) || <vul-end> <vul-start> ( dir -> d_inode -> i_mode & 0020 && <vul-end> ( ( sysctl_protected_fifos >= 2 && S_ISFIFO ( inode -> i_mode ) ) || ( sysctl_protected_regular >= 2 && S_ISREG ( inode -> i_mode ) ) ) ) ) { const char * operation = S_ISFIFO ( inode -> i_mode ) ? \"sticky_create_fifo\" : \"sticky_create_regular\" ; audit_log_path_denied ( AUDIT_ANOM_CREAT , operation ) ; return - EACCES ; } return 0 ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> int may_create_in_sticky ( umode_t dir_mode , kuid_t dir_uid <vul-end> , struct inode <vul-start> ( ! ( dir_mode <vul-end> & S_ISVTX ) <vul-start> -> i_uid , dir_uid <vul-end> ) || uid_eq <vul-start> ( likely ( dir_mode <vul-end> & 0002 ) <vul-start> ) || ( dir_mode <vul-end> & 0020 &&\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> int may_create_in_sticky ( struct mnt_sb * sb, <vul-start> (! ( sb <vul-end> -> d_inode -> <vul-start> -> i_mode & S_IFREG <vul-end> ) ) || <vul-start> -> i_uid, sb <vul-end> -> d_inode -> <vul-start> ( likely ( sb <vul-end> -> d_inode -> <vul-start> ) || ( sb <vul-end> -> d_inode ->\n"
 },
 {
  "id": 1125,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int <vul-start> mptctl_fw_download ( unsigned long arg ) <vul-end> { struct mpt_fw_xfer __user * ufwdl = ( void __user * ) arg ; struct mpt_fw_xfer kfwdl ; if ( copy_from_user ( & kfwdl , ufwdl , sizeof ( struct mpt_fw_xfer ) ) ) { printk ( KERN_ERR MYNAM \"%s@%d::_ioctl_fwdl - \" \"Unable to copy mpt_fw_xfer struct @ %p\\\\n\" , __FILE__ , __LINE__ , ufwdl ) ; return - EFAULT ; } <vul-start> return mptctl_do_fw_download ( kfwdl . iocnum , kfwdl . bufp , kfwdl . fwlen ) ; <vul-end> }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_fw_download ( MPT_ADAPTER * iocp , <vul-start> return mptctl_do_fw_download ( iocp <vul-end> , kfwdl .\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_fw_download ( MPT_COMP * ctx, <vul-start> EFAULT ; } if ( ctx -> disconnected ) return - EPERM ;\n"
 },
 {
  "id": 1126,
  "question": "CWE-358 Code Input Vulnerable Code Is: CWE-358 static void DefragTrackerInit ( DefragTracker * dt , Packet * p ) { COPY_ADDRESS ( & p -> src , & dt -> src_addr ) ; COPY_ADDRESS ( & p -> dst , & dt -> dst_addr ) ; if ( PKT_IS_IPV4 ( p ) ) { dt -> id = ( int32_t ) IPV4_GET_IPID ( p ) ; dt -> af = AF_INET ; } else { dt -> id = ( int32_t ) IPV6_EXTHDR_GET_FH_ID ( p ) ; dt -> af = AF_INET6 ; } <vul-start> dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; <vul-end> dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ; dt -> policy = DefragGetOsPolicy ( p ) ; dt -> host_timeout = DefragPolicyGetHostTimeout ( p ) ; dt -> remove = 0 ; dt -> seen_last = 0 ; TAILQ_INIT ( & dt -> frags ) ; ( void ) DefragTrackerIncrUsecnt ( dt ) ; }",
  "golden_answers": [
   "CWE-358 Fixed Code Lines are: <vul-start> } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->\n"
  ],
  "generated_answer": "CWE-358 Fixed Code Lines are: <vul-start> } dt -> vlan_id = 0 ; dt ->\n"
 },
 {
  "id": 1127,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_rc_postencode_update_drop_frame ( VP9_COMP * cpi ) { update_buffer_level ( cpi , 0 ) ; <vul-start> cpi -> common . last_frame_type = cpi -> common . frame_type ; <vul-end> cpi -> rc . frames_since_key ++ ; cpi -> rc . frames_to_key -- ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; cpi -> <vul-end> rc . frames_since_key <vul-start> frames_to_key -- ; cpi -> rc . rc_2_frame = 0 ; cpi -> rc . rc_1_frame = 0 ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 0 ) ; if ( cpi -> oxcf. rc_mode == VPX_Q ) { <vul-start> -- ; } }\n"
 },
 {
  "id": 1128,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int process_plane ( uint8 * in , int width , int height , uint8 * out , int size ) { UNUSED ( size ) ; int indexw ; int indexh ; int code ; int collen ; int replen ; int color ; int x ; int revcode ; uint8 * last_line ; uint8 * this_line ; uint8 * org_in ; uint8 * org_out ; org_in = in ; org_out = out ; last_line = 0 ; indexh = 0 ; while ( indexh < height ) { out = ( org_out + width * height * 4 ) - ( ( indexh + 1 ) * width * 4 ) ; color = 0 ; this_line = out ; indexw = 0 ; if ( last_line == 0 ) { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <vul-start> while ( collen > 0 ) <vul-end> { color = CVAL ( in ) ; * out = color ; out += 4 ; indexw ++ ; collen -- ; } <vul-start> while ( replen > 0 ) <vul-end> { * out = color ; out += 4 ; indexw ++ ; replen -- ; } } } else { while ( indexw < width ) {",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> } while ( indexw < width && <vul-start> } while ( indexw < width && <vul-start> } while ( indexw < width && <vul-start> } while ( indexw < width &&\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> while ( collen >= 4 <vul-end> ) { color <vul-start> while ( replen >= 4 <vul-end> ) { * <vul-start> 0 ; } if ( collen >= 4 ) { * out = color ; out += 4 ; indexw ++ ; replen -- ; }\n"
 },
 {
  "id": 1129,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 <vul-start> void <vul-end> pci_populate_msicap ( struct msicap * msicap , int msgnum , int nextptr ) { int mmc ; <vul-start> assert ( ( msgnum & ( msgnum - 1 ) ) == 0 && msgnum >= 1 && msgnum <= 32 ) ; <vul-end> mmc = ffs ( msgnum ) - 1 ; bzero ( msicap , sizeof ( struct msicap ) ) ; msicap -> capid = PCIY_MSI ; msicap -> nextptr = nextptr ; msicap -> msgctrl = PCIM_MSICTRL_64BIT | ( mmc << 1 ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start>       int <vul-end> pci_populate_msicap ( struct <vul-start> int mmc ; if ( <vul-end> ( ( msgnum <vul-start> 1 ) ) != 0 ) || msgnum < 1 || msgnum > 32 ) { pr_err ( \"%s: invalid number of msi messages!\\\\n\" , __func__ ) ; return - 1 ; } <vul-end> mmc = ffs <vul-start> 1 ) ; return 0 ;\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start>       int <vul-end> pci_populate_msicap ( struct <vul-start> int mmc ; if <vul-end> ( ( msgnum <vul-start> msgnum <= 32 ) { pr_err ( \"%s: invalid msgnum %d\\\\n\", __func__, msgnum ) ; return - 1 ; } <vul-end> mmc = ffs <vul-start> 1 ) ; return 0 ;\n"
 },
 {
  "id": 1130,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic !=",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( ResourceLimitError , \"ImproperImageHeader\" <vul-end> ) ; number_pixels <vul-start> ( ResourceLimitError , \"ImproperImageHeader\" <vul-end> ) ; bytes_per_line <vul-start> ( ResourceLimitError , \"ImproperImageHeader\" <vul-end> ) ; bytes_per_line <vul-start> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , \"ImproperImageHeader\" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) ThrowReaderException ( CorruptImageError <vul-end>, \"ImproperImageHeader\" ) <vul-start> ) ThrowReaderException ( CorruptImageError <vul-end>, \"ImproperImageHeader\" ) <vul-start> ) ThrowReaderException ( CorruptImageError <vul-end>, \"ImproperImageHeader\" )\n"
 },
 {
  "id": 1131,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int xc2028_set_config ( struct dvb_frontend * fe , void * priv_cfg ) { struct xc2028_data * priv = fe -> tuner_priv ; struct xc2028_ctrl * p = priv_cfg ; int rc = 0 ; tuner_dbg ( \"%s called\\\\n\" , __func__ ) ; mutex_lock ( & priv -> lock ) ; kfree ( priv -> ctrl . fname ) ; <vul-start> memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ; <vul-end> if ( p -> fname ) { priv -> ctrl . fname = kstrdup ( p -> fname , GFP_KERNEL ) ; if ( priv -> ctrl . fname == NULL ) <vul-start> rc = - ENOMEM ; <vul-end> } if ( ! firmware_name [ 0 ] && p -> fname && priv -> fname && strcmp ( p -> fname , priv -> fname ) ) free_firmware ( priv ) ; if ( priv -> ctrl . max_len < 9 ) priv -> ctrl . max_len = 13 ; if ( priv -> state == XC2028_NO_FIRMWARE ) { if ( ! firmware_name [ 0 ] ) priv -> fname = priv -> ctrl . fname ; else priv -> fname = firmware_name ; rc = request_firmware_nowait ( THIS_MODULE , 1 , priv -> fname , priv -> i2c_props . adap -> dev . parent , GFP_KERNEL , fe , load_firmware_cb ) ; if ( rc < 0 ) { tuner_err ( \"Failed to request firmware %s\\\\n\" , priv -> fname ) ; priv -> state = XC2028_NODEV ; } else priv -> state = XC2028_WAITING_FIRMWARE",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> fname ) ; priv -> ctrl . fname = NULL ; <vul-start> == NULL ) return <vul-end> - ENOMEM ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> fname ) ; if ( p -> fname ) { <vul-start> - ENOMEM ; } else { priv -> ctrl. fname = NULL ; }\n"
 },
 {
  "id": 1132,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static int ca8210_probe ( struct spi_device * spi_device ) { struct ca8210_priv * priv ; struct ieee802154_hw * hw ; struct ca8210_platform_data * pdata ; int ret ; dev_info ( & spi_device -> dev , \"Inserting ca8210\\\\n\" ) ; hw = ieee802154_alloc_hw ( sizeof ( struct ca8210_priv ) , & ca8210_phy_ops ) ; if ( ! hw ) { dev_crit ( & spi_device -> dev , \"ieee802154_alloc_hw failed\\\\n\" ) ; ret = - ENOMEM ; goto error ; } priv = hw -> priv ; priv -> hw = hw ; priv -> spi = spi_device ; hw -> parent = & spi_device -> dev ; spin_lock_init ( & priv -> lock ) ; priv -> async_tx_pending = false ; priv -> hw_registered = false ; priv -> sync_up = 0 ; priv -> sync_down = 0 ; priv -> promiscuous = false ; priv -> retries = 0 ; init_completion ( & priv -> ca8210_is_awake ) ; init_completion ( & priv -> spi_transfer_complete ) ; init_completion ( & priv -> sync_exchange_complete ) ; spi_set_drvdata ( priv -> spi , priv ) ; if ( IS_ENABLED ( CONFIG_IEEE802154_CA8210_DEBUGFS ) ) { cascoda_api_upstream = ca8210_test_int_driver_write ; ca8210_test_interface_init ( priv ) ; } else { cascoda_api_upstream = NULL ; } ca8210_hw_setup ( hw ) ; ieee802154_random_extended_addr ( & hw -> phy -> perm_extended_addr ) ; pdata = kmalloc ( sizeof ( * pdata ) , GFP_KERNEL ) ; if ( ! pdata ) { ret = - ENOMEM ; goto error ; } <vul-start> ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; <vul-end> if",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> error ; } <vul-end> priv -> spi <vul-start> ; ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; if ( ret ) { dev_crit ( & spi_device -> dev , \"ca8210_get_platform_data failed\\\\n\" ) ; goto error ; } ret =\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> error ; } priv -> tx_bufs = kzalloc ( sizeof ( * priv -> tx_bufs ), GFP_KERNEL ) ; if (! priv -> tx_bufs ) { ret = - ENOMEM ; goto error ; } <vul-start> = pdata ; priv -> tx_bufs [ 0 ] = ( u8 * ) priv -> tx_bufs ; priv -> tx_bufs [ 1 ] = 0 ;\n"
 },
 {
  "id": 1133,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) { static char * function = \"libevt_record_values_read_event\" ; size_t record_data_offset = 0 ; size_t strings_data_offset = 0 ; ssize_t value_data_size = 0 ; uint32_t data_offset = 0 ; uint32_t data_size = 0 ; uint32_t members_data_size = 0 ; uint32_t size = 0 ; uint32_t size_copy = 0 ; uint32_t strings_offset = 0 ; uint32_t strings_size = 0 ; uint32_t user_sid_offset = 0 ; uint32_t user_sid_size = 0 ; # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ; uint16_t value_16bit = 0 ; # endif if ( record_values == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid record values.\" , function ) ; return ( - 1 ) ; } if ( record_data == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , \"%s: invalid record data.\" , function ) ; return ( - 1 ) ; } if ( record_data_size > ( size_t ) SSIZE_MAX ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , \"%s: invalid record data size value exceeds maximum.\" , function ) ; return ( - 1 ) ; } if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: record data size value out of bounds.\" , function ) ; return ( - 1 ) ; } byte_stream_copy_to_uint32_little_endian ( ( ( evt_record_event_header_t * ) record_data ) -> size , size ) ; byte_stream_copy_to_uint32_little_endian ( ( (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: user SID data size value out of bounds.\" , function ) ; goto on_error ; } if ( <vul-start> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: strings size value out of bounds.\" , function ) ; goto on_error ; } <vul-start> 0 ) { if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , \"%s: data size value out of bounds.\" , function ) ; goto on_error ; } <vul-start> ( record_data [ record_data_offset <vul-end> ] ) ,\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> { if ( libfvalue_value_set_data <vul-end> ( record_values -> <vul-start> { if ( libfvalue_value_set_data <vul-end> ( record_values ->\n"
 },
 {
  "id": 1134,
  "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ; <vul-start> total_len = iov_length ( iov , nr_segs ) ; <vul-end> if ( unlikely ( total_len == 0 ) ) <vul-start> return 0 ; <vul-end> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ; <vul-start> void * addr ; <vul-end> <vul-start> size_t chars = buf -> len ; <vul-end> <vul-start> int error , atomic ; <vul-end> if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; } <vul-start> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <vul-end> redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic",
  "golden_answers": [
   "CWE-17 Fixed Code Lines are: <vul-start> size_t total_len ; struct iov_iter iter ; <vul-start> ) return 0 ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <vul-start> -> ops ; <vul-end> size_t chars = <vul-start> buf -> len ; size_t written <vul-start> ; int error <vul-end> ; if ( <vul-start> break ; } written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <vul-end> ; break ;\n"
  ],
  "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> size_t total_len ; struct iov_iter * iter = ( struct iov_iter * ) _iov ; <vul-start> ) ) return - EFAULT <vul-end> ; do_wakeup = <vul-start> -> ops ; const struct iov_iter * iter = & pipe -> iov_iter ; <vul-start> -> len ; size_t <vul-end> error, atomic <vul-start> error, atomic ; if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe, buf ) ; if ( error ) { if (! ret ) ret = error ; break ; } for ( ; ; ) { if (! iov_iter_is_iovec ( iter, & buf -> page ) ) { if (! ret ) ret = - EFAULT ; break ; } if ( iov_iter_count ( iter ) ) { if (! ret ) ret = - EFAULT ; break ; } } <vul-end> if (!\n"
 },
 {
  "id": 1135,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int bta_co_rfc_data_outgoing ( void * user_data , uint8_t * buf , uint16_t size ) { pthread_mutex_lock ( & slot_lock ) ; uint32_t id = ( uintptr_t ) user_data ; int ret = false ; rfc_slot_t * slot = find_rfc_slot_by_id ( id ) ; if ( ! slot ) goto out ; <vul-start> int received = recv ( slot -> fd , buf , size , 0 ) ; <vul-end> if ( received == size ) { ret = true ; } else { LOG_ERROR ( \"%s error receiving RFCOMM data from app: %s\" , __func__ , strerror ( errno ) ) ; cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; return ret ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> int received = TEMP_FAILURE_RETRY ( <vul-start> size , 0 )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> int received = TEMP_FAILURE_RETRY ( <vul-start> size, 0 )\n"
 },
 {
  "id": 1136,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( \"check_rpcsec_auth: failed \" \"inquire_context, stat=%u\" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ; <vul-start> if ( strncmp ( handle -> params . realm , realm -> data , realm -> length ) == 0 <vul-end> &&",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> princ ) ; success = data_eq_string ( * realm , <vul-end> handle -> params <vul-start> params . realm ) && data_eq_string ( * c1 , \"kadmin\" ) && ! data_eq_string ( * c2 , \"history\" ) ; <vul-end> fail_princ : if\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ; if ( realm &&\n"
 },
 {
  "id": 1137,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int put_chars ( u32 vtermno , const char * buf , int count ) { struct port * port ; <vul-start> struct scatterlist sg [ 1 ] ; <vul-end> if ( unlikely ( early_put_chars ) ) return early_put_chars ( vtermno , buf , count ) ; port = find_port_by_vtermno ( vtermno ) ; if ( ! port ) return - EPIPE ; <vul-start> sg_init_one ( sg , buf , count ) ; <vul-end> <vul-start> return __send_to_port ( port , sg , 1 , count , ( void * ) buf , false ) ; <vul-end> <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> [ 1 ] ; void * data ; int ret <vul-start> - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; <vul-start> ( sg , data <vul-end> , count ) <vul-start> count ) ; ret = <vul-end> __send_to_port ( port <vul-start> , count , data <vul-end> , false ) <vul-start> false ) ; kfree ( data ) ; return ret ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> port ; struct scatterlist * sg <vul-end> ; if ( <vul-start> - EPIPE ; if ( unlikely ( skb_zero ( buf, count ) ) ) return - ENOMEM ; <vul-start> count ) ; rc = <vul-end> __send_to_port ( port <vul-start> false ) ; sg_free_one ( sg ) ; return rc ;\n"
 },
 {
  "id": 1138,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , \"Pixel format 0x%0x\" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> bpp <= 8 && c -> format != CHUNKY\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>! encoding && c -> format == CHUNKY &&\n"
 },
 {
  "id": 1139,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) { struct f2fs_nm_info * nm_i = NM_I ( sbi ) ; <vul-start> struct free_nid * i ; <vul-end> struct nat_entry * ne ; <vul-start> int err ; <vul-end> if ( unlikely ( nid == 0 ) ) return false ; <vul-start> if ( build ) { <vul-end> ne = __lookup_nat_cache ( nm_i , nid ) ; if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) <vul-start> return false ; <vul-end> } i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } spin_lock ( & nm_i -> nid_list_lock ) ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; if ( err ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } return true ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> free_nid * i , * e <vul-start> ; int err = - EINVAL ; bool ret = false <vul-start> return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <vul-start> NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct f2fs_inode_info * ei ; struct <vul-start> ; int err ; unsigned long flags ; unsigned long nid_blocknr = nid & FREE_NID_MASK <vul-start> build ) { if ( ni. nid_max > sbi -> blocks_per_seg ) return false ; <vul-start> return false ; } for ( ei = nm_i -> nodes ; ei ; ei = ei -> next_node ) { if ( ei -> state!= NID_NEW ) continue ; if (! f2fs_is_node_valid ( sbi, ei ) ) return true ; }\n"
 },
 {
  "id": 1140,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , \"initial",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> * ke ; <vul-end> char fromname [ <vul-start> ADDRTOT_BUF ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( \"Received Notify(%d): %s\" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( \"rejecting I1 from %s:%u, no KE payload present\" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <vul-end> \"rejecting I1 from %s:%u, invalid DH group=%u\" , fromname <vul-start> ) ; return STF_FAIL +\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> * ke ; st -> st_oakley. group = lookup_group ( <vul-end> md -> chain <vul-start> [ ISAKMP_NEXT_v2KE ], <vul-end> isak_group ) ; <vul-start> ADDRTOT_BUF ) ; return v2N_INVALID_KE_PAYLOAD ; } { struct ikev2_ke * ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload. v2ke ; <vul-start> isak_group ) ; } DBG ( DBG_CONTROLMORE, DBG_log ( \"will not send/process a dcookie\" ) ) ; <vul-end> } { struct <vul-start> * ke ; st -> st_oakley. group = NULL ; <vul-start> ISAKMP_NEXT_v2KE ] -> <vul-end> payload. v2ke <vul-start> ADDRTOT_BUF ) ; return v2N_INVALID_KE_PAYLOAD <vul-end> ; } }\n"
 },
 {
  "id": 1141,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ; <vul-start> vpx_memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ; <vul-end> if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ; <vul-start> cpi -> kf_overspend_bits = 0 ; <vul-end> cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ GOLDEN_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ ALTREF_FRAME ] = 1 ; cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> common ; memset <vul-end> ( cpi , <vul-start> ; cpi -> temporal_layer_id = - 1 ; cpi -> <vul-start> endif cpi -> mse_source_denoised = 0 ; cpi -> <vul-start> / 5 ; if ( cpi -> oxcf . number_of_layers == 1 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } else if ( cpi -> oxcf . number_of_layers == 2 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } <vul-start> ) NULL ; CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ; CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; <vul-start> ; cpi -> force_maxqp = 0 ; cpi -> <vul-start> # endif # ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( \"denoised.yuv\" , \"ab\" ) ; # endif # <vul-start> . sdf = vpx_sad16x16 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance16x16 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance16x16 <vul-end> ; cpi -> <vul-start> . svf_halfpix_h = vpx_variance_halfpixvar16x16_h <vul-end> ; cpi -> <vul-start> . svf_halfpix_v = vpx_variance_halfpixvar16x16_v <vul-end> ; cpi -> <vul-start> . svf_halfpix_hv = vpx_variance_halfpixvar16x16_hv <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad16x16x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad16x16x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad16x16x4d <vul-end> ; cpi -> <vul-start> . sdf = vpx_sad16x8 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance16x8 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance16x8 <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad16x8x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad16x8x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad16x8x4d <vul-end> ; cpi -> <vul-start> . sdf = vpx_sad8x16 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance8x16 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance8x16 <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad8x16x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad8x16x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad8x16x4d <vul-end> ; cpi -> <vul-start> . sdf = vpx_sad8x8 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance8x8 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance8x8 <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad8x8x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad8x8x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad8x8x4d <vul-end> ; cpi -> <vul-start> . sdf = vpx_sad4x4 <vul-end> ; cpi -> <vul-start> . vf = vpx_variance4x4 <vul-end> ; cpi -> <vul-start> . svf = vpx_sub_pixel_variance4x4 <vul-end> ; cpi -> <vul-start> . sdx3f = vpx_sad4x4x3 <vul-end> ; cpi -> <vul-start> . sdx8f = vpx_sad4x4x8 <vul-end> ; cpi -> <vul-start> . sdx4df = vpx_sad4x4x4d <vul-end> ; # if\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> common ; memset <vul-end> ( cpi, <vul-start> ; cpi -> temporal_pattern_counter = 0 ; cpi -> <vul-start> # ifdef VP8_ENTROPY_STATS if ( cpi -> oxcf. error_resilient_mode ) { cpi -> temporal_pattern_counter = vp8_create_temporal_pattern ( & cpi -> common ) ; if (! cpi -> temporal_pattern_counter ) { vpx_free ( cpi ) ; vp8_remove_compressor ( & cpi ) ; return 0 ; } } # endif cpi -> <vul-start> endif cpi -> mb. ss = vpx_calloc ( ( cpi -> common. mb_rows * cpi -> common. mb_cols ) + 1 ) ; memcpy ( cpi -> common. mb. ss, vpx_calloc ( ( cpi -> common. mb_rows * cpi -> common. mb_cols ) + 1, cpi -> common. mb_rows * cpi -> common. mb_cols ) ; cpi -> common. mb. mb_mb_counters = vpx_calloc ( ( cpi -> common. mb_rows * cpi -> common. mb_cols ) + 1 ) ; if (! cpi -> common. mb. mb_counters ) { vpx_free ( cpi ) ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi ->\n"
 },
 {
  "id": 1142,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; <vul-start> dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & dh ) ; <vul-end> BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = \"nf_ct_dccp: not picking up existing connection \" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = \"nf_ct_dccp: invalid state transition \" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , \"%s\" , msg ) ; return false ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ) , & _dh <vul-end> ) ; BUG_ON\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> u_int8_t state ; if ( skb -> len < sizeof ( _dh ) ) return false ;\n"
 },
 {
  "id": 1143,
  "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 void __fput_sync ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { struct task_struct * task = current ; <vul-start> file_sb_list_del ( file ) ; <vul-end> BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ; __fput ( file ) ; } }",
  "golden_answers": [
   "CWE-17 Fixed Code Lines are: <vul-start> = current ; <vul-end> BUG_ON ( !\n"
  ],
  "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> = current ; <vul-end> BUG_ON (!\n"
 },
 {
  "id": 1144,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 void * gdImageWBMPPtr ( gdImagePtr im , int * size , int fg ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <vul-start> gdImageWBMPCtx ( im , fg , out ) ; <vul-end> <vul-start> rv = gdDPExtractData ( out , size ) ; <vul-end> out -> gd_free ( out ) ; return rv ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> NULL ) ; if ( ! _gdImageWBMPCtx <vul-end> ( im , <vul-start> , out ) ) { <vul-end> rv = gdDPExtractData <vul-start> size ) ; } else { rv = NULL ; }\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> NULL ) ; if (! _gdImageWBMPCtx <vul-end> ( im, <vul-start>, out ) ) { <vul-end> rv = gdDPExtractData <vul-start> size ) ; } else { rv = NULL ; }\n"
 },
 {
  "id": 1145,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MaxTextExtent ] ; CINInfo cin ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register PixelPacket * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , \"\\\\200\\\\052\\\\137\\\\327\" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> image_info -> ping != MagickFalse <vul-start> return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. lines_per_image ; <vul-end> cin. file <vul-start> ->ping ) <vul-end> ( void ) <vul-start> ) ) ; <vul-end> quantum_info = AcquireQuantumInfo\n"
 },
 {
  "id": 1146,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <vul-start> record_and_restart ( event , val , regs , nmi ) ; <vul-end> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> val , regs <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> val, regs <vul-end> ) ; }\n"
 },
 {
  "id": 1147,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 unsigned char * base64decode ( const char * buf , size_t * size ) { if ( ! buf || ! size ) return NULL ; size_t len = ( * size > 0 ) ? * size : strlen ( buf ) ; if ( len <= 0 ) return NULL ; unsigned char * outbuf = ( unsigned char * ) malloc ( ( len / 4 ) * 3 + 3 ) ; const char * ptr = buf ; int p = 0 ; <vul-start> size_t l = 0 ; <vul-end> do { <vul-start> ptr += strspn ( ptr , \"\\\\r\\\\n\\\\t \" ) ; <vul-end> if ( * ptr == '\\\\0' || ptr >= buf + len ) { break ; } <vul-start> l = strcspn ( ptr , \"\\\\r\\\\n\\\\t \" ) ; <vul-end> if ( l > 3 && ptr + l <= buf + len ) { p += base64decode_block ( outbuf + p , ptr , l ) ; ptr += l ; } else { break ; } } while ( 1 ) ; outbuf [ p ] = 0 ; * size = p ; return outbuf ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; int wv , w1 , w2 , w3 , w4 ; int tmpval [ 4 ] ; int tmpcnt <vul-end> = 0 ; <vul-start> ; do { while ( ptr < buf + len && ( * ptr == ' ' || * ptr == '\\\\t' || * ptr == '\\\\n' || * ptr == '\\\\r' ) ) { ptr ++ ; } <vul-end> if ( * <vul-start> break ; } if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) { continue ; } tmpval [ tmpcnt ++ ] = wv ; if ( tmpcnt == 4 ) { tmpcnt = 0 ; w1 = tmpval [ 0 ] ; w2 = tmpval [ 1 ] ; w3 = tmpval [ 2 ] ; w4 = tmpval [ 3 ] ; if ( w2 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ; } if ( w3 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ; } if ( w4 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ; } <vul-end> } } while\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; ssize_t <vul-end> l = 0 <vul-start> { ptr += ssize_t <vul-end> ( ptr, <vul-start> } l = ssize_t <vul-end> ( ptr,\n"
 },
 {
  "id": 1148,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static const char * parse_scheme ( struct parse_state * state ) { size_t mb ; const char * tmp = state -> ptr ; do { switch ( * state -> ptr ) { case ':' : state -> url . scheme = & state -> buffer [ 0 ] ; state -> buffer [ state -> offset ++ ] = 0 ; return ++ state -> ptr ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '+' : case '-' : case '.' : if ( state -> ptr == tmp ) { <vul-start> return tmp ; <vul-end> } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> tmp ) { goto softfail <vul-end> ; } case <vul-start> ) ) { goto softfail <vul-end> ; } state <vul-start> end ) ; softfail : state -> offset = 0 ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> tmp ) { break <vul-end> ; } case <vul-start> ) ) { break <vul-end> ; } state <vul-start> end ) ; if (! state -> ptr ) { break ; }\n"
 },
 {
  "id": 1149,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) { kuid_t euid ; kgid_t egid ; int id ; int next_id = ids -> next_id ; if ( size > IPCMNI ) size = IPCMNI ; if ( ids -> in_use >= size ) return - ENOSPC ; idr_preload ( GFP_KERNEL ) ; spin_lock_init ( & new -> lock ) ; new -> deleted = false ; rcu_read_lock ( ) ; spin_lock ( & new -> lock ) ; <vul-start> id = idr_alloc ( & ids -> ipcs_idr , new , <vul-end> ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ; idr_preload_end ( ) ; if ( id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; } ids -> in_use ++ ; <vul-start> current_euid_egid ( & euid , & egid ) ; <vul-end> new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; if ( next_id < 0 ) { new -> seq = ids -> seq ++ ; if ( ids -> seq > IPCID_SEQ_MAX ) ids -> seq = 0 ; } else { new -> seq = ipcid_to_seqx ( next_id ) ; ids -> next_id = - 1 ; } new -> id = ipc_buildid ( id , new -> seq ) ; return id ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> lock ) ; current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <vul-start> in_use ++ ; <vul-end> if ( next_id\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> lock ) ; if ( next_id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return - EINVAL ; } <vul-start> in_use ++ ; if ( next_id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; }\n"
 },
 {
  "id": 1150,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 apr_status_t ap_http_filter ( ap_filter_t * f , apr_bucket_brigade * b , ap_input_mode_t mode , apr_read_type_e block , apr_off_t readbytes ) { core_server_config * conf ; apr_bucket * e ; http_ctx_t * ctx = f -> ctx ; apr_status_t rv ; apr_off_t totalread ; int again ; conf = ( core_server_config * ) ap_get_module_config ( f -> r -> server -> module_config , & core_module ) ; if ( mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE ) { return ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; } if ( ! ctx ) { const char * tenc , * lenp ; f -> ctx = ctx = apr_pcalloc ( f -> r -> pool , sizeof ( * ctx ) ) ; ctx -> state = BODY_NONE ; if ( ! f -> r -> proxyreq ) { ctx -> limit = ap_get_limit_req_body ( f -> r ) ; } else { ctx -> limit = 0 ; } tenc = apr_table_get ( f -> r -> headers_in , \"Transfer-Encoding\" ) ; lenp = apr_table_get ( f -> r -> headers_in , \"Content-Length\" ) ; if ( tenc ) { if ( strcasecmp ( tenc , \"chunked\" ) == 0 || ap_find_last_token ( f -> r -> pool , tenc , \"chunked\" ) ) { ctx -> state = BODY_CHUNK ; } else if ( f -> r -> proxyreq == PROXYREQ_RESPONSE ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) <vul-start> \"Unknown Transfer-Encoding: %s;\" <vul-end> \" using read-until-close\"",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( 02555 ) \"Unknown Transfer-Encoding: %s; \" \"using read-until-close\" <vul-end> , tenc ) <vul-start> ) ; return APR_EINVAL <vul-end> ; } if <vul-start> bb ) ; apr_brigade_cleanup ( bb ) ; <vul-start> BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <vul-end> : { rv <vul-start> BODY_CHUNK_TRAILER ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <vul-end> ) ; } <vul-start> default : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) \"Unexpected body state (%i)\" , ( int ) ctx -> state ) ; return APR_EGENERAL <vul-end> ; } }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 02555 ) \"Unknown Transfer-Encoding: %s;\" \" using read-until-close\" <vul-end>, tenc ) <vul-start> BODY_CHUNK_TRAILER ) { if ( f -> r -> proxyreq == PROXYREQ_RESPONSE && f -> r -> read_max_offset == 0 && f -> next -> proxyreq == NULL ) { return APR_EINVAL ; } <vul-start> bb ) ; f -> r -> proxyreq = NULL ;\n"
 },
 {
  "id": 1151,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 bool_t xdr_krb5_tl_data ( XDR * xdrs , krb5_tl_data * * tl_data_head ) { krb5_tl_data * tl , * tl2 ; bool_t more ; unsigned int len ; switch ( xdrs -> x_op ) { case XDR_FREE : tl = tl2 = * tl_data_head ; while ( tl ) { tl2 = tl -> tl_data_next ; free ( tl -> tl_data_contents ) ; free ( tl ) ; tl = tl2 ; } <vul-start> break ; <vul-end> case XDR_ENCODE : tl = * tl_data_head ; while ( 1 ) { more = ( tl != NULL ) ; if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( tl == NULL ) break ; if ( ! xdr_krb5_int16 ( xdrs , & tl -> tl_data_type ) ) return FALSE ; len = tl -> tl_data_length ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl = tl -> tl_data_next ; } break ; case XDR_DECODE : tl = NULL ; while ( 1 ) { if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( more == FALSE ) break ; tl2 = ( krb5_tl_data * ) malloc ( sizeof ( krb5_tl_data ) ) ; if ( tl2 == NULL ) return FALSE ; memset ( tl2 , 0 , sizeof ( krb5_tl_data ) ) ; if ( ! xdr_krb5_int16 ( xdrs , & tl2 -> tl_data_type ) ) return FALSE ; if ( !",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> tl2 ; } * tl_data_head = NULL ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> tl2 ; } xdrs -> x_op = XDR_ENCODE ; <vul-start> tl2 ; } xdrs -> x_op = XDR_ENCODE ;\n"
 },
 {
  "id": 1152,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int jpc_pi_nextrlcp ( register jpc_pi_t * pi ) { jpc_pchg_t * pchg ; int * prclyrno ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> rlvlno = pchg -> rlvlnostart ; pi -> rlvlno < pi -> maxrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno ) { for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < pi -> numcomps && pi -> compno < JAS_CAST ( int , pchg -> compnoend ) ; ++ pi -> compno , ++ pi -> picomp ) { if ( pi -> rlvlno >= pi -> picomp -> numrlvls ) { continue ; } pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; for ( pi -> prcno = 0 , prclyrno = pi -> pirlvl -> prclyrnos ; pi -> prcno < pi -> pirlvl -> numprcs ; ++ pi -> prcno , ++ prclyrno ) { if ( pi",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: \n"
 },
 {
  "id": 1153,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void iriap_getvaluebyclass_indication ( struct iriap_cb * self , struct sk_buff * skb ) { struct ias_object * obj ; struct ias_attrib * attrib ; int name_len ; int attr_len ; char name [ IAS_MAX_CLASSNAME + 1 ] ; char attr [ IAS_MAX_ATTRIBNAME + 1 ] ; __u8 * fp ; int n ; IRDA_DEBUG ( 4 , \"%s()\\\\n\" , __func__ ) ; IRDA_ASSERT ( self != NULL , return ; ) ; IRDA_ASSERT ( self -> magic == IAS_MAGIC , return ; ) ; IRDA_ASSERT ( skb != NULL , return ; ) ; fp = skb -> data ; n = 1 ; name_len = fp [ n ++ ] ; <vul-start> memcpy ( name , fp + n , name_len ) ; n += name_len ; <vul-end> name [ name_len ] = '\\\\0' ; <vul-start> attr_len = fp [ n ++ ] ; <vul-end> memcpy ( attr , fp + n , attr_len ) ; n += attr_len ; attr [ attr_len ] = '\\\\0' ; IRDA_DEBUG ( 4 , \"LM-IAS: Looking up %s: %s\\\\n\" , name , attr ) ; obj = irias_find_object ( name ) ; if ( obj == NULL ) { IRDA_DEBUG ( 2 , \"LM-IAS: Object %s not found\\\\n\" , name ) ; iriap_getvaluebyclass_response ( self , 0x1235 , IAS_CLASS_UNKNOWN , & irias_missing ) ; return ; } IRDA_DEBUG ( 4 , \"LM-IAS: found %s, id=%d\\\\n\" , obj -> name , obj -> id ) ; attrib = irias_find_attrib ( obj , attr ) ; if ( attrib == NULL ) { IRDA_DEBUG ( 2 , \"LM-IAS:",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ++ ] ; IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ; ) ; <vul-start> n ++ ] ; IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ; )\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ++ ] ; if ( name_len > IAS_MAX_CLASSNAME + 1 + sizeof ( name ) ) { IRDA_DEBUG ( 2, \"LM-IAS: Object %s has %d chars, bigger than maximum of %d\\\\n\", name, IAS_MAX_CLASSNAME + 1, ( int ) ( size_t ) ( size_t ) ( size_t ) name_len ) ; return ; } <vul-start> ++ ] ; if ( attr_len > IAS_MAX_ATTRIBNAME + 1 + sizeof ( attr ) ) { IRDA_DEBUG ( 2, \"LM-IAS: Object %s has %d chars, bigger than maximum of %d\\\\n\", name, attr_len, ( int ) ( size_t ) ( size_t ) ( attr_len ) ) ; return ; }\n"
 },
 {
  "id": 1154,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static void finish_process_as_req ( struct as_req_state * state , krb5_error_code errcode ) { krb5_key_data * server_key ; krb5_keyblock * as_encrypting_key = NULL ; krb5_data * response = NULL ; const char * emsg = 0 ; int did_log = 0 ; loop_respond_fn oldrespond ; void * oldarg ; kdc_realm_t * kdc_active_realm = state -> active_realm ; krb5_audit_state * au_state = state -> au_state ; assert ( state ) ; oldrespond = state -> respond ; oldarg = state -> arg ; if ( errcode ) goto egress ; au_state -> stage = ENCR_REP ; if ( ( errcode = validate_forwardable ( state -> request , * state -> client , * state -> server , state -> kdc_time , & state -> status ) ) ) { errcode += ERROR_TABLE_BASE_krb5 ; goto egress ; } errcode = check_indicators ( kdc_context , state -> server , state -> auth_indicators ) ; if ( errcode ) { state -> status = \"HIGHER_AUTHENTICATION_REQUIRED\" ; goto egress ; } state -> ticket_reply . enc_part2 = & state -> enc_tkt_reply ; if ( ( errcode = krb5_dbe_find_enctype ( kdc_context , state -> server , - 1 , - 1 , 0 , & server_key ) ) ) { state -> status = \"FINDING_SERVER_KEY\" ; goto egress ; } if ( ( errcode = krb5_dbe_decrypt_key_data ( kdc_context , NULL , server_key , & state -> server_keyblock , NULL ) ) ) { state -> status = \"DECRYPT_SERVER_KEY\" ; goto egress ; } state -> reply . msg_type = KRB5_AS_REP ; state -> reply . client = state -> enc_tkt_reply . client",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> errcode != 0 && state -> status == NULL ) state -> status = \"UNKNOWN_REASON\" <vul-end> ; au_state ->\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> ; egress : <vul-end> assert ( state\n"
 },
 {
  "id": 1155,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; <vul-start> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <vul-end> flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY )",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> , 1 , <vul-end> regs , address <vul-start> , 1 , <vul-end> regs , address <vul-start> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <vul-end> , regs ,\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> & __FAIL_ADDR_MASK ; if ( unlikely ( address > MAX_RW_COUNT ) ) goto out_up <vul-end> ; flags = <vul-start>, 1, <vul-end> regs, address <vul-start>, 1, <vul-end> regs, address <vul-start> PERF_COUNT_SW_PAGE_FAULTS_MIN, 1 <vul-end>, regs,\n"
 },
 {
  "id": 1156,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ; <vul-start> spin_lock ( & desc -> iuspin ) ; <vul-end> clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , \"nonzero urb status received: -ENOENT\" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , \"nonzero urb status received: -ECONNRESET\" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , \"nonzero urb status received: -ESHUTDOWN\" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , \"nonzero urb status received: -EPIPE\\\\n\" ) ; break ; default : dev_err ( & desc -> intf -> dev , \"Unexpected error %d\\\\n\" , status ) ; break ; } } desc -> rerr = status ; <vul-start> desc -> reslength = urb -> actual_length ; <vul-end> <vul-start> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <vul-end> desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> status ; int length = urb -> actual_length ; <vul-start> = status ; if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <vul-end> memmove ( desc <vul-start> -> inbuf , length ) ; desc -> length += length ; <vul-start> desc -> reslength = length ; } } <vul-end> skip_error : wake_up\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> status ; int length = urb -> actual_length ; <vul-start> -> iuspin ) ; if (! ( status & 0x01 ) ) goto skip_error <vul-start> = status ; <vul-end> memmove ( desc <vul-start> -> inbuf, & length, sizeof ( * desc -> inbuf ) ) ; desc -> length += length <vul-end> ; skip_error :\n"
 },
 {
  "id": 1157,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int DetectEngineContentInspection ( DetectEngineCtx * de_ctx , DetectEngineThreadCtx * det_ctx , const Signature * s , const SigMatchData * smd , Flow * f , uint8_t * buffer , uint32_t buffer_len , uint32_t stream_start_offset , uint8_t inspection_mode , void * data ) { SCEnter ( ) ; KEYWORD_PROFILING_START ; det_ctx -> inspection_recursion_counter ++ ; if ( det_ctx -> inspection_recursion_counter == de_ctx -> inspection_recursion_limit ) { det_ctx -> discontinue_matching = 1 ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd == NULL || buffer_len == 0 ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd -> type == DETECT_CONTENT ) { DetectContentData * cd = ( DetectContentData * ) smd -> ctx ; SCLogDebug ( \"inspecting content %\" PRIu32 \" buffer_len %\" PRIu32 , cd -> id , buffer_len ) ; # ifdef DEBUG BUG_ON ( cd -> depth != 0 && cd -> depth <= cd -> offset ) ; # endif uint8_t * found = NULL ; uint32_t offset = 0 ; uint32_t depth = buffer_len ; uint32_t prev_offset = 0 ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; do { if ( ( cd -> flags & DETECT_CONTENT_DISTANCE ) || ( cd -> flags & DETECT_CONTENT_WITHIN ) ) { SCLogDebug ( \"det_ctx->buffer_offset %\" PRIu32 , det_ctx -> buffer_offset ) ; offset = prev_buffer_offset ; depth = buffer_len ; int distance = cd -> distance ; if ( cd -> flags & DETECT_CONTENT_DISTANCE ) { if ( cd ->",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ) ) { if ( ( cd -> flags & ( DETECT_CONTENT_DISTANCE | DETECT_CONTENT_WITHIN ) ) == 0 ) { det_ctx -> discontinue_matching = 1 ; } <vul-start> } if ( smd -> is_last ) { goto match <vul-end> ; } SCLogDebug <vul-start> ) ; } SCLogDebug ( \"no match for \\'next sm\\'\" ) ; <vul-start> -> discontinue_matching ) { SCLogDebug ( \"\\'next sm\\' said to discontinue this right now\" ) ; goto no_match ; } if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) { SCLogDebug ( \"\\'next sm\\' does not depend on me, so we can give up\" ) ; det_ctx -> discontinue_matching = 1 ; goto no_match ; } SCLogDebug ( \"\\'next sm\\' depends on me %p, lets see what we can do (flags %u)\" , cd , cd -> flags ) <vul-end> ; prev_offset =\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ) { goto match <vul-end> ; } else <vul-start> ) { goto match <vul-end> ; } else <vul-start> } } } if (! found ) { SCLogError ( \"detector %\" PRIu32 \", not in content\", cd -> id ) ; goto no_match ; }\n"
 },
 {
  "id": 1158,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int btrfs_add_link ( struct btrfs_trans_handle * trans , struct inode * parent_inode , struct inode * inode , const char * name , int name_len , int add_backref , u64 index ) { int ret = 0 ; struct btrfs_key key ; struct btrfs_root * root = BTRFS_I ( parent_inode ) -> root ; u64 ino = btrfs_ino ( inode ) ; u64 parent_ino = btrfs_ino ( parent_inode ) ; if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { memcpy ( & key , & BTRFS_I ( inode ) -> root -> root_key , sizeof ( key ) ) ; } else { key . objectid = ino ; btrfs_set_key_type ( & key , BTRFS_INODE_ITEM_KEY ) ; key . offset = 0 ; } if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { ret = btrfs_add_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , index , name , name_len ) ; } else if ( add_backref ) { ret = btrfs_insert_inode_ref ( trans , root , name , name_len , ino , parent_ino , index ) ; } if ( ret ) return ret ; ret = btrfs_insert_dir_item ( trans , root , name , name_len , parent_inode , & key , btrfs_inode_type ( inode ) , index ) ; <vul-start> if ( ret == - EEXIST ) <vul-end> goto fail_dir_item ; else if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; return ret ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + name_len",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> == - EEXIST || ret == - EOVERFLOW\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> == - EEXIST || ret == - EOVERFLOW\n"
 },
 {
  "id": 1159,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void fadst8 ( const int16_t * input , int16_t * output ) { <vul-end> <vul-start> int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; <vul-end> int x0 = input [ 7 ] ; <vul-start> int x1 = input [ 0 ] ; <vul-end> <vul-start> int x2 = input [ 5 ] ; <vul-end> <vul-start> int x3 = input [ 2 ] ; <vul-end> <vul-start> int x4 = input [ 3 ] ; <vul-end> <vul-start> int x5 = input [ 4 ] ; <vul-end> <vul-start> int x6 = input [ 1 ] ; <vul-end> <vul-start> int x7 = input [ 6 ] ; <vul-end> s0 = cospi_2_64 * x0 + cospi_30_64 * x1 ; s1 = cospi_30_64 * x0 - cospi_2_64 * x1 ; s2 = cospi_10_64 * x2 + cospi_22_64 * x3 ; s3 = cospi_22_64 * x2 - cospi_10_64 * x3 ; s4 = cospi_18_64 * x4 + cospi_14_64 * x5 ; s5 = cospi_14_64 * x4 - cospi_18_64 * x5 ; s6 = cospi_26_64 * x6 + cospi_6_64 * x7 ; s7 = cospi_6_64 * x6 - cospi_26_64 * x7 ; x0 = fdct_round_shift ( s0 + s4 ) ; x1 = fdct_round_shift ( s1 + s5 ) ; x2 = fdct_round_shift ( s2 + s6 ) ; x3 = fdct_round_shift ( s3 + s7 ) ; x4 = fdct_round_shift ( s0 - s4 ) ; x5 = fdct_round_shift ( s1 - s5 ) ; x6 = fdct_round_shift ( s2 - s6 ) ; x7 = fdct_round_shift ( s3 - s7 ) ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> fadst8 ( const tran_low_t * input , tran_low_t <vul-end> * output ) <vul-start> output ) { tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; tran_high_t <vul-end> x0 = input <vul-start> 7 ] ; tran_high_t <vul-end> x1 = input <vul-start> 0 ] ; tran_high_t <vul-end> x2 = input <vul-start> 5 ] ; tran_high_t <vul-end> x3 = input <vul-start> 2 ] ; tran_high_t <vul-end> x4 = input <vul-start> 3 ] ; tran_high_t <vul-end> x5 = input <vul-start> 4 ] ; tran_high_t <vul-end> x6 = input <vul-start> 1 ] ; tran_high_t <vul-end> x7 = input <vul-start> 0 ] = ( tran_low_t ) <vul-start> 1 ] = ( tran_low_t ) <vul-start> 2 ] = ( tran_low_t ) <vul-start> 3 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 5 ] = ( tran_low_t ) <vul-start> 6 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> fadst8 ( const tran_low_t <vul-end> * input, <vul-start> * input, tran_low_t <vul-end> * output ) <vul-start> output ) { tran_high_t <vul-end> s0, s1 <vul-start>, s7 ; tran_high_t <vul-end> x0 = input <vul-start> 0 ] ; tran_high_t <vul-end> x2 = input <vul-start> 5 ] ; tran_high_t <vul-end> x3 = input <vul-start> 2 ] ; tran_high_t <vul-end> x4 = input <vul-start> 3 ] ; tran_high_t <vul-end> x5 = input <vul-start> 4 ] ; tran_high_t <vul-end> x6 = input <vul-start> 1 ] ; tran_high_t <vul-end> x7 = input <vul-start> s7 ) ; tran_high_t <vul-end> x0 = input <vul-start> 7 ] = ( tran_low_t ) <vul-start> 0 ] = ( tran_low_t ) <vul-start> 1 ] = ( tran_low_t ) <vul-start> 2 ] = ( tran_low_t ) <vul-start> 3 ] = ( tran_low_t ) <vul-start> 4 ] = ( tran_low_t ) <vul-start> 5 ] = ( tran_low_t ) <vul-start> 6 ] = ( tran_low_t ) <vul-start> 7 ] = ( tran_low_t ) <vul-start> 8 ] = ( tran_low_t ) <vul-start> 9 ] = ( tran_low_t ) <vul-start> 10 ] = ( tran_low_t ) <vul-start> 11 ] = ( tran_low_t ) <vul-start> 12 ] = ( tran_low_t ) <vul-start> 13 ] = ( tran_low_t ) <vul-start> 14 ] = ( tran_low_t ) <vul-start> 15 ] = ( tran_low_t ) <vul-start> 16 ] = ( tran_low_t ) <vul-start> 17 ] = ( tran_low_t ) <vul-start> 19 ] = ( tran_low_t ) <vul-start> 19 ] = ( tran_low_t ) <vul-start> 12 ] = ( tran_low_t ) <vul-start> 13 ] = ( tran_low_t ) <vul-start> 14 ] = ( tran_low_t ) <vul-start> 15 ] = ( tran_low_t ) <vul-start> 13 ] = ( tran_low_t ) <vul-start> 16 ] = ( tran_low"
 },
 {
  "id": 1160,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static EAS_RESULT Parse_wave ( SDLS_SYNTHESIZER_DATA * pDLSData , EAS_I32 pos , EAS_U16 waveIndex ) { EAS_RESULT result ; EAS_U32 temp ; EAS_I32 size ; EAS_I32 endChunk ; EAS_I32 chunkPos ; EAS_I32 wsmpPos = 0 ; EAS_I32 fmtPos = 0 ; EAS_I32 dataPos = 0 ; EAS_I32 dataSize = 0 ; S_WSMP_DATA * p ; void * pSample ; S_WSMP_DATA wsmp ; chunkPos = pos + 12 ; if ( ( result = EAS_HWFileSeek ( pDLSData -> hwInstData , pDLSData -> fileHandle , pos ) ) != EAS_SUCCESS ) return result ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; if ( temp != CHUNK_WAVE ) { { } return EAS_ERROR_FILE_FORMAT ; } pos = chunkPos ; endChunk = pos + size ; while ( pos < endChunk ) { chunkPos = pos ; if ( ( result = NextChunk ( pDLSData , & pos , & temp , & size ) ) != EAS_SUCCESS ) return result ; switch ( temp ) { case CHUNK_WSMP : wsmpPos = chunkPos + 8 ; break ; case CHUNK_FMT : fmtPos = chunkPos + 8 ; break ; case CHUNK_DATA : dataPos = chunkPos + 8 ; dataSize = size ; break ; default : break ; } } <vul-start> if ( dataSize > MAX_DLS_WAVE_SIZE ) <vul-end> { return EAS_ERROR_SOUND_LIBRARY ; } if ( pDLSData -> pDLS == NULL ) p = & wsmp ; else p = & pDLSData -> wsmpData [ waveIndex ] ; p -> fineTune = 0",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> } if ( dataSize < 0 ||\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> if ( dataSize < 8 || dataSize\n"
 },
 {
  "id": 1161,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 int parse_sym_line ( buf , which_set ) char * buf ; int which_set ; { int val , i ; struct symparse * symp ; <vul-start> char * bufp , * commentp , * altp ; <vul-end> mungspaces ( buf ) ; if ( ( commentp = rindex ( buf , '#' ) ) != 0 && commentp [ - 1 ] == ' ' ) commentp [ - 1 ] = '\\\\0' ; bufp = index ( buf , '=' ) ; altp = index ( buf , ':' ) ; if ( ! bufp || ( altp && altp < bufp ) ) bufp = altp ; if ( ! bufp ) { if ( strncmpi ( buf , \"finish\" , 6 ) == 0 ) { if ( chosen_symset_start ) chosen_symset_end = TRUE ; chosen_symset_start = FALSE ; return 1 ; } config_error_add ( \"No \\\\\"finish\\\\\"\" ) ; return 0 ; } ++ bufp ; if ( * bufp == ' ' ) ++ bufp ; symp = match_sym ( buf ) ; if ( ! symp ) { config_error_add ( \"Unknown sym keyword\" ) ; return 0 ; } if ( ! symset [ which_set ] . name ) { if ( symp -> range == SYM_CONTROL ) { struct symsetentry * tmpsp , * lastsp ; for ( lastsp = symset_list ; lastsp ; lastsp = lastsp -> next ) if ( ! lastsp -> next ) break ; switch ( symp -> idx ) { case 0 : tmpsp = ( struct symsetentry * ) alloc ( sizeof *",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> , * altp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\\\0'\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> * altp ; if ( which_set == SYM_SETUP ) { if ( chosen_symset_end ) chosen_symset_end = FALSE ; return 1 ; }\n"
 },
 {
  "id": 1162,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void command_timed_out ( UNUSED_ATTR void * context ) { pthread_mutex_lock ( & commands_pending_response_lock ) ; if ( list_is_empty ( commands_pending_response ) ) { LOG_ERROR ( \"%s with no commands pending response\" , __func__ ) ; } else { waiting_command_t * wait_entry = list_front ( commands_pending_response ) ; pthread_mutex_unlock ( & commands_pending_response_lock ) ; LOG_ERROR ( \"%s hci layer timeout waiting for response to a command. opcode: 0x%x\" , __func__ , wait_entry -> opcode ) ; } LOG_ERROR ( \"%s restarting the bluetooth process.\" , __func__ ) ; <vul-start> usleep ( 10000 ) ; <vul-end> kill ( getpid ( ) , SIGKILL ) ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> __func__ ) ; TEMP_FAILURE_RETRY ( <vul-start> usleep ( 10000 )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> __func__ ) ; TEMP_FAILURE_RETRY ( <vul-start> usleep ( 10000 )\n"
 },
 {
  "id": 1163,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t ctrl_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx , <vul-start> int ctrl_id , va_list args ) { <vul-end> int * corrupted = va_arg ( args , int * ) ; if ( corrupted ) { <vul-start> if ( ctx -> pbi ) <vul-end> <vul-start> * corrupted = ctx -> pbi -> common . frame_to_show -> corrupted ; <vul-end> else return VPX_CODEC_ERROR ; return VPX_CODEC_OK ; } else { <vul-start> return VPX_CODEC_INVALID_PARAM ; <vul-end> } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * ctx , <vul-end> va_list args ) <vul-start> ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; RefCntBuffer * const frame_bufs = frame_worker_data -> pbi -> common . buffer_pool -> frame_bufs ; if ( frame_worker_data <vul-end> -> pbi -> <vul-start> common . frame_to_show == NULL ) return VPX_CODEC_ERROR ; if ( ctx -> last_show_frame >= 0 ) * corrupted = frame_bufs [ ctx -> last_show_frame ] . buf . corrupted <vul-end> ; return VPX_CODEC_OK <vul-start> else { return VPX_CODEC_ERROR <vul-end> ; } } <vul-start> ; } } return VPX_CODEC_INVALID_PARAM ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * ctx, <vul-end> va_list args ) <vul-start> ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx, \"Not supported in frame parallel decode\" ) ; return VPX_CODEC_INCAPABLE ; } if ( ctx -> <vul-start> -> corrupted ; else { set_error_detail ( ctx, \"Invalid frame count in frame parallel decode\" ) ; return VPX_CODEC_ERROR ; } } else { <vul-end> return VPX_CODEC_INVALID_PARAM ; <vul-start> ; } } }\n"
 },
 {
  "id": 1164,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , \" [invalid len %d]\" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , \" [max resp delay=%d]\" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , \" [gaddr %s\" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , \" sflag\" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , \" robustness=%d\" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 )",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( ndo , \"%s\" , mldv2_tstr <vul-end> ) ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( ndo, \"%s\", mldv2_tstr <vul-end> ) ) ;\n"
 },
 {
  "id": 1165,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int mi_repair ( MI_CHECK * param , register MI_INFO * info , <vul-start> char * name , int rep_quick ) <vul-end> { int error , got_error ; ha_rows start_records , new_header_length ; my_off_t del ; File new_file ; MYISAM_SHARE * share = info -> s ; char llbuff [ 22 ] , llbuff2 [ 22 ] ; SORT_INFO sort_info ; MI_SORT_PARAM sort_param ; DBUG_ENTER ( \"mi_repair\" ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ; start_records = info -> state -> records ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0L : share -> pack . header_length ; got_error = 1 ; new_file = - 1 ; sort_param . sort_info = & sort_info ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( \"- recovering (with keycache) MyISAM-table \\'%s\\'\\\\n\" , name ) ; printf ( \"Data records: %s\\\\n\" , llstr ( info -> state -> records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; DBUG_ASSERT ( param -> use_buffers < SIZE_T_MAX ) ; if ( ! param -> using_global_keycache ) ( void ) init_key_cache ( dflt_key_cache , param -> key_cache_block_size , param -> use_buffers , 0 , 0 ) ; if ( init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length ,",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> , int rep_quick , my_bool no_copy_stat <vul-start> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <vul-start> , DATA_TMP_EXT , flags <vul-end> ) || mi_open_datafile\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start>, int rep_quick, my_bool no_copy_stat <vul-start> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <vul-start>, DATA_TMP_EXT, flags <vul-end> ) || mi_open_datafile\n"
 },
 {
  "id": 1166,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int dbConnect ( char * host , char * user , char * passwd ) { DBUG_ENTER ( \"dbConnect\" ) ; if ( verbose ) { fprintf ( stderr , \"# Connecting to %s...\\\\n\" , host ? host : \"localhost\" ) ; } mysql_init ( & mysql_connection ) ; if ( opt_compress ) mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ; <vul-start> # ifdef HAVE_OPENSSL <vul-end> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } # endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql_connection , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql_connection , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql_connection , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql_connection , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql_connection , MYSQL_SET_CHARSET_NAME , default_charset ) ; mysql_options ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_ADD , \"program_name\" , \"mysqlcheck\" ) ; if ( ! ( sock = mysql_real_connect ( & mysql_connection , host , user , passwd , NULL , opt_mysql_port , opt_mysql_unix_port , 0 )",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> NullS ) ; SSL_SET_OPTIONS ( & mysql_connection ) ; <vul-end> if ( opt_protocol\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> NullS ) ; SSL_SET_OPTIONS ( & mysql_connection ) ; <vul-end> if ( opt_protocol\n"
 },
 {
  "id": 1167,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , \"metadata sets count %d\\\\n\" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , \"no material package found\\\\n\" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , \"material_package_umid\" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , \"material_package_name\" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> av_log ( mxf -> fc\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( mxf, AV_LOG_ERROR <vul-end>, \"could not resolve essence container data strong ref\\\\n\" )\n"
 },
 {
  "id": 1168,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 void deinit_pci ( struct vmctx * ctx ) { struct pci_vdev_ops * ops ; struct businfo * bi ; struct slotinfo * si ; struct funcinfo * fi ; int bus , slot , func ; size_t lowmem ; struct mem_range mr ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = \"PCI ECFG\" ; mr . base = PCI_EMUL_ECFG_BASE ; mr . size = PCI_EMUL_ECFG_SIZE ; unregister_mem ( & mr ) ; lowmem = vm_get_lowmem_size ( ctx ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = \"PCI hole (32-bit)\" ; mr . base = lowmem ; mr . size = ( 4ULL * 1024 * 1024 * 1024 ) - lowmem ; unregister_mem_fallback ( & mr ) ; bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = \"PCI hole (64-bit)\" ; mr . base = PCI_EMUL_MEMBASE64 ; mr . size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64 ; unregister_mem_fallback ( & mr ) ; for ( bus = 0 ; bus < MAXBUSES ; bus ++ ) { bi = pci_businfo [ bus ] ; if ( bi == NULL ) continue ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { fi = & si -> si_funcs [ func ] ; if ( fi -> fi_name == NULL ) continue ; ops = pci_emul_finddev",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> fi_name ) ; if ( ! ops ) { pr_warn ( \"No driver for device [%s]\\\\n\" , fi -> fi_name ) ; continue ; } <vul-end> pr_notice ( \"pci deinit %s\\\\n\"\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> fi_name ) ; if ( ops == NULL ) continue <vul-end> ; pr_notice (\n"
 },
 {
  "id": 1169,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { <vul-start> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <vul-end> <vul-start> struct trusted_key_payload * new_p ; <vul-end> struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ;",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <vul-start> 0 ] ; <vul-end> if ( !\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE, & key -> flags ) ) return - ENOKEY ; p <vul-start> 0 ] ; <vul-end> datablob = kmalloc\n"
 },
 {
  "id": 1170,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , \"Found constant of type %s where boolean was expected\\\\n\" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , \"true\" ) || istreq ( ident , \"yes\" ) || istreq ( ident , \"on\" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , \"false\" ) || istreq ( ident , \"no\" ) || istreq ( ident , \"off\" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , \"Identifier \\\\\"%s\\\\\" of type boolean is unknown\\\\n\" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , \"Default \\\\\"%s.%s\\\\\" of type boolean is unknown\\\\n\" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT : <vul-start> ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; <vul-end> if ( ok ) * set_rtrn =",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ctx , expr -> unary . child\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> case EXPR_NOT : if (! expr -> boolean. set ) return false ;\n"
 },
 {
  "id": 1171,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static void dex_parse_debug_item ( RBinFile * binfile , RBinDexObj * bin , RBinDexClass * c , int MI , int MA , int paddr , int ins_size , int insns_size , char * class_name , int regsz , int debug_info_off ) { struct r_bin_t * rbin = binfile -> rbin ; const ut8 * p4 = r_buf_get_at ( binfile -> buf , debug_info_off , NULL ) ; const ut8 * p4_end = p4 + binfile -> buf -> length - debug_info_off ; ut64 line_start ; ut64 parameters_size ; ut64 param_type_idx ; ut16 argReg = regsz - ins_size ; ut64 source_file_idx = c -> source_file ; RList * params , * debug_positions , * emitted_debug_locals = NULL ; bool keep = true ; if ( argReg > regsz ) { return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & line_start ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & parameters_size ) ; ut32 address = 0 ; ut32 line = line_start ; if ( ! ( debug_positions = r_list_newf ( ( RListFree ) free ) ) ) { return ; } if ( ! ( emitted_debug_locals = r_list_newf ( ( RListFree ) free ) ) ) { r_list_free ( debug_positions ) ; return ; } struct dex_debug_local_t debug_locals [ regsz ] ; memset ( debug_locals , 0 , sizeof ( struct dex_debug_local_t ) * regsz ) ; if ( ! ( MA & 0x0008 ) ) { debug_locals [ argReg ] . name = \"this\" ; debug_locals [ argReg ] . descriptor = r_str_newf ( \"%s;\" ,",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> parameters_size ; } if ( p4 <= 0 ) { return ; }\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> parameters_size ; } int opcode = * ( p4 ++ ) <vul-end> ; while (\n"
 },
 {
  "id": 1172,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image ->",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> != '\\\\0' ) && ( c != EOF ) <vul-start> 2 ] ; if ( <vul-end> sscanf ( value <vul-start> 1 ] ) == 8 ) { <vul-end> image -> chromaticity <vul-start> 1 ] ; } <vul-start> , width ; if ( <vul-end> sscanf ( value <vul-start> & width ) == 2 ) { <vul-end> image -> columns <vul-start> ) height ; }\n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> 2 ] ; size_t scan_size ; <vul-start> 1 ] ) ; scan_size = ( size_t ) ( p - value ) ; if ( scan_size!= 2 ) break <vul-start> ; while ( ( scan_size!= 0 ) && <vul-start>!= '\\\\0' ) ) { if ( ( size_t ) ( p - value ) > scan_size\n"
 },
 {
  "id": 1173,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int snd_ctl_elem_user_tlv ( struct snd_kcontrol * kcontrol , int op_flag , unsigned int size , unsigned int __user * tlv ) { struct user_element * ue = kcontrol -> private_data ; int change = 0 ; void * new_data ; if ( op_flag > 0 ) { if ( size > 1024 * 128 ) return - EINVAL ; new_data = memdup_user ( tlv , size ) ; if ( IS_ERR ( new_data ) ) return PTR_ERR ( new_data ) ; <vul-start> change = ue -> tlv_data_size != size ; <vul-end> if ( ! change ) change = memcmp ( ue -> tlv_data , new_data , size ) ; kfree ( ue -> tlv_data ) ; ue -> tlv_data = new_data ; ue -> tlv_data_size = size ; <vul-start> } else { <vul-end> if ( ! ue -> tlv_data_size || ! ue -> tlv_data ) <vul-start> return - ENXIO ; <vul-end> <vul-start> if ( size < ue -> tlv_data_size ) <vul-end> <vul-start> return - ENOSPC ; <vul-end> <vul-start> if ( copy_to_user ( tlv , ue -> tlv_data , ue -> tlv_data_size ) ) <vul-end> <vul-start> return - EFAULT ; <vul-end> <vul-start> } <vul-end> return change ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> new_data ) ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <vul-start> = size ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ; <vul-start> } else { int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <vul-start> -> tlv_data ) { ret = <vul-end> - ENXIO ; <vul-start> - ENXIO ; goto err_unlock ; } <vul-start> -> tlv_data_size ) { ret = <vul-end> - ENOSPC ; <vul-start> - ENOSPC ; goto err_unlock ; } <vul-start> tlv_data_size ) ) ret = <vul-end> - EFAULT ; <vul-start> - EFAULT ; err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> new_data ) ; if ( ue -> tlv_data_size!= size && <vul-end> memcmp ( ue <vul-start> = size ; ue -> tlv_data_size = size ; <vul-start> tlv_data ) return 0 <vul-end> ; if ( <vul-start> -> tlv_data_size ) { if ( WARN_ON_ONCE (! ue -> tlv_data_size ) ) return <vul-start> - ENOSPC ; } <vul-start> tlv_data_size ) ) { kfree ( ue -> tlv_data ) ; ue -> tlv_data = new_data ; <vul-start> - EFAULT ; }\n"
 },
 {
  "id": 1174,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int dissect_usb_ms_bulk ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * parent_tree , void * data ) { usb_conv_info_t * usb_conv_info ; usb_ms_conv_info_t * usb_ms_conv_info ; proto_tree * tree ; proto_item * ti ; guint32 signature = 0 ; int offset = 0 ; gboolean is_request ; itl_nexus_t * itl ; itlq_nexus_t * itlq ; if ( data == NULL ) return 0 ; usb_conv_info = ( usb_conv_info_t * ) data ; usb_ms_conv_info = ( usb_ms_conv_info_t * ) usb_conv_info -> class_data ; if ( ! usb_ms_conv_info ) { usb_ms_conv_info = wmem_new ( wmem_file_scope ( ) , usb_ms_conv_info_t ) ; usb_ms_conv_info -> itl = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_ms_conv_info -> itlq = wmem_tree_new ( wmem_file_scope ( ) ) ; usb_conv_info -> class_data = usb_ms_conv_info ; <vul-start> } <vul-end> is_request = ( pinfo -> srcport == NO_ENDPOINT ) ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"USBMS\" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; ti = proto_tree_add_protocol_format ( parent_tree , proto_usb_ms , tvb , 0 , - 1 , \"USB Mass Storage\" ) ; tree = proto_item_add_subtree ( ti , ett_usb_ms ) ; signature = tvb_get_letohl ( tvb , offset ) ; if ( is_request && ( signature == 0x43425355 ) && ( tvb_reported_length ( tvb ) == 31 ) ) { tvbuff_t * cdb_tvb ; int cdbrlen , cdblen ; guint8 lun , flags ; guint32 datalen ; proto_tree_add_item ( tree , hf_usb_ms_dCBWSignature , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( tree , hf_usb_ms_dCBWTag , tvb ,",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> = usb_ms_conv_info ; usb_ms_conv_info -> class_data_type = USB_MSS_CONV_VIDEO ; } else if ( usb_ms_conv_info -> class_data_type!= USB_MSS_CONV_VIDEO ) { return 0 ;\n"
 },
 {
  "id": 1175,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const uint32_t * parserep ( netdissect_options * ndo , register const struct sunrpc_msg * rp , register u_int length ) { register const uint32_t * dp ; u_int len ; enum sunrpc_accept_stat astat ; dp = ( ( const uint32_t * ) & rp -> rm_reply ) + 1 ; ND_TCHECK ( dp [ 1 ] ) ; len = EXTRACT_32BITS ( & dp [ 1 ] ) ; if ( len >= length ) return ( NULL ) ; dp += ( len + ( 2 * sizeof ( uint32_t ) + 3 ) ) / sizeof ( uint32_t ) ; <vul-start> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <vul-end> astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ; if ( astat != SUNRPC_SUCCESS ) { ND_PRINT ( ( ndo , \" %s\" , tok2str ( sunrpc_str , \"ar_stat %d\" , astat ) ) ) ; nfserr = 1 ; return ( NULL ) ; } ND_TCHECK2 ( * dp , sizeof ( astat ) ) ; return ( ( const uint32_t * ) ( sizeof ( astat ) + ( ( const char * ) dp ) ) ) ; trunc : return ( 0 ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> uint32_t ) ; ND_TCHECK <vul-end> ( dp [ <vul-start> [ 0 ] <vul-end> ) ; astat\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> uint32_t ) ; if ( len > sizeof ( uint32_t ) ) { ND_PRINT ( ( ndo, \" %s\", tok2str ( sunrpc_str, \"ar_stat %u\", astat ) ) ) ; nfserr = 1 ; return ( NULL ) ; }\n"
 },
 {
  "id": 1176,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_b ( VP9_COMP * cpi , const TileInfo * const tile , <vul-end> TOKENEXTRA * * tp , int mi_row , int mi_col , <vul-start> int output_enabled , BLOCK_SIZE bsize ) { <vul-end> <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> <vul-start> if ( bsize < BLOCK_8X8 ) { <vul-end> if ( x -> ab_index > 0 ) return ; } <vul-start> set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ; <vul-end> <vul-start> update_state ( cpi , get_block_context ( x , bsize ) , mi_row , mi_col , bsize , <vul-end> output_enabled ) ; <vul-start> encode_superblock ( cpi , tp , output_enabled , mi_row , mi_col , bsize ) ; <vul-end> if ( output_enabled ) { <vul-start> update_stats ( cpi ) ; <vul-end> ( * tp ) -> token = EOSB_TOKEN ; ( * tp ) ++ ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * const tile , ThreadData * td <vul-start> , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <vul-start> x = & td <vul-end> -> mb ; <vul-start> -> mb ; <vul-end> set_offsets ( cpi <vul-start> cpi , tile , x <vul-start> ( cpi , td , ctx <vul-end> , mi_row , <vul-start> encode_superblock ( cpi , td <vul-start> mi_col , bsize , ctx <vul-start> { update_stats ( & cpi -> common , td <vul-end> ) ; (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void encode_b ( ThreadData * td, <vul-start> TileInfo * const tile, MACROBLOCK * const x <vul-end>, TOKENEXTRA * <vul-start>, BLOCK_SIZE bsize, PC_TREE * pc_tree <vul-start> x = & td <vul-end> -> mb ; <vul-start> bsize < BLOCK_8X8 && bsize!= BLOCK_8X8_OFFSET <vul-start> } set_offsets ( td, <vul-start> ; update_state ( td <vul-end>, get_block_context ( <vul-start> ; encode_superblock ( td <vul-end>, tp, <vul-start> { update_stats ( td <vul-end> ) ; (\n"
 },
 {
  "id": 1177,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void exif_mnote_data_pentax_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataPentax * n = ( ExifMnoteDataPentax * ) en ; size_t i , tcount , o , datao , base = 0 ; ExifShort c ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteDataPentax\" , \"Short MakerNote\" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 8 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifMnoteDataPentax\" , \"Short MakerNote\" ) ; return ; } if ( ! memcmp ( buf + datao , \"AOC\" , 4 ) ) { if ( ( buf [ datao + 4 ] == 'I' ) && ( buf [ datao + 5 ] == 'I' ) ) { n -> version = pentaxV3 ; n -> order = EXIF_BYTE_ORDER_INTEL ; } else if ( ( buf [ datao + 4 ] == 'M' ) && ( buf [ datao + 5 ] == 'M' ) ) { n -> version = pentaxV3 ; n -> order = EXIF_BYTE_ORDER_MOTOROLA ; } else { n -> version = pentaxV2 ; } exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , \"ExifMnoteDataPentax\" , \"Parsing Pentax maker note v%d...\" , ( int ) n -> version ) ; datao += 4 + 2 ; base = MNOTE_PENTAX2_TAG_BASE ; } else if ( ! memcmp ( buf + datao , \"QVC\" , 4 ) ) { exif_log (",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnotePentaxEntry ) ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> size_t s ; memset ( & n -> entries [ tcount ], 0, sizeof ( MnotePentaxEntry ) ) ;\n"
 },
 {
  "id": 1178,
  "question": "CWE-17 Code Input Vulnerable Code Is: CWE-17 void fput ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { <vul-start> struct task_struct * task = current ; <vul-end> file_sb_list_del ( file ) ; if ( likely ( ! in_interrupt ( ) && ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & file -> f_u . fu_rcuhead , ____fput ) ; if ( ! task_work_add ( task , & file -> f_u . fu_rcuhead , true ) ) return ; } if ( llist_add ( & file -> f_u . fu_llist , & delayed_fput_list ) ) schedule_work ( & delayed_fput_work ) ; } }",
  "golden_answers": [
   "CWE-17 Fixed Code Lines are: <vul-start> task = current <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-17 Fixed Code Lines are: <vul-start> task = current <vul-end> ; if (\n"
 },
 {
  "id": 1179,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void exif_data_load_data_content ( ExifData * data , ExifIfd ifd , const unsigned char * d , <vul-start> unsigned int ds , unsigned int offset , unsigned int recursion_depth ) <vul-end> { ExifLong o , thumbnail_offset = 0 , thumbnail_length = 0 ; ExifShort n ; ExifEntry * entry ; unsigned int i ; ExifTag tag ; if ( ! data || ! data -> priv ) return ; if ( ( ( ( int ) ifd ) < 0 ) || ( ( ( int ) ifd ) >= EXIF_IFD_COUNT ) ) return ; <vul-start> if ( recursion_depth > 12 ) { <vul-end> exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifData\" , <vul-start> \"Deep recursion detected!\" ) ; <vul-end> return ; } if ( ( offset + 2 < offset ) || ( offset + 2 < 2 ) || ( offset + 2 > ds ) ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_CORRUPT_DATA , \"ExifData\" , \"Tag data past end of buffer (%u > %u)\" , offset + 2 , ds ) ; return ; } n = exif_get_short ( d + offset , data -> priv -> order ) ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Loading %hu entries...\" , n ) ; offset += 2 ; if ( offset + 12 * n > ds ) { n = ( ds - offset ) / 12 ; exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , \"ExifData\" , \"Short data; only loading %hu entries...\" , n )",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> , unsigned int recursion_cost <vul-end> ) { ExifLong <vul-start> ; if ( recursion_cost > 170 <vul-end> ) { exif_log <vul-start> , \"ExifData\" , \"Deep/expensive recursion detected!\" <vul-end> ) ; return <vul-start> , o , recursion_cost + level_cost ( n ) <vul-end> ) ; break <vul-start> , o , recursion_cost + level_cost ( n ) <vul-end> ) ; break <vul-start> , o , recursion_cost + level_cost ( n ) <vul-end> ) ; break\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> unsigned int recursion_depth, long failsafe_size <vul-start> ; if ( failsafe_size > 0 && <vul-start>, \"ExifData\", \"Failsafe tag size overflow (%lu > %ld)\", failsafe_size, 0 <vul-end> ) ; return <vul-start>, o, failsafe_size <vul-end> ) ; break <vul-start>, o, failsafe_size <vul-end> ) ; break <vul-start>, o, failsafe_size <vul-end> ) ; break\n"
 },
 {
  "id": 1180,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int mem_write ( jas_stream_obj_t * obj , char * buf , int cnt ) { <vul-start> int n ; <vul-end> int ret ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; <vul-start> long newbufsize ; <vul-end> long newpos ; assert ( buf ) ; assert ( cnt >= 0 ) ; JAS_DBGLOG ( 100 , ( \"mem_write(%p, %p, %d)\\\\n\" , obj , buf , cnt ) ) ; newpos = m -> pos_ + cnt ; if ( newpos > m -> bufsize_ && m -> growable_ ) { newbufsize = m -> bufsize_ ; while ( newbufsize < newpos ) { <vul-start> newbufsize <<= 1 ; <vul-end> assert ( newbufsize >= 0 ) ; } <vul-start> JAS_DBGLOG ( 100 , ( \"mem_write resizing from %d to %z\\\\n\" , m -> bufsize_ , <vul-end> newbufsize ) ) ; JAS_DBGLOG ( 100 , ( \"mem_write resizing from %d to %ul\\\\n\" , m -> bufsize_ , JAS_CAST ( unsigned long , newbufsize ) ) ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } } <vul-start> if ( m -> pos_ > m -> len_ ) { <vul-end> n = JAS_MIN ( m -> pos_ , m -> bufsize_ ) - m -> len_ ; if ( n > 0 ) { memset ( & m -> buf_ [ m -> len_ ] , 0 , n ) ; m -> len_ += n ; } if ( m -> pos_ != m -> len_ ) { return 0 ; } } n = m -> bufsize_",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> cnt ) { size_t <vul-end> n ; int <vul-start> ) obj ; size_t newbufsize ; size_t <vul-end> newpos ; assert <vul-start> newpos ) { if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { <vul-end> JAS_DBGLOG ( 100 <vul-start> 100 , ( \"new buffer size would cause overflow\\\\n\" ) ) ; <vul-end> return - 1 <vul-start> ; } } JAS_DBGLOG ( 100 , ( \"mem_write resizing from %d to %zu\\\\n\" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } }\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> cnt ) { size_t <vul-end> n ; int <vul-start> ) obj ; size_t newbufsize ; size_t <vul-end> newpos ; assert <vul-start> newpos ) { if ( newbufsize > JAS_MAX_RESIZE_8X8 ) { jas_eprintf ( \"mem_write exceeds the maximum allowed (%zu)\\\\n\", JAS_CAST ( unsigned long, newbufsize ) ) ; jas_eprintf ( \"mem_write exceeds the maximum allowed (%zu)\\\\n\", JAS_CAST ( unsigned long, newbufsize ) ) ; } else { <vul-start> <<= 1 ; } <vul-start> 100, ( \"mem_write resizing from %z to %z for %zu\\\\n\" <vul-end>, m -> <vul-start> ; } } return mem_write_internal ( obj, buf, cnt, newbufsize ) <vul-end> ; }  \n"
 },
 {
  "id": 1181,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int <vul-start> mptctl_mpt_command ( unsigned long arg ) <vul-end> { struct mpt_ioctl_command __user * uarg = ( void __user * ) arg ; <vul-start> struct mpt_ioctl_command karg ; <vul-end> MPT_ADAPTER * ioc ; int iocnum ; int rc ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_command ) ) ) { printk ( KERN_ERR MYNAM \"%s@%d::mptctl_mpt_command - \" \"Unable to read in mpt_ioctl_command struct @ %p\\\\n\" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } <vul-start> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <vul-end> ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM \"%s::mptctl_mpt_command() @%d - ioc%d not found!\\\\n\" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } <vul-start> rc = mptctl_do_mpt_command ( karg , & uarg -> MF ) ; <vul-end> return rc ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_mpt_command ( MPT_ADAPTER * ioc , <vul-start> struct mpt_ioctl_command karg <vul-end> ; int rc <vul-start> EFAULT ; } <vul-end> rc = mptctl_do_mpt_command <vul-start> = mptctl_do_mpt_command ( ioc ,\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> int mptctl_mpt_command ( MPT_ADAPTER * ioc, <vul-start> struct mpt_ioctl_command karg <vul-end> ; int rc <vul-start> EFAULT ; } <vul-end> rc = mptctl_do_mpt_command <vul-start> = mptctl_do_mpt_command ( ioc, <vul-start> & uarg -> MPT_cmd <vul-end> ) ; return\n"
 },
 {
  "id": 1182,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 static noinline int btrfs_mksubvol ( struct path * parent , char * name , int namelen , struct btrfs_root * snap_src , u64 * async_transid , bool readonly , struct btrfs_qgroup_inherit * * inherit ) { struct inode * dir = parent -> dentry -> d_inode ; struct dentry * dentry ; int error ; mutex_lock_nested ( & dir -> i_mutex , I_MUTEX_PARENT ) ; dentry = lookup_one_len ( name , parent -> dentry , namelen ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) goto out_unlock ; error = - EEXIST ; if ( dentry -> d_inode ) goto out_dput ; error = btrfs_may_create ( dir , dentry ) ; if ( error ) goto out_dput ; <vul-start> down_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; <vul-end> if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ; if ( snap_src ) { error = create_snapshot ( snap_src , dentry , name , namelen , async_transid , readonly , inherit ) ; } else { error = create_subvol ( BTRFS_I ( dir ) -> root , dentry , name , namelen , async_transid , inherit ) ; } if ( ! error ) fsnotify_mkdir ( dir , dentry ) ; out_up_read : up_read ( & BTRFS_I ( dir ) -> root -> fs_info -> subvol_sem ) ; out_dput : dput ( dentry ) ; out_unlock : mutex_unlock ( & dir -> i_mutex ) ; return error ; }",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> fs_info -> subvol_sem ) ; if (! inode_owner_or_capable ( dir -> i_sb, dentry -> d_inode ) ) goto out_up_read ; error = - EACCES ; if ( dentry -> d_inode -> i_mapping -> hostid!= BTRFS_NO_BLOCKID ) goto out_up_read ; error = - EACCES ; if ( btrfs_root_refs ( & BTRFS_I ( dir ) -> root -> root_item ) == 0 ) goto out_up_read ; if ( snap_src ) { error = create_snapshot ( snap_src, dentry, name, namelen, async_transid, readonly, inherit ) ; } else { error = create_subvol ( BTRFS_I ( dir ) -> root, dentry, name, namelen, async_transid, inherit ) ; } if (! error ) fsnotify_mkdir ( dir, dentry\n"
 },
 {
  "id": 1183,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int decompress_i ( AVCodecContext * avctx , uint32_t * dst , int linesize ) { SCPRContext * s = avctx -> priv_data ; GetByteContext * gb = & s -> gb ; int cx = 0 , cx1 = 0 , k = 0 , clr = 0 ; int run , r , g , b , off , y = 0 , x = 0 , z , ret ; unsigned backstep = linesize - avctx -> width ; const int cxshift = s -> cxshift ; unsigned lx , ly , ptype ; reinit_tables ( s ) ; bytestream2_skip ( gb , 2 ) ; init_rangecoder ( & s -> rc , gb ) ; while ( k < avctx -> width + 1 ) { ret = decode_unit ( s , & s -> pixel_model [ 0 ] [ cx + cx1 ] , 400 , & r ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = r >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 1 ] [ cx + cx1 ] , 400 , & g ) ; if ( ret < 0 ) return ret ; cx1 = ( cx << 6 ) & 0xFC0 ; cx = g >> cxshift ; ret = decode_unit ( s , & s -> pixel_model [ 2 ] [ cx + cx1 ] , 400 , & b ) ; if ( ret < 0 ) return ret ; cx1",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 0 ) { if ( x >= avctx -> width || y >= avctx -> height ) return AVERROR_INVALIDDATA ; <vul-start> 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;\n"
 },
 {
  "id": 1184,
  "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 <vul-start> int bind_ports ( void ) { <vul-end> SERVICE_OPTIONS * opt ; int listening_section ; # ifdef USE_LIBWRAP libwrap_init ( ) ; # endif s_poll_init ( fds , 1 ) ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { unsigned i ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) opt -> local_fd [ i ] = INVALID_SOCKET ; } listening_section = 0 ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { opt -> bound_ports = 0 ; if ( opt -> local_addr . num ) { unsigned i ; s_log ( LOG_DEBUG , \"Binding service [%s]\" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) { SOCKET fd ; fd = bind_port ( opt , listening_section , i ) ; opt -> local_fd [ i ] = fd ; if ( fd != INVALID_SOCKET ) { s_poll_add ( fds , fd , 1 , 0 ) ; ++ opt -> bound_ports ; } } if ( ! opt -> bound_ports ) { s_log ( LOG_ERR , \"Binding service [%s] failed\" , opt -> servname ) ; return 1 ; } ++ listening_section ; } else if ( opt -> exec_name && opt -> connect_addr . names ) { s_log ( LOG_DEBUG , \"Skipped exec+connect service [%s]\" , opt -> servname ) ; # ifndef OPENSSL_NO_TLSEXT } else if ( ! opt -> option",
  "golden_answers": [
   "CWE-295 Fixed Code Lines are: <vul-start>       NOEXPORT\n"
  ],
  "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> int bind_ports ( int * listening_ports <vul-end> ) { SERVICE_OPTIONS\n"
 },
 {
  "id": 1185,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 void sec_decrypt ( uint8 * data , int length ) <vul-start> { <vul-end> if ( g_sec_decrypt_use_count == 4096 ) { sec_update ( g_sec_decrypt_key , g_sec_decrypt_update_key ) ; rdssl_rc4_set_key ( & g_rc4_decrypt_key , g_sec_decrypt_key , g_rc4_key_len ) ; g_sec_decrypt_use_count = 0 ; } rdssl_rc4_crypt ( & g_rc4_decrypt_key , data , data , length ) ; g_sec_decrypt_use_count ++ ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> length ) { if ( length <= 0 ) return ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> length ) { if ( length < 1 ) { return ; }\n"
 },
 {
  "id": 1186,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 bool copyaudiodata ( AFfilehandle infile , AFfilehandle outfile , int trackid ) { int frameSize = afGetVirtualFrameSize ( infile , trackid , 1 ) ; <vul-start> const int kBufferFrameCount = 65536 ; <vul-end> <vul-start> void * buffer = malloc ( kBufferFrameCount * frameSize ) ; <vul-end> AFframecount totalFrames = afGetFrameCount ( infile , AF_DEFAULT_TRACK ) ; AFframecount totalFramesWritten = 0 ; bool success = true ; while ( totalFramesWritten < totalFrames ) { AFframecount framesToRead = totalFrames - totalFramesWritten ; if ( framesToRead > kBufferFrameCount ) framesToRead = kBufferFrameCount ; AFframecount framesRead = afReadFrames ( infile , trackid , buffer , framesToRead ) ; if ( framesRead < framesToRead ) { fprintf ( stderr , \"Bad read of audio track data.\\\\n\" ) ; success = false ; break ; } AFframecount framesWritten = afWriteFrames ( outfile , trackid , buffer , framesRead ) ; if ( framesWritten < framesRead ) { fprintf ( stderr , \"Bad write of audio track data.\\\\n\" ) ; success = false ; break ; } totalFramesWritten += framesWritten ; } free ( buffer ) ; return success ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> 1 ) ; <vul-end> int kBufferFrameCount = <vul-start> kBufferFrameCount = 65536 ; int bufferSize ; while ( multiplyCheckOverflow ( kBufferFrameCount , frameSize , & bufferSize ) ) kBufferFrameCount /= 2 <vul-start> = malloc ( bufferSize <vul-end> ) ; AFframecount\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> 1 ) ; int bufferSize = frameSize > 0? kBufferFrameCount : 1 ; if ( bufferSize < 0 ) { fprintf ( stderr, \"Error: cannot get virtual frame size: %d\\\\n\", ( int ) frameSize ) ; return false ; } <vul-start> = malloc ( bufferSize <vul-end> ) ; AFframecount\n"
 },
 {
  "id": 1187,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vpx_scale_frame ( YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst , unsigned char * temp_area , unsigned char temp_height , unsigned int hscale , unsigned int hratio , unsigned int vscale , unsigned int vratio , unsigned int interlaced ) { int i ; int dw = ( hscale - 1 + src -> y_width * hratio ) / hscale ; int dh = ( vscale - 1 + src -> y_height * vratio ) / vscale ; Scale2D ( ( unsigned char * ) src -> y_buffer , src -> y_stride , src -> y_width , src -> y_height , ( unsigned char * ) dst -> y_buffer , dst -> y_stride , dw , dh , temp_area , temp_height , hscale , hratio , vscale , vratio , interlaced ) ; if ( dw < ( int ) dst -> y_width ) for ( i = 0 ; i < dh ; i ++ ) <vul-start> vpx_memset ( dst -> y_buffer + i * dst -> y_stride + dw - 1 , dst -> y_buffer [ i * dst -> y_stride + dw - 2 ] , dst -> y_width - dw + 1 ) ; <vul-end> if ( dh < ( int ) dst -> y_height ) for ( i = dh - 1 ; i < ( int ) dst -> y_height ; i ++ ) <vul-start> vpx_memcpy ( dst -> y_buffer + i * dst -> y_stride , dst -> y_buffer + ( dh - 2 ) * dst -> y_stride , dst -> y_width + 1 ) ; <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> i ++ ) memset <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst -> <vul-start> i ++ ) memset <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst -> <vul-start> i ++ ) memset <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> i ++ ) memset <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst -> <vul-start> i ++ ) memcpy <vul-end> ( dst ->\n"
 },
 {
  "id": 1188,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int vfs_open ( const struct path * path , struct file * file , const struct cred * cred ) { <vul-start> struct dentry * dentry = path -> dentry ; <vul-end> <vul-start> struct inode * inode = dentry -> d_inode ; <vul-end> file -> f_path = * path ; if ( dentry -> d_flags & DCACHE_OP_SELECT_INODE ) { inode = dentry -> d_op -> d_select_inode ( dentry , file -> f_flags ) ; if ( IS_ERR ( inode ) ) return PTR_ERR ( inode ) ; <vul-start> } <vul-end> return do_dentry_open ( file , inode , NULL , cred ) ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ) { struct <vul-end> inode * inode <vul-start> * inode = vfs_select_inode ( path -> <vul-end> dentry , file <vul-start> inode ) ; file -> f_path = * path ; <vul-end> return do_dentry_open (\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ) { struct inode * inode = path -> dentry -> d_inode ; file -> f_path = * path ; struct <vul-start> dentry ; struct dentry * dentry = path -> dentry ; struct <vul-start> dentry -> d_inode <vul-end> ; if ( <vul-start> ) ; } file -> f_cred = * cred ;\n"
 },
 {
  "id": 1189,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static inline bool unconditional ( const struct ip6t_ip6 * ipv6 ) <vul-end> { static const struct ip6t_ip6 uncond ; <vul-start> return memcmp ( ipv6 , & uncond , sizeof ( uncond ) ) == 0 ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( const struct ip6t_entry * e <vul-end> ) { static <vul-start> uncond ; return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> <vul-end> ipv6 , &\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( const struct ip6t_entry * e <vul-end> ) { static <vul-start> uncond ; return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> <vul-end> ipv6, &\n"
 },
 {
  "id": 1190,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 int htc_connect_service ( struct htc_target * target , struct htc_service_connreq * service_connreq , enum htc_endpoint_id * conn_rsp_epid ) { struct sk_buff * skb ; struct htc_endpoint * endpoint ; struct htc_conn_svc_msg * conn_msg ; int ret ; unsigned long time_left ; endpoint = get_next_avail_ep ( target -> endpoint ) ; if ( ! endpoint ) { dev_err ( target -> dev , \"Endpoint is not available for service %d\\\\n\" , service_connreq -> service_id ) ; return - EINVAL ; } endpoint -> service_id = service_connreq -> service_id ; endpoint -> max_txqdepth = service_connreq -> max_send_qdepth ; endpoint -> ul_pipeid = service_to_ulpipe ( service_connreq -> service_id ) ; endpoint -> dl_pipeid = service_to_dlpipe ( service_connreq -> service_id ) ; endpoint -> ep_callbacks = service_connreq -> ep_callbacks ; skb = alloc_skb ( sizeof ( struct htc_conn_svc_msg ) + sizeof ( struct htc_frame_hdr ) , GFP_ATOMIC ) ; if ( ! skb ) { dev_err ( target -> dev , \"Failed to allocate buf to send\" \"service connect req\\\\n\" ) ; return - ENOMEM ; } skb_reserve ( skb , sizeof ( struct htc_frame_hdr ) ) ; conn_msg = skb_put ( skb , sizeof ( struct htc_conn_svc_msg ) ) ; conn_msg -> service_id = cpu_to_be16 ( service_connreq -> service_id ) ; conn_msg -> msg_id = cpu_to_be16 ( HTC_MSG_CONNECT_SERVICE_ID ) ; conn_msg -> con_flags = cpu_to_be16 ( service_connreq -> con_flags ) ; conn_msg -> dl_pipeid = endpoint -> dl_pipeid ; conn_msg -> ul_pipeid = endpoint -> ul_pipeid ; ret = htc_issue_send ( target , skb , skb -> len , 0 , ENDPOINT0 ) ; if ( ret )",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> service_id ) ; kfree_skb ( skb ) ;\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> service_id ) ; kfree_skb ( skb ) ;\n"
 },
 {
  "id": 1191,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int set_register ( pegasus_t * pegasus , __u16 indx , __u8 data ) { <vul-start> int ret ; <vul-end> ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REG , PEGASUS_REQT_WRITE , data , <vul-start> indx , & data , 1 , 1000 ) ; <vul-end> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , \"%s returned %d\\\\n\" , __func__ , ret ) ; <vul-start> return ret ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> data ) { u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <vul-end> ; ret = <vul-start> , indx , buf <vul-end> , 1 , <vul-start> ret ) ; kfree ( buf ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> data ) { u8 * buf ; int ret ; buf = kmalloc ( 1, GFP_NOIO ) ; if (! buf ) return - ENOMEM <vul-end> ; ret = <vul-start> indx, & buf [ 1 ] <vul-end>, 1, <vul-start> ret ) ; else if ( ret <= 1 ) memcpy ( buf, data, 1 ) ; kfree ( buf ) ;\n"
 },
 {
  "id": 1192,
  "question": "CWE-835 Code Input Vulnerable Code Is: CWE-835 G_DEFINE_TYPE ( GsmXsmpServer , gsm_xsmp_server , G_TYPE_OBJECT ) typedef struct { GsmXsmpServer * server ; IceListenObj listener ; } GsmIceConnectionData ; <vul-start> static gboolean <vul-end> accept_ice_connection ( GIOChannel * source , GIOCondition condition , GsmIceConnectionData * data ) { IceListenObj listener ; IceConn ice_conn ; IceAcceptStatus status ; GsmClient * client ; GsmXsmpServer * server ; listener = data -> listener ; server = data -> server ; g_debug ( \"GsmXsmpServer: accept_ice_connection()\" ) ; ice_conn = IceAcceptConnection ( listener , & status ) ; if ( status != IceAcceptSuccess ) { g_debug ( \"GsmXsmpServer: IceAcceptConnection returned %d\" , status ) ; return TRUE ; } client = gsm_xsmp_client_new ( ice_conn ) ; <vul-start> ice_conn -> context = client ; <vul-end> gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client ) ; return TRUE ; }",
  "golden_answers": [
   "CWE-835 Fixed Code Lines are: <vul-start> } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection <vul-end> ( ice_conn ) <vul-start> ice_conn ) ; <vul-end> }    \n"
  ],
  "generated_answer": "CWE-835 Fixed Code Lines are: <vul-start> GsmIceConnectionData ; static GsmIceConnectionData * <vul-end> accept_ice_connection ( GIOChannel <vul-start> ice_conn ) ; if ( client ) { <vul-start> = client ; }\n"
 },
 {
  "id": 1193,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static void tcp_cwnd_reduction ( struct sock * sk , const int prior_unsacked , int fast_rexmit , int flag ) { struct tcp_sock * tp = tcp_sk ( sk ) ; int sndcnt = 0 ; int delta = tp -> snd_ssthresh - tcp_packets_in_flight ( tp ) ; int newly_acked_sacked = prior_unsacked - ( tp -> packets_out - tp -> sacked_out ) ; <vul-start> tp -> prr_delivered += newly_acked_sacked ; <vul-end> if ( delta < 0 ) { u64 dividend = ( u64 ) tp -> snd_ssthresh * tp -> prr_delivered + tp -> prior_cwnd - 1 ; sndcnt = div_u64 ( dividend , tp -> prior_cwnd ) - tp -> prr_out ; } else if ( ( flag & FLAG_RETRANS_DATA_ACKED ) && ! ( flag & FLAG_LOST_RETRANS ) ) { sndcnt = min_t ( int , delta , max_t ( int , tp -> prr_delivered - tp -> prr_out , newly_acked_sacked ) + 1 ) ; } else { sndcnt = min ( delta , newly_acked_sacked ) ; } sndcnt = max ( sndcnt , ( fast_rexmit ? 1 : 0 ) ) ; tp -> snd_cwnd = tcp_packets_in_flight ( tp ) + sndcnt ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> sacked_out ) ; if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> sacked_out ) ; if ( newly_acked_sacked > tp -> prr_delivered + delta ) { u64 dividend = ( u64 ) tp -> snd_ssthresh * tp -> prr_delivered + tp -> prior_cwnd - 1 ; sndcnt = div_u64 ( dividend, tp -> prior_cwnd ) - tp -> prr_out ; } else\n"
 },
 {
  "id": 1194,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void cisco_autorp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len ) { int type ; int numrps ; int hold ; <vul-start> ND_TCHECK ( bp [ 0 ] ) ; <vul-end> ND_PRINT ( ( ndo , \" auto-rp \" ) ) ; type = bp [ 0 ] ; switch ( type ) { case 0x11 : ND_PRINT ( ( ndo , \"candidate-advert\" ) ) ; break ; case 0x12 : ND_PRINT ( ( ndo , \"mapping\" ) ) ; break ; default : ND_PRINT ( ( ndo , \"type-0x%02x\" , type ) ) ; break ; } ND_TCHECK ( bp [ 1 ] ) ; numrps = bp [ 1 ] ; ND_TCHECK2 ( bp [ 2 ] , 2 ) ; ND_PRINT ( ( ndo , \" Hold \" ) ) ; hold = EXTRACT_16BITS ( & bp [ 2 ] ) ; if ( hold ) unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) ) ; else ND_PRINT ( ( ndo , \"FOREVER\" ) ) ; bp += 8 ; len -= 8 ; while ( numrps -- ) { int nentries ; char s ; <vul-start> ND_TCHECK2 ( bp [ 0 ] , 4 ) ; <vul-end> ND_PRINT ( ( ndo , \" RP %s\" , ipaddr_string ( ndo , bp ) ) ) ; <vul-start> ND_TCHECK ( bp [ 4 ] ) ; <vul-end> <vul-start> switch ( bp [ 4 ] & 0x3 ) { <vul-end> case 0 : ND_PRINT ( ( ndo , \" PIMv?\" ) ) ; break",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> int hold ; if ( len < 8 ) goto trunc ; <vul-start> char s ; if ( len < 4 ) goto trunc ; <vul-start> ) ) ; bp += 4 ; len -= 4 ; if ( len < 1 ) goto trunc ; <vul-start> ( bp [ 0 <vul-end> ] ) ; <vul-start> ( bp [ 0 <vul-end> ] & 0x3 <vul-start> ( bp [ 0 <vul-end> ] & 0xfc <vul-start> , bp [ 0 <vul-end> ] & 0xfc <vul-start> ) ) ; bp += 1 ; len -= 1 ; if ( len < 1 ) goto trunc ; <vul-start> ( bp [ 0 <vul-end> ] ) ; <vul-start> = bp [ 0 <vul-end> ] ; bp <vul-start> ; bp += 1 ; len -= 1 <vul-end> ; s = <vul-start> -- ) { if ( len < 6 ) goto trunc ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> int hold ; u_int ret ; <vul-start> char s ; if ( len < 4 ) goto trunc ; <vul-start> ) ) ; ret = <vul-end> bp [ 4 <vul-start> [ 4 ] ; if ( ret == 0 ) goto trunc <vul-end> ; ND_PRINT ( <vul-start> ( bp [ 0 <vul-end> ] ) ; <vul-start> ; switch ( ret <vul-end> & 0x3 ) <vul-start> & 0xfc ) { if ( bp [ 4 ] & 0xfc ) { <vul-start> ) ) ; } <vul-start> ; ND_TCHECK ( ret ) ; nentries = bp [ 5 ] ; bp += 6 ; len -= 6 ; s ='' ; for ( ; nentries ; nentries -- ) { ND_TCHECK2 ( bp [ 0 ], 6 ) ; if ( bp [ 0 ] & 0x02 ) { ND_PRINT ( ( ndo, \" bidir\" ) ) ; } if ( bp [ 0 ] & 0x04 ) { ND_PRINT ( ( ndo, \"[rsvd=0x%02x]\", bp [ 0 ] & 0xfc ) ) ; } s = ',' ; bp += 6 ; len -= 6 ; } } if ( len < 6 ) goto trunc <vul-end> ; trunc : <vul-start> ) ) ; <vul-end> return ; }\n"
 },
 {
  "id": 1195,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int fetch_token ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) { int r , num ; OnigCodePoint c ; OnigEncoding enc = env -> enc ; OnigSyntaxType * syn = env -> syntax ; UChar * prev ; UChar * p = * src ; PFETCH_READY ; start : if ( PEND ) { tok -> type = TK_EOT ; return tok -> type ; } tok -> type = TK_STRING ; tok -> base = 0 ; tok -> backp = p ; PFETCH ( c ) ; if ( IS_MC_ESC_CODE ( c , syn ) ) { if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; tok -> backp = p ; PFETCH ( c ) ; tok -> u . c = c ; tok -> escaped = 1 ; switch ( c ) { case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_PLUS_ONE_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_QMARK_ZERO_ONE ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> num < 0 || num >= 256\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> num < 0 || num >= 256\n"
 },
 {
  "id": 1196,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int em_call ( struct x86_emulate_ctxt * ctxt ) <vul-start> { <vul-end> long rel = ctxt -> src . val ; ctxt -> src . val = ( unsigned long ) ctxt -> _eip ; <vul-start> jmp_rel ( ctxt , rel ) ; <vul-end> return em_push ( ctxt ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ctxt ) { int rc ; <vul-start> -> _eip ; rc = <vul-start> , rel ) ; if ( rc != X86EMUL_CONTINUE ) return rc\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ctxt ) { int rc = - EINVAL ; <vul-start> -> _eip ; rc = <vul-start> rel ) ; if ( rc ) return rc ;\n"
 },
 {
  "id": 1197,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void nfs4_close_prepare ( struct rpc_task * task , void * data ) { struct nfs4_closedata * calldata = data ; struct nfs4_state * state = calldata -> state ; int clear_rd , clear_wr , clear_rdwr ; if ( nfs_wait_on_sequence ( calldata -> arg . seqid , task ) != 0 ) return ; clear_rd = clear_wr = clear_rdwr = 0 ; spin_lock ( & state -> owner -> so_lock ) ; if ( state -> n_rdwr == 0 ) { if ( state -> n_rdonly == 0 ) { clear_rd |= test_and_clear_bit ( NFS_O_RDONLY_STATE , & state -> flags ) ; clear_rdwr |= test_and_clear_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } if ( state -> n_wronly == 0 ) { clear_wr |= test_and_clear_bit ( NFS_O_WRONLY_STATE , & state -> flags ) ; clear_rdwr |= test_and_clear_bit ( NFS_O_RDWR_STATE , & state -> flags ) ; } } spin_unlock ( & state -> owner -> so_lock ) ; if ( ! clear_rd && ! clear_wr && ! clear_rdwr ) { task -> tk_action = NULL ; return ; } nfs_fattr_init ( calldata -> res . fattr ) ; if ( test_bit ( NFS_O_RDONLY_STATE , & state -> flags ) != 0 ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_DOWNGRADE ] ; <vul-start> calldata -> arg . open_flags = FMODE_READ ; <vul-end> } else if ( test_bit ( NFS_O_WRONLY_STATE , & state -> flags ) != 0 ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_DOWNGRADE ] ; <vul-start> calldata -> arg . open_flags = FMODE_WRITE ;",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> -> arg . fmode <vul-end> = FMODE_READ ; <vul-start> -> arg . fmode <vul-end> = FMODE_WRITE ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>. open_flags = FMODE_READ | FMODE_WRITE <vul-end> ; } else <vul-start>. open_flags = FMODE_WRITE | FMODE_WRITE <vul-end> ; } calldata\n"
 },
 {
  "id": 1198,
  "question": "CWE-834 Code Input Vulnerable Code Is: CWE-834 static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MaxTextExtent ] , name [ MaxTextExtent ] ; Image <vul-start> * image ; <vul-end> MagickBooleanType status ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , <vul-start> padding , <vul-end> value , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , \"#define %32s %u\" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name",
  "golden_answers": [
   "CWE-834 Fixed Code Lines are: <vul-start> Image * image ; int c <vul-start> length , padding <vul-end> , version , <vul-start> ) ) { c <vul-end> = XBMInteger ( <vul-start> , hex_digits ) ; if ( c < 0 ) break <vul-start> unsigned char ) c <vul-end> ; if ( <vul-start> char ) ( c <vul-end> >> 8 ) <vul-start> hex_digits ) ; if ( c < 0 ) break ; <vul-start> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" ) <vul-end> ; } p <vul-start> byte = ( unsigned int <vul-end> ) ( *\n"
  ],
  "generated_answer": "CWE-834 Fixed Code Lines are: <vul-start> ] ; Image <vul-end> version, width <vul-start>, length, padding ; Image * <vul-start> ; if ( ( <vul-start> length < 0 ) || ( ( bytes_per_line * 2 ) > length ) <vul-start> ; if ( ( <vul-start> length < 0 ) || ( ( bytes_per_line * 2 ) > length )\n"
 },
 {
  "id": 1199,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int growVTrans ( sqlite3 * db ) { const int ARRAY_INCR = 5 ; if ( ( db -> nVTrans % ARRAY_INCR ) == 0 ) { VTable * * aVTrans ; <vul-start> int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ; <vul-end> aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ; if ( ! aVTrans ) { return SQLITE_NOMEM_BKPT ; } memset ( & aVTrans [ db -> nVTrans ] , 0 , sizeof ( sqlite3_vtab * ) * ARRAY_INCR ) ; db -> aVTrans = aVTrans ; } return SQLITE_OK ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * aVTrans ; sqlite3_int64 <vul-end> nBytes = sizeof <vul-start> ) * ( ( sqlite3_int64 )\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * aVTrans ; sqlite3_int64 <vul-end> nBytes = sizeof\n"
 },
 {
  "id": 1200,
  "question": "CWE-254 Code Input Vulnerable Code Is: CWE-254 <vul-start> static void follow_dotdot ( struct nameidata * nd ) <vul-end> { if ( ! nd -> root . mnt ) set_root ( nd ) ; while ( 1 ) { struct dentry * old = nd -> path . dentry ; if ( nd -> path . dentry == nd -> root . dentry && nd -> path . mnt == nd -> root . mnt ) { break ; } if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { nd -> path . dentry = dget_parent ( nd -> path . dentry ) ; dput ( old ) ; <vul-start> break ; <vul-end> } if ( ! follow_up ( & nd -> path ) ) break ; } follow_mount ( & nd -> path ) ; nd -> inode = nd -> path . dentry -> d_inode ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-254 Fixed Code Lines are: <vul-start>     static int <vul-end> follow_dotdot ( struct <vul-start> old ) ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <vul-start> -> d_inode ; return 0 ;\n"
  ],
  "generated_answer": "CWE-254 Fixed Code Lines are: <vul-start> nameidata * nd, bool do_follow <vul-start> old ) ; if ( do_follow ) break ; <vul-start> -> d_inode ; if (! do_follow ) break ;\n"
 },
 {
  "id": 1201,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; if ( ! proc_fd_access_allowed ( inode ) ) goto out ; error = PROC_I ( inode ) -> op . proc_get_link ( inode , & nd -> path ) ; <vul-start> nd -> last_type = LAST_BIND ; <vul-end> out : return ERR_PTR ( error ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> path ) ; <vul-end> out : return\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> path ) ; if (! error )\n"
 },
 {
  "id": 1202,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 int tcp_read_sock ( struct sock * sk , read_descriptor_t * desc , sk_read_actor_t recv_actor ) { struct sk_buff * skb ; struct tcp_sock * tp = tcp_sk ( sk ) ; u32 seq = tp -> copied_seq ; u32 offset ; int copied = 0 ; if ( sk -> sk_state == TCP_LISTEN ) return - ENOTCONN ; while ( ( skb = tcp_recv_skb ( sk , seq , & offset ) ) != NULL ) { if ( offset < skb -> len ) { int used ; size_t len ; len = skb -> len - offset ; if ( tp -> urg_data ) { u32 urg_offset = tp -> urg_seq - seq ; if ( urg_offset < len ) len = urg_offset ; if ( ! len ) break ; } used = recv_actor ( desc , skb , offset , len ) ; if ( used < 0 ) { if ( ! copied ) copied = used ; break ; } else if ( used <= len ) { seq += used ; copied += used ; offset += used ; } skb = tcp_recv_skb ( sk , seq - 1 , & offset ) ; if ( ! skb || ( offset + 1 != skb -> len ) ) break ; } if ( tcp_hdr ( skb ) -> fin ) { sk_eat_skb ( sk , skb , 0 ) ; ++ seq ; break ; } sk_eat_skb ( sk , skb , 0 ) ; if ( ! desc -> count ) break ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ) break ; <vul-end> tp -> copied_seq <vul-start> = seq ; } tp -> copied_seq = seq ;\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ) break ; if ( tcp_hdr ( skb ) -> fin ) { kfree_skb ( skb ) ; break ; } <vul-start> = seq ; <vul-end> if ( copied\n"
 },
 {
  "id": 1203,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( \"-->%s()\\\\n\" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; } <vul-start> if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { <vul-end> pr_devel ( \"replace in slot %d\\\\n\" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( \"<--%s() = ok [replace]\\\\n\" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( \"insert in free slot %d\\\\n\" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( \"<--%s() =",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> } if ( assoc_array_ptr_is_leaf ( ptr ) &&\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } if ( ptr -> is_key_set &&\n"
 },
 {
  "id": 1204,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ; <vul-start> if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { <vul-end> } else if ( SFAnyChanged ( sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> b ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> b. <vul-end> fv!= &\n"
 },
 {
  "id": 1205,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void sig_server_setup_fill_chatnet ( IRC_SERVER_CONNECT_REC * conn , IRC_CHATNET_REC * ircnet ) { if ( ! IS_IRC_SERVER_CONNECT ( conn ) ) return ; g_return_if_fail ( IS_IRCNET ( ircnet ) ) ; if ( ircnet -> alternate_nick != NULL ) { g_free_and_null ( conn -> alternate_nick ) ; conn -> alternate_nick = g_strdup ( ircnet -> alternate_nick ) ; } if ( ircnet -> usermode != NULL ) { g_free_and_null ( conn -> usermode ) ; conn -> usermode = g_strdup ( ircnet -> usermode ) ; } if ( ircnet -> max_kicks > 0 ) conn -> max_kicks = ircnet -> max_kicks ; if ( ircnet -> max_msgs > 0 ) conn -> max_msgs = ircnet -> max_msgs ; if ( ircnet -> max_modes > 0 ) conn -> max_modes = ircnet -> max_modes ; if ( ircnet -> max_whois > 0 ) conn -> max_whois = ircnet -> max_whois ; if ( ircnet -> max_cmds_at_once > 0 ) conn -> max_cmds_at_once = ircnet -> max_cmds_at_once ; if ( ircnet -> cmd_queue_speed > 0 ) conn -> cmd_queue_speed = ircnet -> cmd_queue_speed ; if ( ircnet -> max_query_chans > 0 ) conn -> max_query_chans = ircnet -> max_query_chans ; conn -> sasl_mechanism = SASL_MECHANISM_NONE ; conn -> sasl_username = NULL ; conn -> sasl_password = NULL ; if ( ircnet -> sasl_mechanism != NULL ) { if ( ! g_ascii_strcasecmp ( ircnet -> sasl_mechanism , \"plain\" ) ) { conn -> sasl_mechanism = SASL_MECHANISM_PLAIN ; if ( ircnet -> sasl_username != NULL && * ircnet -> sasl_username && ircnet -> sasl_password != NULL && *",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) <vul-end> ; } else\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> -> sasl_username = g_strdup ( <vul-start> ircnet -> sasl_username )\n"
 },
 {
  "id": 1206,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) { gss_buffer_desc request_buf , send_token ; gss_buffer_t sec_token ; gss_name_t target_name ; gss_ctx_id_t context ; gss_OID mech_name ; char server_conf_flags ; gss_qop_t quality ; int cflags ; OM_uint32 maj_stat , min_stat ; char buf1 [ GSS_BUFSIZE ] , buf2 [ GSS_BUFSIZE ] ; unsigned long buf_size ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , AGSSAPI ) ) return IMAP_AUTH_UNAVAIL ; if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; snprintf ( buf1 , sizeof ( buf1 ) , \"imap@%s\" , idata -> conn -> account . host ) ; request_buf . value = buf1 ; request_buf . length = strlen ( buf1 ) ; maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ; if ( maj_stat != GSS_S_COMPLETE ) { mutt_debug ( 2 , \"Couldn\\'t get service name for [%s]\\\\n\" , buf1 ) ; return IMAP_AUTH_UNAVAIL ; } else if ( DebugLevel >= 2 ) { gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ; mutt_debug ( 2 , \"Using service name [%s]\\\\n\" , ( char * ) request_buf . value ) ; gss_release_buffer ( & min_stat , & request_buf ) ; } sec_token = GSS_C_NO_BUFFER ; context = GSS_C_NO_CONTEXT ; maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int *",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> buf + 2 , sizeof ( buf2 ) <vul-start> buf + 2 , sizeof ( buf2 )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> buf + 2, sizeof ( buf2 ) <vul-start> bail ; } if ( request_buf. length < 2 || request_buf. value [ request_buf. length - 1 ]!= '\\\\r\\\\n' ) { print_gss_error ( maj_stat, min_stat ) ; gss_release_name ( & min_stat, & target_name ) ; goto err_abort_cmd ; }\n"
 },
 {
  "id": 1207,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; <vul-start> int ret = 0 ; <vul-end> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE, & key -> flags ) ) return - ENOKEY\n"
 },
 {
  "id": 1208,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , \"DSD \" , 4 ) ) { error_line ( \"%s is not a valid .DFF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( \"%s is not a valid .DFF file (by total size)!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( \"file header indicated length = %lld\" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( \"%s is not a valid .DFF file!\" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( \"got PROP chunk of %d bytes total\" , ( int ) dff_chunk_header . ckDataSize ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> char * prop_chunk ; if ( dff_chunk_header. ckDataSize > 1024 ) { error_line ( \"%s is not a valid.DFF file!\", infilename ) ; return WAVPACK_SOFT_ERROR ; } prop_chunk\n"
 },
 {
  "id": 1209,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void filter_selectively_horiz ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; int count ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= count ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; count = 1 ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { if ( ( mask_16x16 & 3 ) == 3 ) { <vul-start> vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , <vul-end> lfi -> hev_thr , 2 ) ; count = 2 ; } else { <vul-start> vp9_lpf_horizontal_16 ( s , pitch , lfi -> mblim , lfi -> lim , <vul-end> lfi -> hev_thr , 1 ) ; } } else if ( mask_8x8 & 1 ) { if ( ( mask_8x8 & 3 ) == 3 ) { const loop_filter_thresh * lfin = lfi_n -> lfthr + * ( lfl + 1 ) ; <vul-start> vp9_lpf_horizontal_8_dual ( s , pitch , lfi -> mblim , lfi -> lim , <vul-end> lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; if ( ( mask_4x4_int & 3 ) == 3 ) { <vul-start> vp9_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , <vul-end> lfi -> lim , lfi -> hev_thr , lfin ->",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 3 ) { vpx_lpf_horizontal_16 <vul-end> ( s , <vul-start> } else { vpx_lpf_horizontal_16 <vul-end> ( s , <vul-start> 1 ) ; vpx_lpf_horizontal_8_dual <vul-end> ( s , <vul-start> 3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> & 2 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> } else { vpx_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> 1 ) ; vpx_lpf_horizontal_4_dual <vul-end> ( s , <vul-start> 3 ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> & 2 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> } else { vpx_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vpx_lpf_horizontal_4 <vul-end> ( s +\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 3 ) { vpx_lpf_horizontal_16 <vul-end> ( s, <vul-start> } else { vpx_lpf_horizontal_16 <vul-end> ( s, <vul-start> 1 ) ; vpx_lpf_horizontal_8_dual <vul-end> ( s, <vul-start> 3 ) { vpx_lpf_horizontal_4_dual <vul-end> ( s + <vul-start> & 2 ) vpx_lpf_horizontal_4 <vul-end> ( s + <vul-start> } else { vpx_lpf_horizontal_8 <vul-end> ( s, <vul-start> } else { vpx_lpf_horizontal_4 <vul-end> ( s,\n"
 },
 {
  "id": 1210,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static ssize_t perf_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct perf_event * event = file -> private_data ; <vul-start> return perf_read_hw ( event , buf , count ) ; <vul-end> <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> -> private_data ; struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock ( event ) ; ret = <vul-end> perf_read_hw ( event <vul-start> count ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> -> private_data ; ssize_t ret ; ret = <vul-end> perf_read_hw ( event <vul-start> count ) ; if ( ret < 0 ) return ret ; else return count ;\n"
 },
 {
  "id": 1211,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int jpc_enc_encodemainhdr ( jpc_enc_t * enc ) { jpc_siz_t * siz ; jpc_cod_t * cod ; jpc_qcd_t * qcd ; int i ; long startoff ; long mainhdrlen ; jpc_enc_cp_t * cp ; jpc_qcc_t * qcc ; jpc_enc_tccp_t * tccp ; uint_fast16_t cmptno ; jpc_tsfb_band_t bandinfos [ JPC_MAXBANDS ] ; jpc_fix_t mctsynweight ; jpc_enc_tcp_t * tcp ; jpc_tsfb_t * tsfb ; jpc_tsfb_band_t * bandinfo ; uint_fast16_t numbands ; uint_fast16_t bandno ; uint_fast16_t rlvlno ; uint_fast16_t analgain ; jpc_fix_t absstepsize ; char buf [ 1024 ] ; jpc_com_t * com ; cp = enc -> cp ; startoff = jas_stream_getrwcount ( enc -> out ) ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SOC ) ) ) { return - 1 ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( \"cannot write SOC marker\\\\n\" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SIZ ) ) ) { return - 1 ; } siz = & enc -> mrk -> parms . siz ; siz -> caps = 0 ; siz -> xoff = cp -> imgareatlx ; siz -> yoff = cp -> imgareatly ; siz -> width = cp -> refgrdwidth ; siz -> height = cp -> refgrdheight ; siz -> tilexoff = cp -> tilegrdoffx ; siz -> tileyoff = cp -> tilegrdoffy ; siz -> tilewidth = cp -> tilewidth ; siz ->",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> = JAS_CAST ( jas_uchar <vul-end> * , jas_strdup\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = JPC_COM_LATIN ; com -> data = 0 ;\n"
 },
 {
  "id": 1212,
  "question": "CWE-755 Code Input Vulnerable Code Is: CWE-755 int sqlite3WindowRewrite ( Parse * pParse , Select * p ) { int rc = SQLITE_OK ; if ( p -> pWin && p -> pPrior == 0 && ( p -> selFlags & SF_WinRewrite ) == 0 ) { Vdbe * v = sqlite3GetVdbe ( pParse ) ; sqlite3 * db = pParse -> db ; Select * pSub = 0 ; SrcList * pSrc = p -> pSrc ; Expr * pWhere = p -> pWhere ; ExprList * pGroupBy = p -> pGroupBy ; Expr * pHaving = p -> pHaving ; ExprList * pSort = 0 ; ExprList * pSublist = 0 ; Window * pMWin = p -> pWin ; Window * pWin ; Table * pTab ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) { <vul-start> return SQLITE_NOMEM ; <vul-end> } p -> pSrc = 0 ; p -> pWhere = 0 ; p -> pGroupBy = 0 ; p -> pHaving = 0 ; p -> selFlags &= ~ SF_Aggregate ; p -> selFlags |= SF_WinRewrite ; pSort = sqlite3ExprListDup ( db , pMWin -> pPartition , 0 ) ; pSort = exprListAppendList ( pParse , pSort , pMWin -> pOrderBy , 1 ) ; if ( pSort && p -> pOrderBy && p -> pOrderBy -> nExpr <= pSort -> nExpr ) { int nSave = pSort -> nExpr ; pSort -> nExpr = p -> pOrderBy -> nExpr ; if ( sqlite3ExprListCompare ( pSort , p -> pOrderBy , - 1 ) == 0 )",
  "golden_answers": [
   "CWE-755 Fixed Code Lines are: <vul-start> ) { return sqlite3ErrorToParser ( db , SQLITE_NOMEM ) <vul-end> ; } p <vul-start> ) ; } if ( rc && pParse -> nErr == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return sqlite3ErrorToParser ( pParse -> db , SQLITE_NOMEM ) ; }\n"
  ],
  "generated_answer": "CWE-755 Fixed Code Lines are: <vul-start> 0 ) { sqlite3ErrorMsg ( pParse, \"too many window entries\" ) ; <vul-start> ) ; } if ( pParse -> nErr ) { sqlite3ErrorMsg ( pParse, \"too many columns\" ) ; pParse -> nErr = 0 ; }\n"
 },
 {
  "id": 1213,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 void irc_mode_channel_update ( struct t_irc_server * server , struct t_irc_channel * channel , char set_flag , char chanmode , const char * argument ) { char * pos_args , * str_modes , * * argv , * pos , * ptr_arg ; char * new_modes , * new_args , str_mode [ 2 ] , * str_temp ; int argc , current_arg , chanmode_found , length ; if ( ! channel -> modes ) channel -> modes = strdup ( \"+\" ) ; if ( ! channel -> modes ) return ; argc = 0 ; argv = NULL ; pos_args = strchr ( channel -> modes , ' ' ) ; if ( pos_args ) { str_modes = weechat_strndup ( channel -> modes , pos_args - channel -> modes ) ; if ( ! str_modes ) return ; pos_args ++ ; while ( pos_args [ 0 ] == ' ' ) pos_args ++ ; argv = weechat_string_split ( pos_args , \" \" , NULL , WEECHAT_STRING_SPLIT_STRIP_LEFT | WEECHAT_STRING_SPLIT_STRIP_RIGHT | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS , 0 , & argc ) ; } else { str_modes = strdup ( channel -> modes ) ; if ( ! str_modes ) return ; } new_modes = malloc ( strlen ( channel -> modes ) + 1 + 1 ) ; new_args = malloc ( ( ( pos_args ) ? strlen ( pos_args ) : 0 ) + ( ( argument ) ? 1 + strlen ( argument ) : 0 ) + 1 ) ; if ( new_modes && new_args ) { new_modes [ 0 ] = '\\\\0' ; new_args [ 0",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> chanmode ) { if ( ! chanmode_found ) { <vul-start> } } } }\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> chanmode ) { <vul-end> if ( set_flag <vul-start> } } } chanmode_found = 1 ;\n"
 },
 {
  "id": 1214,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { FILE * infile , * outfile [ NUM_ENCODERS ] ; <vul-start> vpx_codec_ctx_t codec [ NUM_ENCODERS ] ; <vul-end> vpx_codec_enc_cfg_t cfg [ NUM_ENCODERS ] ; <vul-start> vpx_codec_pts_t frame_cnt = 0 ; <vul-end> vpx_image_t raw [ NUM_ENCODERS ] ; vpx_codec_err_t res [ NUM_ENCODERS ] ; int i ; long width ; long height ; <vul-start> int frame_avail ; <vul-end> int got_data ; int flags = 0 ; <vul-start> int arg_deadline = VPX_DL_REALTIME ; <vul-end> int show_psnr = 0 ; <vul-start> uint64_t psnr_sse_total [ NUM_ENCODERS ] = { 0 } ; <vul-end> uint64_t psnr_samples_total [ NUM_ENCODERS ] = { 0 } ; double psnr_totals [ NUM_ENCODERS ] [ 4 ] = { { 0 , 0 } } ; <vul-start> int psnr_count [ NUM_ENCODERS ] = { 0 } ; <vul-end> unsigned int target_bitrate [ NUM_ENCODERS ] = { 1000 , 500 , 100 } ; int framerate = 30 ; vpx_rational_t dsf [ NUM_ENCODERS ] = { { 2 , 1 } , { 2 , 1 } , { 1 , 1 } } ; <vul-start> if ( argc != ( 5 + NUM_ENCODERS ) ) <vul-end> <vul-start> die ( \"Usage: %s <width> <height> <infile> <outfile(s)> <output psnr?>\\\\n\" , <vul-end> argv [ 0 ] ) ; printf ( \"Using %s\\\\n\" , vpx_codec_iface_name ( interface ) ) ; width = strtol ( argv [ 1 ] , NULL , 0 ) ; <vul-start> height = strtol ( argv [ 2 ] , NULL , 0 ) ; <vul-end> if ( width < 16 || width",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> NUM_ENCODERS ] ; FILE * downsampled_input [ NUM_ENCODERS - 1 ] ; char filename [ 50 ] ; <vul-start> NUM_ENCODERS ] ; int <vul-end> frame_cnt = 0 <vul-start> height ; int length_frame ; int <vul-start> 0 ; int layer_id = 0 ; int layer_flags [ VPX_TS_MAX_PERIODICITY * NUM_ENCODERS ] = { 0 } ; int flag_periodicity ; int <vul-start> = 0 ; int key_frame_insert = 0 ; <vul-start> { 0 } ; double cx_time = 0 ; struct timeval tv1 , tv2 , difftv <vul-start> } } ; unsigned int num_temporal_layers [ NUM_ENCODERS ] = { 3 , 3 , 3 } ; <vul-start> argc != ( 7 + 3 * <vul-end> NUM_ENCODERS ) ) <vul-start> ) die ( \"Usage: %s <width> <height> <frame_rate>  <infile> <outfile(s)> \" \"<rate_encoder(s)> <temporal_layer(s)> <key_frame_insert> <output psnr?> \\\\n\" <vul-end> , argv [ <vul-start> argv [ 2 ] , NULL , 0 ) ; framerate = strtol ( argv [ 3 <vul-start> ( argv [ 4 <vul-end> ] , \"rb\" <vul-start> , argv [ 4 <vul-end> ] ) ; <vul-start> [ i + 5 <vul-end> ] , \"wb\" <vul-start> ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { target_bitrate [ i ] <vul-end> = strtol ( <vul-start> [ NUM_ENCODERS + 5 + i <vul-end> ] , NULL <vul-start> 0 ) ; } <vul-start> ++ ) { num_temporal_layers [ i ] = strtol ( argv [ 2 * NUM_ENCODERS + 5 + i ] , NULL , 0 ) ; if ( num_temporal_layers [ i ] < 1 || num_temporal_layers [ i ] > 3 ) die ( \"Invalid temporal layers: %d, Must be 1, 2, or 3. \\\\n\" , num_temporal_layers ) ; } for ( i = 0 ; i < NUM_ENCODERS - 1 ; i ++ ) { if ( sprintf ( filename , \"ds%d.yuv\" , NUM_ENCODERS - i ) < 0 ) { <vul-end> return EXIT_FAILURE ; <vul-start> EXIT_FAILURE ; } downsampled_input [ i ] = fopen ( filename , \"wb\" ) ; } key_frame_insert = strtol ( argv [ 3 * NUM_ENCODERS + 5 ] , NULL , 0 ) ; show_psnr = strtol ( argv [ 3 * NUM_ENCODERS + 6 ] , NULL , 0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; if ( res [ i ] ) { printf ( \"Failed to get config: %s\\\\n\" , vpx_codec_err_to_string ( res [ i ] ) ) ; return EXIT_FAILURE ; } <vul-start> 0 ] . rc_dropframe_thresh = 0 <vul-end> ; cfg [ <vul-start> . rc_min_quantizer = 2 <vul-end> ; cfg [ <vul-start> . rc_undershoot_pct = 100 <vul-end> ; cfg [ <vul-start> . rc_overshoot_pct = 15 <vul-end> ; cfg [ <vul-start> vpx_codec_enc_cfg_t ) ) <vul-end> ; cfg [ <vul-start> ++ ; } cfg [ 0 ] . g_threads = 2 ; cfg [ 1 ] . g_threads = 1 ; cfg [ 2 ] . g_threads = 1 ; <vul-start> 0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { set_temporal_layer_pattern ( num_temporal_layers [ i ] , & cfg [ i ] , cfg [ i ] . rc_target_bitrate , & layer_flags [ i * VPX_TS_MAX_PERIODICITY ] ) ; } <vul-start> ; if ( i == NUM_ENCODERS - 1 ) speed = - 4 ; if ( <vul-start> ] , \"Failed to set cpu_used\" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , 1 ) ) die_codec ( & codec [ i ] , \"Failed to set static threshold\" ) ; } if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) die_codec ( & codec [ 0 ] , \"Failed to set noise_sensitivity\" ) ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) die_codec ( & codec [ i ] , \"Failed to set noise_sensitivity\" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_TOKEN_PARTITIONS , 1 ) ) die_codec ( & codec [ i ] , \"Failed to set static threshold\" <vul-start> { unsigned int max_intra_size_pct = ( int ) ( ( ( double ) cfg [ 0 ] . rc_buf_optimal_sz * 0.5 ) * framerate / 10 ) <vul-end> ; if ( <vul-start> i ] , VP8E_SET_MAX_INTRA_BITRATE_PCT , max_intra_size_pct <vul-end> ) ) die_codec <vul-start> ] , \"Failed to set static threshold\" <vul-end> ) ; } <vul-start> 1 ) ; length_frame = cfg [ i ] . g_w * cfg [ i ] . g_h * 3 / 2 ; if ( fwrite ( raw [ i ] . planes [ 0 ] , 1 , length_frame , downsampled_input [ NUM_ENCODERS - i - 1 ] ) != length_frame ) { return EXIT_FAILURE ; } } } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { layer_id = cfg [ i ] . ts_layer_id [ frame_cnt % cfg [ i ] . ts_periodicity ] ; flags = 0 ; flag_periodicity = periodicity_to_num_layers [ num_temporal_layers [ i ] - 1 ] ; flags = layer_flags [ i * VPX_TS_MAX_PERIODICITY + frame_cnt % flag_periodicity ] ; if ( frame_cnt == 0 ) { flags |= VPX_EFLAG_FORCE_KF ; } if ( frame_cnt > 0 && frame_cnt == key_frame_insert ) { flags = VPX_EFLAG_FORCE_KF ; } vpx_codec_control ( & codec [ i ] , VP8E_SET_FRAME_FLAGS , flags ) ; vpx_codec_control ( & codec [ i ] , VP8E_SET_TEMPORAL_LAYER_ID , layer_id ) ; } gettimeofday ( & tv1 , NULL ) ; <vul-end> if ( vpx_codec_encode <vul-start> , 1 , 0 <vul-end> , arg_deadline ) <vul-start> arg_deadline ) ) { <vul-start> ] , \"Failed to encode frame\" ) ; } gettimeofday ( & tv2 , NULL ) ; timersub ( & tv2 , & tv1 , & difftv ) ; cx_time += ( double ) ( difftv . tv_sec * 1000000 + difftv . tv_usec <vul-start> ? \"K\" : \"\" <vul-end> ) ; fflush <vul-start> printf ( \"\\\\n\" ) ; printf ( \"FPS for encoding %d %f %f \\\\n\" , frame_cnt , ( float ) cx_time / 1000000 , 1000000 * ( double ) frame_cnt / ( double ) cx_time\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ] ; vpx_codec_ctx_t * <vul-start> ] ; vpx_codec_pts_t frame_cnt = 0 ; vpx_image_t raw [ NUM_ENCODERS ] ; vpx_codec_err_t res [ NUM_ENCODERS ] ; int i ; long width ; long height ; long frame_avail ; long arg_deadline = VPX_DL_REALTIME ; int show_psnr [ NUM_ENCODERS ] = 0 ; int arg_deadline = VPX_DL_REALTIME ; int target_bitrate [ NUM_ENCODERS ] = { 0, 0 } ; int framerate = 30 ; vpx_rational_t dsf [ NUM_ENCODERS ] ; int framerate = 30 ; int ctx [ NUM_ENCODERS ] ; long total_samples [ 0 ] ; long psnr_samples [ 0 ] ; long psnr_sse_total [ 0 ] = 0 ; long psnr_samples_total [ 0 ] = 0 ; long psnr_samples [ 0 ] [ 0 ] = 0 ; long dsf_total [ 0 ] [ 0 ] = 0 ; int target_bitrate [ 0 ] = { 0, 0 } ; int target_bitrate [ 0 ] = { 0, 0 } ; int arg_deadline = VPX_DL_REALTIME ; int show_psnr [ 0 ] = 0 ; long psnr_totals [ 0 ] [ 0 ] = 0 ; long psnr_totals [ 0 ] [ 0 ] = 0 ; long psnr_totals [ 0 ] [ 0 ] = 0 ; long psnr_samples_total [ 0 ] [ 0 ] = 0 ; long dsf_total [ 0 ] [ 0 ] = 0 ; int framerate_samples [ 0 ] ; long dsf_total [ 0 ] [ 0 ] = 0 ; long dsf_total [ 0 ] [ 0 ] = 0 ; long dsf_total [ 0 ] [ 0 ] = 0 ; long dsf_total [ 0 ] [ 0 ] = 0 ; long dsf_total [ 0 ] [ 0 ] = 0 ; long dsf_total [ 0 ] [ 0 ] = 0 ; long dsf_total_total [ 0 ] = 0 ; int target_bitrate_s = 0 ; int"
 },
 {
  "id": 1215,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 bool_t xdr_nullstring ( XDR * xdrs , char * * objp ) { u_int size ; if ( xdrs -> x_op == XDR_ENCODE ) { if ( * objp == NULL ) size = 0 ; else size = strlen ( * objp ) + 1 ; } if ( ! xdr_u_int ( xdrs , & size ) ) { return FALSE ; } switch ( xdrs -> x_op ) { case XDR_DECODE : if ( size == 0 ) { * objp = NULL ; return TRUE ; } else if ( * objp == NULL ) { * objp = ( char * ) mem_alloc ( size ) ; if ( * objp == NULL ) { errno = ENOMEM ; return FALSE ; } } <vul-start> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <vul-end> case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ; return TRUE ; case XDR_FREE : if ( * objp != NULL ) mem_free ( * objp , size ) ; * objp = NULL ; return TRUE ; } return FALSE ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; } } if ( ! <vul-end> xdr_opaque ( xdrs <vul-start> size ) ) return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\\\0' ) return FALSE ; if ( memchr ( * objp , '\\\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; } } if ( * objp [ size ] == '\\\\0' ) { * objp = ( char * ) mem_alloc ( size + 1 ) ; if ( * objp == NULL ) { errno = ENOMEM ; return FALSE ; } }\n"
 },
 {
  "id": 1216,
  "question": "CWE-254 Code Input Vulnerable Code Is: CWE-254 void test_parser ( void ) { <vul-start> int i , retval ; <vul-end> bzrtpPacket_t * zrtpPacket ; bzrtpContext_t * context87654321 = bzrtp_createBzrtpContext ( 0x87654321 ) ; bzrtpContext_t * context12345678 = bzrtp_createBzrtpContext ( 0x12345678 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 0 ] , H12345678 [ 0 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 1 ] , H12345678 [ 1 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 2 ] , H12345678 [ 2 ] , 32 ) ; memcpy ( context12345678 -> channelContext [ 0 ] -> selfH [ 3 ] , H12345678 [ 3 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 0 ] , H87654321 [ 0 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 1 ] , H87654321 [ 1 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 2 ] , H87654321 [ 2 ] , 32 ) ; memcpy ( context87654321 -> channelContext [ 0 ] -> selfH [ 3 ] , H87654321 [ 3 ] , 32 ) ; context87654321 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ; context12345678 -> channelContext [ 0 ] -> keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k ; context87654321 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ; context12345678 -> channelContext [ 0 ] -> cipherAlgo = ZRTP_CIPHER_AES1 ; context87654321 -> channelContext [ 0 ] -> hashAlgo = ZRTP_HASH_S256",
  "golden_answers": [
   "CWE-254 Fixed Code Lines are: <vul-start> void ) { test_parser_param ( <vul-end> 0 ) ; <vul-start> ) ; } <vul-end>      \n"
  ],
  "generated_answer": "CWE-254 Fixed Code Lines are: <vul-start> i, retval ; uint32_t * packetLength <vul-start> 0 ) ; packetLength = ( uint32_t * ) memchr ( zrtpPacket -> packetString, '\\\\0', i * sizeof ( uint32_t ) ) ; if ( packetLength!= 32 ) { CU_FAIL ( \"Invalid ZRTP packet length\" ) ; break ; } <vul-start> 0 ) ; packetLength = ( uint32_t * ) memchr ( zrtpPacket -> packetString, '\\\\0', i * sizeof ( uint32_t ) ) ; if ( packetLength!= 16 ) { CU_FAIL ( \"Invalid ZRTP packet length\" ) ; break ; }\n"
 },
 {
  "id": 1217,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int decode_uniform ( vp9_reader * r ) { <vul-end> const int l = 8 ; const int m = ( 1 << l ) - 191 ; <vul-start> const int v = vp9_read_literal ( r , l - 1 ) ; <vul-end> <vul-start> return v < m ? v : ( v << 1 ) - m + vp9_read_bit ( r ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int decode_uniform ( vpx_reader <vul-end> * r ) <vul-start> int v = vpx_read_literal <vul-end> ( r , <vul-start> - m + vpx_read_bit <vul-end> ( r )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int decode_uniform ( vpx_reader <vul-end> * r ) <vul-start> int v = vpx_read_literal <vul-end> ( r, <vul-start> - m + vpx_read_bit <vul-end> ( r )\n"
 },
 {
  "id": 1218,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ; <vul-start> in_uint16_le ( s , length ) ; <vul-end> in_uint16_le ( s , flags ) ; <vul-start> in_uint8 ( s , type ) ; <vul-end> next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , \"process_secondary_order(), unhandled secondary order %d\" , type ) ; } s -> p = next_order ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * next_order ; struct stream packet = * s ; <vul-start> type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( \"process_secondary_order(), next order pointer would overrun stream\" , & packet ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * next_order ; struct stream packet = * s ; <vul-start> type ) ; if (! s_check ( s ) ) { rdp_protocol_error ( \"process_secondary_order(), consume of secondary order from stream would overrun\", & packet ) ; }\n"
 },
 {
  "id": 1219,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; PixelChannels * * pixels ; register ssize_t i ; size_t columns , <vul-start> number_threads ; <vul-end> <vul-start> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <vul-end> <vul-start> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <vul-end> sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; <vul-start> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <vul-end> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <vul-start> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <vul-end> { register ssize_t j ; pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <vul-end> ( size_t ) <vul-start> ( ThreadResource ) ) <vul-start> ) AcquireQuantumMemory ( rows , <vul-end> sizeof ( * <vul-start> NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <vul-end> ; i < <vul-start> ( ssize_t ) rows <vul-end> ; i ++\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> size_t columns, rows ; rows = MagickMax ( GetImageListLength ( images ), <vul-end> ( size_t ) <vul-start> ( ThreadResource ) ) <vul-start> ) AcquireQuantumMemory ( rows, <vul-end> sizeof ( * <vul-start> NULL ) ; columns = images -> columns ; for ( next = images ; next!= ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns, columns ) ; for ( i = 0 <vul-end> ; i < <vul-start> ( ssize_t ) rows <vul-end> ; i ++\n"
 },
 {
  "id": 1220,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; struct rds_transport * otrans = trans ; if ( ! is_outgoing && otrans -> t_type == RDS_TRANS_TCP ) goto new_conn ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; new_conn : conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR (",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; } } if (! trans ) { trans = & rds_loop_transport ; }\n"
 },
 {
  "id": 1221,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static int http_connect ( http_subtransport * t ) { int error ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , \"git_stream\" ) ; apply_proxy_config ( t ) ; error = git_stream_connect ( t -> io ) ; if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ; <vul-start> int is_valid ; <vul-end> if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ; <vul-start> giterr_clear ( ) ; <vul-end> is_valid = error != GIT_ECERTIFICATE ; error = t -> owner -> certificate_check_cb ( cert",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ; int is_valid = ( error == GIT_OK ) <vul-start> giterr_clear ( ) <vul-end> ; error =\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> * cert ; <vul-end> if ( ( <vul-start> return error ; <vul-end> error = t\n"
 },
 {
  "id": 1222,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <vul-start> FreeStmt ( ( ParseCommon * ) & append ) ; <vul-end> return expr ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ParseCommon * ) <vul-end> append ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> syms ) ; if ( append -> type == ExprType_Block ) { darray_append ( expr -> keysym_list. blocks, append -> keysym_list. blocks ) ; }\n"
 },
 {
  "id": 1223,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , \" who-are-you request\" ) ) ; break ; } ND_PRINT ( ( ndo , \" node information query\" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , \" (\" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , \"noop\" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , \"supported qtypes\" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , \" [%s]\" , ( i & 0x01 ) ? \"C\" : \"\" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , \"DNS name\" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , \"node addresses\" ) ) ; i",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <vul-start> ) + 4 ; ND_TCHECK ( cp [ 0 ] )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> icmp6_nodeinfo * ) bp <vul-end> ; ND_PRINT ( <vul-start> = 0 ; if ( siz!= sizeof ( * ni6 ) ) break ; <vul-start> ) ) ; if ( siz!= sizeof ( * ni6 ) ) break ;\n"
 },
 {
  "id": 1224,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int Unpickler_set_memo ( UnpicklerObject * self , PyObject * obj ) { PyObject * * new_memo ; <vul-start> Py_ssize_t new_memo_size = 0 ; <vul-end> Py_ssize_t i ; if ( obj == NULL ) { PyErr_SetString ( PyExc_TypeError , \"attribute deletion is not supported\" ) ; return - 1 ; } if ( Py_TYPE ( obj ) == & UnpicklerMemoProxyType ) { UnpicklerObject * unpickler = ( ( UnpicklerMemoProxyObject * ) obj ) -> unpickler ; new_memo_size = unpickler -> memo_size ; new_memo = _Unpickler_NewMemo ( new_memo_size ) ; if ( new_memo == NULL ) return - 1 ; <vul-start> for ( i = 0 ; i < new_memo_size ; i ++ ) { <vul-end> Py_XINCREF ( unpickler -> memo [ i ] ) ; new_memo [ i ] = unpickler -> memo [ i ] ; } } else if ( PyDict_Check ( obj ) ) { Py_ssize_t i = 0 ; PyObject * key , * value ; new_memo_size = PyDict_GET_SIZE ( obj ) ; new_memo = _Unpickler_NewMemo ( new_memo_size ) ; if ( new_memo == NULL ) return - 1 ; while ( PyDict_Next ( obj , & i , & key , & value ) ) { Py_ssize_t idx ; if ( ! PyLong_Check ( key ) ) { PyErr_SetString ( PyExc_TypeError , \"memo key must be integers\" ) ; goto error ; } idx = PyLong_AsSsize_t ( key ) ; if ( idx == - 1 && PyErr_Occurred ( ) ) goto error ; if ( idx < 0 ) { PyErr_SetString ( PyExc_ValueError , \"memo key must be positive",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * new_memo ; size_t new_memo_size = 0 <vul-end> ; if ( <vul-start> ; for ( size_t <vul-start> new_memo_size ) { for ( size_t i = new_memo_size - 1 ; i != SIZE_MAX ; i -- <vul-end> ) { Py_XDECREF\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; Py_ssize_t new_memo_size <vul-end> ; if ( <vul-start> - 1 ; if ( new_memo_size > PY_SSIZE_T_MAX ) { PyErr_SetString ( PyExc_ValueError, \"number of memo items (%zu) exceeds the maximum allowed (%zu)\", new_memo_size, ( size_t ) Py_SSIZE_T_MAX ) ; return - 1 ; } <vul-start> new_memo_size ) { size_t\n"
 },
 {
  "id": 1225,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <vul-start> struct va_format vaf ; <vul-end> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( \"[%s]:[%s:%d]:%d: %pV\" , dev_name ( & qedi -> pdev -> dev ) , <vul-start> nfunc , line , qedi -> host_no , & vaf ) ; <vul-end> else <vul-start> pr_warn ( \"[0000:00:00.0]:[%s:%d]: %pV\" , nfunc , line , & vaf ) ; <vul-end> ret : va_end ( va ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> struct va_format vaf <vul-end> ; va_start ( <vul-start> dev ) , func <vul-end> , line , <vul-start> ( \"[0000:00:00.0]:[%s:%d]: %pV\" , func <vul-end> , line ,\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> struct va_format vaf <vul-end> ; va_start ( <vul-start> dev ), func <vul-end>, line, <vul-start> ( \"[0000:00:00.0]:[%s:%d]: %pV\", func <vul-end>, line,\n"
 },
 {
  "id": 1226,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int send_parameters ( struct iperf_test * test ) { int r = 0 ; cJSON * j ; j = cJSON_CreateObject ( ) ; if ( j == NULL ) { i_errno = IESENDPARAMS ; r = - 1 ; } else { if ( test -> protocol -> id == Ptcp ) cJSON_AddTrueToObject ( j , \"tcp\" ) ; else if ( test -> protocol -> id == Pudp ) cJSON_AddTrueToObject ( j , \"udp\" ) ; <vul-start> cJSON_AddIntToObject ( j , \"omit\" , test -> omit ) ; <vul-end> if ( test -> server_affinity != - 1 ) <vul-start> cJSON_AddIntToObject ( j , \"server_affinity\" , test -> server_affinity ) ; <vul-end> if ( test -> duration ) cJSON_AddIntToObject ( j , \"time\" , test -> duration ) ; if ( test -> settings -> bytes ) cJSON_AddIntToObject ( j , \"num\" , test -> settings -> bytes ) ; if ( test -> settings -> blocks ) cJSON_AddIntToObject ( j , \"blockcount\" , test -> settings -> blocks ) ; if ( test -> settings -> mss ) cJSON_AddIntToObject ( j , \"MSS\" , test -> settings -> mss ) ; if ( test -> no_delay ) cJSON_AddTrueToObject ( j , \"nodelay\" ) ; cJSON_AddIntToObject ( j , \"parallel\" , test -> num_streams ) ; if ( test -> reverse ) cJSON_AddTrueToObject ( j , \"reverse\" ) ; if ( test -> settings -> socket_bufsize ) cJSON_AddIntToObject ( j , \"window\" , test -> settings -> socket_bufsize ) ; if ( test -> settings -> blksize ) cJSON_AddIntToObject ( j , \"len\"",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> \"udp\" ) ; cJSON_AddNumberToObject <vul-end> ( j , <vul-start> - 1 ) cJSON_AddNumberToObject ( j , \"server_affinity\" , test -> server_affinity ) ; if ( test -> duration ) cJSON_AddNumberToObject ( j , \"time\" , test -> duration ) ; if ( test -> settings -> bytes ) cJSON_AddNumberToObject ( j , \"num\" , test -> settings -> bytes ) ; if ( test -> settings -> blocks ) cJSON_AddNumberToObject ( j , \"blockcount\" , test -> settings -> blocks ) ; if ( test -> settings -> mss ) cJSON_AddNumberToObject ( j , \"MSS\" , test -> settings -> mss ) ; if ( test -> no_delay ) cJSON_AddTrueToObject ( j , \"nodelay\" ) ; cJSON_AddNumberToObject ( j , \"parallel\" , test -> num_streams ) ; if ( test -> reverse ) cJSON_AddTrueToObject ( j , \"reverse\" ) ; if ( test -> settings -> socket_bufsize ) cJSON_AddNumberToObject ( j , \"window\" , test -> settings -> socket_bufsize ) ; if ( test -> settings -> blksize ) cJSON_AddNumberToObject ( j , \"len\" , test -> settings -> blksize ) ; if ( test -> settings -> rate ) cJSON_AddNumberToObject ( j , \"bandwidth\" , test -> settings -> rate ) ; if ( test -> settings -> burst ) cJSON_AddNumberToObject ( j , \"burst\" , test -> settings -> burst ) ; if ( test -> settings -> tos ) cJSON_AddNumberToObject ( j , \"TOS\" , test -> settings -> tos ) ; if ( test -> settings -> flowlabel ) cJSON_AddNumberToObject ( j , \"flowlabel\" , test -> settings -> flowlabel ) ; if ( test -> title ) cJSON_AddStringToObject ( j , \"title\" , test -> title ) ; if ( test -> congestion ) cJSON_AddStringToObject ( j , \"congestion\" , test -> congestion ) ; if ( test -> get_server_output ) << << << < HEAD <vul-start> ( j , \"get_server_output\" , iperf_get_test_get_server_output ( test ) ) ; == == == = cJSON_AddNumberToObject ( j , \"get_server_output\" , iperf_get_test_get_server_output ( test ) ) ; if ( test -> udp_counters_64bit ) cJSON_AddNumberToObject ( j , \"udp_counters_64bit\" , iperf_get_test_udp_counters_64bit ( test ) ) ; if ( test -> no_fq_socket_pacing ) cJSON_AddNumberToObject ( j , \"no_fq_socket_pacing\" , iperf_get_no_fq_socket_pacing ( test ) ) ; <vul-end> cJSON_AddStringToObject ( j <vul-start> ( j , \"client_version\" , IPERF_VERSION ) ; >> >> >> > ed94082 ... Fix a buffer overflow / heap corruption issue that could occur if a <vul-end> if ( test\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> \"udp\" ) ; if ( test -> settings -> bytes ) cJSON_AddNumberToObject ( j, \"len\", test -> settings -> bytes ) ; if ( test -> settings -> blocks ) cJSON_AddNumberToObject ( j, \"blockcount\", test -> settings -> blocks ) ; <vul-start> - 1 ) cJSON_AddNumberToObject <vul-end> ( j, <vul-start> \"port\" ) ; if ( test -> settings -> socket_bufsize ) cJSON_AddNumberToObject ( j, \"window\", test -> settings -> socket_bufsize ) ; if ( test -> settings -> blksize ) cJSON_AddNumberToObject ( j, \"blocksize\", test -> settings -> blksize ) ;\n"
 },
 {
  "id": 1227,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int snd_timer_start_slave ( struct snd_timer_instance * timeri ) { unsigned long flags ; spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags |= SNDRV_TIMER_IFLG_RUNNING ; <vul-start> if ( timeri -> master ) <vul-end> list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ; <vul-start> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <vul-end> return 1 ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> timeri -> master && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <vul-end> list_add_tail ( & <vul-start> slave_active_head ) ; spin_unlock ( & timeri -> timer -> lock ) ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> -> master ) { spin_unlock_irqrestore ( & slave_active_lock, flags ) ; return 0 ; } else { <vul-start> slave_active_head ) ; }\n"
 },
 {
  "id": 1228,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ; <vul-start> spin_lock_irq ( & tu -> qlock ) ; <vul-end> while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ; <vul-start> schedule ( ) ; <vul-end> spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ; <vul-start> mutex_lock ( & tu -> ioctl_lock ) ; <vul-end> if ( tu -> tread ) { if ( copy_to_user (",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <vul-start> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <vul-end> ) ; spin_lock_irq <vul-start> qlock ) ; <vul-end> if ( tu <vul-start> EFAULT ; } <vul-end> spin_lock_irq ( & <vul-start> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <vul-start> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; <vul-start> qlock ) ; <vul-end> if ( tu <vul-start> EFAULT ; } mutex_unlock ( & tu -> ioctl_lock ) ;\n"
 },
 {
  "id": 1229,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 xmlAttrPtr xsltAttrTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attr ) { const xmlChar * value ; xmlAttrPtr ret ; if ( ( ctxt == NULL ) || ( attr == NULL ) || ( target == NULL ) ) return ( NULL ) ; if ( attr -> type != XML_ATTRIBUTE_NODE ) return ( NULL ) ; # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) return ( NULL ) ; # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) return ( NULL ) ; # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , \"Internal error: The children of an attribute node of a \" \"literal result element are not in the expected form.\\\\n\" ) ; return ( NULL ) ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST \"\" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST \"\" , 0 ) ; ret = target -> properties ; while ( ret != NULL ) { if ( ( ( attr -> ns != NULL ) == ( ret -> ns != NULL ) ) && xmlStrEqual ( ret -> name , attr -> name ) && ( (",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> -> dict ) && xmlDictOwns ( ctxt -> dict , value )\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> -> dict ) && xmlDictOwns ( ctxt -> dict, value )\n"
 },
 {
  "id": 1230,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 bool btsock_thread_remove_fd_and_close ( int thread_handle , int fd ) { if ( thread_handle < 0 || thread_handle >= MAX_THREAD ) { APPL_TRACE_ERROR ( \"%s invalid thread handle: %d\" , __func__ , thread_handle ) ; return false ; } if ( fd == - 1 ) { APPL_TRACE_ERROR ( \"%s invalid file descriptor.\" , __func__ ) ; return false ; } sock_cmd_t cmd = { CMD_REMOVE_FD , fd , 0 , 0 , 0 } ; <vul-start> return send ( ts [ thread_handle ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <vul-end> }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> } ; return TEMP_FAILURE_RETRY ( <vul-start> , 0 ) )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> } ; return TEMP_FAILURE_RETRY ( <vul-start>, 0 ) )\n"
 },
 {
  "id": 1231,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 void sock_release ( struct socket * sock ) { <vul-start> if ( sock -> ops ) { <vul-end> struct module * owner = sock -> ops -> owner ; sock -> ops -> release ( sock ) ; sock -> ops = NULL ; module_put ( owner ) ; } <vul-start> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <vul-end> pr_err ( \"%s: fasync list not empty!\\\\n\" , __func__ ) ; if ( ! sock -> file ) { iput ( SOCK_INODE ( sock ) ) ; return ; } sock -> file = NULL ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> sock ) { __sock_release ( sock , NULL <vul-end> ) ; } <vul-start> ) ; } <vul-end>      \n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> sock ) { struct module * owner = rcu_dereference_protected ( sock -> wq, 1 ) ; <vul-start> } if ( <vul-end>! sock ->\n"
 },
 {
  "id": 1232,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static NPError g_NPN_GetValue ( NPP instance , NPNVariable variable , void * value ) { D ( bug ( \"NPN_GetValue instance=%p, variable=%d [%s]\\\\n\" , instance , variable , string_of_NPNVariable ( variable ) ) ) ; if ( ! thread_check ( ) ) { npw_printf ( \"WARNING: NPN_GetValue not called from the main thread\\\\n\" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } PluginInstance * plugin = NULL ; if ( instance ) plugin = PLUGIN_INSTANCE ( instance ) ; switch ( variable ) { case NPNVxDisplay : * ( void * * ) value = x_display ; break ; case NPNVxtAppContext : * ( void * * ) value = XtDisplayToApplicationContext ( x_display ) ; break ; case NPNVToolkit : * ( NPNToolkitType * ) value = NPW_TOOLKIT ; break ; # if USE_XPCOM case NPNVserviceManager : { nsIServiceManager * sm ; int ret = NS_GetServiceManager ( & sm ) ; if ( NS_FAILED ( ret ) ) { npw_printf ( \"WARNING: NS_GetServiceManager failed\\\\n\" ) ; return NPERR_GENERIC_ERROR ; } * ( nsIServiceManager * * ) value = sm ; break ; } case NPNVDOMWindow : case NPNVDOMElement : npw_printf ( \"WARNING: %s is not supported by NPN_GetValue()\\\\n\" , string_of_NPNVariable ( variable ) ) ; return NPERR_INVALID_PARAM ; # endif case NPNVnetscapeWindow : if ( plugin == NULL ) { npw_printf ( \"ERROR: NPNVnetscapeWindow requires a non NULL instance\\\\n\" ) ; return NPERR_INVALID_INSTANCE_ERROR ; } if ( plugin -> browser_toplevel == NULL ) { GdkNativeWindow netscape_xid = None ; NPError error = g_NPN_GetValue_real ( instance , variable , & netscape_xid ) ; if ( error != NPERR_NO_ERROR )",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling :\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> case NPNVPluginElementNPObject : case NPNVprivateModeNPObject :\n"
 },
 {
  "id": 1233,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 WORD32 ih264d_parse_islice_data_cavlc ( dec_struct_t * ps_dec , dec_slice_params_t * ps_slice , UWORD16 u2_first_mb_in_slice ) { UWORD8 uc_more_data_flag ; UWORD8 u1_num_mbs , u1_mb_idx ; dec_mb_info_t * ps_cur_mb_info ; deblk_mb_t * ps_cur_deblk_mb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD16 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; WORD16 i2_cur_mb_addr ; UWORD8 u1_mbaff ; UWORD8 u1_num_mbs_next , u1_end_of_row , u1_tfr_n_mb ; WORD32 ret = OK ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; u1_mb_idx = ps_dec -> u1_mb_idx ; u1_num_mbs = u1_mb_idx ; uc_more_data_flag = 1 ; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff ; do { UWORD8 u1_mb_type ; ps_dec -> pv_prev_mb_parse_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) { ret = ERROR_MB_ADDRESS_T ; break ; } ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_dec -> pf_get_mb_info ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , 0 ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; ps_cur_deblk_mb -> u1_mb_type = ps_cur_deblk_mb -> u1_mb_type | D_INTRA_MB ; { UWORD32 u4_bitstream_offset = * pu4_bitstrm_ofst ; UWORD32 u4_word , u4_ldz , u4_temp ; NEXTBITS_32 ( u4_word , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_ldz = CLZ (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> u1_num_mbs ++ ; <vul-end> u1_num_mbs_next = i2_pic_wdin_mbs <vul-start> ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> u2_total_mbs_coded ++ ; if ( ps_dec -> u2_total_mbs_coded > i2_pic_wdin_mbs ) { return ERROR_EOB_FLUSHBITS_T ; } <vul-start> ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;\n"
 },
 {
  "id": 1234,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int x25_negotiate_facilities ( struct sk_buff * skb , struct sock * sk , struct x25_facilities * new , struct x25_dte_facilities * dte ) { struct x25_sock * x25 = x25_sk ( sk ) ; struct x25_facilities * ours = & x25 -> facilities ; struct x25_facilities theirs ; int len ; memset ( & theirs , 0 , sizeof ( theirs ) ) ; <vul-start> memcpy ( new , ours , sizeof ( * new ) ) ; <vul-end> len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ; if ( len < 0 ) return len ; if ( ( theirs . reverse & 0x01 ) && ( ours -> reverse & 0x01 ) ) { SOCK_DEBUG ( sk , \"X.25: rejecting reverse charging request\\\\n\" ) ; return - 1 ; } new -> reverse = theirs . reverse ; if ( theirs . throughput ) { int theirs_in = theirs . throughput & 0x0f ; int theirs_out = theirs . throughput & 0xf0 ; int ours_in = ours -> throughput & 0x0f ; int ours_out = ours -> throughput & 0xf0 ; if ( ! ours_in || theirs_in < ours_in ) { SOCK_DEBUG ( sk , \"X.25: inbound throughput negotiated\\\\n\" ) ; new -> throughput = ( new -> throughput & 0xf0 ) | theirs_in ; } if ( ! ours_out || theirs_out < ours_out ) { SOCK_DEBUG ( sk , \"X.25: outbound throughput negotiated\\\\n\" ) ; new -> throughput = ( new -> throughput & 0x0f ) | theirs_out ; } } if ( theirs",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ( * new ) ) ; memset ( dte , 0 , sizeof ( * dte\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; theirs. fcs = 0 ;\n"
 },
 {
  "id": 1235,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height ) { c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 ) ; aligned_height = FFALIGN ( c -> height , 16 ) ; av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height ) { <vul-start> c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 ) ; <vul-end> aligned_height = FFALIGN ( c -> tile_height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> c -> tile_width <vul-end> , 16 ) <vul-start> , 16 ) * 3\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> c -> tile_width + 15 <vul-end>, 16 )\n"
 },
 {
  "id": 1236,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <vul-end> assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> costs , const vpx_prob <vul-end> * probs , <vul-start> * probs , vpx_tree <vul-end> tree ) {\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> costs, const vpx_prob <vul-end> * probs, <vul-start> * probs, vpx_tree <vul-end> tree ) {\n"
 },
 {
  "id": 1237,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int sqlite3Select ( Parse * pParse , Select * p , SelectDest * pDest ) { int i , j ; WhereInfo * pWInfo ; Vdbe * v ; int isAgg ; ExprList * pEList = 0 ; SrcList * pTabList ; Expr * pWhere ; ExprList * pGroupBy ; Expr * pHaving ; int rc = 1 ; DistinctCtx sDistinct ; SortCtx sSort ; AggInfo sAggInfo ; int iEnd ; sqlite3 * db ; ExprList * pMinMaxOrderBy = 0 ; u8 minMaxFlag ; db = pParse -> db ; v = sqlite3GetVdbe ( pParse ) ; if ( p == 0 || db -> mallocFailed || pParse -> nErr ) { return 1 ; } if ( sqlite3AuthCheck ( pParse , SQLITE_SELECT , 0 , 0 , 0 ) ) return 1 ; memset ( & sAggInfo , 0 , sizeof ( sAggInfo ) ) ; # if SELECTTRACE_ENABLED SELECTTRACE ( 1 , pParse , p , ( \"begin processing:\\\\n\" , pParse -> addrExplain ) ) ; if ( sqlite3SelectTrace & 0x100 ) { sqlite3TreeViewSelect ( 0 , p , 0 ) ; } # endif assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistFifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Fifo ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_DistQueue ) ; assert ( p -> pOrderBy == 0 || pDest -> eDest != SRT_Queue ) ; if ( IgnorableOrderby ( pDest ) ) { assert ( pDest -> eDest == SRT_Exists || pDest ->",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ) == 0 && p -> pWin == 0\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ) == 0 && pTabList -> nSrc == 0\n"
 },
 {
  "id": 1238,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd , <vul-start> vp9_reader * r ) { <vul-end> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { const int ctx = vp9_get_reference_mode_context ( cm , xd ) ; const REFERENCE_MODE mode = <vul-start> ( REFERENCE_MODE ) vp9_read ( r , cm -> fc . comp_inter_prob [ ctx ] ) ; <vul-end> <vul-start> if ( ! cm -> frame_parallel_decoding_mode ) <vul-end> ++ cm -> counts . comp_inter [ ctx ] [ mode ] ; return mode ; } else { return cm -> reference_mode ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * xd , vpx_reader <vul-end> * r ) <vul-start> ( REFERENCE_MODE ) vpx_read <vul-end> ( r , <vul-start> cm -> fc -> <vul-end> comp_inter_prob [ ctx <vul-start> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <vul-end> comp_inter [ ctx\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * xd, vpx_reader <vul-end> * r ) <vul-start> ( REFERENCE_MODE ) vpx_read <vul-end> ( r, <vul-start> cm -> fc -> <vul-end> comp_inter_prob [ ctx <vul-start> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <vul-end> comp_inter [ ctx\n"
 },
 {
  "id": 1239,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , \"nreslevels %d is invalid\\\\n\" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } if ( c -> nreslevels < s -> reduction_factor ) c -> nreslevels2decode = 1 ; else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , \"cblk size invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; } <vul-start> c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; <vul-end> if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , \"extra cblk styles %X\\\\n\" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , \"cblk size > 64\" ) ; return AVERROR_PATCHWELCOME ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 15 || c -> log2_cblk_height > 15 ) { av_log ( s -> avctx, AV_LOG_ERROR, \"cblk size invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; }\n"
 },
 {
  "id": 1240,
  "question": "CWE-89 Code Input Vulnerable Code Is: CWE-89 static CURLcode imap_parse_url_path ( struct connectdata * conn ) { struct imap_conn * imapc = & conn -> proto . imapc ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <vul-start> int len ; <vul-end> if ( ! * path ) path = \"INBOX\" ; <vul-start> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <vul-end> <vul-start> if ( ! imapc -> mailbox ) <vul-end> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }",
  "golden_answers": [
   "CWE-89 Fixed Code Lines are: <vul-start> . path ; <vul-end> if ( ! <vul-start> = \"INBOX\" ; return Curl_urldecode <vul-end> ( data , <vul-start> 0 , & <vul-end> imapc -> mailbox <vul-start> imapc -> mailbox , NULL , TRUE ) <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-89 Fixed Code Lines are: <vul-start>. path ; <vul-end> if (! <vul-start> = \"INBOX\" ; if (! imapc -> mailbox ) return CURLE_OUT_OF_MEMORY ; <vul-start> if (! get_mailbox ( data, path ) <vul-end> ) return CURLE_OUT_OF_MEMORY\n"
 },
 {
  "id": 1241,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , \"vCont;c;s\" ) ; } if ( ! ( action = strtok ( g -> data , \";\" ) ) ) { return send_msg ( g , \"E01\" ) ; } while ( action = strtok ( NULL , \";\" ) ) { eprintf ( \"action: %s\\\\n\" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , \"ds\" , NULL , 0 ) < 0 ) { send_msg ( g , \"E01\" ) ; return - 1 ; } return send_msg ( g , \"OK\" ) ; case 'c' : if ( cmd_cb ( core_ptr , \"dc\" , NULL , 0 ) < 0 ) { send_msg ( g , \"E01\" ) ; return - 1 ; } return send_msg ( g , \"OK\" ) ; default : return send_msg ( g , \"E01\" ) ; } } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ; } } return - 1 ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; } } return 0 ;\n"
 },
 {
  "id": 1242,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; <vul-start> kfree ( fpl ) ; <vul-end> } }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ] ) ; free_uid ( fpl -> user ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> ] ) ; if ( fpl -> count == 0 ) fpl -> user = NULL ;\n"
 },
 {
  "id": 1243,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_cyclic_refresh_update_segment ( VP9_COMP * const cpi , MB_MODE_INFO * const mbmi , int mi_row , int mi_col , <vul-start> BLOCK_SIZE bsize , int use_rd ) { <vul-end> const VP9_COMMON * const cm = & cpi -> common ; CYCLIC_REFRESH * const cr = cpi -> cyclic_refresh ; const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; const int bh = num_8x8_blocks_high_lookup [ bsize ] ; const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ; const int block_index = mi_row * cm -> mi_cols + mi_col ; <vul-start> const int refresh_this_block = candidate_refresh_aq ( cr , mbmi , bsize , use_rd ) ; <vul-end> int new_map_value = cr -> map [ block_index ] ; int x = 0 ; int y = 0 ; <vul-start> if ( mbmi -> segment_id > 0 && ! refresh_this_block ) <vul-end> mbmi -> segment_id = 0 ; <vul-start> if ( mbmi -> segment_id == 1 ) { <vul-end> new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] == 1 ) new_map_value = 0 ; } else { new_map_value = 1 ; } for ( y = 0 ; y < ymis ; y ++ ) for ( x = 0 ; x < xmis ; x ++ ) { <vul-start> cr -> map [ block_index + y * cm -> mi_cols + x ] = new_map_value ; <vul-end> <vul-start> cpi -> segmentation_map [ block_index +",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> BLOCK_SIZE bsize , int64_t rate , int64_t dist , int skip <vul-end> ) { const <vul-start> , mbmi , rate , dist , bsize <vul-end> ) ; int <vul-start> ; if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { mbmi -> segment_id = refresh_this_block ; if ( skip ) mbmi -> segment_id = CR_SEGMENT_ID_BASE ; } if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] <vul-end> == 1 ) <vul-start> == 1 ) <vul-end> new_map_value = 0 <vul-start> ++ ) { int map_offset = <vul-end> block_index + y <vul-start> mi_cols + x ; cr -> map [ map_offset <vul-start> -> segmentation_map [ map_offset ] = mbmi -> segment_id ; if ( ! is_inter_block ( mbmi ) || ! skip ) cr -> last_coded_q_map [ map_offset ] = clamp ( cm -> base_qindex + cr -> qindex_delta [ mbmi -> segment_id ] , 0 , MAXQ ) ; } <vul-end> }    \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, BLOCK_SIZE bsize, int segment_id <vul-start>, use_rd ) <vul-end> ; int new_map_value <vul-start> ; if ( <vul-end> segment_id > 0 <vul-start>! refresh_this_block ) { <vul-start> = 0 ; } <vul-end> for ( y <vul-start> ++ ) { if ( segment_id == 1 ) { new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index + y * cm -> mi_cols + x ] == 1 ) new_map_value = 0 ; } else { new_map_value = 1 ; } <vul-start> = new_map_value ; } if ( segment_id == 1 ) { if ( cr -> segmentation_map [ block_index + y * cm -> mi_cols + x ] == 1 ) { new_map_value = 0 ; } else { <vul-start> -> segmentation_map [ block_index + y * cm -> mi_cols + x ] = new_map_value ; } } <vul-end> } if (\n"
 },
 {
  "id": 1244,
  "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 <vul-start> static char * create_output_name ( unsigned char * fname , unsigned char * dir , <vul-end> int lower , int isunix , int utf8 ) { unsigned char * p , * name , c , * fe , sep , slash ; unsigned int x ; sep = ( isunix ) ? '/' : '\\\\\\\\' ; slash = ( isunix ) ? '\\\\\\\\' : '/' ; x = strlen ( ( char * ) fname ) ; <vul-start> if ( utf8 ) x *= 3 ; <vul-end> if ( dir ) x += strlen ( ( char * ) dir ) ; if ( ! ( name = ( unsigned char * ) malloc ( x + 2 ) ) ) { <vul-start> fprintf ( stderr , \"out of memory!\\\\n\" ) ; <vul-end> return NULL ; } * name = '\\\\0' ; if ( dir ) { strcpy ( ( char * ) name , ( char * ) dir ) ; strcat ( ( char * ) name , \"/\" ) ; } <vul-start> while ( * fname == sep ) fname ++ ; <vul-end> <vul-start> p = & name [ strlen ( ( char * ) name ) ] ; <vul-end> fe = & fname [ strlen ( ( char * ) fname ) ] ; if ( utf8 ) { do { <vul-start> if ( fname >= fe ) { <vul-end> free ( name ) ; return NULL ; } if ( ( c = * fname ++ ) < 0x80 ) x = c ; else { if (",
  "golden_answers": [
   "CWE-22 Fixed Code Lines are: <vul-start>       <vul-end> char * create_output_name <vul-start> * create_output_name ( <vul-end> char * fname <vul-start> char * fname ) { char * out , * p <vul-end> ; if ( <vul-start> ; if ( ( out = malloc ( strlen ( fname ) + 1 <vul-end> ) ) ) <vul-start> ) ) { <vul-end> while ( * <vul-start> * fname == '/' || * fname == '\\\\\\\\' <vul-end> ) fname ++ <vul-start> fname ++ ; strcpy ( out , ( * fname ) ? fname : \"x\" ) ; for ( p = out ; * p ; p ++ ) <vul-end> { if ( <vul-start> { if ( p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\\\\\' <vul-end> ) ) { <vul-start> ) ) { p [ 0 ] = p [ 1 ] = 'x' <vul-end> ; } } <vul-start> ; } } } return out <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start> char * dir, int is_absolute <vul-start> ) x *= 4 <vul-end> ; if ( <vul-start> ( stderr, \"out of memory! (fname=%s)\\\\n\", fname <vul-end> ) ; return <vul-start> ) ; } if ( is_absolute ) { if ( x >= 0x80 ) x = '\\\\\\\\' ; else if ( x == 0xE0 ) x = '\\\\\\\\' ; else if ( x == 0xF0 ) x = * fname ++ ; } else { x = '?' ; } <vul-start> fname ++ ; if ( x < 0x80 ) x = c ; else <vul-end> { do { <vul-start> { if (! is_absolute ) break ; if ( <vul-start> ) ; } if (! x ) free ( name ) ; return NULL ; }\n"
 },
 {
  "id": 1245,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 struct tcp_sock_t * tcp_open ( uint16_t port ) { struct tcp_sock_t * this = calloc ( 1 , sizeof * this ) ; if ( this == NULL ) { <vul-start> ERR ( \"callocing this failed\" ) ; <vul-end> goto error ; } this -> sd = - 1 ; <vul-start> this -> sd = socket ( AF_INET6 , SOCK_STREAM , 0 ) ; <vul-end> if ( this -> sd < 0 ) { <vul-start> ERR ( \"sockect open failed\" ) ; <vul-end> goto error ; } struct sockaddr_in6 addr ; memset ( & addr , 0 , sizeof addr ) ; <vul-start> addr . sin6_family = AF_INET6 ; <vul-end> addr . sin6_port = htons ( port ) ; <vul-start> addr . sin6_addr = in6addr_any ; <vul-end> if ( bind ( this -> sd , ( struct sockaddr * ) & addr , sizeof addr ) < 0 ) { if ( g_options . only_desired_port == 1 ) <vul-start> ERR ( \"Bind on port failed. \" <vul-end> \"Requested port may be taken or require root permissions.\" ) ; goto error ; } if ( listen ( this -> sd , HTTP_MAX_PENDING_CONNS ) < 0 ) { <vul-start> ERR ( \"listen failed on socket\" ) ; <vul-end> goto error ; } return this ; error : if ( this != NULL ) { if ( this -> sd != - 1 ) { close ( this -> sd ) ; } free ( this ) ; } return NULL ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> { ERR ( \"IPv4: callocing this failed\" <vul-end> ) ; goto <vul-start> = socket ( AF_INET <vul-end> , SOCK_STREAM , <vul-start> { ERR ( \"IPv4 socket open failed\" ) ; goto error ; } struct sockaddr_in <vul-end> addr ; memset <vul-start> ; addr . sin_family = AF_INET ; addr . sin_port <vul-end> = htons ( <vul-start> ; addr . sin_addr . s_addr = htonl ( 0x7F000001 ) <vul-end> ; if ( <vul-start> ) ERR ( \"IPv4 bind on port failed. \" <vul-end> \"Requested port may be taken or require root permissions.\" ) ; <vul-start> { ERR ( \"IPv4 listen failed on socket\" <vul-end> ) ; goto\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> NULL ) { goto error <vul-end> ; } this <vul-start> -> sd = TEMP_FAILURE_RETRY ( <vul-start>, 0 ) ) <vul-start> 0 ) { goto error <vul-end> ; } struct <vul-start> addr ) ; memset ( & addr, 0, sizeof addr ) ; <vul-start> sin6_addr = in6addr_any ; if ( bind ( this -> sd, ( struct sockaddr * ) & addr, sizeof addr ) < 0 ) { if ( g_options. only_desired_port == 1 ) ERR ( \"Bind on port failed. \" \"Requested port may be taken or require root permissions.\" ) ; goto error ; } if ( listen ( this -> sd, HTTP_MAX_PENDING_CONNS ) < 0 ) { <vul-start> 0 ) { goto error ; } <vul-end> } return this\n"
 },
 {
  "id": 1246,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void freeClient ( redisClient * c ) { listNode * ln ; sdsfree ( c -> querybuf ) ; c -> querybuf = NULL ; if ( c -> flags & REDIS_BLOCKED ) unblockClientWaitingData ( c ) ; unwatchAllKeys ( c ) ; listRelease ( c -> watched_keys ) ; pubsubUnsubscribeAllChannels ( c , 0 ) ; pubsubUnsubscribeAllPatterns ( c , 0 ) ; dictRelease ( c -> pubsub_channels ) ; listRelease ( c -> pubsub_patterns ) ; aeDeleteFileEvent ( server . el , c -> fd , AE_READABLE ) ; aeDeleteFileEvent ( server . el , c -> fd , AE_WRITABLE ) ; listRelease ( c -> reply ) ; freeClientArgv ( c ) ; close ( c -> fd ) ; ln = listSearchKey ( server . clients , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( server . clients , ln ) ; if ( c -> flags & REDIS_IO_WAIT ) { <vul-start> redisAssert ( server . vm_enabled ) ; <vul-end> if ( listLength ( c -> io_keys ) == 0 ) { ln = listSearchKey ( server . io_ready_clients , c ) ; redisAssert ( ln != NULL ) ; listDelNode ( server . io_ready_clients , ln ) ; } else { while ( listLength ( c -> io_keys ) ) { ln = listFirst ( c -> io_keys ) ; dontWaitForSwappedKey ( c , ln -> value ) ; } } <vul-start> server . vm_blocked_clients -- ; <vul-end> } listRelease ( c -> io_keys ) ; if ( c -> flags & REDIS_SLAVE ) { if",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( server . ds_enabled <vul-end> ) ; if <vul-start> } server . cache_blocked_clients <vul-end> -- ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( server. ds_enabled <vul-end> ) ; if <vul-start> } server. cache_blocked_clients <vul-end> -- ; }\n"
 },
 {
  "id": 1247,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 <vul-start> void oz_hcd_get_desc_cnf ( void * hport , u8 req_id , int status , const u8 * desc , <vul-end> <vul-start> int length , int offset , int total_size ) <vul-end> { struct oz_port * port = hport ; struct urb * urb ; int err = 0 ; oz_dbg ( ON , \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\\\n\" , length , offset , total_size ) ; urb = oz_find_urb_by_id ( port , 0 , req_id ) ; if ( ! urb ) return ; if ( status == 0 ) { <vul-start> int copy_len ; <vul-end> <vul-start> int required_size = urb -> transfer_buffer_length ; <vul-end> if ( required_size > total_size ) required_size = total_size ; copy_len = required_size - offset ; if ( length <= copy_len ) copy_len = length ; memcpy ( urb -> transfer_buffer + offset , desc , copy_len ) ; offset += copy_len ; if ( offset < required_size ) { struct usb_ctrlrequest * setup = ( struct usb_ctrlrequest * ) urb -> setup_packet ; unsigned wvalue = le16_to_cpu ( setup -> wValue ) ; if ( oz_enqueue_ep_urb ( port , 0 , 0 , urb , req_id ) ) err = - ENOMEM ; else if ( oz_usb_get_desc_req ( port -> hpd , req_id , setup -> bRequestType , ( u8 ) ( wvalue >> 8 ) , ( u8 ) wvalue , setup -> wIndex , offset , required_size - offset ) ) { oz_dequeue_ep_urb ( port , 0 , 0 , urb ) ; err = - ENOMEM ; } if ( err",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> u8 req_id , u8 <vul-end> status , const <vul-start> * desc , u8 length , u16 offset , u16 <vul-end> total_size ) { <vul-start> 0 ) { unsigned <vul-start> int copy_len ; unsigned\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> * hport, int <vul-end> req_id, int <vul-start> * desc, size_t length, int offset, size_t <vul-end> total_size ) { <vul-start> 0 ) { size_t <vul-end> required_size = urb <vul-start> urb -> transfer_buffer_length <vul-end> ; if (\n"
 },
 {
  "id": 1248,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static long vfio_pci_ioctl ( void * device_data , unsigned int cmd , unsigned long arg ) { struct vfio_pci_device * vdev = device_data ; unsigned long minsz ; if ( cmd == VFIO_DEVICE_GET_INFO ) { struct vfio_device_info info ; minsz = offsetofend ( struct vfio_device_info , num_irqs ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; info . flags = VFIO_DEVICE_FLAGS_PCI ; if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ; info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ; info . num_irqs = VFIO_PCI_NUM_IRQS ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) { struct pci_dev * pdev = vdev -> pdev ; struct vfio_region_info info ; struct vfio_info_cap caps = { . buf = NULL , . size = 0 } ; int i , ret ; minsz = offsetofend ( struct vfio_region_info , offset ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pdev -> cfg_size ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; case VFIO_PCI_BAR0_REGION_INDEX ...",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> vfio_irq_set hdr ; size_t size ; <vul-start> NULL ; int max , <vul-start> || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <vul-start> - EINVAL ; <vul-end> max = vfio_pci_get_irq_count <vul-start> ; if ( <vul-end> hdr . start <vul-start> count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; u8 * data <vul-end> ; int ret <vul-start> ret = 0 ; size_t flags <vul-start> VFIO_IRQ_SET_DATA_NONE ) ) return - EINVAL ; flags = ( hdr. flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) | ( hdr. flags & VFIO_IRQ_SET_ACTION_TYPE_MASK ) ; if ( flags ) memset ( & caps, 0, sizeof ( caps ) ) ; ret = - EINVAL ; if ( flags ) memset ( & info, 0, sizeof ( info ) ) ; if ( ret ) return ret <vul-end> ; if ( <vul-start>. offset = offset <vul-end> ; ret = <vul-start> ; ret = - EFAULT ; if ( hdr. argsz < minsz ) return - EFAULT ; if ( copy_to_user ( ( void __user * ) arg, & info, minsz )? - EFAULT : 0 ; if ( info. index >= VFIO_PCI_NUM_IRQS ) return - EINVAL ; data = kmalloc ( minsz, GFP_KERNEL ) ; if (! data ) return - ENOMEM ; memcpy ( data, & hdr, sizeof ( hdr ) ) ; if ( data ) memcpy ( data + info. offset, & caps, minsz ) ; kfree ( data ) ; return ret <vul-end> ; } else\n"
 },
 {
  "id": 1249,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int HTMLtagproc1 ( struct parsed_tag * tag , struct html_feed_environ * h_env ) { char * p , * q , * r ; int i , w , x , y , z , count , width ; struct readbuffer * obuf = h_env -> obuf ; struct environment * envs = h_env -> envs ; Str tmp ; int hseq ; int cmd ; # ifdef ID_EXT char * id = NULL ; # endif cmd = tag -> tagid ; if ( obuf -> flag & RB_PRE ) { switch ( cmd ) { case HTML_NOBR : case HTML_N_NOBR : case HTML_PRE_INT : case HTML_N_PRE_INT : return 1 ; } } switch ( cmd ) { case HTML_B : obuf -> in_bold ++ ; if ( obuf -> in_bold > 1 ) return 1 ; return 0 ; case HTML_N_B : if ( obuf -> in_bold == 1 && close_effect0 ( obuf , HTML_B ) ) obuf -> in_bold = 0 ; if ( obuf -> in_bold > 0 ) { obuf -> in_bold -- ; if ( obuf -> in_bold == 0 ) return 0 ; } return 1 ; case HTML_I : obuf -> in_italic ++ ; if ( obuf -> in_italic > 1 ) return 1 ; return 0 ; case HTML_N_I : if ( obuf -> in_italic == 1 && close_effect0 ( obuf , HTML_I ) ) obuf -> in_italic = 0 ; if ( obuf -> in_italic > 0 ) { obuf -> in_italic -- ; if ( obuf -> in_italic == 0 ) return 0 ;",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( h_env -> envc >= MAX_ENV && <vul-start> HTML_DL_COMPACT ) { if ( obuf -> in_under == 1 ) obuf -> in_under = 0 ; if ( obuf -> in_under > 0 ) return 0 ;\n"
 },
 {
  "id": 1250,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int sd_isoc_init ( struct gspca_dev * gspca_dev ) <vul-start> { <vul-end> struct usb_host_interface * alt ; int max_packet_size ; switch ( gspca_dev -> pixfmt . width ) { case 160 : max_packet_size = 450 ; break ; case 176 : max_packet_size = 600 ; break ; default : max_packet_size = 1022 ; break ; } <vul-start> alt = & gspca_dev -> dev -> actconfig -> intf_cache [ 0 ] -> altsetting [ 1 ] ; <vul-end> alt -> endpoint [ 0 ] . desc . wMaxPacketSize = cpu_to_le16 ( max_packet_size ) ; return 0 ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> gspca_dev ) { struct usb_interface_cache * intfc ; <vul-start> break ; } intfc = <vul-end> gspca_dev -> dev <vul-start> [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <vul-start> [ 1 ] ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> gspca_dev ) { struct usb_interface_cache * intfc ; <vul-start> break ; } intfc = <vul-end> gspca_dev -> dev <vul-start> [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <vul-start> [ 1 ] ; if ( alt -> desc. bNumEndpoints < 1 ) return - ENODEV\n"
 },
 {
  "id": 1251,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; <vul-start> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <vul-end> track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> * F_SECT_PER_TRACK ; if ( ! F_SECT_PER_TRACK ) return ;\n"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> * F_SECT_PER_TRACK ; raw_cmd -> size = 0 ;\n"
 },
 {
  "id": 1252,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int sctp_getsockopt_assoc_stats ( struct sock * sk , int len , char __user * optval , int __user * optlen ) { struct sctp_assoc_stats sas ; struct sctp_association * asoc = NULL ; if ( len < sizeof ( sctp_assoc_t ) ) return - EINVAL ; <vul-start> if ( copy_from_user ( & sas , optval , len ) ) <vul-end> return - EFAULT ; asoc = sctp_id2assoc ( sk , sas . sas_assoc_id ) ; if ( ! asoc ) return - EINVAL ; sas . sas_rtxchunks = asoc -> stats . rtxchunks ; sas . sas_gapcnt = asoc -> stats . gapcnt ; sas . sas_outofseqtsns = asoc -> stats . outofseqtsns ; sas . sas_osacks = asoc -> stats . osacks ; sas . sas_isacks = asoc -> stats . isacks ; sas . sas_octrlchunks = asoc -> stats . octrlchunks ; sas . sas_ictrlchunks = asoc -> stats . ictrlchunks ; sas . sas_oodchunks = asoc -> stats . oodchunks ; sas . sas_iodchunks = asoc -> stats . iodchunks ; sas . sas_ouodchunks = asoc -> stats . ouodchunks ; sas . sas_iuodchunks = asoc -> stats . iuodchunks ; sas . sas_idupchunks = asoc -> stats . idupchunks ; sas . sas_opackets = asoc -> stats . opackets ; sas . sas_ipackets = asoc -> stats . ipackets ; sas . sas_maxrto = asoc -> stats . max_obs_rto ; memcpy ( & sas . sas_obs_rto_ipaddr , & asoc -> stats . obs_rto_ipaddr , sizeof ( struct sockaddr_storage ) ) ; asoc -> stats . max_obs_rto = asoc -> rto_min",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> - EINVAL ; len = min_t ( size_t , len , sizeof ( sas ) ) ; <vul-start> -> rto_min ; <vul-end> if ( put_user\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( len > sizeof ( struct sctp_assoc_stats ) ) return - EINVAL ; if ( <vul-start> -> rto_min ; asoc -> stats. obs_rto_bytes = asoc -> stats. obs_rto_bytes ;\n"
 },
 {
  "id": 1253,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; unsigned int npages = DIV_ROUND_UP ( buflen , PAGE_SIZE ) ; int ret = - ENOMEM , i ; if ( npages == 0 ) npages = 1 ; if ( npages > ARRAY_SIZE ( pages ) ) return - ERANGE ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; dprintk ( \"%s buf %p buflen %zu npages %d args.acl_len %zu\\\\n\" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( buf ) { if ( res . acl_len > buflen ) { ret = - ERANGE ; goto out_free ; } <vul-start> acl_len ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> acl_len ) ; out_ok : <vul-start> acl_len ) ; <vul-end> for ( i\n"
 },
 {
  "id": 1254,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static void copy_xauthority ( void ) { char * src = RUN_XAUTHORITY_FILE ; char * dest ; if ( asprintf ( & dest , \"%s/.Xauthority\" , cfg . homedir ) == - 1 ) errExit ( \"asprintf\" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , \"Error: %s is a symbolic link\\\\n\" , dest ) ; exit ( 1 ) ; } <vul-start> pid_t child = fork ( ) ; <vul-end> if ( child < 0 ) errExit ( \"fork\" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <vul-start> if ( rv ) <vul-end> fprintf ( stderr , \"Warning: cannot transfer .Xauthority in private home directory\\\\n\" ) ; else { <vul-start> fs_logger2 ( \"clone\" , dest ) ; <vul-end> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> ) ; } copy_file_as_user <vul-end> ( src , <vul-start> S_IWUSR ) ; <vul-end> fs_logger2 ( \"clone\" <vul-start> \"clone\" , dest <vul-end> ) ; unlink\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> ) ; } copy_file_as_user <vul-end> ( src, <vul-start> S_IWUSR ) ; <vul-end> fs_logger2 ( \"clone\" <vul-start> \"clone\", dest <vul-end> ) ; unlink\n"
 },
 {
  "id": 1255,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static long vbg_misc_device_ioctl ( struct file * filp , unsigned int req , unsigned long arg ) { struct vbg_session * session = filp -> private_data ; size_t returned_size , size ; struct vbg_ioctl_hdr hdr ; bool is_vmmdev_req ; int ret = 0 ; void * buf ; if ( copy_from_user ( & hdr , ( void * ) arg , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ; if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ; size = max ( hdr . size_in , hdr . size_out ) ; if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ; if ( size > SZ_16M ) return - E2BIG ; is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ; if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ; else buf = kmalloc ( size , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; <vul-start> if ( copy_from_user ( buf , ( void * ) arg , hdr . size_in ) ) { <vul-end> ret = - EFAULT ; goto out ; } if ( hdr . size_in < size ) memset ( buf + hdr . size_in , 0 , size - hdr . size_in ) ; ret = vbg_core_ioctl ( session , req",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> - ENOMEM ; * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <vul-start> copy_from_user ( buf + sizeof ( hdr ) <vul-start> * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <vul-end> ) ) {\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ; if ( hdr. size_in < sizeof ( hdr ) ) return - EINVAL ; if (\n"
 },
 {
  "id": 1256,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 <vul-start> static int bson_string_is_db_ref ( const unsigned char * string , const int length ) { <vul-end> int result = 0 ; if ( length >= 4 ) { if ( string [ 1 ] == 'r' && string [ 2 ] == 'e' && string [ 3 ] == 'f' ) result = 1 ; } else if ( length >= 3 ) { if ( string [ 1 ] == 'i' && string [ 2 ] == 'd' ) result = 1 ; else if ( string [ 1 ] == 'd' && string [ 2 ] == 'b' ) result = 1 ; } return result ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> string , const size_t <vul-end> length ) {\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start>       <vul-end> int bson_string_is_db_ref (\n"
 },
 {
  "id": 1257,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <vul-start> # define ThrowDCMException ( exception , message ) { if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <vul-end> char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , *",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> , message ) \\\\\\n{ <vul-end> if ( info <vul-start> ) ) ; \\\\\\n} <vul-end> char explicit_vr [ <vul-start> break ; } if ( <vul-end> fputc ( c <vul-start> , file ) != c ) break\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>, message ) \\\\\\n{ <vul-end> if ( info <vul-start> ) ) ; \\\\\\n} <vul-end> char explicit_vr [ <vul-start> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError, \"InsufficientImageDataInFile\" ) ; if (\n"
 },
 {
  "id": 1258,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int detect_flash ( const struct twopass_rc * twopass , int offset ) { <vul-end> <vul-start> FIRSTPASS_STATS next_frame ; <vul-end> int flash_detected = 0 ; <vul-start> if ( read_frame_stats ( twopass , & next_frame , offset ) != EOF ) { <vul-end> <vul-start> if ( next_frame . pcnt_second_ref > next_frame . pcnt_inter && <vul-end> <vul-start> next_frame . pcnt_second_ref >= 0.5 ) <vul-end> flash_detected = 1 ; } return flash_detected ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> detect_flash ( const TWO_PASS <vul-end> * twopass , <vul-start> offset ) { const FIRSTPASS_STATS * const next_frame = <vul-end> read_frame_stats ( twopass <vul-start> ( twopass , offset ) ; return next_frame != NULL && next_frame -> <vul-end> pcnt_second_ref > next_frame <vul-start> pcnt_second_ref > next_frame -> <vul-end> pcnt_inter && next_frame <vul-start> pcnt_inter && next_frame -> <vul-end> pcnt_second_ref >= 0.5 <vul-start> pcnt_second_ref >= 0.5 <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * twopass, TWO_PASS * const twopass, <vul-start> offset ) { TWO_PASS * const frame = & twopass -> stats. frame [ offset ] <vul-end> ; int flash_detected <vul-start> ; if ( frame <vul-end>!= EOF ) <vul-start> { if ( frame -> <vul-end> pcnt_second_ref > next_frame <vul-start>. pcnt_second_ref > frame -> pcnt_inter && frame -> <vul-end> pcnt_second_ref >= 0.5\n"
 },
 {
  "id": 1259,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 void inode_init_owner ( struct inode * inode , const struct inode * dir , umode_t mode ) { inode -> i_uid = current_fsuid ( ) ; if ( dir && dir -> i_mode & S_ISGID ) { inode -> i_gid = dir -> i_gid ; if ( S_ISDIR ( mode ) ) mode |= S_ISGID ; <vul-start> } else <vul-end> inode -> i_gid = current_fsgid ( ) ; inode -> i_mode = mode ; }",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> |= S_ISGID ; else inode -> i_gid = current_fsgid ( ) ; } else <vul-end> inode -> i_gid\n"
 },
 {
  "id": 1260,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static rfbBool webSocketsHandshake ( rfbClientPtr cl , char * scheme ) { char * buf , * response , * line ; int n , linestart = 0 , len = 0 , llen , base64 = TRUE ; char prefix [ 5 ] , trailer [ 17 ] ; char * path = NULL , * host = NULL , * origin = NULL , * protocol = NULL ; char * key1 = NULL , * key2 = NULL , * key3 = NULL ; char * sec_ws_origin = NULL ; char * sec_ws_key = NULL ; char sec_ws_version = 0 ; ws_ctx_t * wsctx = NULL ; buf = ( char * ) malloc ( WEBSOCKETS_MAX_HANDSHAKE_LEN ) ; if ( ! buf ) { rfbLogPerror ( \"webSocketsHandshake: malloc\" ) ; return FALSE ; } response = ( char * ) malloc ( WEBSOCKETS_MAX_HANDSHAKE_LEN ) ; if ( ! response ) { free ( buf ) ; rfbLogPerror ( \"webSocketsHandshake: malloc\" ) ; return FALSE ; } while ( len < WEBSOCKETS_MAX_HANDSHAKE_LEN - 1 ) { if ( ( n = rfbReadExactTimeout ( cl , buf + len , 1 , WEBSOCKETS_CLIENT_SEND_WAIT_MS ) ) <= 0 ) { if ( ( n < 0 ) && ( errno == ETIMEDOUT ) ) { break ; } if ( n == 0 ) rfbLog ( \"webSocketsHandshake: client gone\\\\n\" ) ; else rfbLogPerror ( \"webSocketsHandshake: read\" ) ; free ( response ) ; free ( buf ) ; return FALSE ; } len += 1 ; llen = len - linestart ; if ( (",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> = base64 ; hybiDecodeCleanup ( wsctx ) ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> = base64 ; if ( len < 2 ) { rfbLog ( \"webSocketsHandshake: too large client handshake\\\\n\" ) ; free ( response ) ; free ( buf ) ; return FALSE ; }\n"
 },
 {
  "id": 1261,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { int vm_shared = dst_vma -> vm_flags & VM_SHARED ; struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; if ( vm_shared ) { struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; spin_lock ( ptl ) ; ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <vul-end> put_page ( page\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; out_release_nounlock : if (! try_get_page ( page ) ) { ret = - ENOMEM ; goto out_release_unlock ; }\n"
 },
 {
  "id": 1262,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int csnmp_read_table ( host_definition_t * host , data_definition_t * data ) { struct snmp_pdu * req ; struct snmp_pdu * res = NULL ; struct variable_list * vb ; const data_set_t * ds ; size_t oid_list_len = data -> values_len + 1 ; oid_t oid_list [ oid_list_len ] ; _Bool oid_list_todo [ oid_list_len ] ; int status ; size_t i ; csnmp_list_instances_t * instance_list_head ; csnmp_list_instances_t * instance_list_tail ; csnmp_table_values_t * * value_list_head ; csnmp_table_values_t * * value_list_tail ; DEBUG ( \"snmp plugin: csnmp_read_table (host = %s, data = %s)\" , host -> name , data -> name ) ; if ( host -> sess_handle == NULL ) { DEBUG ( \"snmp plugin: csnmp_read_table: host->sess_handle == NULL\" ) ; return ( - 1 ) ; } ds = plugin_get_ds ( data -> type ) ; if ( ! ds ) { ERROR ( \"snmp plugin: DataSet `%s\\' not defined.\" , data -> type ) ; return ( - 1 ) ; } if ( ds -> ds_num != data -> values_len ) { ERROR ( \"snmp plugin: DataSet `%s\\' requires %zu values, but config talks \" \"about %zu\" , data -> type , ds -> ds_num , data -> values_len ) ; return ( - 1 ) ; } assert ( data -> values_len > 0 ) ; memcpy ( oid_list , data -> values , data -> values_len * sizeof ( oid_t ) ) ; if ( data -> instance . oid . oid_len > 0 ) memcpy ( oid_list + data -> values_len , & data -> instance . oid , sizeof",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> DEBUG ( \"snmp plugin: all variables have left their subtree\" ) ; snmp_free_pdu ( req <vul-start> = NULL ; <vul-end> sfree ( errstr <vul-start> ; if ( <vul-end> status == 0\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> 0 ) { if (! req ) { ERROR ( \"snmp plugin: request is missing snmp request\" ) ; status = - 1 ; break ; } <vul-end> status = 0 <vul-start> = NULL ; <vul-end> sfree ( errstr\n"
 },
 {
  "id": 1263,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int jas_stream_pad ( jas_stream_t * stream , int n , int c ) { <vul-start> int m ; <vul-end> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> int m ; if ( n < 0 ) { jas_deprecated ( \"negative count for jas_stream_pad\" ) ; }\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> int m ; if ( n < 0 ) { jas_deprecated ( \"negative count for jas_stream_pad\" ) ; }\n"
 },
 {
  "id": 1264,
  "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 int context_init ( SERVICE_OPTIONS * section ) { # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> option . client ) section -> ctx = SSL_CTX_new ( TLS_client_method ( ) ) ; else section -> ctx = SSL_CTX_new ( TLS_server_method ( ) ) ; if ( ! SSL_CTX_set_min_proto_version ( section -> ctx , section -> min_proto_version ) ) { s_log ( LOG_ERR , \"Failed to set the minimum protocol version 0x%X\" , section -> min_proto_version ) ; return 1 ; } if ( ! SSL_CTX_set_max_proto_version ( section -> ctx , section -> max_proto_version ) ) { s_log ( LOG_ERR , \"Failed to set the maximum protocol version 0x%X\" , section -> max_proto_version ) ; return 1 ; } # else if ( section -> option . client ) section -> ctx = SSL_CTX_new ( section -> client_method ) ; else section -> ctx = SSL_CTX_new ( section -> server_method ) ; # endif if ( ! section -> ctx ) { sslerror ( \"SSL_CTX_new\" ) ; return 1 ; } if ( ! SSL_CTX_set_ex_data ( section -> ctx , index_ssl_ctx_opt , section ) ) { sslerror ( \"SSL_CTX_set_ex_data\" ) ; return 1 ; } current_section = section ; <vul-start> if ( section -> cipher_list ) { <vul-end> s_log ( LOG_DEBUG , \"Ciphers: %s\" , section -> cipher_list ) ; if ( ! SSL_CTX_set_cipher_list ( section -> ctx , section -> cipher_list ) ) { sslerror ( \"SSL_CTX_set_cipher_list\" ) ; return 1 ; } } # ifndef OPENSSL_NO_TLS1_3 if ( section -> ciphersuites ) { s_log ( LOG_DEBUG , \"TLSv1.3 ciphersuites: %s\" , section -> ciphersuites",
  "golden_answers": [
   "CWE-295 Fixed Code Lines are: <vul-start> = section ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> security_level >= 0 ) { SSL_CTX_set_security_level ( section -> ctx , section -> security_level ) ; s_log ( LOG_INFO , \"User-specified security level set: %d\" , section -> security_level ) ; } else if ( SSL_CTX_get_security_level ( section -> ctx ) < DEFAULT_SECURITY_LEVEL ) { SSL_CTX_set_security_level ( section -> ctx , DEFAULT_SECURITY_LEVEL ) ; s_log ( LOG_INFO , \"stunnel default security level set: %d\" , DEFAULT_SECURITY_LEVEL ) ; } else { s_log ( LOG_INFO , \"OpenSSL security level is used: %d\" , SSL_CTX_get_security_level ( section -> ctx ) ) ; } # endif <vul-start> return 1 ; # ifndef OPENSSL_NO_TLSEXT <vul-start> . client ) <vul-end> SSL_CTX_set_tlsext_servername_callback ( section <vul-start> ; # endif <vul-end> return 0 ;\n"
  ],
  "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> = section ; <vul-end> # ifndef OPENSSL_NO_TLSEXT <vul-start> ; # endif <vul-end> return 0 ;\n"
 },
 {
  "id": 1265,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> static void <vul-end> ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; if ( length < 3 ) { ND_PRINT ( ( ndo , \" [bad length %u]\" , length ) ) ; <vul-start> return ; <vul-end> } if ( ( length + 1 ) & 3 ) <vul-start> ND_PRINT ( ( ndo , \" [bad length %u]\" , length ) ) ; <vul-end> ptr = cp [ 2 ] - 1 ; if ( ptr < 3 || ( ( ptr + 1 ) & 3 ) || ptr > length + 1 ) ND_PRINT ( ( ndo , \" [bad ptr %u]\" , cp [ 2 ] ) ) ; for ( len = 3 ; len < length ; len += 4 ) { <vul-start> ND_PRINT ( ( ndo , \" %s\" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ; <vul-end> if ( ptr > len ) ND_PRINT ( ( ndo , \",\" ) ) ; <vul-start> } <vul-end> }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start>     static int <vul-end> ip_printroute ( netdissect_options <vul-start> ) ; return ( 0 ) <vul-start> , length ) ) ; ND_TCHECK ( cp [ 2 ] <vul-start> 4 ) { ND_TCHECK2 ( cp [ len ] , 4 ) ; <vul-start> ) ; } return ( 0 ) ; trunc : return ( - 1 ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>     static int <vul-end> ip_printroute ( netdissect_options <vul-start> ) ; return ( 0 ) <vul-start> length ) ) ; if ( cp [ 2 ] < 3 ) return ( 0 ) <vul-start> 4 ) { if ( cp [ len ] > length + 1 ) return ( 0 ) ; <vul-start> ) ) ; return ( 0 ) ; } return ( 1 ) ; <vul-end> }    \n"
 },
 {
  "id": 1266,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void calc_pframe_target_size ( VP8_COMP * cpi ) { int min_frame_target ; int old_per_frame_bandwidth = cpi -> per_frame_bandwidth ; if ( cpi -> current_layer > 0 ) cpi -> per_frame_bandwidth = cpi -> layer_context [ cpi -> current_layer ] . avg_frame_size_for_layer ; min_frame_target = 0 ; if ( cpi -> pass == 2 ) { min_frame_target = cpi -> min_frame_bandwidth ; if ( min_frame_target < ( cpi -> av_per_frame_bandwidth >> 5 ) ) min_frame_target = cpi -> av_per_frame_bandwidth >> 5 ; } else if ( min_frame_target < cpi -> per_frame_bandwidth / 4 ) min_frame_target = cpi -> per_frame_bandwidth / 4 ; if ( ( cpi -> common . refresh_alt_ref_frame ) && ( cpi -> oxcf . number_of_layers == 1 ) ) { if ( cpi -> pass == 2 ) { cpi -> per_frame_bandwidth = cpi -> twopass . gf_bits ; cpi -> this_frame_target = cpi -> per_frame_bandwidth ; } } else { if ( cpi -> pass == 2 ) { cpi -> this_frame_target = cpi -> per_frame_bandwidth ; } else { int Adjustment ; if ( cpi -> kf_overspend_bits > 0 ) { Adjustment = ( cpi -> kf_bitrate_adjustment <= cpi -> kf_overspend_bits ) ? cpi -> kf_bitrate_adjustment : cpi -> kf_overspend_bits ; if ( Adjustment > ( cpi -> per_frame_bandwidth - min_frame_target ) ) Adjustment = ( cpi -> per_frame_bandwidth - min_frame_target ) ; cpi -> kf_overspend_bits -= Adjustment ; cpi -> this_frame_target = cpi -> per_frame_bandwidth - Adjustment ; if ( cpi -> this_frame_target < min_frame_target ) cpi -> this_frame_target = min_frame_target ; } else cpi -> this_frame_target = cpi ->",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ) { Adjustment = <vul-end> ( cpi -> <vul-start> ) * Adjustment ; if ( Adjustment > ( 10 * cpi -> this_frame_target ) / 100 ) Adjustment = ( 10 * cpi -> this_frame_target ) / 100 ; cpi -> this_frame_target += Adjustment ; } <vul-end> else cpi ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> this_frame_target += <vul-end> ( ( cpi\n"
 },
 {
  "id": 1267,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = \"INVALID AS OPTIONS\" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = \"CLIENT EXPIRED\" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = \"CLIENT KEY EXPIRED\" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = \"SERVICE EXPIRED\" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = \"REQUIRED PWCHANGE\" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_KDB_DISALLOW_POSTDATED ) ) ) { * status = \"POSTDATE NOT ALLOWED\" ; return ( KDC_ERR_CANNOT_POSTDATE ) ; } if ( isflagset ( request -> kdc_options , KDC_OPT_PROXIABLE",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ( kdc_active_realm , client . princ <vul-end> , request ->\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> } if ( isflagset ( request -> kdc_options, KDC_OPT_ANON ) &&\n"
 },
 {
  "id": 1268,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int rose_parse_facilities ( unsigned char * p , struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; if ( facilities_len == 0 ) return 0 ; while ( facilities_len > 0 ) { if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ; <vul-start> facilities_len -= len + 1 ; <vul-end> p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ; <vul-start> facilities_len -= len + 1 ; <vul-end> p += len + 1 ; break ; default : printk ( KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\\\n\" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> 1 ) ; if ( len < 0 ) return 0 ; <vul-start> 1 ) ; if ( len < 0 ) return 0 ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 1 ) ; if (! len ) return 0 ; <vul-start> 1 ) ; if (! len ) return 0 ;\n"
 },
 {
  "id": 1269,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) { unsigned char arg [ 128 ] ; int ret = 0 ; <vul-start> if ( ! capable ( CAP_NET_ADMIN ) ) <vul-end> <vul-start> return - EPERM ; <vul-end> if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { pr_err ( \"get_ctl: len %u < %u\\\\n\" , * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; return - EINVAL ; } <vul-start> if ( copy_from_user ( arg , user , get_arglen [ GET_CMDID ( cmd ) ] ) != 0 ) <vul-end> return - EFAULT ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) return - ERESTARTSYS ; switch ( cmd ) { case IP_VS_SO_GET_VERSION : { char buf [ 64 ] ; sprintf ( buf , \"IP Virtual Server version %d.%d.%d (size=%d)\" , NVERSION ( IP_VS_VERSION_CODE ) , IP_VS_CONN_TAB_SIZE ) ; if ( copy_to_user ( user , buf , strlen ( buf ) + 1 ) != 0 ) { ret = - EFAULT ; goto out ; } * len = strlen ( buf ) + 1 ; } break ; case IP_VS_SO_GET_INFO : { struct ip_vs_getinfo info ; info . version = IP_VS_VERSION_CODE ; info . size = IP_VS_CONN_TAB_SIZE ; info . num_services = ip_vs_num_services ; if ( copy_to_user ( user , & info , sizeof ( info ) ) != 0 ) ret = - EFAULT ; } break ; case IP_VS_SO_GET_SERVICES : { struct ip_vs_get_services * get ; int size ; get",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; unsigned int copylen ; <vul-start> return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL <vul-start> EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; <vul-start> , user , copylen <vul-end> ) != 0\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; struct ip_vs_cmd_entry * cmd = ( struct ip_vs_cmd_entry * ) arg ; <vul-start> return - EPERM ; if (! cmd -> handle_data ) return - EINVAL <vul-start>, user, sizeof ( arg ) )!= 0 ) return - EFAULT ; if ( copy_from_user ( arg, user, <vul-start> )!= 0 <vul-end> ) return -\n"
 },
 {
  "id": 1270,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void pgm_print ( netdissect_options * ndo , register const u_char * bp , register u_int length , register const u_char * bp2 ) { register const struct pgm_header * pgm ; register const struct ip * ip ; register char ch ; uint16_t sport , dport ; u_int nla_afnum ; char nla_buf [ INET6_ADDRSTRLEN ] ; register const struct ip6_hdr * ip6 ; uint8_t opt_type , opt_len ; uint32_t seq , opts_len , len , offset ; pgm = ( const struct pgm_header * ) bp ; ip = ( const struct ip * ) bp2 ; if ( IP_V ( ip ) == 6 ) ip6 = ( const struct ip6_hdr * ) bp2 ; else ip6 = NULL ; ch = '\\\\0' ; if ( ! ND_TTEST ( pgm -> pgm_dport ) ) { if ( ip6 ) { ND_PRINT ( ( ndo , \"%s > %s: [|pgm]\" , ip6addr_string ( ndo , & ip6 -> ip6_src ) , ip6addr_string ( ndo , & ip6 -> ip6_dst ) ) ) ; return ; } else { ND_PRINT ( ( ndo , \"%s > %s: [|pgm]\" , ipaddr_string ( ndo , & ip -> ip_src ) , ipaddr_string ( ndo , & ip -> ip_dst ) ) ) ; return ; } } sport = EXTRACT_16BITS ( & pgm -> pgm_sport ) ; dport = EXTRACT_16BITS ( & pgm -> pgm_dport ) ; if ( ip6 ) { if ( ip6 -> ip6_nxt == IPPROTO_PGM ) { ND_PRINT ( ( ndo , \"%s.%s > %s.%s: \" , ip6addr_string ( ndo , & ip6 ->",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , \" [|OPT]\" ) ) ; return ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> return ; } ND_TCHECK_16BITS ( bp ) ;\n"
 },
 {
  "id": 1271,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_rd_pick_intra_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x , <vul-start> int * returnrate , int64_t * returndist , <vul-end> BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; <vul-start> int rate_y = 0 , rate_uv = 0 , rate_y_tokenonly = 0 , rate_uv_tokenonly = 0 ; <vul-end> int y_skip = 0 , uv_skip = 0 ; <vul-start> int64_t dist_y = 0 , dist_uv = 0 , tx_cache [ TX_MODES ] = { 0 } ; <vul-end> TX_SIZE max_uv_tx_size ; x -> skip_encode = 0 ; ctx -> skip = 0 ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = INTRA_FRAME ; <vul-start> if ( bsize >= BLOCK_8X8 ) { <vul-end> if ( rd_pick_intra_sby_mode ( cpi , x , & rate_y , & rate_y_tokenonly , <vul-start> & dist_y , & y_skip , bsize , tx_cache , <vul-end> best_rd ) >= best_rd ) { <vul-start> * returnrate = INT_MAX ; <vul-end> <vul-start> return ; <vul-end> } <vul-start> max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi . tx_size , bsize ) ; <vul-end> rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv , & rate_uv_tokenonly , <vul-start> & dist_uv , & uv_skip , bsize , max_uv_tx_size ) ; <vul-end> <vul-start> } else { <vul-end> y_skip = 0 ; if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) { * returnrate",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * x , RD_COST * rd_cost , <vul-end> BLOCK_SIZE bsize , <vul-start> -> e_mbd ; struct macroblockd_plane * const pd = xd -> plane ; <vul-start> dist_uv = 0 <vul-end> ; TX_SIZE max_uv_tx_size <vul-start> = INTRA_FRAME ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ; <vul-start> , bsize , <vul-end> best_rd ) >= <vul-start> best_rd ) { rd_cost -> rate <vul-end> = INT_MAX ; <vul-start> ; return ; } } else { y_skip = 0 ; if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) { rd_cost -> rate = INT_MAX ; return ; } <vul-start> tx_size , bsize , pd [ 1 ] . subsampling_x , pd [ 1 ] . subsampling_y <vul-start> & uv_skip , MAX ( BLOCK_8X8 , bsize ) , <vul-end> max_uv_tx_size ) ; <vul-start> max_uv_tx_size ) ; <vul-end> if ( y_skip <vul-start> uv_skip ) { rd_cost -> rate <vul-end> = rate_y + <vul-start> 1 ) ; rd_cost -> dist <vul-end> = dist_y + <vul-start> + dist_uv ; } else { rd_cost -> rate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; rd_cost -> dist = dist_y + dist_uv ; } ctx -> mic = * xd -> mi [ 0 ] ; ctx -> mbmi_ext = * x -> mbmi_ext ; rd_cost -> rdcost = RDCOST ( x -> rdmult , x -> rddiv , rd_cost -> rate , rd_cost -> dist ) <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int64_t * returndist <vul-end>, BLOCK_SIZE bsize <vul-start> rate_y_tokenonly = 0 ; int rate_uv = 0 <vul-start> = 0 ; <vul-end> TX_SIZE max_uv_tx_size ; <vul-start> >= BLOCK_8X8 ) <vul-end> if ( rd_pick_intra_sby_mode <vul-start> dist_y, & rate_uv <vul-end>, bsize, <vul-start> ) { * returndist <vul-end> = INT_MAX ; <vul-start> = INT_MAX ; ctx -> skip = 1 ; ctx -> mic = * xd -> mi [ 0 ] ; } else if ( bsize == BLOCK_8X8 ) { max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi. tx_size, bsize ) ; rd_pick_intra_sbuv_mode ( cpi, x, ctx, & rate_y, & rate_y_tokenonly, & dist_y, & best_rd ) >= best_rd ) { * returnrate = INT_MAX ; return ; } xd -> mi [ 0 ] -> mbmi. ref_frame [ 1 ] = INTRA_FRAME ; if ( xd -> mi [ 0 ] -> mbmi. tx_size > bsize ) { vp9_rd_cost_sb ( cpi, x, ctx, & rate_y, & rate_y_tokenonly, & dist_y, & best_rd, ctx, & uv_skip, bsize, ctx -> skip ) ; ctx -> mic = * xd -> mi [ 0 ] ; return ; } dist_y += max_uv_tx_size ; dist_uv = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi. tx_size, bsize ) ; if ( y_skip && uv_skip ) { * returndist = rate_y + rate_uv - rate_y_tokenonly - rate_uv_tokenonly ; ctx -> skip = 1 ; return ; } max_uv_tx_size = get_uv_tx_size_impl ( xd -> mi [ 0 ] -> mbmi. tx_size, bsize ) ; rd_pick_intra_sbuv_mode ( cpi, x, ctx, & rate_"
 },
 {
  "id": 1272,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static Image * ReadCALSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char filename [ MagickPathExtent ] , header [ MagickPathExtent ] , message [ MagickPathExtent ] ; FILE * file ; Image * image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register ssize_t i ; unsigned long density , direction , height , orientation , pel_path , type , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( header , 0 , sizeof ( header ) ) ; density = 0 ; direction = 0 ; orientation = 1 ; pel_path = 0 ; type = 1 ; width = 0 ; height = 0 ; for ( i = 0 ; i < 16 ; i ++ ) { if ( ReadBlob ( image , 128 , ( unsigned char * ) header ) != 128 ) break ; switch ( * header",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> != EOF ) if ( <vul-end> fputc ( c <vul-start> , file ) != c ) break\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start>!= EOF ) { if ( <vul-end> fputc ( c <vul-start>, file )!= c ) break ; } <vul-end> ( void )\n"
 },
 {
  "id": 1273,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> ( ! npages || base_gfn != old . base_gfn\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> out_free ; } new. user_alloc = user_alloc ; new. userspace_addr = mem -> userspace_addr ; if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ;\n"
 },
 {
  "id": 1274,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 void * arm_dma_alloc ( struct device * dev , size_t size , dma_addr_t * handle , gfp_t gfp , struct dma_attrs * attrs ) { <vul-start> pgprot_t prot = __get_dma_pgprot ( attrs , pgprot_kernel ) ; <vul-end> void * memory ; if ( dma_alloc_from_coherent ( dev , size , handle , & memory ) ) return memory ; return __dma_alloc ( dev , size , handle , gfp , prot , false , __builtin_return_address ( 0 ) ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ( attrs , PAGE_KERNEL <vul-end> ) ; void\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( attrs, PAGE_KERNEL <vul-end> ) ; void\n"
 },
 {
  "id": 1275,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int pci_emul_mem_handler ( struct vmctx * ctx , int vcpu , int dir , uint64_t addr , int size , uint64_t * val , void * arg1 , long arg2 ) { struct pci_vdev * pdi = arg1 ; struct pci_vdev_ops * ops = pdi -> dev_ops ; uint64_t offset ; int bidx = ( int ) arg2 ; <vul-start> assert ( bidx <= PCI_BARMAX ) ; <vul-end> <vul-start> assert ( pdi -> bar [ bidx ] . type == PCIBAR_MEM32 || <vul-end> <vul-start> pdi -> bar [ bidx ] . type == PCIBAR_MEM64 ) ; <vul-end> assert ( addr >= pdi -> bar [ bidx ] . addr && addr + size <= pdi -> bar [ bidx ] . addr + pdi -> bar [ bidx ] . size ) ; offset = addr - pdi -> bar [ bidx ] . addr ; if ( dir == MEM_F_WRITE ) { if ( size == 8 ) { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , 4 , * val & 0xffffffff ) ; ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset + 4 , 4 , * val >> 32 ) ; } else { ( * ops -> vdev_barwrite ) ( ctx , vcpu , pdi , bidx , offset , size , bar_value ( size , * val ) ) ; } } else { if ( size == 8 ) { uint64_t val_lo , val_hi ; val_lo = ( * ops",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> ) arg2 ; if ( addr + size > <vul-end> pdi -> bar <vul-start> bidx ] . addr + <vul-end> pdi -> bar <vul-start> bidx ] . size ) { printf ( \"%s, Out of emulated memory range.\\\\n\" , __func__ ) ; return - ESRCH ; } <vul-end> offset = addr\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> ) arg2 ; if <vul-end> ( bidx <= <vul-start> bidx <= PCI_BARMAX ) { pr_err ( \"%s: invalid bar index %d\\\\n\", __func__, bidx ) ; return - 1 ; } if <vul-end> ( pdi -> <vul-start> type == PCIBAR_MEM32 ) { if ( addr >= pdi -> bar [ bidx ]. addr && addr + size <= pdi -> bar [ bidx ]. size ) return - 1 ; } else if ( <vul-end> pdi -> bar <vul-start> type == PCIBAR_MEM64 ) { if ( addr >= pdi -> bar [ bidx ]. addr + pdi -> bar [ bidx ]. size ) return - 1 ; } <vul-end> assert ( addr\n"
 },
 {
  "id": 1276,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int sctp_wait_for_sndbuf ( struct sctp_association * asoc , long * timeo_p , size_t msg_len ) { struct sock * sk = asoc -> base . sk ; int err = 0 ; long current_timeo = * timeo_p ; DEFINE_WAIT ( wait ) ; pr_debug ( \"%s: asoc:%p, timeo:%ld, msg_len:%zu\\\\n\" , __func__ , asoc , * timeo_p , msg_len ) ; sctp_association_hold ( asoc ) ; for ( ; ; ) { prepare_to_wait_exclusive ( & asoc -> wait , & wait , TASK_INTERRUPTIBLE ) ; if ( ! * timeo_p ) goto do_nonblock ; if ( sk -> sk_err || asoc -> state >= SCTP_STATE_SHUTDOWN_PENDING || asoc -> base . dead ) goto do_error ; if ( signal_pending ( current ) ) goto do_interrupted ; if ( msg_len <= sctp_wspace ( asoc ) ) break ; release_sock ( sk ) ; current_timeo = schedule_timeout ( current_timeo ) ; <vul-start> if ( sk != asoc -> base . sk ) <vul-end> goto do_error ; lock_sock ( sk ) ; * timeo_p = current_timeo ; } out : finish_wait ( & asoc -> wait , & wait ) ; sctp_association_put ( asoc ) ; return err ; do_error : err = - EPIPE ; goto out ; do_interrupted : err = sock_intr_errno ( * timeo_p ) ; goto out ; do_nonblock : err = - EAGAIN ; goto out ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> current_timeo ) ; <vul-end> lock_sock ( sk\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> current_timeo ) ; lock_sock ( sk ) ; if ( asoc -> base. sk ) goto do_error <vul-end> ; * timeo_p\n"
 },
 {
  "id": 1277,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; PixelPacket * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> image_info -> ping != MagickFalse <vul-start> goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; if ( ( clone_info = DestroyImageInfo ( clone_info ) ) == ( Image * ) NULL <vul-end> ) goto Finish\n"
 },
 {
  "id": 1278,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; int iskew = imagew - tilew ; uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <vul-start> for ( col = 0 ; col < imagewidth ; col += tw ) { <vul-end> if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , \"Error, can\\'t read tile at %lu %lu\" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf ,",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> col < imagewidth && colb < imagew\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> uint32 col ; if ( row > 0 && row < imagelength ) { TIFFError ( TIFFFileName ( in ), \"Error, can only read %u tiles\", ( unsigned long ) row ) ; status = 0 ; goto done ; }\n"
 },
 {
  "id": 1279,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , \"\\\\122\\\\314\" , 2 ) != 0",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> rows * MagickMax ( number_planes_filled , 4 ) <vul-end> * sizeof ( <vul-start> -> rows * MagickMax ( number_planes_filled , 4 ) <vul-end> ; pixels =\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> \"MemoryAllocationFailed\" ) ; if ( pixel_info_length > ( size_t ) GetVirtualMemorySize ( pixel_info ) ) ThrowReaderException ( ResourceLimitError, \"MemoryAllocationFailed\" ) ; <vul-start> \"MemoryAllocationFailed\" ) ; if ( pixel_info_length > ( size_t ) GetVirtualMemorySize ( pixel_info ) ) ThrowReaderException ( ResourceLimitError, \"MemoryAllocationFailed\" ) <vul-end> ; pixels =\n"
 },
 {
  "id": 1280,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int verify_iovec ( struct msghdr * m , struct iovec * iov , struct sockaddr_storage * address , int mode ) { int size , ct , err ; if ( m -> msg_namelen ) { if ( mode == VERIFY_READ ) { void __user * namep ; namep = ( void __user __force * ) m -> msg_name ; err = move_addr_to_kernel ( namep , m -> msg_namelen , address ) ; if ( err < 0 ) return err ; } <vul-start> m -> msg_name = address ; <vul-end> } else { m -> msg_name = NULL ; } size = m -> msg_iovlen * sizeof ( struct iovec ) ; if ( copy_from_user ( iov , ( void __user __force * ) m -> msg_iov , size ) ) return - EFAULT ; m -> msg_iov = iov ; err = 0 ; for ( ct = 0 ; ct < m -> msg_iovlen ; ct ++ ) { size_t len = iov [ ct ] . iov_len ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return err ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> err ; } if ( m -> msg_name )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> err ; } else { m -> msg_name = NULL ; } <vul-end> size = m\n"
 },
 {
  "id": 1281,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int smb_send_kvec ( struct TCP_Server_Info * server , struct kvec * iov , size_t n_vec , size_t * sent ) { int rc = 0 ; int i = 0 ; struct msghdr smb_msg ; unsigned int remaining ; size_t first_vec = 0 ; struct socket * ssocket = server -> ssocket ; <vul-start> * sent = 0 ; <vul-end> if ( ssocket == NULL ) return - ENOTSOCK ; smb_msg . msg_name = ( struct sockaddr * ) & server -> dstaddr ; smb_msg . msg_namelen = sizeof ( struct sockaddr ) ; smb_msg . msg_control = NULL ; smb_msg . msg_controllen = 0 ; if ( server -> noblocksnd ) smb_msg . msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL ; else smb_msg . msg_flags = MSG_NOSIGNAL ; remaining = 0 ; for ( i = 0 ; i < n_vec ; i ++ ) remaining += iov [ i ] . iov_len ; i = 0 ; while ( remaining ) { rc = kernel_sendmsg ( ssocket , & smb_msg , & iov [ first_vec ] , n_vec - first_vec , remaining ) ; if ( rc == - ENOSPC || rc == - EAGAIN ) { WARN_ON_ONCE ( rc == - ENOSPC ) ; i ++ ; if ( i >= 14 || ( ! server -> noblocksnd && ( i > 2 ) ) ) { cERROR ( 1 , \"sends on sock %p stuck for 15 \" \"seconds\" , ssocket ) ; rc = - EAGAIN ; break ; } msleep ( 1 << i ) ; continue ; } if",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> sent = 0 <vul-end> ; smb_msg .\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> sent = 0 ; if ( server -> noblocksnd == 0 ) return - ENOTSOCK\n"
 },
 {
  "id": 1282,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int parsestr ( struct compiling * c , const node * n , int * bytesmode , int * rawmode , PyObject * * result , const char * * fstr , Py_ssize_t * fstrlen ) { size_t len ; const char * s = STR ( n ) ; int quote = Py_CHARMASK ( * s ) ; int fmode = 0 ; * bytesmode = 0 ; * rawmode = 0 ; * result = NULL ; * fstr = NULL ; if ( Py_ISALPHA ( quote ) ) { while ( ! * bytesmode || ! * rawmode ) { if ( quote == 'b' || quote == 'B' ) { quote = * ++ s ; * bytesmode = 1 ; } else if ( quote == 'u' || quote == 'U' ) { quote = * ++ s ; } else if ( quote == 'r' || quote == 'R' ) { quote = * ++ s ; * rawmode = 1 ; } else if ( quote == 'f' || quote == 'F' ) { quote = * ++ s ; fmode = 1 ; } else { break ; } } } if ( fmode && * bytesmode ) { PyErr_BadInternalCall ( ) ; return - 1 ; } if ( quote != '\\\\'' && quote != \\'\\\\\"\\' ) { PyErr_BadInternalCall ( ) ; return - 1 ; } s ++ ; len = strlen ( s ) ; if ( len > INT_MAX ) { PyErr_SetString ( PyExc_OverflowError , \"string to parse is too long\" )",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 1 ; } if ( fmode && * fstr ) { * fstrlen = len ; return - 1 ; }\n"
 },
 {
  "id": 1283,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) { struct stream_state * stream ; stream = calloc ( 1 , sizeof ( * stream ) ) ; <vul-start> if ( ! stream ) <vul-end> <vul-start> fatal ( \"Failed to allocate new stream.\" ) ; <vul-end> if ( prev ) { memcpy ( stream , prev , sizeof ( * stream ) ) ; stream -> index ++ ; prev -> next = stream ; } else { vpx_codec_err_t res ; <vul-start> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <vul-end> & stream -> config . cfg , global -> usage ) ; if ( res ) fatal ( \"Failed to get config: %s\\\\n\" , vpx_codec_err_to_string ( res ) ) ; stream -> config . cfg . g_timebase . den = 1000 ; stream -> config . cfg . g_w = 0 ; stream -> config . cfg . g_h = 0 ; <vul-start> stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; <vul-end> <vul-start> stream -> config . write_webm = 1 ; <vul-end> # if CONFIG_WEBM_IO <vul-start> stream -> ebml . last_pts_ms = - 1 ; <vul-end> # endif stream -> ebml . debug = global -> debug ; if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ; } stream -> config . out_fn = NULL ; stream -> next = NULL ; return stream ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ; if ( stream == NULL ) { <vul-end> fatal ( \"Failed to allocate new stream.\" <vul-start> \"Failed to allocate new stream.\" ) ; } <vul-start> -> codec -> codec_interface <vul-end> ( ) , <vul-start> -> config . write_webm = 1 ; # if CONFIG_WEBM_IO stream -> config . <vul-start> ; stream -> ebml . last_pts_ns <vul-end> = - 1 <vul-start> = - 1 ; stream -> ebml . writer = NULL ; stream -> ebml . segment = NULL\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) ) ; assert (! stream ) ; <vul-start> ( \"Failed to allocate new stream.\" ) ; struct stream_state * first_stream = NULL <vul-start> vpx_codec_err_t res ; # if CONFIG_VP9_HIGHBITDEPTH if ( global -> codec -> interface ( ) == NULL ) fatal ( \"Failed to get codec interface: %s\\\\n\", vpx_codec_err_to_string ( VPX_CODEC_ERR_TO_STRING ( VPX_CODEC_ERR_TO_STRING ( VPX_CODEC_ERR_TO_STRING ( VPX_CODEC_ERR_TO_STRING ( VPX_CODEC_ERR_DEFAULT ) ) ) ; # else <vul-start> \"Failed to allocate new stream.\" ) ; # endif <vul-start> -> codec -> codec_interface ( ), & stream -> config. cfg, global -> usage ) ; if ( res ) fatal ( \"Failed to get config: %s\\\\n\", vpx_codec_err_to_string ( res ) ) ; # if CONFIG_WEBM_IO <vul-start> -> config. last_pts_ms = - 1 ; # endif <vul-end> stream -> ebml <vul-start> -> ebml. <vul-end> debug = global\n"
 },
 {
  "id": 1284,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , \"\\\\n\\\\t %s option (%u), length %u (%u): \" , tok2str ( icmp6_opt_values , \"unknown\" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ( ndo , \"%s\" , icmp6_tstr <vul-end> ) ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( ndo, \"%s\", icmp6_tstr <vul-end> ) ) ;\n"
 },
 {
  "id": 1285,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int cma_req_handler ( struct ib_cm_id * cm_id , struct ib_cm_event * ib_event ) { struct rdma_id_private * listen_id , * conn_id ; struct rdma_cm_event event ; int offset , ret ; <vul-start> u8 smac [ ETH_ALEN ] ; <vul-end> u8 alt_smac [ ETH_ALEN ] ; u8 * psmac = smac ; u8 * palt_smac = alt_smac ; int is_iboe = ( ( rdma_node_get_transport ( cm_id -> device -> node_type ) == RDMA_TRANSPORT_IB ) && ( rdma_port_get_link_layer ( cm_id -> device , ib_event -> param . req_rcvd . port ) == IB_LINK_LAYER_ETHERNET ) ) ; listen_id = cm_id -> context ; if ( ! cma_check_req_qp_type ( & listen_id -> id , ib_event ) ) return - EINVAL ; if ( cma_disable_callback ( listen_id , RDMA_CM_LISTEN ) ) return - ECONNABORTED ; memset ( & event , 0 , sizeof event ) ; offset = cma_user_data_offset ( listen_id ) ; event . event = RDMA_CM_EVENT_CONNECT_REQUEST ; if ( ib_event -> event == IB_CM_SIDR_REQ_RECEIVED ) { conn_id = cma_new_udp_id ( & listen_id -> id , ib_event ) ; event . param . ud . private_data = ib_event -> private_data + offset ; event . param . ud . private_data_len = IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset ; } else { conn_id = cma_new_conn_id ( & listen_id -> id , ib_event ) ; cma_set_req_event_data ( & event , & ib_event -> param . req_rcvd , ib_event -> private_data , offset ) ; } if ( ! conn_id ) { ret = - ENOMEM ; goto err1 ; } mutex_lock_nested ( & conn_id -> handler_mutex , SINGLE_DEPTH_NESTING ) ; ret = cma_acquire_dev",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> , ret ; <vul-end> listen_id = cm_id <vul-start> goto err3 ; <vul-end> mutex_lock ( & <vul-start> ( & lock <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ret ; u8 * psmac = NULL ; u8 * palt_smac = NULL ; if ( cma_comp ( conn_id, RDMA_CM_CONNECT ) && ( conn_id -> id. qp_type!= IB_QPT_UD ) ) ib_send_cm_mra ( cm_id, CMA_CM_MRA_SETTING, NULL, 0 ) ; if ( conn_id -> id. ib = NULL ; err3 : <vul-end> mutex_lock ( & <vul-start> ( & lock <vul-end> ) ; mutex_unlock\n"
 },
 {
  "id": 1286,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 BOOL transport_accept_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> TlsIn == NULL ) transport -> TlsIn = tls_new ( transport -> settings ) ; if ( transport -> TlsOut == NULL ) transport -> TlsOut = transport -> TlsIn ; transport -> layer = TRANSPORT_LAYER_TLS ; transport -> TlsIn -> sockfd = transport -> TcpIn -> sockfd ; if ( tls_accept ( transport -> TlsIn , transport -> settings -> CertificateFile , transport -> settings -> PrivateKeyFile ) != TRUE ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { fprintf ( stderr , \"client authentication failure\\\\n\" ) ; credssp_free ( transport -> credssp ) ; <vul-start> return FALSE ; <vul-end> } return TRUE ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; transport -> credssp = NULL ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; transport -> credssp = NULL ;\n"
 },
 {
  "id": 1287,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int t220_frontend_attach ( struct dvb_usb_adapter * d ) <vul-end> { u8 obuf [ 3 ] = { 0xe , 0x87 , 0 } ; u8 ibuf [ ] = { 0 } ; <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x86 ; <vul-end> <vul-start> obuf [ 2 ] = 1 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x80 ; <vul-end> <vul-start> obuf [ 2 ] = 0 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> msleep ( 50 ) ; <vul-end> obuf [ 0 ] = 0xe ; obuf [ 1 ] = 0x80 ; obuf [ 2 ] = 1 ; <vul-start> if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> <vul-start> err ( \"command 0x0e transfer failed.\" ) ; <vul-end> obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( \"command 0x0e transfer failed.\" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data <vul-end> [ 2 ] <vul-start> 2 ] = 0 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; msleep ( 50 ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x80 ; state -> data <vul-end> [ 2 ] <vul-start> 2 ] = 1 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data [ 0 ] = 0x51 <vul-end> ; if ( <vul-start> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <vul-end> , 1 , <vul-start> ) err ( <vul-end> \"command 0x51 transfer failed.\" ) ; <vul-start> \"command 0x51 transfer failed.\" ) ; mutex_unlock ( & d -> data_mutex ) ; adap <vul-end> -> fe_adap [ <vul-start> & d -> <vul-end> i2c_adap , NULL <vul-start> ; if ( adap <vul-end> -> fe_adap [ <vul-start> ( tda18271_attach , adap <vul-end> -> fe_adap [ <vul-start> , & d <vul-end> -> i2c_adap ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2636_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 ; mutex_unlock ( & d -> data_mutex ) ; if ( adap -> data [ 0 ]!= 0x86 ) { mutex_unlock ( & d -> data_mutex ) ; err ( \"command 0x0e data not faulted.\" ) ; } <vul-end> if ( dvb_usb_generic_rw <vul-start> -> dev, state -> data <vul-end>, 3, <vul-start>, ibuf, state -> data <vul-end>, 1, <vul-start> \"command 0x0e transfer failed.\" ) ; } mutex_unlock ( & d -> data_mutex ) ; adap -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x86 ; state -> data <vul-end> [ 2 ] <vul-start> = 1 ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x80 ; state -> data <vul-end> [ 2 ] <vul-start> \"command 0x0e transfer failed.\" ) ; mutex_unlock ( & d -> data_mutex ) ; <vul-start> ( 50 ) ; state -> data = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data <vul-end> [ 2 ] <vul-start> = 1 ; mutex_unlock ( & d -> data_mutex ) ; <vul-start> -> dev, state -> data <vul-end>, 3, <vul-start>, ibuf, state -> data <vul-end>, 1, <vul-start> \"command 0x0e transfer failed.\" ) ; mutex_lock ( & d -> data_mutex ) ; <vul-start> 0 ] = state -> data <vul-end> [ 1 ] <vul-start> = 0x51 ; state -> data [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev, state -> data, 1, ibuf, state -> data <vul-end>, 1, <vul-start>, ibuf, state -> data <vul-end>, 1, <vul-start> NULL ) { mutex_unlock ( & d -> data"
 },
 {
  "id": 1288,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int ring_buffer_resize ( struct ring_buffer * buffer , unsigned long size , int cpu_id ) { struct ring_buffer_per_cpu * cpu_buffer ; unsigned long nr_pages ; int cpu , err = 0 ; if ( ! buffer ) return size ; if ( cpu_id != RING_BUFFER_ALL_CPUS && ! cpumask_test_cpu ( cpu_id , buffer -> cpumask ) ) return size ; <vul-start> size = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; <vul-end> size *= BUF_PAGE_SIZE ; if ( size < BUF_PAGE_SIZE * 2 ) size = BUF_PAGE_SIZE * 2 ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( atomic_read ( & buffer -> resize_disabled ) ) return - EBUSY ; mutex_lock ( & buffer -> mutex ) ; if ( cpu_id == RING_BUFFER_ALL_CPUS ) { for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; cpu_buffer -> nr_pages_to_update = nr_pages - cpu_buffer -> nr_pages ; if ( cpu_buffer -> nr_pages_to_update <= 0 ) continue ; INIT_LIST_HEAD ( & cpu_buffer -> new_pages ) ; if ( __rb_allocate_pages ( cpu_buffer -> nr_pages_to_update , & cpu_buffer -> new_pages , cpu ) ) { err = - ENOMEM ; goto out_err ; } } get_online_cpus ( ) ; for_each_buffer_cpu ( buffer , cpu ) { cpu_buffer = buffer -> buffers [ cpu ] ; if ( ! cpu_buffer -> nr_pages_to_update ) continue ; if ( ! cpu_online ( cpu ) ) { rb_update_pages ( cpu_buffer ) ; cpu_buffer -> nr_pages_to_update = 0 ; } else { schedule_work_on ( cpu , & cpu_buffer -> update_pages_work ) ; } } for_each_buffer_cpu ( buffer ,",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> return size ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> return size ; nr_pages = DIV_ROUND_UP ( size, BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = min_t ( unsigned long, nr_pages, size ) <vul-end> ; if (\n"
 },
 {
  "id": 1289,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> horAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; <vul-start> assert ( ( cc % ( 2 * stride ) ) == 0 ) ; <vul-end> if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] = ( uint16 ) ( ( ( unsigned int ) wp [ stride ] + ( unsigned int ) wp [ 0 ] ) & 0xffff ) ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> horAcc16 ( TIFF <vul-start> / 2 ; if <vul-end> ( ( cc <vul-start> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , \"horAcc16\" , \"%s\" , \"cc%(2*stride))!=0\" ) ; return 0 ; } <vul-end> if ( wc <vul-start> ) ; } return 1 ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> horAcc16 ( TIFF <vul-start> / 2 ; if <vul-end> ( ( cc <vul-start> stride ) )!= 0 ) { TIFFErrorExt ( tif -> tif_clientdata, \"horAcc16\", \"%s\", \"(cc%(2*stride))!=0\" ) ; return 0 ; } <vul-end> if ( wc <vul-start> ) ; } return 1 ;\n"
 },
 {
  "id": 1290,
  "question": "CWE-674 Code Input Vulnerable Code Is: CWE-674 int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; <vul-start> ( * re_ast ) -> root_node = NULL ; <vul-end> return ERROR_SUCCESS ; }",
  "golden_answers": [
   "CWE-674 Fixed Code Lines are: <vul-start> re_ast ) -> levels = 0 ; ( * re_ast ) ->\n"
  ],
  "generated_answer": "CWE-674 Fixed Code Lines are: <vul-start> = 0 ; memset ( ( * re_ast ) -> root_node, 0, sizeof ( RE_AST ) ) <vul-end> ; return ERROR_SUCCESS\n"
 },
 {
  "id": 1291,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <vul-start> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <vul-end> duprintf ( \"Bad offset %p\\\\n\" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( \"checking: element %p size %u\\\\n\" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( \"Underflows must be unconditional and \" \"use the STANDARD target with \" \"ACCEPT/DROP\\\\n\" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> struct arpt_entry ) > <vul-end> limit ) {\n"
 },
 {
  "id": 1292,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void lspci_process ( STREAM s ) { unsigned int pkglen ; static char * rest = NULL ; <vul-start> char * buf ; <vul-end> pkglen = s -> end - s -> p ; buf = xmalloc ( pkglen + 1 ) ; STRNCPY ( buf , ( char * ) s -> p , pkglen + 1 ) ; str_handle_lines ( buf , & rest , lspci_process_line , NULL ) ; xfree ( buf ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * buf ; struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( \"lspci_process(), stream is in unstable state\" , & packet ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * buf ; if (! s_check ( s ) ) { rdp_protocol_error ( \"lspci_process(), stream is in unstable state\", s ) ; }\n"
 },
 {
  "id": 1293,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 DECLAREwriteFunc ( writeBufferToContigTiles ) { uint32 imagew = TIFFScanlineSize ( out ) ; uint32 tilew = TIFFTileRowSize ( out ) ; int iskew = imagew - tilew ; tsize_t tilesize = TIFFTileSize ( out ) ; tdata_t obuf ; uint8 * bufp = ( uint8 * ) buf ; uint32 tl , tw ; uint32 row ; ( void ) spp ; obuf = _TIFFmalloc ( TIFFTileSize ( out ) ) ; if ( obuf == NULL ) return 0 ; _TIFFmemset ( obuf , 0 , tilesize ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILELENGTH , & tl ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILEWIDTH , & tw ) ; for ( row = 0 ; row < imagelength ; row += tilelength ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <vul-start> for ( col = 0 ; col < imagewidth ; col += tw ) { <vul-end> if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; int oskew = tilew - width ; cpStripToTile ( obuf , bufp + colb , nrow , width , oskew , oskew + iskew ) ; } else cpStripToTile ( obuf , bufp + colb , nrow , tilew , 0 , iskew ) ; if ( TIFFWriteTile ( out , obuf , col , row , 0 , 0 ) < 0 ) { TIFFError ( TIFFFileName ( out ) , \"Error, can\\'t write tile",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> col < imagewidth && colb < imagew\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> uint32 col ; if ( nrow > 0 && row < imagelength ) { TIFFError ( TIFFFileName ( out ), \"Error, can only write tile %u, %u rows\", row, imagelength ) ; return 0 ; }\n"
 },
 {
  "id": 1294,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void close_output_file ( struct stream_state * stream , unsigned int fourcc ) { const struct vpx_codec_enc_cfg * const cfg = & stream -> config . cfg ; if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ; # if CONFIG_WEBM_IO if ( stream -> config . write_webm ) { <vul-start> write_webm_file_footer ( & stream -> ebml , stream -> hash ) ; <vul-end> free ( stream -> ebml . cue_list ) ; stream -> ebml . cue_list = NULL ; } # endif if ( ! stream -> config . write_webm ) { if ( ! fseek ( stream -> file , 0 , SEEK_SET ) ) ivf_write_file_header ( stream -> file , & stream -> config . cfg , fourcc , stream -> frames_out ) ; } fclose ( stream -> file ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> stream -> ebml ) <vul-end> ; } #\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> write_webm ) { if ( stream -> ebml. cue_list!= NULL )\n"
 },
 {
  "id": 1295,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void encode_uniform ( vp9_writer * w , int v ) { <vul-end> const int l = 8 ; const int m = ( 1 << l ) - 191 ; if ( v < m ) { <vul-start> vp9_write_literal ( w , v , l - 1 ) ; <vul-end> } else { <vul-start> vp9_write_literal ( w , m + ( ( v - m ) >> 1 ) , l - 1 ) ; <vul-end> <vul-start> vp9_write_literal ( w , ( v - m ) & 1 , 1 ) ; <vul-end> } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> void encode_uniform ( vpx_writer <vul-end> * w , <vul-start> m ) { vpx_write_literal <vul-end> ( w , <vul-start> } else { vpx_write_literal <vul-end> ( w , <vul-start> 1 ) ; vpx_write_literal <vul-end> ( w ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> void encode_uniform ( vpx_writer <vul-end> * w, <vul-start> m ) { vpx_write_literal <vul-end> ( w, <vul-start> } else { vpx_write_literal <vul-end> ( w, <vul-start> 1 ) ; vpx_write_literal <vul-end> ( w,\n"
 },
 {
  "id": 1296,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 uint32_t virtio_config_readw ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint16_t val ; <vul-start> k -> get_config ( vdev , vdev -> config ) ; <vul-end> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = lduw_p ( vdev -> config + addr ) ; return val ; }",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> uint16_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <vul-start> -> config ) <vul-end> ; val =\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> uint16_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <vul-start> -> config ) <vul-end> ; val =\n"
 },
 {
  "id": 1297,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) { struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ; struct tipc_link_info link_info ; int err ; if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ; err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ; if ( err ) return err ; link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ; link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ; <vul-start> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <vul-end> return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; nla_strlcpy <vul-end> ( link_info . <vul-start> TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; if (! link_info. str ) return - EINVAL ;\n"
 },
 {
  "id": 1298,
  "question": "CWE-59 Code Input Vulnerable Code Is: CWE-59 static int setup_ttydir_console ( const struct lxc_rootfs * rootfs , const struct lxc_console * console , char * ttydir ) { char path [ MAXPATHLEN ] , lxcpath [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , \"%s/dev/%s\" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( path ) ) return - 1 ; ret = mkdir ( path , 0755 ) ; if ( ret && errno != EEXIST ) { SYSERROR ( \"failed with errno %d to create %s\" , errno , path ) ; return - 1 ; } INFO ( \"created %s\" , path ) ; ret = snprintf ( lxcpath , sizeof ( lxcpath ) , \"%s/dev/%s/console\" , rootfs -> mount , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( \"console path too long\" ) ; return - 1 ; } snprintf ( path , sizeof ( path ) , \"%s/dev/console\" , rootfs -> mount ) ; ret = unlink ( path ) ; if ( ret && errno != ENOENT ) { SYSERROR ( \"error unlinking %s\" , path ) ; return - 1 ; } ret = creat ( lxcpath , 0660 ) ; if ( ret == - 1 && errno != EEXIST ) { SYSERROR ( \"error %d creating %s\" , errno , lxcpath ) ; return - 1 ; } if ( ret >= 0 ) close ( ret ) ; if ( console -> master < 0 ) { INFO ( \"no console\"",
  "golden_answers": [
   "CWE-59 Fixed Code Lines are: <vul-start> } if ( safe_mount ( console -> name , lxcpath , \"none\" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( \"failed to mount \\'%s\\' on \\'%s\\'\" , <vul-end> console -> name <vul-start> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , \"%s/console\" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( \"lxc/console path too long\" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( \"failed to create symlink for console\" ) ; return - 1 ; } INFO ( \"console has been setup on %s\" , lxcpath ) ; return 0 <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-59 Fixed Code Lines are: <vul-start> } if ( safe_mount <vul-end> ( console ->\n"
 },
 {
  "id": 1299,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 <vul-start> static void nsc_decode ( NSC_CONTEXT * context ) <vul-end> { UINT16 x ; UINT16 y ; <vul-start> UINT16 rw = ROUND_UP_TO ( context -> width , 8 ) ; <vul-end> <vul-start> BYTE shift = context -> ColorLossLevel - 1 ; <vul-end> <vul-start> BYTE * bmpdata = context -> BitmapData ; <vul-end> for ( y = 0 ; y < context -> height ; y ++ ) { const BYTE * yplane ; const BYTE * coplane ; const BYTE * cgplane ; const BYTE * aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; if ( context -> ChromaSubsamplingLevel ) { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + ( y >> 1 ) * ( rw >> 1 ) ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + ( y >> 1 ) * ( rw >> 1 ) ; } else { yplane = context -> priv -> PlaneBuffers [ 0 ] + y * context -> width ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * context -> width ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * context -> width ; } for ( x = 0 ; x < context -> width ; x ++ ) { INT16 y_val = ( INT16 ) * yplane ; INT16 co_val = ( INT16 ) ( INT8 ) ( * coplane << shift",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start>     static BOOL <vul-end> nsc_decode ( NSC_CONTEXT <vul-start> ; UINT16 rw ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <vul-start> 8 ) ; <vul-end> shift = context <vul-start> - 1 ; <vul-end> bmpdata = context <vul-start> context -> BitmapData ; if ( ! bmpdata ) return FALSE <vul-start> - cg_val ; if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <vul-start> ; } } return TRUE ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>     static BOOL <vul-end> nsc_decode ( NSC_CONTEXT <vul-start> UINT16 y ; const <vul-start> 8 ) ; if (! context ) return FALSE ; <vul-start> - 1 ; const <vul-start> ; } } return TRUE ;\n"
 },
 {
  "id": 1300,
  "question": "CWE-763 Code Input Vulnerable Code Is: CWE-763 <vul-start> static void atomic2gen ( lua_State * L , global_State * g ) { <vul-end> sweep2old ( L , & g -> allgc ) ; g -> reallyold = g -> old = g -> survival = g -> allgc ; sweep2old ( L , & g -> finobj ) ; g -> finobjrold = g -> finobjold = g -> finobjsur = g -> finobj ; sweep2old ( L , & g -> tobefnz ) ; g -> gckind = KGC_GEN ; g -> lastatomic = 0 ; g -> GCestimate = gettotalbytes ( g ) ; finishgencycle ( L , g ) ; }",
  "golden_answers": [
   "CWE-763 Fixed Code Lines are: <vul-start> g ) { g -> gcstate = GCSswpallgc ;\n"
  ],
  "generated_answer": "CWE-763 Fixed Code Lines are: <vul-start> g ) { luaL_checkstack ( L, 1, \"in function atomic2gen\" ) ;\n"
 },
 {
  "id": 1301,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp8dx_start_decode ( BOOL_DECODER * br , const unsigned char * source , unsigned int source_sz , <vul-start> vp8_decrypt_cb * decrypt_cb , <vul-end> void * decrypt_state ) { br -> user_buffer_end = source + source_sz ; br -> user_buffer = source ; br -> value = 0 ; br -> count = - 8 ; br -> range = 255 ; br -> decrypt_cb = decrypt_cb ; br -> decrypt_state = decrypt_state ; if ( source_sz && ! source ) return 1 ; vp8dx_bool_decoder_fill ( br ) ; return 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int source_sz , vpx_decrypt_cb <vul-end> decrypt_cb , void\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int source_sz, vpx_decrypt_cb <vul-end> decrypt_cb, void\n"
 },
 {
  "id": 1302,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static OM_uint32 acc_ctx_cont ( OM_uint32 * minstat , gss_buffer_t buf , gss_ctx_id_t * ctx , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * return_token ) { OM_uint32 ret , tmpmin ; gss_OID supportedMech ; spnego_gss_ctx_id_t sc ; unsigned int len ; unsigned char * ptr , * bufstart ; sc = ( spnego_gss_ctx_id_t ) * ctx ; ret = GSS_S_DEFECTIVE_TOKEN ; * negState = REJECT ; * minstat = 0 ; supportedMech = GSS_C_NO_OID ; * return_token = ERROR_TOKEN_SEND ; * responseToken = * mechListMIC = GSS_C_NO_BUFFER ; ptr = bufstart = buf -> value ; # define REMAIN ( buf -> length - ( ptr - bufstart ) ) <vul-start> if ( REMAIN > INT_MAX ) <vul-end> return GSS_S_DEFECTIVE_TOKEN ; if ( * ptr == HEADER_ID ) { ret = g_verify_token_header ( gss_mech_spnego , & len , & ptr , 0 , REMAIN ) ; if ( ret ) { * minstat = ret ; return GSS_S_DEFECTIVE_TOKEN ; } } if ( * ptr != ( CONTEXT | 0x01 ) ) { return GSS_S_DEFECTIVE_TOKEN ; } ret = get_negTokenResp ( minstat , ptr , REMAIN , negState , & supportedMech , responseToken , mechListMIC ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; if ( * responseToken == GSS_C_NO_BUFFER && * mechListMIC == GSS_C_NO_BUFFER ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } if ( supportedMech != GSS_C_NO_OID ) { ret = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } sc -> firstpass = 0 ; * negState = ACCEPT_INCOMPLETE ; * return_token = CONT_TOKEN_SEND ; cleanup",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> if ( REMAIN == 0 || REMAIN\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( REMAIN > INT_MAX || REMAIN < 0\n"
 },
 {
  "id": 1303,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int check_alu_op ( struct bpf_verifier_env * env , struct bpf_insn * insn ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode == BPF_END || opcode == BPF_NEG ) { if ( opcode == BPF_NEG ) { if ( BPF_SRC ( insn -> code ) != 0 || insn -> src_reg != BPF_REG_0 || insn -> off != 0 || insn -> imm != 0 ) { verbose ( env , \"BPF_NEG uses reserved fields\\\\n\" ) ; return - EINVAL ; } } else { if ( insn -> src_reg != BPF_REG_0 || insn -> off != 0 || ( insn -> imm != 16 && insn -> imm != 32 && insn -> imm != 64 ) || BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { verbose ( env , \"BPF_END uses reserved fields\\\\n\" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , \"R%d pointer arithmetic prohibited\\\\n\" , insn -> dst_reg ) ; return - EACCES ; } err = check_reg_arg ( env , insn -> dst_reg , DST_OP ) ; if ( err ) return err ; } else if ( opcode == BPF_MOV ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 || insn",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> dst_reg ) ; coerce_reg_to_size <vul-end> ( & regs <vul-start> -> dst_reg ] , 4\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> dst_reg ) ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <vul-start> 4 ) ; } else { regs [ insn -> dst_reg ]. var_off = 0 ; }\n"
 },
 {
  "id": 1304,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 <vul-start> WORD32 ih264d_end_of_pic ( dec_struct_t * ps_dec , <vul-end> UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num ) { dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; <vul-start> WORD32 ret ; <vul-end> ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } } H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ret = ih264d_end_of_pic_processing ( ps_dec ) ; if ( ret != OK ) return ret ; <vul-start> ps_dec -> u2_total_mbs_coded = 0 ; <vul-end> { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ret = ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; if ( ret != OK ) return ret ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ;",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> dec_struct_t * ps_dec <vul-end> ) { dec_slice_params_t <vul-start> ; WORD32 ret <vul-end> ; { dec_err_status_t <vul-start> return ret ; <vul-end> H264_MUTEX_UNLOCK ( &\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>       WORD32 <vul-end> ih264d_end_of_pic ( dec_struct_t <vul-start> ; WORD32 ret <vul-end> ; { dec_err_status_t <vul-start> return ret ; <vul-end> { pocstruct_t * <vul-start> -> ps_cur_slice ; ps_dec -> u2_total_mbs_coded = 0 ;\n"
 },
 {
  "id": 1305,
  "question": "CWE-674 Code Input Vulnerable Code Is: CWE-674 static void renameColumnFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; RenameCtx sCtx ; const char * zSql = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zTable = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; int iCol = sqlite3_value_int ( argv [ 5 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 6 ] ) ; int bQuote = sqlite3_value_int ( argv [ 7 ] ) ; int bTemp = sqlite3_value_int ( argv [ 8 ] ) ; const char * zOld ; int rc ; Parse sParse ; Walker sWalker ; Index * pIdx ; int i ; Table * pTab ; # ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; # endif UNUSED_PARAMETER ( NotUsed ) ; if ( zSql == 0 ) return ; if ( zTable == 0 ) return ; if ( zNew == 0 ) return ; if ( iCol < 0 ) return ; sqlite3BtreeEnterAll ( db ) ; pTab = sqlite3FindTable ( db , zTable , zDb ) ; if ( pTab == 0 || iCol >= pTab -> nCol ) { sqlite3BtreeLeaveAll ( db ) ; return ; } zOld = pTab -> aCol [ iCol ] . zName ; memset ( & sCtx , 0 , sizeof (",
  "golden_answers": [
   "CWE-674 Fixed Code Lines are: <vul-start> pSelect ) { pSelect -> selFlags &= ~ SF_View ; <vul-start> & sParse , <vul-end> pSelect , 0\n"
  ],
  "generated_answer": "CWE-674 Fixed Code Lines are: <vul-start> pSelect ) { Select * pSelect = sParse. pNewTable -> pSelect ; <vul-start> = SQLITE_OK ; if ( pSelect -> selFlags & SF_View ) { Select * pSelect = pSelect -> selFlags ; if ( pSelect -> selFlags & SF_View ) { renameColumnFunc_done ( & sParse, pSelect ) ; } }\n"
 },
 {
  "id": 1306,
  "question": "CWE-552 Code Input Vulnerable Code Is: CWE-552 static ssize_t _consolefs_write ( oe_fd_t * file_ , const void * buf , size_t count ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( file_ ) ; <vul-start> if ( ! file ) <vul-end> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_syscall_write_ocall ( & ret , file -> host_fd , buf , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <vul-start> done : <vul-end> return ret ; }",
  "golden_answers": [
   "CWE-552 Fixed Code Lines are: <vul-start> ( ! file || count > OE_SSIZE_MAX <vul-start> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }\n"
  ],
  "generated_answer": "CWE-552 Fixed Code Lines are: <vul-start> (! file || count > OE_SSIZE_MAX <vul-start> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }\n"
 },
 {
  "id": 1307,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int i915_gem_do_execbuffer ( struct drm_device * dev , void * data , struct drm_file * file , struct drm_i915_gem_execbuffer2 * args , struct drm_i915_gem_exec_object2 * exec ) { drm_i915_private_t * dev_priv = dev -> dev_private ; struct list_head objects ; struct eb_objects * eb ; struct drm_i915_gem_object * batch_obj ; struct drm_clip_rect * cliprects = NULL ; struct intel_ring_buffer * ring ; u32 exec_start , exec_len ; u32 seqno ; u32 mask ; int ret , mode , i ; if ( ! i915_gem_check_execbuffer ( args ) ) { DRM_DEBUG ( \"execbuf with invalid offset/length\\\\n\" ) ; return - EINVAL ; } ret = validate_exec_list ( exec , args -> buffer_count ) ; if ( ret ) return ret ; switch ( args -> flags & I915_EXEC_RING_MASK ) { case I915_EXEC_DEFAULT : case I915_EXEC_RENDER : ring = & dev_priv -> ring [ RCS ] ; break ; case I915_EXEC_BSD : if ( ! HAS_BSD ( dev ) ) { DRM_DEBUG ( \"execbuf with invalid ring (BSD)\\\\n\" ) ; return - EINVAL ; } ring = & dev_priv -> ring [ VCS ] ; break ; case I915_EXEC_BLT : if ( ! HAS_BLT ( dev ) ) { DRM_DEBUG ( \"execbuf with invalid ring (BLT)\\\\n\" ) ; return - EINVAL ; } ring = & dev_priv -> ring [ BCS ] ; break ; default : DRM_DEBUG ( \"execbuf with unknown ring: %d\\\\n\" , ( int ) ( args -> flags & I915_EXEC_RING_MASK ) ) ; return - EINVAL ; } mode = args -> flags & I915_EXEC_CONSTANTS_MASK ; mask = I915_EXEC_CONSTANTS_MASK ; switch (",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> DRM_DEBUG ( \"clip rectangles are only valid with the render ring\\\\n\" ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( \"execbuf with %u cliprects\\\\n\" , args -> num_cliprects\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> DRM_DEBUG ( \"clip rectangles are only valid with the render ring\\\\n\" ) ; return - EINVAL ; } if ( args -> num_cliprects > I915_MAX_EXEC_CWE-189 Fixed Code Lines are: <vul-start> ] ) { DRM_ERROR <vul-end> ( \"clip rectangles are only valid with the render ring\\\\n\" )\n"
 },
 {
  "id": 1308,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static inline int ldsem_cmpxchg ( long * old , long new , struct ld_semaphore * sem ) { <vul-start> long tmp = * old ; <vul-end> * old = atomic_long_cmpxchg ( & sem -> count , * old , new ) ; <vul-start> return * old == tmp ; <vul-end> }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> long tmp = <vul-end> atomic_long_cmpxchg ( & <vul-start> new ) ; if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; } <vul-end> }    \n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> sem ) { unsigned <vul-start> new ) ; if ( * old == new ) return 1 ;\n"
 },
 {
  "id": 1309,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= POLLERR | ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) mask |= POLLRDHUP | POLLIN | POLLRDNORM ; if ( sk -> sk_shutdown == SHUTDOWN_MASK ) mask |= POLLHUP ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= POLLIN | POLLRDNORM ; if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( sk -> sk_state == TCP_CLOSE ) mask |= POLLHUP ; if ( sk -> sk_state == TCP_SYN_SENT ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) return mask ; writable = unix_writable ( sk ) ; <vul-start> other = unix_peer_get ( sk ) ; <vul-end> if ( other ) { <vul-start> if ( unix_peer ( other ) != sk ) { <vul-end> sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ; <vul-start> if ( unix_recvq_full ( other ) ) <vul-end> writable = 0 ; <vul-start> } <vul-end> sock_put ( other ) ; } if ( writable ) mask |= POLLOUT | POLLWRNORM |",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> sk ) ; if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <vul-end> other ) != <vul-start> ) != sk && <vul-end> unix_recvq_full ( other <vul-start> ( other ) && unix_dgram_peer_wake_me ( sk , other ) <vul-start> = 0 ; unix_state_unlock ( sk <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> sk ) ; if ( writable ) mask |= POLLOUT | POLLWRNORM | POLLWRBAND ; <vul-start> { if ( unix_dgram_peer_wake_disconnect ( sk, other ) ) goto out ; <vul-end> sock_poll_wait ( file <vul-start> ( unix_recvq_full ( sk <vul-end> ) ) writable <vul-start> = 0 ; <vul-end> sock_put ( other\n"
 },
 {
  "id": 1310,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static void numtostr ( js_State * J , const char * fmt , int w , double n ) { <vul-start> char buf [ 32 ] , * e ; <vul-end> sprintf ( buf , fmt , w , n ) ; e = strchr ( buf , 'e' ) ; if ( e ) { int exp = atoi ( e + 1 ) ; sprintf ( e , \"e%+d\" , exp ) ; } js_pushstring ( J , buf ) ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> char buf [ 50 <vul-end> ] , *\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char buf [ 64 <vul-end> ], *\n"
 },
 {
  "id": 1311,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static __u8 * nci_extract_rf_params_nfcf_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfcf_poll * nfcf_poll , __u8 * data ) { nfcf_poll -> bit_rate = * data ++ ; <vul-start> nfcf_poll -> sensf_res_len = * data ++ ; <vul-end> pr_debug ( \"bit_rate %d, sensf_res_len %d\\\\n\" , nfcf_poll -> bit_rate , nfcf_poll -> sensf_res_len ) ; memcpy ( nfcf_poll -> sensf_res , data , nfcf_poll -> sensf_res_len ) ; data += nfcf_poll -> sensf_res_len ; return data ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> -> sensf_res_len = min_t ( __u8 , <vul-start> * data ++ , NFC_SENSF_RES_MAXSIZE )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> sensf_res_len = min_t ( __u8, <vul-start> * data ++, NFC_NFCF_SNS_RES_LEN )\n"
 },
 {
  "id": 1312,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static ssize_t ucma_process_join ( struct ucma_file * file , struct rdma_ucm_join_mcast * cmd , int out_len ) { struct rdma_ucm_create_id_resp resp ; struct ucma_context * ctx ; struct ucma_multicast * mc ; struct sockaddr * addr ; int ret ; u8 join_state ; if ( out_len < sizeof ( resp ) ) return - ENOSPC ; addr = ( struct sockaddr * ) & cmd -> addr ; if ( cmd -> addr_size != rdma_addr_size ( addr ) ) return - EINVAL ; if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER ) join_state = BIT ( FULLMEMBER_JOIN ) ; else if ( cmd -> join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER ) join_state = BIT ( SENDONLY_FULLMEMBER_JOIN ) ; else return - EINVAL ; ctx = ucma_get_ctx_dev ( file , cmd -> id ) ; if ( IS_ERR ( ctx ) ) return PTR_ERR ( ctx ) ; mutex_lock ( & file -> mut ) ; mc = ucma_alloc_multicast ( ctx ) ; if ( ! mc ) { ret = - ENOMEM ; goto err1 ; } mc -> join_state = join_state ; mc -> uid = cmd -> uid ; memcpy ( & mc -> addr , addr , cmd -> addr_size ) ; ret = rdma_join_multicast ( ctx -> cm_id , ( struct sockaddr * ) & mc -> addr , join_state , mc ) ; if ( ret ) goto err2 ; resp . id = mc -> id ; if ( copy_to_user ( u64_to_user_ptr ( cmd -> response ) , & resp , sizeof ( resp ) ) ) { ret = - EFAULT ;",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> err3 ; } mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> err3 ; } mutex_unlock ( & file -> mut ) ;\n"
 },
 {
  "id": 1313,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int selectExpander ( Walker * pWalker , Select * p ) { Parse * pParse = pWalker -> pParse ; int i , j , k ; SrcList * pTabList ; ExprList * pEList ; struct SrcList_item * pFrom ; sqlite3 * db = pParse -> db ; Expr * pE , * pRight , * pExpr ; u16 selFlags = p -> selFlags ; u32 elistFlags = 0 ; p -> selFlags |= SF_Expanded ; if ( db -> mallocFailed ) { return WRC_Abort ; } assert ( p -> pSrc != 0 ) ; if ( ( selFlags & SF_Expanded ) != 0 ) { return WRC_Prune ; } if ( pWalker -> eCode ) { p -> selId = ++ pParse -> nSelect ; } pTabList = p -> pSrc ; pEList = p -> pEList ; sqlite3WithPush ( pParse , p -> pWith , 0 ) ; sqlite3SrcListAssignCursors ( pParse , pTabList ) ; for ( i = 0 , pFrom = pTabList -> a ; i < pTabList -> nSrc ; i ++ , pFrom ++ ) { Table * pTab ; assert ( pFrom -> fg . isRecursive == 0 || pFrom -> pTab != 0 ) ; if ( pFrom -> fg . isRecursive ) continue ; assert ( pFrom -> pTab == 0 ) ; # ifndef SQLITE_OMIT_CTE if ( withExpand ( pWalker , pFrom ) ) return WRC_Abort ; if ( pFrom -> pTab ) { } else # endif if ( pFrom -> zName == 0 ) { # ifndef SQLITE_OMIT_SUBQUERY Select * pSel",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> } if ( pParse -> nErr ||\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> } if ( pParse -> nErr ) return WRC_Prune ; if (\n"
 },
 {
  "id": 1314,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int em_sysexit ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; <vul-start> u64 msr_data ; <vul-end> int usermode ; u16 cs_sel = 0 , ss_sel = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_gp ( ctxt , 0 ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ( ctxt -> rex_prefix & 0x8 ) != 0x0 ) usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ; <vul-start> cs . dpl = 3 ; <vul-end> ss . dpl = 3 ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( usermode ) { case X86EMUL_MODE_PROT32 : cs_sel = ( u16 ) ( msr_data + 16 ) ; if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = ( u16 ) ( msr_data + 24 ) ; break ; case X86EMUL_MODE_PROT64 : cs_sel = ( u16 ) ( msr_data + 32 ) ; if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = cs_sel + 8 ; cs . d = 0 ; cs . l = 1 ; <vul-start> break ; <vul-end> } cs_sel |= SELECTOR_RPL_MASK ; ss_sel |= SELECTOR_RPL_MASK ; ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; <vul-start>",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; u64 msr_data , rcx , rdx <vul-start> = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <vul-start> = 1 ; if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <vul-start> -> _eip = rdx <vul-end> ; * reg_write <vul-start> VCPU_REGS_RSP ) = rcx <vul-end> ; return X86EMUL_CONTINUE\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ss ; u64 eip <vul-end> ; int usermode <vul-start> = X86EMUL_MODE_PROT32 ; eip = get_eip ( ctxt ) ; if ( eip < 3 ) return emulate_gp ( ctxt, 0 ) ; <vul-start> = 1 ; } else { <vul-end> cs_sel |= SELECTOR_RPL_MASK <vul-start> VCPU_SREG_SS ) ; } <vul-start> -> _eip = eip <vul-end> ; * reg_write <vul-start> VCPU_REGS_RSP ) = eip <vul-end> ; return X86EMUL_CONTINUE\n"
 },
 {
  "id": 1315,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { <vul-start> struct packet_sock * po = pkt_sk ( sk ) ; <vul-end> struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } <vul-start> if ( ! po -> running ) <vul-end> <vul-start> return - EINVAL ; <vul-end> if ( po -> fanout ) <vul-start> return - EALREADY ; <vul-end> if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { <vul-start> po -> rollover = kzalloc ( sizeof ( * po -> rollover ) , GFP_KERNEL ) ; <vul-end> <vul-start> if ( ! po -> rollover ) <vul-end> return - ENOMEM ; <vul-start> atomic_long_set ( & po -> rollover -> num , 0 ) ; <vul-end> <vul-start> atomic_long_set ( & po -> rollover -> num_huge , 0 ) ; <vul-end> <vul-start> atomic_long_set ( & po -> rollover -> num_failed , 0 ) ; <vul-end> <vul-start> } <vul-end> mutex_lock ( & fanout_mutex ) ; match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { if ( f -> id == id && read_pnet ( & f -> net ) == sock_net ( sk ) ) { match = f ; break",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ) { struct packet_rollover * rollover = NULL ; struct <vul-start> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <vul-start> -> running ) goto out ; err = - EALREADY <vul-end> ; if ( <vul-start> -> fanout ) goto out <vul-end> ; if ( <vul-start> ) ) { err = - ENOMEM ; <vul-end> rollover = kzalloc <vul-start> sizeof ( * <vul-end> rollover ) , <vul-start> if ( ! rollover ) goto out <vul-end> ; atomic_long_set ( <vul-start> atomic_long_set ( & <vul-end> rollover -> num <vul-start> atomic_long_set ( & <vul-end> rollover -> num_huge <vul-start> atomic_long_set ( & <vul-end> rollover -> num_failed <vul-start> 0 ) ; po -> rollover = rollover ; } <vul-end> match = NULL <vul-start> } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <vul-start> fanout_mutex ) ; <vul-end> return err ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ( sk ) ; struct packet_fanout * rollover <vul-start> EINVAL ; } mutex_lock ( & fanout_mutex ) ; <vul-start> -> running ) { err = <vul-end> - EALREADY ; <vul-start> - EALREADY ; goto out ; } <vul-start> ) ) { <vul-end> rollover = kzalloc <vul-start> ; if (! rollover ) { err = <vul-end> - ENOMEM ; <vul-start> - ENOMEM ; goto out ; } <vul-start> 0 ) ; goto out ; } <vul-end> rollover -> num_huge <vul-start> 0 ) ; goto out ; } err = - EINVAL ; <vul-start> } out : if ( err ) { <vul-start> fanout_mutex ) ; <vul-end> kfree ( po\n"
 },
 {
  "id": 1316,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static inline int mk_vhost_fdt_open ( int id , unsigned int hash , struct session_request * sr ) { int i ; int fd ; struct vhost_fdt_hash_table * ht = NULL ; struct vhost_fdt_hash_chain * hc ; if ( config -> fdt == MK_FALSE ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } ht = mk_vhost_fdt_table_lookup ( id , sr -> host_conf ) ; if ( mk_unlikely ( ! ht ) ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } hc = mk_vhost_fdt_chain_lookup ( hash , ht ) ; if ( hc ) { hc -> readers ++ ; return hc -> fd ; } fd = open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; if ( fd == - 1 ) { return - 1 ; } if ( ht -> av_slots <= 0 ) { return fd ; } for ( i = 0 ; i < VHOST_FDT_HASHTABLE_CHAINS ; i ++ ) { hc = & ht -> chain [ i ] ; if ( hc -> fd == - 1 ) { hc -> fd = fd ; hc -> hash = hash ; hc -> readers ++ ; ht -> av_slots -- ; sr -> vhost_fdt_id = id ; sr -> vhost_fdt_hash = hash ; <vul-start> return fd ; <vul-end> } } return - 1 ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> = hash ; sr -> fd_is_fdt = MK_TRUE ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = hash ; sr -> vhost_fdt_flags = 0 ;\n"
 },
 {
  "id": 1317,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int vp8_denoiser_allocate ( VP8_DENOISER * denoiser , int width , int height ) <vul-end> { int i ; <vul-start> assert ( denoiser ) ; <vul-end> for ( i = 0 ; i < MAX_REF_FRAMES ; i ++ ) { denoiser -> yv12_running_avg [ i ] . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & ( denoiser -> yv12_running_avg [ i ] ) , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } <vul-start> vpx_memset ( denoiser -> yv12_running_avg [ i ] . buffer_alloc , 0 , <vul-end> denoiser -> yv12_running_avg [ i ] . frame_size ) ; } denoiser -> yv12_mc_running_avg . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & ( denoiser -> yv12_mc_running_avg ) , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } <vul-start> vpx_memset ( denoiser -> yv12_mc_running_avg . buffer_alloc , 0 , <vul-end> denoiser -> yv12_mc_running_avg . frame_size ) ; <vul-start> return 0 ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , int height , int num_mb_rows , int num_mb_cols , int mode <vul-start> ( denoiser ) ; denoiser -> num_mb_cols = num_mb_cols <vul-start> 1 ; } memset <vul-end> ( denoiser -> <vul-start> 1 ; } memset <vul-end> ( denoiser -> <vul-start> frame_size ) ; if ( vp8_yv12_alloc_frame_buffer ( & denoiser -> yv12_last_source , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } memset ( denoiser -> yv12_last_source . buffer_alloc , 0 , denoiser -> yv12_last_source . frame_size ) ; denoiser -> denoise_state = vpx_calloc ( ( num_mb_rows * num_mb_cols ) , 1 ) ; memset ( denoiser -> denoise_state , 0 , ( num_mb_rows * num_mb_cols ) ) ; vp8_denoiser_set_parameters ( denoiser , mode ) ; denoiser -> nmse_source_diff = 0 ; denoiser -> nmse_source_diff_count = 0 ; denoiser -> qp_avg = 0 ; denoiser -> qp_threshold_up = 80 ; denoiser -> qp_threshold_down = 128 ; denoiser -> bitrate_threshold = 400000 ; denoiser -> threshold_aggressive_mode = 80 ; if ( width * height > 1280 * 720 ) { denoiser -> bitrate_threshold = 3000000 ; denoiser -> threshold_aggressive_mode = 200 ; } else if ( width * height > 960 * 540 ) { denoiser -> bitrate_threshold = 1200000 ; denoiser -> threshold_aggressive_mode = 120 ; } else if ( width * height > 640 * 480 ) { denoiser -> bitrate_threshold = 600000 ; denoiser -> threshold_aggressive_mode = 100 ; } return <vul-end> 0 ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>       void <vul-end> vp8_denoiser_allocate ( VP8_DENOISER <vul-start> int i ; <vul-end> for ( i <vul-start> 1 ; } memset <vul-end> ( denoiser -> <vul-start> 1 ; } memset <vul-end> ( denoiser -> <vul-start> frame_size ) ; <vul-end> }    \n"
 },
 {
  "id": 1318,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void btif_config_flush ( void ) { assert ( config != NULL ) ; assert ( alarm_timer != NULL ) ; alarm_cancel ( alarm_timer ) ; <vul-start> pthread_mutex_lock ( & lock ) ; <vul-end> config_save ( config , CONFIG_FILE_PATH ) ; pthread_mutex_unlock ( & lock ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> alarm_timer ) ; btif_config_write ( <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> alarm_timer ) ; config_flush_all ( config <vul-end> ) ; }\n"
 },
 {
  "id": 1319,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int db_dict_iter_lookup_key_values ( struct db_dict_value_iter * iter ) { struct db_dict_iter_key * key ; string_t * path ; const char * error ; int ret ; array_sort ( & iter -> keys , db_dict_iter_key_cmp ) ; path = t_str_new ( 128 ) ; str_append ( path , DICT_PATH_SHARED ) ; array_foreach_modifiable ( & iter -> keys , key ) { if ( ! key -> used ) continue ; str_truncate ( path , strlen ( DICT_PATH_SHARED ) ) ; <vul-start> ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; <vul-end> <vul-start> if ( ret <= 0 ) { <vul-end> <vul-start> auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , <vul-end> <vul-start> \"Failed to expand key %s: %s\" , key -> key -> key , error ) ; <vul-end> return - 1 ; } <vul-start> ret = dict_lookup ( iter -> conn -> dict , iter -> pool , <vul-end> str_c ( path ) , & key -> value , & error ) ; if ( ret > 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , \"Lookup: %s = %s\" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , \"Failed to lookup key %s: %s\" , str_c ( path ) , error ) ; return - 1 ; } else if ( key -> key -> default_value != NULL ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , \"Lookup: %s not found,",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ) ) ; str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <vul-end> , & error <vul-start> if ( ret > <vul-end> 0 ) { <vul-start> 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , \"Lookup: %s = %s\" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <vul-start> , AUTH_SUBSYS_DB , \"Failed to lookup key %s: %s\" , str_c ( path ) <vul-end> , error ) <vul-start> 1 ; } <vul-end> else if (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) ) ; if ( iter -> var_expand_table == NULL ) { auth_request_log_error ( iter -> auth_request, AUTH_SUBSYS_DB, \"Lookup: No such key %s\", str_c ( path ) ) ; return - 1 ; } ret = var_expand_recursive <vul-end> ( path, <vul-start>, iter -> var_expand_table, & error, iter -> conn -> dict, iter -> pool <vul-end>, & error <vul-start> ; if ( error!= NULL && <vul-start> 0 ) { <vul-end> return - 1 <vul-start> 1 ; } if ( ret == 0 ) { auth_request_log_error ( iter -> auth_request, AUTH_SUBSYS_DB, \"Failed to expand key %s: %s\", str_c ( path ), error ) ; return - 1 ; }\n"
 },
 {
  "id": 1320,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int kex_input_kexinit ( int type , u_int32_t seq , void * ctxt ) { struct ssh * ssh = ctxt ; struct kex * kex = ssh -> kex ; const u_char * ptr ; u_int i ; size_t dlen ; int r ; debug ( \"SSH2_MSG_KEXINIT received\" ) ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ; <vul-start> ptr = sshpkt_ptr ( ssh , & dlen ) ; <vul-end> if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ; for ( i = 0 ; i < KEX_COOKIE_LEN ; i ++ ) if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 ) return r ; for ( i = 0 ; i < PROPOSAL_MAX ; i ++ ) if ( ( r = sshpkt_get_string ( ssh , NULL , NULL ) ) != 0 ) return r ; if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_u32 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) return r ; if ( ! ( kex -> flags & KEX_INIT_SENT ) ) if ( ( r = kex_send_kexinit ( ssh ) ) != 0 ) return r ; if ( ( r = kex_choose_conf ( ssh ) ) != 0 ) return r ; if ( kex -> kex_type < KEX_MAX && kex -> kex [ kex -> kex_type ] != NULL ) return ( kex ->",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> return SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> return SSH_ERR_INVALID_ARGUMENT ; if ( ( r = kex_set_peer ( kex, seq, NULL ) )!= 0 ) return r ;\n"
 },
 {
  "id": 1321,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int mpeg4video_probe ( AVProbeData * probe_packet ) { uint32_t temp_buffer = - 1 ; int VO = 0 , VOL = 0 , VOP = 0 , VISO = 0 , res = 0 ; int i ; for ( i = 0 ; i < probe_packet -> buf_size ; i ++ ) { temp_buffer = ( temp_buffer << 8 ) + probe_packet -> buf [ i ] ; <vul-start> if ( ( temp_buffer & 0xffffff00 ) != 0x100 ) <vul-end> continue ; if ( temp_buffer == VOP_START_CODE ) VOP ++ ; else if ( temp_buffer == VISUAL_OBJECT_START_CODE ) VISO ++ ; <vul-start> else if ( temp_buffer < 0x120 ) <vul-end> VO ++ ; <vul-start> else if ( temp_buffer < 0x130 ) <vul-end> VOL ++ ; else if ( ! ( 0x1AF < temp_buffer && temp_buffer < 0x1B7 ) && ! ( 0x1B9 < temp_buffer && temp_buffer < 0x1C4 ) ) res ++ ; } if ( VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0 ) return AVPROBE_SCORE_EXTENSION ; return 0 ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ; if ( temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <vul-end> ) continue ; <vul-start> if ( temp_buffer >= 0x100 && temp_buffer <vul-start> else if ( temp_buffer >= 0x120 &&\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> & 0xffffff00 ) == 0x100 <vul-end> ) continue ; <vul-start> ( temp_buffer < 0x120U <vul-end> ) VO ++ <vul-start> ( temp_buffer < 0x130U <vul-end> ) VOL ++\n"
 },
 {
  "id": 1322,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 SYSCALL_DEFINE5 ( perf_event_open , struct perf_event_attr __user * , attr_uptr , pid_t , pid , int , cpu , int , group_fd , unsigned long , flags ) { struct perf_event * group_leader = NULL , * output_event = NULL ; struct perf_event * event , * sibling ; struct perf_event_attr attr ; struct perf_event_context * ctx , * uninitialized_var ( gctx ) ; struct file * event_file = NULL ; struct fd group = { NULL , 0 } ; struct task_struct * task = NULL ; struct pmu * pmu ; int event_fd ; int move_group = 0 ; int err ; int f_flags = O_RDWR ; int cgroup_fd = - 1 ; if ( flags & ~ PERF_FLAG_ALL ) return - EINVAL ; err = perf_copy_attr ( attr_uptr , & attr ) ; if ( err ) return err ; if ( ! attr . exclude_kernel ) { if ( perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EACCES ; } if ( attr . freq ) { if ( attr . sample_freq > sysctl_perf_event_sample_rate ) return - EINVAL ; } else { if ( attr . sample_period & ( 1ULL << 63 ) ) return - EINVAL ; } if ( ! attr . sample_max_stack ) attr . sample_max_stack = sysctl_perf_event_max_stack ; if ( ( flags & PERF_FLAG_PID_CGROUP ) && ( pid == - 1 || cpu == - 1 ) ) return - EINVAL ; if ( flags & PERF_FLAG_FD_CLOEXEC ) f_flags |= O_CLOEXEC ; event_fd = get_unused_fd_flags ( f_flags ) ; if ( event_fd <",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> { gctx = __perf_event_ctx_lock_double ( group_leader , ctx <vul-end> ) ; if <vul-start> err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <vul-start> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <vul-end> ) ; mutex_unlock <vul-start> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <vul-end> ) ; mutex_unlock\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> move_group ) { if (! ctx -> task ) { err = - EINVAL ; goto err_locked ; } <vul-start> } else { if (! ctx -> task ) { err = - EINVAL ; goto err_locked ; }\n"
 },
 {
  "id": 1323,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static u64 __skb_get_nlattr_nest ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; if ( skb_is_nonlinear ( skb ) ) return 0 ; <vul-start> if ( A > skb -> len - sizeof ( struct nlattr ) ) <vul-end> return 0 ; nla = ( struct nlattr * ) & skb -> data [ A ] ; <vul-start> if ( nla -> nla_len > A - skb -> len ) <vul-end> return 0 ; nla = nla_find_nested ( nla , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> ; if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <vul-start> -> nla_len > <vul-end> skb -> len <vul-start> skb -> len - A\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> skb -> len <vul-end> ) return 0 <vul-start> skb -> len ) return 0 ; if ( skb -> len < nla -> nla_len\n"
 },
 {
  "id": 1324,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int em_jmp_far ( struct x86_emulate_ctxt * ctxt ) { int rc ; <vul-start> unsigned short sel ; <vul-end> memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; <vul-start> rc = load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS ) ; <vul-end> if ( rc != X86EMUL_CONTINUE ) return rc ; <vul-start> ctxt -> _eip = 0 ; <vul-end> <vul-start> memcpy ( & ctxt -> _eip , ctxt -> src . valptr , ctxt -> op_bytes ) ; <vul-end> <vul-start> return X86EMUL_CONTINUE ; <vul-end> }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <vul-start> ; rc = __load_segment_descriptor <vul-end> ( ctxt , <vul-start> sel , VCPU_SREG_CS , cpl , false , & new_desc <vul-start> return rc ; rc = assign_eip_far ( ctxt <vul-end> , ctxt -> <vul-start> -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS <vul-end> ) ; return <vul-start> ) ; return rc ; } return rc <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> unsigned short sel ; unsigned long eip <vul-start> 2 ) ; eip = <vul-end> ctxt -> src <vul-start> ctxt -> src. <vul-end> valptr + ctxt <vul-start> ctxt -> op_bytes ; if ( rc!= X86EMUL_CONTINUE ) return rc ; rc = load_segment_descriptor ( ctxt, eip <vul-start> return rc ; rc = assign_eip_near ( ctxt, eip <vul-end> ) ; memcpy <vul-start> memcpy ( & eip <vul-end>, ctxt -> <vul-start> ) ; return rc <vul-end> ; }  \n"
 },
 {
  "id": 1325,
  "question": "CWE-682 Code Input Vulnerable Code Is: CWE-682 static int find_low_bit ( unsigned int x ) { int i ; for ( i = 0 ; i <= 31 ; i ++ ) { <vul-start> if ( x & ( 1 << i ) ) return i ; <vul-end> } return 0 ; }",
  "golden_answers": [
   "CWE-682 Fixed Code Lines are: <vul-start> x & ( 1U << ( unsigned int ) <vul-end> i ) )\n"
  ],
  "generated_answer": "CWE-682 Fixed Code Lines are: <vul-start> x & ( 1U << ( unsigned int ) <vul-end> i ) )\n"
 },
 {
  "id": 1326,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 int connection_exit_begin_conn ( cell_t * cell , circuit_t * circ ) { edge_connection_t * n_stream ; relay_header_t rh ; char * address = NULL ; uint16_t port = 0 ; <vul-start> or_circuit_t * or_circ = NULL ; <vul-end> const or_options_t * options = get_options ( ) ; begin_cell_t bcell ; int rv ; uint8_t end_reason = 0 ; assert_circuit_ok ( circ ) ; <vul-start> if ( ! CIRCUIT_IS_ORIGIN ( circ ) ) <vul-end> <vul-start> or_circ = TO_OR_CIRCUIT ( circ ) ; <vul-end> relay_header_unpack ( & rh , cell -> payload ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) return - END_CIRC_REASON_TORPROTOCOL ; if ( ! server_mode ( options ) && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , \"Relay begin cell at non-server. Closing.\" ) ; relay_send_end_cell_from_edge ( rh . stream_id , circ , END_STREAM_REASON_EXITPOLICY , NULL ) ; return 0 ; } rv = begin_cell_parse ( cell , & bcell , & end_reason ) ; if ( rv < - 1 ) { return - END_CIRC_REASON_TORPROTOCOL ; } else if ( rv == - 1 ) { tor_free ( bcell . address ) ; <vul-start> relay_send_end_cell_from_edge ( rh . stream_id , circ , end_reason , NULL ) ; <vul-end> return 0 ; } if ( ! bcell . is_begindir ) { address = bcell . address ; port = bcell . port ; if ( or_circ && or_circ -> p_chan ) { if ( ! options -> AllowSingleHopExits && ( or_circ -> is_first_hop || ( ! connection_or_digest_is_known_relay ( or_circ -> p_chan -> identity_digest ) && should_refuse_unknown_exits (",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> or_circuit_t * or_circ = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <vul-start> circ ) ) { <vul-start> circ ) ; } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <vul-start> , end_reason , layer_hint <vul-end> ) ; return <vul-start> , END_STREAM_REASON_NOTDIRECTORY , layer_hint <vul-end> ) ; return <vul-start> , END_STREAM_REASON_INTERNAL , layer_hint <vul-end> ) ; return <vul-start> , END_STREAM_REASON_EXITPOLICY , layer_hint <vul-end> ) ; return <vul-start> CIRCUIT_PURPOSE_S_REND_JOINED ) { tor_assert ( origin_circ <vul-end> ) ; log_info <vul-start> , END_STREAM_REASON_DONE , layer_hint <vul-end> ) ; connection_free\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> = 0 ; volatile <vul-start> circ ) ) { or_circ = NULL ; } <vul-end> relay_header_unpack ( & <vul-start>, circ, END_STREAM_REASON_NOTDIRECTORY <vul-end>, NULL ) <vul-start> NULL ) ; } <vul-start>, circ, END_STREAM_REASON_INTERNAL <vul-end>, NULL )\n"
 },
 {
  "id": 1327,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void unix_copy_addr ( struct msghdr * msg , struct sock * sk ) { <vul-start> struct unix_sock * u = unix_sk ( sk ) ; <vul-end> msg -> msg_namelen = 0 ; if ( u -> addr ) { msg -> msg_namelen = u -> addr -> len ; memcpy ( msg -> msg_name , u -> addr -> name , u -> addr -> len ) ; } }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( sk ) <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( sk ) ; msg -> msg_namelen = 0\n"
 },
 {
  "id": 1328,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int xstateregs_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void __user * ubuf ) { struct fpu * fpu = & target -> thread . fpu ; struct xregs_state * xsave ; int ret ; if ( ! boot_cpu_has ( X86_FEATURE_XSAVE ) ) return - ENODEV ; if ( ( pos != 0 ) || ( count < fpu_user_xstate_size ) ) return - EFAULT ; xsave = & fpu -> state . xsave ; fpu__activate_fpstate_write ( fpu ) ; if ( boot_cpu_has ( X86_FEATURE_XSAVES ) ) { if ( kbuf ) ret = copy_kernel_to_xstate ( xsave , kbuf ) ; else ret = copy_user_to_xstate ( xsave , ubuf ) ; } else { ret = user_regset_copyin ( & pos , & count , & kbuf , & ubuf , xsave , 0 , - 1 ) ; <vul-start> } <vul-end> if ( ret ) fpstate_init ( & fpu -> state ) ; xsave -> i387 . mxcsr &= mxcsr_feature_mask ; xsave -> header . xfeatures &= xfeatures_mask ; memset ( & xsave -> header . reserved , 0 , 48 ) ; return ret ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> 1 ) ; if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> 1 ) ; if (! ret && xsave -> header. xcomp_bv ) ret = - EINVAL ;\n"
 },
 {
  "id": 1329,
  "question": "CWE-285 Code Input Vulnerable Code Is: CWE-285 static int v9fs_xattr_set_acl ( const struct xattr_handler * handler , struct dentry * dentry , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { int retval ; struct posix_acl * acl ; struct v9fs_session_info * v9ses ; v9ses = v9fs_dentry2v9ses ( dentry ) ; if ( ( v9ses -> flags & V9FS_ACCESS_MASK ) != V9FS_ACCESS_CLIENT ) return v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( value ) { acl = posix_acl_from_xattr ( & init_user_ns , value , size ) ; if ( IS_ERR ( acl ) ) return PTR_ERR ( acl ) ; else if ( acl ) { retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ; if ( retval ) goto err_out ; } } else acl = NULL ; switch ( handler -> flags ) { case ACL_TYPE_ACCESS : if ( acl ) { <vul-start> umode_t mode = inode -> i_mode ; <vul-end> retval = posix_acl_equiv_mode ( acl , & mode ) ; if ( retval < 0 ) goto err_out ; <vul-start> else { <vul-end> struct iattr iattr ; if ( retval == 0 ) { acl = NULL ; value = NULL ; size = 0 ; } iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ;",
  "golden_answers": [
   "CWE-285 Fixed Code Lines are: <vul-start> acl ) { struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval <vul-end> ) goto err_out <vul-start> goto err_out ; if ( ! acl ) { value = NULL ; size = 0 ; } <vul-end> iattr . ia_valid <vul-start> iattr ) ; <vul-end> } break ;\n"
  ],
  "generated_answer": "CWE-285 Fixed Code Lines are: <vul-start> { umode_t mode ; retval = posix_acl_update_mode ( inode, & inode -> i_mode, & acl ) ; if ( retval <vul-end> ) goto err_out <vul-start> goto err_out ; <vul-end> iattr. ia_mode <vul-start> iattr ) ; <vul-end> } break ;\n"
 },
 {
  "id": 1330,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static Image * ReadICONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { IconFile icon_file ; IconInfo icon_info ; Image * image ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bit , byte , bytes_per_line , one , scanline_pad ; ssize_t count , offset , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } icon_file . reserved = ( short ) ReadBlobLSBShort ( image ) ; icon_file . resource_type = ( short ) ReadBlobLSBShort ( image ) ; icon_file . count = ( short ) ReadBlobLSBShort ( image ) ; if ( ( icon_file . reserved != 0 ) || ( ( icon_file . resource_type != 1 ) && ( icon_file . resource_type != 2 ) ) || ( icon_file . count > MaxIcons ) ) ThrowReaderException ( CorruptImageError , \"ImproperImageHeader\" ) ; for ( i = 0 ; i < icon_file . count ; i ++ ) { icon_file .",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , \"MemoryAllocationFailed\" )\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> * png ; if ( EOFBlob ( image )!= MagickFalse ) ThrowReaderException ( CorruptImageError, \"UnexpectedEndOfFile\" ) ;\n"
 },
 {
  "id": 1331,
  "question": "CWE-290 Code Input Vulnerable Code Is: CWE-290 static int valid_host ( cupsd_client_t * con ) { cupsd_alias_t * a ; cupsd_netif_t * netif ; const char * end ; char * ptr ; strlcpy ( con -> clientname , httpGetField ( con -> http , HTTP_FIELD_HOST ) , sizeof ( con -> clientname ) ) ; if ( ( ptr = strrchr ( con -> clientname , ':' ) ) != NULL && ! strchr ( ptr , ']' ) ) { * ptr ++ = '\\\\0' ; con -> clientport = atoi ( ptr ) ; } else con -> clientport = con -> serverport ; if ( httpAddrLocalhost ( httpGetAddress ( con -> http ) ) ) { return ( ! _cups_strcasecmp ( con -> clientname , \"localhost\" ) || ! _cups_strcasecmp ( con -> clientname , \"localhost.\" ) || <vul-start> # ifdef __linux <vul-end> ! _cups_strcasecmp ( con -> clientname , \"localhost.localdomain\" ) || # endif ! strcmp ( con -> clientname , \"127.0.0.1\" ) || ! strcmp ( con -> clientname , \"[::1]\" ) ) ; } # if defined ( HAVE_DNSSD ) || defined ( HAVE_AVAHI ) if ( ( end = strrchr ( con -> clientname , '.' ) ) != NULL && end > con -> clientname && ! end [ 1 ] ) { for ( end -- ; end > con -> clientname && * end != '.' ; end -- ) ; } if ( end && ( ! _cups_strcasecmp ( end , \".local\" ) || ! _cups_strcasecmp ( end , \".local.\" ) ) ) return ( 1 ) ; # endif",
  "golden_answers": [
   "CWE-290 Fixed Code Lines are: <vul-start> \"localhost.\" ) || <vul-end> ! strcmp (\n"
  ],
  "generated_answer": "CWE-290 Fixed Code Lines are: <vul-start> \"localhost.\" ) || <vul-end>! strcmp (\n"
 },
 {
  "id": 1332,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> INST_HANDLER ( lds ) { <vul-end> int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; __generic_ld_st ( op , \"ram\" , 0 , 1 , 0 , k , 0 ) ; ESIL_A ( \"r%d,=,\" , d ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> lds ) { if ( len < 4 ) { return ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> lds ) { if ( len < 4 ) { return ; }\n"
 },
 {
  "id": 1333,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } <vul-start> EVP_MD_CTX_init ( & ctx ) ; <vul-end> if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; }",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> 1 ; } if (! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ), & mdnid, & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY, ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } <vul-start> ( & ctx <vul-end> ) ; if\n"
 },
 {
  "id": 1334,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 MagickExport const char * GetMagickFeatures ( void ) { return \"DPC\" <vul-start> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <vul-end> \" Modules\" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) <vul-start> \" HDRI\" <vul-end> # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) \" OpenCL\" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) \" OpenMP\" # endif <vul-start> ; <vul-end> }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) \" Debug\" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) \" Cipher\" <vul-end> # endif # <vul-start> MAGICKCORE_HDRI_SUPPORT ) \" HDRI\" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) \" Modules\" <vul-start> \" OpenMP\" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) \" Zero-configuration\" # endif\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> return \"DPC\" # if defined ( MAGICKCORE_OPENCL_SUPPORT ) \"OpenCL\" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) \"OpenMP\" # endif # <vul-start> MAGICKCORE_HDRI_SUPPORT ) \" HDRI\" # else # if defined ( MAGICKCORE_BUILD_MODULES ) \"Build Modules\" # endif <vul-end> # if defined <vul-start> MAGICKCORE_OPENMP_SUPPORT ) \"OpenMP\" # endif <vul-end> # if defined <vul-start> \"HDRI\" # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) \"OpenCL\" # endif <vul-start> # if defined ( MAGICKCORE_OPENMP_SUPPORT ) \" OpenMP\" # endif\n"
 },
 {
  "id": 1335,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void receive_carbon ( void * * state ) { prof_input ( \"/carbons on\" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( \"<iq id=\\'*\\' type=\\'set\\'><enable xmlns=\\'urn:xmpp:carbons:2\\'/></iq>\" ) ) ; stbbr_send ( \"<presence to=\\'stabber@localhost\\' from=\\'buddy1@localhost/mobile\\'>\" \"<priority>10</priority>\" \"<status>On my mobile</status>\" \"</presence>\" ) ; assert_true ( prof_output_exact ( \"Buddy1 (mobile) is online, \\\\\"On my mobile\\\\\"\" ) ) ; prof_input ( \"/msg Buddy1\" ) ; assert_true ( prof_output_exact ( \"unencrypted\" ) ) ; stbbr_send ( <vul-start> \"<message type=\\'chat\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost\\'>\" <vul-end> \"<received xmlns=\\'urn:xmpp:carbons:2\\'>\" \"<forwarded xmlns=\\'urn:xmpp:forward:0\\'>\" \"<message id=\\'prof_msg_7\\' xmlns=\\'jabber:client\\' type=\\'chat\\' lang=\\'en\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost/mobile\\'>\" \"<body>test carbon from recipient</body>\" \"</message>\" \"</forwarded>\" \"</received>\" \"</message>\" ) ; assert_true ( prof_output_regex ( \"Buddy1/mobile: .+test carbon from recipient\" ) ) ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; stbbr_send ( \"<message type=\\'chat\\' to=\\'stabber@localhost/profanity\\' from=\\'stabber@localhost\\'>\" <vul-end> \"<received xmlns=\\'urn:xmpp:carbons:2\\'>\" \"<forwarded xmlns=\\'urn:xmpp:forward:0\\'>\" \"<message id=\\'prof_msg_7\\' xmlns=\\'jabber:client\\' type=\\'chat\\' lang=\\'en\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost/mobile\\'>\"\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; stbbr_send ( \"<message type=\\'chat\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost\\'>\" \"<received xmlns=\\'urn:xmpp:carbons:2\\'>\" \"<forwarded xmlns=\\'urn:xmpp:forward:0\\'>\" \"<message id=\\'prof_msg_7\\' xmlns=\\'chat\\' lang=\\'en\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost/mobile\\'>\" \"<body>test carbon from recipient</body>\" \"</message>\" \"</forwarded>\" \"</message>\" ) ; assert_true ( prof_output_regex ( \"Buddy1/mobile:.+test carbon from recipient\" ) ) ; prof_input ( \"/msg Buddy1\" ) ; assert_true ( prof_output_exact ( \"Unencrypted\" ) ) ; stbbr_send ( \"<message type=\\'chat\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost\\'>\" \"<received xmlns=\\'urn:xmpp:carbons:2\\'>\" \"<forwarded xmlns=\\'urn:xmpp:forward:0\\'>\" \"<message id=\\'prof_msg_7\\' xmlns=\\'chat\\' lang=\\'en\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost/mobile\\'>\" \"<body>test carbon from recipient</body>\" \"</message>\" \"</forwarded>\" \"</message>\" ) ; assert_true ( prof_output_regex ( \"Buddy1/mobile:.+test carbon from recipient\" ) ) ; stbbr_send ( \"<message type=\\'chat\\' to=\\'stabber@localhost/profanity\\' from=\\'buddy1@localhost\\'>\" \"<received xmlns=\\'urn:xmpp:carbons:2\\'>\" \"<forwarded xmlns=\\'urn:xmpp:forward:0\\'>\" \"<message id=\\'prof_msg_7\\' xmlns=\\'chat\\' lang=\\'en\\' to=\\'stabber@localhost/profanity\\'>\" \"<forwarded xmlns=\\'urn:xmpp:forward:0\\'>\" \"<message id=\\'prof_msg_7\\' xmlns=\\'chat\\' lang=\\'en\\' to=\\'stabber@localhost/profanity\\'>\" \"<body>test carbon from recipient</body>\" \"</message>\" \"</forwarded>\" \"</message>\" ) ; assert_true ( prof"
 },
 {
  "id": 1336,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 DECLAREwriteFunc ( writeBufferToContigTiles ) { uint32 imagew = TIFFScanlineSize ( out ) ; uint32 tilew = TIFFTileRowSize ( out ) ; int iskew = imagew - tilew ; tsize_t tilesize = TIFFTileSize ( out ) ; tdata_t obuf ; uint8 * bufp = ( uint8 * ) buf ; uint32 tl , tw ; uint32 row ; ( void ) spp ; obuf = _TIFFmalloc ( TIFFTileSize ( out ) ) ; if ( obuf == NULL ) return 0 ; _TIFFmemset ( obuf , 0 , tilesize ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILELENGTH , & tl ) ; ( void ) TIFFGetField ( out , TIFFTAG_TILEWIDTH , & tw ) ; for ( row = 0 ; row < imagelength ; row += tilelength ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; <vul-start> for ( col = 0 ; col < imagewidth ; col += tw ) { <vul-end> if ( colb + tilew > imagew ) { uint32 width = imagew - colb ; int oskew = tilew - width ; cpStripToTile ( obuf , bufp + colb , nrow , width , oskew , oskew + iskew ) ; } else cpStripToTile ( obuf , bufp + colb , nrow , tilew , 0 , iskew ) ; if ( TIFFWriteTile ( out , obuf , col , row , 0 , 0 ) < 0 ) { TIFFError ( TIFFFileName ( out ) , \"Error, can\\'t write tile",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> col < imagewidth && colb < imagew\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> uint32 col ; if ( nrow > 0 && row < imagelength ) { TIFFError ( TIFFFileName ( out ), \"Error, can only write tile 0%u, %u\", nrow, imagelength ) ; return 0 ; }\n"
 },
 {
  "id": 1337,
  "question": "CWE-191 Code Input Vulnerable Code Is: CWE-191 int rad_packet_recv ( int fd , struct rad_packet_t * * p , struct sockaddr_in * addr ) { struct rad_packet_t * pack ; struct rad_attr_t * attr ; struct rad_dict_attr_t * da ; struct rad_dict_vendor_t * vendor ; uint8_t * ptr ; int n , id , len , vendor_id ; socklen_t addr_len = sizeof ( * addr ) ; * p = NULL ; pack = rad_packet_alloc ( 0 ) ; if ( ! pack ) return 0 ; ptr = mempool_alloc ( buf_pool ) ; if ( ptr == MAP_FAILED ) { log_emerg ( \"radius:packet: out of memory\\\\n\" ) ; goto out_err ; } pack -> buf = ptr ; clock_gettime ( CLOCK_MONOTONIC , & pack -> tv ) ; while ( 1 ) { if ( addr ) n = recvfrom ( fd , pack -> buf , REQ_LENGTH_MAX , 0 , addr , & addr_len ) ; else n = read ( fd , pack -> buf , REQ_LENGTH_MAX ) ; if ( n < 0 ) { rad_packet_free ( pack ) ; if ( errno == EAGAIN ) return 1 ; if ( errno != ECONNREFUSED ) log_ppp_error ( \"radius:packet:read: %s\\\\n\" , strerror ( errno ) ) ; return - 1 ; } break ; } if ( n < 20 ) { log_ppp_warn ( \"radius:packet: short packed received (%i)\\\\n\" , n ) ; goto out_err ; } pack -> code = * ptr ; ptr ++ ; pack -> id = * ptr ; ptr ++ ; pack -> len = ntohs ( * ( uint16_t * ) ptr",
  "golden_answers": [
   "CWE-191 Fixed Code Lines are: <vul-start> -> len ; if ( len < 0 ) { log_ppp_warn ( \"radius:packet invalid vendor attribute len received\\\\n\" ) ; goto out_err ; } if ( 2 + len > n ) { log_ppp_warn ( \"radius:packet: too long vendor attribute received (%i, %i)\\\\n\" , id , len ) ; goto out_err ; }\n"
  ],
  "generated_answer": "CWE-191 Fixed Code Lines are: <vul-start> len ; } else if ( len < 0 ) { log_ppp_warn ( \"radius:packet: too long attribute len received\\\\n\" ) ; goto out_err ; }\n"
 },
 {
  "id": 1338,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( \"cmd %x arg %p\" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; <vul-start> } <vul-end> err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <=",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> err ; } ca. connlist_mutex = 1 ;\n"
 },
 {
  "id": 1339,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int unix_dgram_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( iocb ) ; struct scm_cookie tmp_scm ; struct sock * sk = sock -> sk ; struct unix_sock * u = unix_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; struct sk_buff * skb ; int err ; int peeked , skip ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) <vul-start> goto out ; <vul-end> msg -> msg_namelen = 0 ; err = mutex_lock_interruptible ( & u -> readlock ) ; if ( err ) { err = sock_intr_errno ( sock_rcvtimeo ( sk , noblock ) ) ; goto out ; } skip = sk_peek_offset ( sk , flags ) ; skb = __skb_recv_datagram ( sk , flags , & peeked , & skip , & err ) ; if ( ! skb ) { unix_state_lock ( sk ) ; if ( sk -> sk_type == SOCK_SEQPACKET && err == - EAGAIN && ( sk -> sk_shutdown & RCV_SHUTDOWN ) ) err = 0 ; unix_state_unlock ( sk ) ; goto out_unlock ; } wake_up_interruptible_sync_poll ( & u -> peer_wait , POLLOUT | POLLWRNORM | POLLWRBAND ) ; if ( msg -> msg_name ) unix_copy_addr ( msg , skb -> sk ) ; if ( size > skb -> len - skip ) size = skb -> len - skip ; else if ( size < skb -> len - skip ) msg -> msg_flags",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ) goto out <vul-end> ; err =\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) goto out <vul-end> ; err =\n"
 },
 {
  "id": 1340,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; <vul-start> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <vul-end> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> -> cac_id , serial -> len <vul-end> ) ; SC_FUNC_RETURN\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> SC_MAX_SERIALNR ) ; if ( serial -> len < priv -> cac_id_len ) { return SC_ERROR_INVALID_ARGUMENTS ; }\n"
 },
 {
  "id": 1341,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ; <vul-start> if ( len < tcp_hdrlen ) <vul-end> return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( \"unknown or invalid path-MTU (%u)\\\\n\" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) <vul-start> ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> len < tcp_hdrlen ) return - 1 ; if ( len < TCPOLEN_MSS <vul-start> return 0 ; skb_set_dst_offset ( skb, tcphoff + sizeof ( struct tcphdr ) ) ; <vul-start> ) < TCPOLEN_MSS && len < TCPOLEN_MSS - tcphoff <vul-start> false ) ; skb_set_dst_offset ( skb, tcphoff + sizeof ( struct tcphdr ) ) ;\n"
 },
 {
  "id": 1342,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int snd_ctl_elem_write ( struct snd_card * card , struct snd_ctl_file * file , struct snd_ctl_elem_value * control ) { struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int index_offset ; int result ; down_read ( & card -> controls_rwsem ) ; kctl = snd_ctl_find_id ( card , & control -> id ) ; if ( kctl == NULL ) { result = - ENOENT ; } else { index_offset = snd_ctl_get_ioff ( kctl , & control -> id ) ; vd = & kctl -> vd [ index_offset ] ; if ( ! ( vd -> access & SNDRV_CTL_ELEM_ACCESS_WRITE ) || kctl -> put == NULL || ( file && vd -> owner && vd -> owner != file ) ) { result = - EPERM ; } else { snd_ctl_build_ioff ( & control -> id , kctl , index_offset ) ; result = kctl -> put ( kctl , control ) ; } if ( result > 0 ) { <vul-start> up_read ( & card -> controls_rwsem ) ; <vul-end> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , <vul-start> & control -> id ) ; <vul-end> return 0 ; } } up_read ( & card -> controls_rwsem ) ; return result ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> 0 ) { struct snd_ctl_elem_id id = control -> id ; <vul-start> , SNDRV_CTL_EVENT_MASK_VALUE , & <vul-end> id ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> 0 ) { struct snd_ctl_elem_id id = control -> id ; <vul-start> SNDRV_CTL_EVENT_MASK_VALUE, & <vul-end> id ) ;\n"
 },
 {
  "id": 1343,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int burl_normalize_2F_to_slash_fix ( buffer * b , int qs , int i ) { char * const s = b -> ptr ; const int blen = ( int ) buffer_string_length ( b ) ; const int used = qs < 0 ? blen : qs ; int j = i ; for ( ; i < used ; ++ i , ++ j ) { s [ j ] = s [ i ] ; if ( s [ i ] == '%' && s [ i + 1 ] == '2' && s [ i + 2 ] == 'F' ) { s [ j ] = '/' ; i += 2 ; } } if ( qs >= 0 ) { <vul-start> memmove ( s + j , s + qs , blen - qs ) ; <vul-end> <vul-start> j += blen - qs ; <vul-end> } buffer_string_set_length ( b , j ) ; return qs ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> 0 ) { const int qslen = blen - qs ; <vul-start> + qs , ( size_t ) qslen ) ; qs = j <vul-end> ; j += <vul-start> ; j += qslen <vul-end> ; } buffer_string_set_length\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> 0 ) { const int len = blen - qs ; if ( len < j + len + 1 ) { buffer_string_set_length ( b, j + len + 1 ) ; return 0 ; } <vul-start> + qs, len <vul-end> ) ; j <vul-start> ; j += len <vul-end> ; } buffer_string_set_length\n"
 },
 {
  "id": 1344,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; <vul-start> tok -> level = 0 ; <vul-end> tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; <vul-start> return tok ; <vul-end> }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> level = 0 <vul-end> ; tok -> <vul-start> = 0 ; tok -> async_always = 0 ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; tok -> <vul-end> altwarning = 1 <vul-start> = 0 ; tok -> async_always = 0 ;\n"
 },
 {
  "id": 1345,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static zend_always_inline int process_nested_data ( UNSERIALIZE_PARAMETER , HashTable * ht , zend_long elements , int objprops ) { while ( elements -- > 0 ) { zval key , * data , d , * old_data ; zend_ulong idx ; ZVAL_UNDEF ( & key ) ; if ( ! php_var_unserialize_internal ( & key , p , max , NULL , classes ) ) { zval_dtor ( & key ) ; return 0 ; } data = NULL ; ZVAL_UNDEF ( & d ) ; if ( ! objprops ) { if ( Z_TYPE ( key ) == IS_LONG ) { idx = Z_LVAL ( key ) ; numeric_key : if ( UNEXPECTED ( ( old_data = zend_hash_index_find ( ht , idx ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_index_update ( ht , idx , & d ) ; } else { data = zend_hash_index_add_new ( ht , idx , & d ) ; } } else if ( Z_TYPE ( key ) == IS_STRING ) { if ( UNEXPECTED ( ZEND_HANDLE_NUMERIC ( Z_STR ( key ) , idx ) ) ) { goto numeric_key ; } if ( UNEXPECTED ( ( old_data = zend_hash_find ( ht , Z_STR ( key ) ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_update ( ht , Z_STR ( key ) , & d ) ; } else { data = zend_hash_add_new ( ht , Z_STR ( key ) , & d ) ; } } else { zval_dtor ( & key",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> 0 ; } <vul-end> var_push_dtor ( var_hash <vul-start> data ) ; <vul-end> zval_dtor ( &\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> 0 ; } <vul-end> var_push_dtor ( var_hash <vul-start> data ) ; <vul-end> zval_dtor ( &\n"
 },
 {
  "id": 1346,
  "question": "CWE-404 Code Input Vulnerable Code Is: CWE-404 int install_process_keyring_to_cred ( struct cred * new ) { struct key * keyring ; if ( new -> process_keyring ) <vul-start> return - EEXIST ; <vul-end> keyring = keyring_alloc ( \"_pid\" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> process_keyring = keyring ; return 0 ; }",
  "golden_answers": [
   "CWE-404 Fixed Code Lines are: <vul-start> process_keyring ) return 0 <vul-end> ; keyring =\n"
  ],
  "generated_answer": "CWE-404 Fixed Code Lines are: <vul-start> -> process_keyring ) { kfree ( new -> process_keyring ) ; new -> process_keyring = NULL ; return - EEXIST ; } <vul-end> keyring = keyring_alloc\n"
 },
 {
  "id": 1347,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int ttusbdecfe_dvbs_diseqc_send_master_cmd ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * cmd ) { struct ttusbdecfe_state * state = ( struct ttusbdecfe_state * ) fe -> demodulator_priv ; u8 b [ ] = { 0x00 , 0xff , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; <vul-start> memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; <vul-end> state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ; return 0 ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) ) return - EINVAL ;\n"
 },
 {
  "id": 1348,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_idct32x32_add ( const int16_t * input , uint8_t * dest , int stride , <vul-end> int eob ) { if ( eob == 1 ) <vul-start> vp9_idct32x32_1_add ( input , dest , stride ) ; <vul-end> else if ( eob <= 34 ) <vul-start> vp9_idct32x32_34_add ( input , dest , stride ) ; <vul-end> else <vul-start> vp9_idct32x32_1024_add ( input , dest , stride ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> vp9_idct32x32_add ( const tran_low_t <vul-end> * input , <vul-start> == 1 ) vpx_idct32x32_1_add <vul-end> ( input , <vul-start> <= 34 ) vpx_idct32x32_34_add <vul-end> ( input , <vul-start> ) ; else vpx_idct32x32_1024_add <vul-end> ( input ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vp9_idct32x32_add ( const tran_low_t <vul-end> * input, <vul-start> == 1 ) vpx_idct32x32_1_add <vul-end> ( input, <vul-start> <= 34 ) vpx_idct32x32_34_add <vul-end> ( input, <vul-start> ) ; else vpx_idct32x32_1024_add <vul-end> ( input,\n"
 },
 {
  "id": 1349,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 <vul-start> static inline void assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) <vul-end> { <vul-start> switch ( ctxt -> op_bytes ) { <vul-end> case 2 : ctxt -> _eip = ( u16 ) dst ; break ; case 4 : ctxt -> _eip = ( u32 ) dst ; break ; case 8 : ctxt -> _eip = dst ; break ; default : WARN ( 1 , \"unsupported eip assignment size\\\\n\" ) ; } <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start>   static inline int <vul-end> assign_eip_near ( struct <vul-start> dst ) { return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 <vul-end> ) ; } <vul-start> ) ; } <vul-end>      \n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>   static inline int <vul-end> assign_eip_near ( struct <vul-start> dst ) { if (! ( ctxt -> op_bytes & 2 ) ||! ( ctxt -> op_bytes & 4 ) ||! ( ctxt -> op_bytes & 8 ) ) return - EINVAL ; <vul-start> ) ; } return 0 ;\n"
 },
 {
  "id": 1350,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 <vul-start> static void print_bpf_insn ( struct bpf_insn * insn ) <vul-end> { u8 class = BPF_CLASS ( insn -> code ) ; if ( class == BPF_ALU || class == BPF_ALU64 ) { if ( BPF_SRC ( insn -> code ) == BPF_X ) verbose ( \"(%02x) %sr%d %s %sr%d\\\\n\" , insn -> code , class == BPF_ALU ? \"(u32) \" : \"\" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? \"(u32) \" : \"\" , insn -> src_reg ) ; else verbose ( \"(%02x) %sr%d %s %s%d\\\\n\" , insn -> code , class == BPF_ALU ? \"(u32) \" : \"\" , insn -> dst_reg , bpf_alu_string [ BPF_OP ( insn -> code ) >> 4 ] , class == BPF_ALU ? \"(u32) \" : \"\" , insn -> imm ) ; } else if ( class == BPF_STX ) { if ( BPF_MODE ( insn -> code ) == BPF_MEM ) verbose ( \"(%02x) *(%s *)(r%d %+d) = r%d\\\\n\" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else if ( BPF_MODE ( insn -> code ) == BPF_XADD ) verbose ( \"(%02x) lock *(%s *)(r%d %+d) += r%d\\\\n\" , insn -> code , bpf_ldst_string [ BPF_SIZE ( insn -> code ) >> 3 ] , insn -> dst_reg , insn -> off , insn -> src_reg ) ; else verbose ( \"BUG_%02x\\\\n\" , insn -> code ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> void print_bpf_insn ( const struct bpf_verifier_env * env , const <vul-start> ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( \"(%02x) r%d = 0x%llx\\\\n\" , insn -> code , <vul-end> insn -> dst_reg <vul-start> -> dst_reg , ( unsigned long long ) <vul-end> imm ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start>       static int <vul-end> print_bpf_insn ( struct <vul-start> ) == BPF_IMM && BPF_MODE ( insn -> code ) == BPF_IMM_RD <vul-start> { verbose ( \"(%02x) r%d = 0x%x, %s\\\\n\" <vul-end>, insn -> <vul-start> insn -> imm, func_id_name ( insn -> imm ) ) ; return 0 ; } else if ( BPF_MODE ( insn -> code ) == BPF_IMM ) { verbose ( \"(%02x) r%d = 0x%x\\\\n\", insn -> code, insn -> dst_reg, insn -> imm\n"
 },
 {
  "id": 1351,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int irda_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; struct irda_sock * self ; <vul-start> if ( net != & init_net ) <vul-end> return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_STREAM : case SOCK_SEQPACKET : case SOCK_DGRAM : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_IRDA , GFP_KERNEL , & irda_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; self = irda_sk ( sk ) ; pr_debug ( \"%s() : self is %p\\\\n\" , __func__ , self ) ; init_waitqueue_head ( & self -> query_wait ) ; switch ( sock -> type ) { case SOCK_STREAM : sock -> ops = & irda_stream_ops ; self -> max_sdu_size_rx = TTP_SAR_DISABLE ; break ; case SOCK_SEQPACKET : sock -> ops = & irda_seqpacket_ops ; self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; break ; case SOCK_DGRAM : switch ( protocol ) { # ifdef CONFIG_IRDA_ULTRA case IRDAPROTO_ULTRA : sock -> ops = & irda_ultra_ops ; self -> max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER ; self -> max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER ; break ; # endif case IRDAPROTO_UNITDATA : sock -> ops = & irda_dgram_ops ; self -> max_sdu_size_rx = TTP_SAR_UNBOUND ; break ; default : sk_free ( sk ) ; return - ESOCKTNOSUPPORT ; } break ; default : sk_free ( sk ) ; return - ESOCKTNOSUPPORT ; } sock_init_data ( sock , sk ) ; sk -> sk_family = PF_IRDA ; sk",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> * self ; int ret ;\n"
 },
 {
  "id": 1352,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; <vul-start> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <vul-end> uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( \"\" , \"TIFF scanline size is zero!\" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( \"\" , \"Strip %d: read %lu bytes, strip size %lu\" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( \"\" , \"Error reading strip %lu after %lu rows\" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } bufp += bytes_read ; } return 1 ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> = 0 ; uint32 <vul-end> strip , nstrips\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = 0 ; uint32 <vul-end> strip, nstrips\n"
 },
 {
  "id": 1353,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <vul-start> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <vul-end> <vul-start> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <vul-end> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> desc_ptr dt ; unsigned long cr4 ; <vul-start> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <vul-end> ; vmcs_write16 (\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> desc_ptr dt ; if ( cpu_has_secondary_exec_ctrls ( ) ) { vmcs_writel ( HOST_CR0, read_cr0 ( ) & ~ X86_CR0_GS ) ; vmcs_writel ( HOST_CR4, read_cr4 ( ) ) ; } else { <vul-start> X86_CR0_TS ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) { vmcs_writel ( HOST_CR4, read_cr4 ( ) ) ; vmcs_writel ( HOST_CR3, read_cr3 ( ) ) ; } else { vmcs_writel ( HOST_CR4, read_cr4 ( ) ) ; }\n"
 },
 {
  "id": 1354,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ; <vul-start> s = tcp_recv ( NULL , 4 ) ; <vul-end> if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , \"cssp_read_tsrequest(), expected BER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED, got %x\" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ; <vul-start> if ( ! ber_in_header ( s , & tagval , & length ) || <vul-end> tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; <vul-start> in_uint8s ( s , length ) ; <vul-end> if ( token ) { if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> int tagval ; struct stream packet ; <vul-start> length ) ; packet = * s ; <vul-start> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( \"cssp_read_tsrequest(), consume of version from stream would overrun\" , & packet ) ; } <vul-start> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( \"cssp_read_tsrequest(), consume of token from stream would overrun\" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <vul-end> ; out_uint8p (\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> int tagval ; struct stream packet ; <vul-start> length ) ; packet = * s ; <vul-start> return False ; if (! s_check_rem ( s, length ) ) return False ;\n"
 },
 {
  "id": 1355,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int socket_accept ( int fd , uint16_t port ) { # ifdef WIN32 int addr_len ; # else socklen_t addr_len ; # endif int result ; struct sockaddr_in addr ; memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; <vul-start> addr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <vul-end> addr . sin_port = htons ( port ) ; addr_len = sizeof ( addr ) ; result = accept ( fd , ( struct sockaddr * ) & addr , & addr_len ) ; return result ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> = htonl ( INADDR_LOOPBACK <vul-end> ) ; addr\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> = htonl ( INADDR_LOOPBACK <vul-end> ) ; addr\n"
 },
 {
  "id": 1356,
  "question": "CWE-772 Code Input Vulnerable Code Is: CWE-772 int virtio_gpu_object_create ( struct virtio_gpu_device * vgdev , unsigned long size , bool kernel , bool pinned , struct virtio_gpu_object * * bo_ptr ) { struct virtio_gpu_object * bo ; enum ttm_bo_type type ; size_t acc_size ; int ret ; if ( kernel ) type = ttm_bo_type_kernel ; else type = ttm_bo_type_device ; * bo_ptr = NULL ; acc_size = ttm_bo_dma_acc_size ( & vgdev -> mman . bdev , size , sizeof ( struct virtio_gpu_object ) ) ; bo = kzalloc ( sizeof ( struct virtio_gpu_object ) , GFP_KERNEL ) ; if ( bo == NULL ) return - ENOMEM ; size = roundup ( size , PAGE_SIZE ) ; ret = drm_gem_object_init ( vgdev -> ddev , & bo -> gem_base , size ) ; if ( ret != 0 ) <vul-start> return ret ; <vul-end> bo -> dumb = false ; virtio_gpu_init_ttm_placement ( bo , pinned ) ; ret = ttm_bo_init ( & vgdev -> mman . bdev , & bo -> tbo , size , type , & bo -> placement , 0 , ! kernel , NULL , acc_size , NULL , NULL , & virtio_gpu_ttm_bo_destroy ) ; if ( ret != 0 ) return ret ; * bo_ptr = bo ; return 0 ; }",
  "golden_answers": [
   "CWE-772 Fixed Code Lines are: <vul-start> != 0 ) { kfree ( bo ) ; return ret ; } <vul-end> bo -> dumb\n"
  ],
  "generated_answer": "CWE-772 Fixed Code Lines are: <vul-start>!= 0 ) { kfree ( bo ) ; return ret ; } <vul-end> bo -> dumb\n"
 },
 {
  "id": 1357,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int cg_mkdir ( const char * path , mode_t mode ) { struct fuse_context * fc = fuse_get_context ( ) ; <vul-start> char * fpath = NULL , * path1 , * cgdir = NULL , * controller ; <vul-end> const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) path1 = \"/\" ; else path1 = cgdir ; <vul-start> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { <vul-end> <vul-start> ret = - EACCES ; <vul-end> goto out ; } <vul-start> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { <vul-end> ret = - EACCES ; goto out ; } ret = cgfs_create ( controller , cgroup , fc -> uid , fc -> gid ) ; printf ( \"cgfs_create returned %d for %s %s\\\\n\" , ret , controller , cgroup ) ; out : free ( cgdir ) ; <vul-start> return ret ; <vul-end> }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> , * controller , * next = NULL <vul-start> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next <vul-end> ) ) { <vul-start> ) ) { if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT <vul-end> ; goto out <vul-start> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { ret = - EACCES ; goto out ; } if ( ! <vul-start> cgdir ) ; free ( next ) ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, * controller, * caller <vul-start> = cgdir ; caller = get_caller_from_path ( fpath ) ; if (! caller ) return - ENOENT ; <vul-start> ) ) { if ( caller == NULL ) return - ENOENT ; <vul-start> if (! caller_may_see_dir ( fc -> pid, controller, path1 ) ) { ret = - ENOENT ; goto out ; } if ( caller_may_see_dir ( fc -> pid, controller, path1 ) ) { ret = - ENOENT ; goto out ; } if ( caller_may_see_dir ( fc -> pid, controller, path1 ) ) { ret = - ENOENT ; goto out ; } } ret = cgfs_create ( controller, cgroup, fc -> uid, fc -> gid ) ; printf ( \"cgfs_create returned %d for %s %s\\\\n\", ret, controller, cgroup ) ; out : free ( cgdir ) ; <vul-end> return ret ; <vul-start> ) ; return - EIO <vul-end> ; }  \n"
 },
 {
  "id": 1358,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 error_t nicSendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { error_t error ; <vul-start> bool_t status ; <vul-end> netContext . entropy += netGetSystemTickCount ( ) ; <vul-start> # if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG ) <vul-end> size_t length = netBufferGetLength ( buffer ) - offset ; TRACE_DEBUG ( \"Sending packet (%\" PRIuSIZE \" bytes)...\\\\r\\\\n\" , length ) ; TRACE_DEBUG_NET_BUFFER ( \" \" , buffer , offset , length ) ; # endif if ( interface -> configured && interface -> nicDriver != NULL ) { if ( interface -> nicDriver -> type == NIC_TYPE_LOOPBACK ) { status = TRUE ; } else { status = osWaitForEvent ( & interface -> nicTxEvent , NIC_MAX_BLOCKING_TIME ) ; } if ( status ) { interface -> nicDriver -> disableIrq ( interface ) ; error = interface -> nicDriver -> sendPacket ( interface , buffer , offset , ancillary ) ; if ( interface -> configured ) { interface -> nicDriver -> enableIrq ( interface ) ; } } else { error = NO_ERROR ; } } else { error = ERROR_INVALID_INTERFACE ; } return error ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> bool_t status ; # if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG ) size_t length = netBufferGetLength ( buffer ) - offset ; TRACE_DEBUG ( \"Sending packet (%\" PRIuSIZE \" bytes)...\\\\r\\\\n\" , length ) ; TRACE_DEBUG_NET_BUFFER ( \"  \" , buffer , offset , length ) ; # endif <vul-start> ( ) ; <vul-end> if ( interface\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; bool_t status <vul-end> ; # if <vul-start> >= TRACE_LEVEL_DEBUG ) netBufferGetLength ( buffer ) - offset ; TRACE_DEBUG ( \"Sending packet (%\" PRIuSIZE \" bytes)...\\\\r\\\\n\", length ) ; TRACE_DEBUG_NET_BUFFER ( \" \", buffer, offset, length ) ;\n"
 },
 {
  "id": 1359,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , \"entering CDROM_DRIVE_STATUS\\\\n\" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <vul-start> if ( ( ( int ) arg >= cdi -> capacity ) ) <vul-end> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; if ( <vul-end> arg >= cdi <vul-start> cdi -> capacity <vul-end> ) return -\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; if ( arg == CDSL_NONE &&\n"
 },
 {
  "id": 1360,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static unsigned long randomize_stack_top ( unsigned long stack_top ) { <vul-start> unsigned int random_variable = 0 ; <vul-end> if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { <vul-start> random_variable = get_random_int ( ) & STACK_RND_MASK ; <vul-end> random_variable <<= PAGE_SHIFT ; } # ifdef CONFIG_STACK_GROWSUP return PAGE_ALIGN ( stack_top ) + random_variable ; # else return PAGE_ALIGN ( stack_top ) - random_variable ; # endif }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ) { unsigned long <vul-end> random_variable = 0 <vul-start> { random_variable = ( unsigned long ) <vul-start> get_random_int ( ) ; random_variable &= <vul-end> STACK_RND_MASK ; random_variable\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> { unsigned int random_variable ; # ifdef CONFIG_STACK_GROWSUP random_variable = get_random_long ( ) ; # else unsigned int random_variable = 0 ; # endif <vul-end> if ( ( <vul-start> ) ) { if ( random_variable & STACK_RND_MASK ) { random_variable = get_random_long ( ) & STACK_RND_MASK ; } else { random_variable = ( get_random_int ( ) & STACK_RND_MASK ) ; } <vul-end> random_variable <<= PAGE_SHIFT\n"
 },
 {
  "id": 1361,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static SCSIRequest * scsi_new_request ( SCSIDevice * d , uint32_t tag , uint32_t lun , void * hba_private ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; SCSIRequest * req ; <vul-start> SCSIDiskReq * r ; <vul-end> req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ; <vul-start> r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <vul-end> r -> iov . iov_base = qemu_blockalign ( s -> bs , SCSI_DMA_BUF_SIZE ) ; return req ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * req ; <vul-end> req = scsi_req_alloc <vul-start> hba_private ) ; <vul-end> return req ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * req ; <vul-end> req = scsi_req_alloc <vul-start> hba_private ) ; <vul-end> return req ;\n"
 },
 {
  "id": 1362,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 void AV1_RewriteESDescriptorEx ( GF_MPEGVisualSampleEntryBox * av1 , GF_MediaBox * mdia ) { GF_BitRateBox * btrt = gf_isom_sample_entry_get_bitrate ( ( GF_SampleEntryBox * ) av1 , GF_FALSE ) ; if ( av1 -> emul_esd ) gf_odf_desc_del ( ( GF_Descriptor * ) av1 -> emul_esd ) ; av1 -> emul_esd = gf_odf_desc_esd_new ( 2 ) ; av1 -> emul_esd -> decoderConfig -> streamType = GF_STREAM_VISUAL ; av1 -> emul_esd -> decoderConfig -> objectTypeIndication = GF_CODECID_AV1 ; if ( btrt ) { av1 -> emul_esd -> decoderConfig -> bufferSizeDB = btrt -> bufferSizeDB ; av1 -> emul_esd -> decoderConfig -> avgBitrate = btrt -> avgBitrate ; av1 -> emul_esd -> decoderConfig -> maxBitrate = btrt -> maxBitrate ; } <vul-start> if ( av1 -> av1_config ) { <vul-end> GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ; if ( av1_cfg ) { gf_odf_av1_cfg_write ( av1_cfg , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> data , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> dataLength ) ; gf_odf_av1_cfg_del ( av1_cfg ) ; } } }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> av1 -> av1_config && av1 -> av1_config -> config\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> maxBitrate ; } av1 -> emul_esd -> decoderConfig -> verify_frame_count = 0 ;\n"
 },
 {
  "id": 1363,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void configSetCommand ( client * c ) { robj * o ; long long ll ; int err ; serverAssertWithInfo ( c , c -> argv [ 2 ] , sdsEncodedObject ( c -> argv [ 2 ] ) ) ; serverAssertWithInfo ( c , c -> argv [ 3 ] , sdsEncodedObject ( c -> argv [ 3 ] ) ) ; o = c -> argv [ 3 ] ; if ( 0 ) { config_set_special_field ( \"dbfilename\" ) { if ( ! pathIsBaseName ( o -> ptr ) ) { addReplyError ( c , \"dbfilename can\\'t be a path, just a filename\" ) ; return ; } zfree ( server . rdb_filename ) ; server . rdb_filename = zstrdup ( o -> ptr ) ; } config_set_special_field ( \"requirepass\" ) { if ( sdslen ( o -> ptr ) > CONFIG_AUTHPASS_MAX_LEN ) goto badfmt ; zfree ( server . requirepass ) ; server . requirepass = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( \"masterauth\" ) { zfree ( server . masterauth ) ; server . masterauth = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( \"cluster-announce-ip\" ) { zfree ( server . cluster_announce_ip ) ; server . cluster_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( \"maxclients\" ) {",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 0 ) { int class = <vul-end> getClientTypeByName ( v <vul-start> j ] ) ; if ( class <vul-start> == - 1 || class == CLIENT_TYPE_MASTER\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ] ) == INVALID_CLIENT_TYPE <vul-end> ) { sdsfreesplitres\n"
 },
 {
  "id": 1364,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) { <vul-start> GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( \"[iso file] Missing dref box in dinf\\\\n\" ) ) ; <vul-end> <vul-start> ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; <vul-end> } return GF_OK ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> dref ) { GF_Box * dref ; <vul-start> ( \"[iso file] Missing dref box in dinf\\\\n\" ) ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <vul-start> GF_DataReferenceBox * ) dref ; gf_isom_box_add_for_dump_mode ( s , dref <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> dref ) { GF_ISOM_BOX_TYPE_DREF box_type = GF_ISOM_BOX_TYPE_DREF ; <vul-start> ) gf_isom_box_new ( box_type <vul-end> ) ; }\n"
 },
 {
  "id": 1365,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int sc_pkcs15emu_esteid_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; unsigned char buff [ 128 ] ; int r , i ; size_t field_length = 0 , modulus_length = 0 ; sc_path_t tmppath ; set_string ( & p15card -> tokeninfo -> label , \"ID-kaart\" ) ; set_string ( & p15card -> tokeninfo -> manufacturer_id , \"AS Sertifitseerimiskeskus\" ) ; sc_format_path ( \"3f00eeee5044\" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , \"select esteid PD failed\" ) ; r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , \"read document number failed\" ) ; <vul-start> buff [ r ] = '\\\\0' ; <vul-end> set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION | SC_PKCS15_TOKEN_EID_COMPLIANT | SC_PKCS15_TOKEN_READONLY ; for ( i = 0 ; i < 2 ; i ++ ) { static const char * esteid_cert_names [ 2 ] = { \"Isikutuvastus\" , \"Allkirjastamine\" } ; static char const * esteid_cert_paths [ 2 ] = { \"3f00eeeeaace\" , \"3f00eeeeddce\" } ; static int esteid_cert_ids [ 2 ] = { 1 , 2 } ; struct sc_pkcs15_cert_info cert_info ; struct sc_pkcs15_object cert_obj ; memset ( & cert_info , 0 , sizeof ( cert_info ) ) ; memset ( & cert_obj , 0 , sizeof ( cert_obj ) ) ;",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> ; buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <vul-end> ] = '\\\\0'\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> \"read document number failed\" ) ; if ( r < sizeof ( buff ) ) return SC_ERROR_INTERNAL ;\n"
 },
 {
  "id": 1366,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int btsock_thread_wakeup ( int h ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( \"invalid bt thread handle:%d\" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( \"thread handle:%d, cmd socket is not created\" , h ) ; return FALSE ; } sock_cmd_t cmd = { CMD_WAKEUP , 0 , 0 , 0 , 0 } ; <vul-start> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <vul-end> }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> } ; return TEMP_FAILURE_RETRY ( <vul-start> , 0 ) )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> } ; return TEMP_FAILURE_RETRY ( <vul-start>, 0 ) )\n"
 },
 {
  "id": 1367,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int validate_camera_metadata_structure ( const camera_metadata_t * metadata , const size_t * expected_size ) { if ( metadata == NULL ) { ALOGE ( \"%s: metadata is null!\" , __FUNCTION__ ) ; return ERROR ; } { static const struct { const char * name ; size_t alignment ; } alignments [ ] = { { . name = \"camera_metadata\" , . alignment = METADATA_ALIGNMENT } , { . name = \"camera_metadata_buffer_entry\" , . alignment = ENTRY_ALIGNMENT } , { . name = \"camera_metadata_data\" , . alignment = DATA_ALIGNMENT } , } ; for ( size_t i = 0 ; i < sizeof ( alignments ) / sizeof ( alignments [ 0 ] ) ; ++ i ) { uintptr_t aligned_ptr = ALIGN_TO ( metadata , alignments [ i ] . alignment ) ; if ( ( uintptr_t ) metadata != aligned_ptr ) { ALOGE ( \"%s: Metadata pointer is not aligned (actual %p, \" \"expected %p) to type %s\" , __FUNCTION__ , metadata , ( void * ) aligned_ptr , alignments [ i ] . name ) ; return ERROR ; } } } if ( expected_size != NULL && metadata -> size > * expected_size ) { ALOGE ( \"%s: Metadata size (%\" PRIu32 \") should be <= expected size (%zu)\" , __FUNCTION__ , metadata -> size , * expected_size ) ; return ERROR ; } if ( metadata -> entry_count > metadata -> entry_capacity ) { ALOGE ( \"%s: Entry count (%\" PRIu32 \") should be <= entry capacity \" \"(%\" PRIu32 \")\" , __FUNCTION__ , metadata -> entry_count , metadata -> entry_capacity",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ERROR ; } if ( metadata -> data_count > metadata -> data_capacity ) { ALOGE ( \"%s: Data count (%\" PRIu32 \") should be <= data capacity \" \"(%\" PRIu32 \")\" , __FUNCTION__ , metadata -> data_count , metadata -> data_capacity ) ; android_errorWriteLog ( SN_EVENT_LOG_ID , \"30591838\" ) ; return ERROR ; }\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ERROR ; } if ( ( uintptr_t ) metadata -> entry_count > metadata -> data_capacity ) { ALOGE ( \"%s: Entry index %zu had bad alignment (address %p),\" \" expected alignment %zu (tag name %s)\", __FUNCTION__, i, & metadata -> entry_count, metadata -> entry_capacity ) ; return ERROR ; }\n"
 },
 {
  "id": 1368,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int compare_img ( const vpx_image_t * const img1 , const vpx_image_t * const img2 ) { <vul-start> const uint32_t c_w = <vul-end> ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ; const uint32_t c_h = ( img1 -> d_h + img1 -> y_chroma_shift ) >> img1 -> y_chroma_shift ; uint32_t i ; int match = 1 ; match &= ( img1 -> fmt == img2 -> fmt ) ; match &= ( img1 -> d_w == img2 -> d_w ) ; match &= ( img1 -> d_h == img2 -> d_h ) ; <vul-start> for ( i = 0 ; i < img1 -> d_h ; ++ i ) <vul-end> match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] , img2 -> planes [ VPX_PLANE_Y ] + i * img2 -> stride [ VPX_PLANE_Y ] , <vul-start> img1 -> d_w ) == 0 ) ; <vul-end> for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_U ] + i * img1 -> stride [ VPX_PLANE_U ] , img2 -> planes [ VPX_PLANE_U ] + i * img2 -> stride [ VPX_PLANE_U ] , c_w ) == 0 ) ; for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_V ] + i * img1 -> stride [ VPX_PLANE_V ] , img2 -> planes [ VPX_PLANE_V ] + i * img2 -> stride",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> img2 ) { uint32_t l_w = img1 -> d_w ; <vul-end> uint32_t c_w = <vul-start> d_h ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { l_w *= 2 ; c_w *= 2 ; } # endif <vul-start> VPX_PLANE_Y ] , l_w <vul-end> ) == 0\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) { const int is_larger_than_two = ( img1 -> fmt == VPX_IMG_FMT_YUVA420P || img1 -> fmt == VPX_IMG_FMT_YUV420P ) ; const <vul-start> d_h ) ; if ( is_larger_than_two ) { for ( i = 0 ; i < img1 -> d_w ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_Y ] + i * img1 -> stride [ VPX_PLANE_Y ] + i * img2 -> stride [ VPX_PLANE_Y ], c_w ) == 0 ) ; for ( i = 0 ; i < img1 -> d_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_U ] + i * img1 -> stride [ VPX_PLANE_U ], img2 -> planes [ VPX_PLANE_U ] + i * img2 -> stride [ VPX_PLANE_U ], c_w ) == 0 ) ; for ( i = 0 ; i < c_h ; ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_V ] + i * img1 -> stride [ VPX_PLANE_V ], img2 -> planes [ VPX_PLANE_V ] + i * img2 -> stride [ VPX_PLANE_V ], c_w ) == 0 ) ; } else { <vul-start> 0 ) ; }\n"
 },
 {
  "id": 1369,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 u32 h264bsdInitDpb ( dpbStorage_t * dpb , u32 picSizeInMbs , u32 dpbSize , u32 maxRefFrames , u32 maxFrameNum , u32 noReordering ) { u32 i ; ASSERT ( picSizeInMbs ) ; ASSERT ( maxRefFrames <= MAX_NUM_REF_PICS ) ; ASSERT ( maxRefFrames <= dpbSize ) ; ASSERT ( maxFrameNum ) ; <vul-start> ASSERT ( dpbSize ) ; <vul-end> dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ; dpb -> maxRefFrames = MAX ( maxRefFrames , 1 ) ; if ( noReordering ) dpb -> dpbSize = dpb -> maxRefFrames ; else dpb -> dpbSize = dpbSize ; dpb -> maxFrameNum = maxFrameNum ; dpb -> noReordering = noReordering ; dpb -> fullness = 0 ; dpb -> numRefFrames = 0 ; dpb -> prevRefFrameNum = 0 ; ALLOCATE ( dpb -> buffer , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t ) ; if ( dpb -> buffer == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> buffer , 0 , ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t ) ) ; for ( i = 0 ; i < dpb -> dpbSize + 1 ; i ++ ) { ALLOCATE ( dpb -> buffer [ i ] . pAllocatedData , ( picSizeInMbs * 384 + 32 + 15 ) , u8 ) ; if ( dpb -> buffer [ i ] . pAllocatedData == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; dpb -> buffer [ i ] . data = ALIGN ( dpb -> buffer [ i ] . pAllocatedData , 16 ) ; } ALLOCATE ( dpb -> list , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t *",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> dpbSize ) ; if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( \"b/28533562\" ) ; android_errorWriteLog ( 0x534e4554 , \"28533562\" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ASSERT ( dpbSize ) ; ASSERT ( dpb -> buffer == NULL\n"
 },
 {
  "id": 1370,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int sysMapBlockFile ( FILE * mapf , MemMapping * pMap ) { char block_dev [ PATH_MAX + 1 ] ; size_t size ; unsigned int blksize ; <vul-start> unsigned int blocks ; <vul-end> unsigned int range_count ; unsigned int i ; if ( fgets ( block_dev , sizeof ( block_dev ) , mapf ) == NULL ) { LOGW ( \"failed to read block device from header\\\\n\" ) ; return - 1 ; } for ( i = 0 ; i < sizeof ( block_dev ) ; ++ i ) { if ( block_dev [ i ] == '\\\\n' ) { block_dev [ i ] = 0 ; break ; } } if ( fscanf ( mapf , \"%zu %u\\\\n%u\\\\n\" , & size , & blksize , & range_count ) != 3 ) { LOGW ( \"failed to parse block map header\\\\n\" ) ; return - 1 ; } <vul-start> blocks = ( ( size - 1 ) / blksize ) + 1 ; <vul-end> <vul-start> pMap -> range_count = range_count ; <vul-end> <vul-start> pMap -> ranges = malloc ( range_count * sizeof ( MappedRange ) ) ; <vul-end> <vul-start> memset ( pMap -> ranges , 0 , range_count * sizeof ( MappedRange ) ) ; <vul-end> unsigned char * reserve ; reserve = mmap64 ( NULL , blocks * blksize , PROT_NONE , MAP_PRIVATE | MAP_ANON , - 1 , 0 ) ; if ( reserve == MAP_FAILED ) { LOGW ( \"failed to reserve address space: %s\\\\n\" , strerror ( errno ) ) ; <vul-start> return - 1 ; <vul-end> } <vul-start>",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> int blksize ; size_t <vul-end> blocks ; unsigned <vul-start> 1 ; } if ( blksize != 0 ) { <vul-start> + 1 ; } if ( size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0 ) { LOGE ( \"invalid data in block map file: size %zu, blksize %u, range_count %u\\\\n\" , size , blksize , range_count ) ; return - 1 ; } <vul-start> -> ranges = calloc ( range_count , <vul-end> sizeof ( MappedRange <vul-start> ) ) ; if <vul-end> ( pMap -> <vul-start> pMap -> ranges == NULL ) { LOGE ( \"calloc(%u, %zu) failed: %s\\\\n\" , range_count , <vul-end> sizeof ( MappedRange <vul-start> ( MappedRange ) , strerror ( errno ) ) ; return - 1 ; } <vul-end> unsigned char * <vul-start> ) ) ; free ( pMap -> ranges ) ; <vul-start> return - 1 ; } int fd = open ( block_dev , O_RDONLY ) ; if ( fd < 0 ) { LOGW ( \"failed to open block device %s: %s\\\\n\" , block_dev , strerror ( errno ) ) ; munmap ( reserve , blocks * blksize ) ; free ( pMap -> ranges ) ; return - 1 ; } unsigned char * next = reserve ; size_t remaining_size = blocks * blksize ; bool success = true ; for ( i = 0 ; i < range_count ; ++ i ) { size_t start , end ; if ( fscanf ( mapf , \"%zu %zu\\\\n\" , & start , & end ) != 2 ) { LOGW ( \"failed to parse range %d in block map\\\\n\" , i ) ; success = false ; break ; } size_t length = ( end - start ) * blksize ; if ( end <= start || ( end - start ) > SIZE_MAX / blksize || length > remaining_size ) { LOGE ( \"unexpected range in block map: %zu %zu\\\\n\" , start , end ) ; success = false ; break ; } void * addr = mmap64 ( next , length , PROT_READ , MAP_PRIVATE | MAP_FIXED , fd , ( ( off64_t ) start ) * blksize ) ; if ( addr == MAP_FAILED ) { LOGW ( \"failed to map block %d: %s\\\\n\" , i , strerror ( errno ) ) ; success = false ; break <vul-start> -> ranges [ i <vul-end> ] . addr <vul-start> . addr = addr <vul-end> ; pMap -> <vul-start> -> ranges [ i <vul-end> ] . length <vul-start> . length = length <vul-end> ; next += <vul-start> ; next += length ; remaining_size -= length ; } if ( success && remaining_size != 0 ) { LOGE ( \"ranges in block map are invalid: remaining_size = %zu\\\\n\" , remaining_size ) ; success = false ; } if ( ! success ) { close ( fd ) ; munmap ( reserve , blocks * blksize ) ; free ( <vul-start> pMap -> ranges ) ; return - 1 ; } close ( fd ) ; pMap -> addr = reserve ; pMap -> length <vul-end> = size ;\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> int blocks ; size_t <vul-end> range_count ; unsigned <vul-start> 1 ; } if ( range_count > 0 ) { <vul-start> + 1 ; } <vul-start> = range_count ; if ( pMap -> ranges!= NULL ) { <vul-start> ) ) ; } <vul-start> * blksize ; if ( pMap -> ranges [ i ]. addr + pMap -> ranges [ i ]. length > blocks * blksize ) { LOGW ( \"too large range in block device %s: %s\\\\n\", block_dev, strerror ( errno ) ) ; return - 1 ; } <vul-start> ) ) ; free ( pMap -> ranges ) ; <vul-start> 1 ; } if ( pMap -> addr!= reserve ) { <vul-start> = reserve ; } if ( pMap -> length!= size ) { LOGW ( \"too large range in block device %s: %s\\\\n\", block_dev, strerror ( errno ) ) ; return - 1 ; }\n"
 },
 {
  "id": 1371,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 bool extract_sockaddr ( struct pool * pool , char * url ) { char * url_begin , * url_end , * ipv6_begin , * ipv6_end , * port_start = NULL ; char url_address [ 256 ] , port [ 6 ] ; int url_len , port_len = 0 ; url_begin = strstr ( url , \"//\" ) ; if ( ! url_begin ) url_begin = url ; else url_begin += 2 ; ipv6_begin = strstr ( url_begin , \"[\" ) ; ipv6_end = strstr ( url_begin , \"]\" ) ; if ( ipv6_begin && ipv6_end && ipv6_end > ipv6_begin ) url_end = strstr ( ipv6_end , \":\" ) ; else url_end = strstr ( url_begin , \":\" ) ; if ( url_end ) { url_len = url_end - url_begin ; port_len = strlen ( url_begin ) - url_len - 1 ; if ( port_len < 1 ) return false ; port_start = url_end + 1 ; } else url_len = strlen ( url_begin ) ; if ( url_len < 1 ) return false ; <vul-start> sprintf ( url_address , \"%.*s\" , url_len , url_begin ) ; <vul-end> if ( port_len ) snprintf ( port , 6 , \"%.*s\" , port_len , port_start ) ; else strcpy ( port , \"80\" ) ; free ( pool -> stratum_port ) ; pool -> stratum_port = strdup ( port ) ; free ( pool -> sockaddr_url ) ; pool -> sockaddr_url = strdup ( url_address ) ; return true ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> return false ; if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , \"%s: Truncating overflowed address \\'%.*s\\'\" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> return false ; snprintf ( url_address, sizeof ( url_address ) <vul-end>, \"%.*s\",\n"
 },
 {
  "id": 1372,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd , <vul-start> int64_t * time_stamp , int64_t * time_end_stamp , <vul-end> <vul-start> vp9_ppflags_t * flags ) { <vul-end> <vul-start> int ret = - 1 ; <vul-end> if ( pbi -> ready_for_new_data == 1 ) return ret ; <vul-start> if ( pbi -> common . show_frame == 0 ) <vul-end> return ret ; pbi -> ready_for_new_data = 1 ; <vul-start> * time_stamp = pbi -> last_time_stamp ; <vul-end> * time_end_stamp = 0 ; <vul-start> # if CONFIG_VP9_POSTPROC <vul-end> <vul-start> ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ; <vul-end> # else <vul-start> * sd = * pbi -> common . frame_to_show ; <vul-end> sd -> y_width = pbi -> common . width ; sd -> y_height = pbi -> common . height ; sd -> uv_width = sd -> y_width >> pbi -> common . subsampling_x ; sd -> uv_height = sd -> y_height >> pbi -> common . subsampling_y ; ret = 0 ; # endif <vul-start> vp9_clear_system_state ( ) ; <vul-end> return ret ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * sd , <vul-end> vp9_ppflags_t * flags <vul-start> flags ) { VP9_COMMON * const cm = & pbi -> common ; <vul-start> - 1 ; # if ! CONFIG_VP9_POSTPROC ( void ) * flags ; # endif <vul-start> return ret ; pbi -> ready_for_new_data = 1 ; if ( ! cm -> show_frame <vul-end> ) return ret <vul-start> = 1 ; <vul-end> # if CONFIG_VP9_POSTPROC <vul-start> # if CONFIG_VP9_POSTPROC if ( ! cm -> show_existing_frame ) { <vul-start> = vp9_post_proc_frame ( cm <vul-end> , sd , <vul-start> flags ) ; } else { * sd = * cm -> frame_to_show ; ret = 0 ; } <vul-start> sd = * cm -> frame_to_show <vul-end> ; ret = <vul-start> ; # endif vpx_clear_system_state <vul-end> ( ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int64_t * time_end_stamp <vul-end> ) { int <vul-start> vp9_ppflags_t * flags, int post_proc <vul-start> int ret = 0 ; int post_proc_ret = - 1 <vul-end> ; if ( <vul-start> return ret ; vp9_setup_system_state ( ) ; if (! pbi -> frame_parallel_decode ) { vpx_free_yv12_buffer_config ( pbi ) ; return ret ; } * time_stamp = pbi -> last_time_stamp ; * time_end_stamp = 0 ; if ( post_proc_ret ) { ret = vp9_post_proc_frame ( & pbi -> common, sd, flags, post_proc_ret ) ; } else { <vul-end> if ( pbi <vul-start> -> common. frame_to_show == 0 ) { vpx_clear_system_state ( ) ; return ret ; } <vul-end> pbi -> ready_for_new_data <vul-start> = 1 ; <vul-end> pbi -> ready_for_new_data <vul-start> = 0 ; post_proc_ret = vpx_post_proc_frame <vul-end> ( & pbi <vul-start> pbi -> common. frame_to_show ; } <vul-end> * sd = <vul-start> * sd = <vul-end> pbi -> common <vul-start> ; # endif <vul-end> return ret ;\n"
 },
 {
  "id": 1373,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , \"%s/.asoundrc\" , cfg . homedir ) == - 1 ) errExit ( \"asprintf\" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , \"Error: %s is a symbolic link\\\\n\" , dest ) ; exit ( 1 ) ; } <vul-start> pid_t child = fork ( ) ; <vul-end> if ( child < 0 ) errExit ( \"fork\" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <vul-start> if ( rv ) <vul-end> fprintf ( stderr , \"Warning: cannot transfer .asoundrc in private home directory\\\\n\" ) ; else { <vul-start> fs_logger2 ( \"clone\" , dest ) ; <vul-end> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> ) ; } copy_file_as_user <vul-end> ( src , <vul-start> S_IWUSR ) ; <vul-end> fs_logger2 ( \"clone\" <vul-start> \"clone\" , dest <vul-end> ) ; unlink\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> ) ; } copy_file_as_user <vul-end> ( src, <vul-start> S_IWUSR ) ; <vul-end> fs_logger2 ( \"clone\" <vul-start> \"clone\", dest <vul-end> ) ; unlink\n"
 },
 {
  "id": 1374,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_tokenize_sb ( VP9_COMP * cpi , TOKENEXTRA * * t , int dry_run , <vul-end> BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; <vul-start> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <vul-end> <vul-start> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-end> TOKENEXTRA * t_backup = * t ; const int ctx = vp9_get_skip_context ( xd ) ; <vul-start> const int skip_inc = ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , <vul-end> SEG_LVL_SKIP ) ; <vul-start> struct tokenize_b_args arg = { cpi , xd , t } ; <vul-end> if ( mbmi -> skip ) { if ( ! dry_run ) <vul-start> cm -> counts . skip [ ctx ] [ 1 ] += skip_inc ; <vul-end> reset_skip_context ( xd , bsize ) ; <vul-start> if ( dry_run ) <vul-end> * t = t_backup ; return ; } if ( ! dry_run ) { <vul-start> cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ; <vul-end> vp9_foreach_transformed_block ( xd , bsize , tokenize_b , & arg ) ; } else { vp9_foreach_transformed_block ( xd , bsize , set_entropy_context_b , & arg ) ; <vul-start> * t = t_backup ; <vul-end> } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cpi , ThreadData * td , <vul-start> -> common ; MACROBLOCK * const x = & td -> mb ; <vul-start> xd = & x -> <vul-end> e_mbd ; MB_MODE_INFO <vul-start> ] -> mbmi <vul-end> ; const int <vul-start> skip_inc = ! segfeature_active <vul-end> ( & cm <vul-start> { cpi , td <vul-end> , t } <vul-start> ! dry_run ) td -> counts -> <vul-end> skip [ ctx <vul-start> bsize ) ; <vul-end> return ; } <vul-start> dry_run ) { td -> counts -> <vul-end> skip [ ctx <vul-start> arg ) ; <vul-end> } }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, ThreadData * td, <vul-start> * xd = td <vul-end> -> mb. <vul-start> ] -> mbmi <vul-end> ; TOKENEXTRA * <vul-start> int skip_inc = get_segment_id ( td, mbmi -> segment_id ) >= SEG_LVL_SKIP <vul-end> ; struct tokenize_b_args <vul-start> arg = { td <vul-end>, t } <vul-start>! dry_run ) td -> counts -> <vul-end> skip [ ctx <vul-start> 1 ] += get_skip_inc ( td ) <vul-end> ; reset_skip_context ( <vul-start> bsize ) ; <vul-end> return ; } <vul-start> dry_run ) { td -> counts -> <vul-end> skip [ ctx <vul-start> 0 ] += get_skip_inc ( td ) <vul-end> ; vp9_foreach_transformed_block ( <vul-start> arg ) ; td -> counts -> <vul-end> } }  \n"
 },
 {
  "id": 1375,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> - ENOMEM ; if (! capable ( CAP_NET_ADMIN ) ) return - EPERM ;\n"
 },
 {
  "id": 1376,
  "question": "CWE-552 Code Input Vulnerable Code Is: CWE-552 static int _hostsock_getpeername ( oe_fd_t * sock_ , struct oe_sockaddr * addr , oe_socklen_t * addrlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t addrlen_in = 0 ; <vul-start> oe_errno = 0 ; <vul-end> <vul-start> if ( ! sock ) <vul-end> OE_RAISE_ERRNO ( OE_EINVAL ) ; <vul-start> if ( addrlen ) <vul-end> <vul-start> addrlen_in = * addrlen ; <vul-end> if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , <vul-start> addrlen ) != OE_OK ) <vul-end> { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <vul-start> done : <vul-end> return ret ; }",
  "golden_answers": [
   "CWE-552 Fixed Code Lines are: <vul-start> = 0 ; oe_socklen_t addrlen_out = 0 ; <vul-start> ( ! sock || ! addr || ! addrlen <vul-start> OE_EINVAL ) ; <vul-end> addrlen_in = * <vul-start> = * addrlen ; if ( addrlen_in < 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) <vul-start> , addrlen_in , & addrlen_out <vul-end> ) != OE_OK <vul-start> ) ; } if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ;\n"
  ],
  "generated_answer": "CWE-552 Fixed Code Lines are: <vul-start> = 0 ; oe_socklen_t addrlen_out = 0 ; <vul-start> (! sock ||! addr ||! addrlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ; addrlen_in = * addrlen ; if ( addrlen_in < 0 <vul-start> ; if ( <vul-end> oe_syscall_getpeername_ocall ( & <vul-start>, addrlen_in, & addrlen_out <vul-end> )!= OE_OK <vul-start> ) ; } if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen_in >= addrlen_out ) * addrlen = addrlen_out ;\n"
 },
 {
  "id": 1377,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , \"failed to apply delta: base size does not match given data\" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , \"failed to apply delta: base size does not match given data\" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { size_t off = 0 , len = 0 ; if ( cmd & 0x01 ) off = * delta ++ ; if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; if ( cmd & 0x04 ) off |= * delta ++ << 16UL ; <vul-start> if ( cmd & 0x08 ) off",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ) off |= ( ( unsigned ) <vul-start> ++ << 24UL )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> & 0x08 ) { if ( off > * out_len ) { giterr_set ( GITERR_INVALID, \"offset must be 0, %lu, %lu\", off, * out_len ) ; return - 1 ; } <vul-start> 24UL ; } }\n"
 },
 {
  "id": 1378,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 struct _mdi * _WM_ParseNewXmi ( uint8_t * xmi_data , uint32_t xmi_size ) { struct _mdi * xmi_mdi = NULL ; uint32_t xmi_tmpdata = 0 ; uint8_t xmi_formcnt = 0 ; uint32_t xmi_catlen = 0 ; uint32_t xmi_subformlen = 0 ; uint32_t i = 0 ; uint32_t j = 0 ; uint32_t xmi_evntlen = 0 ; uint32_t xmi_divisions = 60 ; uint32_t xmi_tempo = 500000 ; uint32_t xmi_sample_count = 0 ; float xmi_sample_count_f = 0.0 ; float xmi_sample_remainder = 0.0 ; float xmi_samples_per_delta_f = 0.0 ; uint8_t xmi_ch = 0 ; uint8_t xmi_note = 0 ; uint32_t * xmi_notelen = NULL ; uint32_t setup_ret = 0 ; uint32_t xmi_delta = 0 ; uint32_t xmi_lowestdelta = 0 ; uint32_t xmi_evnt_cnt = 0 ; if ( memcmp ( xmi_data , \"FORM\" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , \"XDIRINFO\" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 8 ; xmi_size -= 8 ; xmi_data += 4 ; xmi_size -= 4 ; xmi_formcnt = * xmi_data ++ ; if ( xmi_formcnt == 0 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , xmi_data , xmi_size ,\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } if ( xmi_size < 8 || ( xmi_tmpdata > xmi_size ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__, __LINE__, WM_ERR_NOT_XMI, NULL, 0 ) ; goto _XMI_end ; } if (\n"
 },
 {
  "id": 1379,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 krb5_error_code kdc_process_s4u2proxy_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , const krb5_enc_tkt_part * t2enc , const krb5_db_entry * server , krb5_const_principal server_princ , krb5_const_principal proxy_princ , const char * * status ) { krb5_error_code errcode ; if ( request -> kdc_options & ( NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY ) ) { <vul-start> return KRB5KDC_ERR_BADOPTION ; <vul-end> } if ( ! krb5_principal_compare ( kdc_context , server -> princ , <vul-start> server_princ ) ) { <vul-end> return KRB5KDC_ERR_SERVER_NOMATCH ; } if ( ! isflagset ( t2enc -> flags , TKT_FLG_FORWARDABLE ) ) { * status = \"EVIDENCE_TKT_NOT_FORWARDABLE\" ; return KRB5_TKT_NOT_FORWARDABLE ; } errcode = check_allowed_to_delegate_to ( kdc_context , t2enc -> client , server , proxy_princ ) ; if ( errcode ) { * status = \"NOT_ALLOWED_TO_DELEGATE\" ; return errcode ; } return 0 ; }",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> ) ) { * status = \"INVALID_S4U2PROXY_OPTIONS\" ; <vul-start> ) ) { * status = \"EVIDENCE_TICKET_MISMATCH\" ;\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> ) ) { * status = \"EVIDENCE_TKT_BADOPTION\" ; return KRB5KDC_ERR_BADOPTION <vul-end> ; } if <vul-start> ) ) { * status = \"EVIDENCE_SERVER_NOMATCH\" ; return KRB5KDC_ERR_SERVER_NOMATCH <vul-end> ; } if\n"
 },
 {
  "id": 1380,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void record_and_restart ( struct perf_event * event , unsigned long val , <vul-start> struct pt_regs * regs , int nmi ) <vul-end> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; <vul-start> if",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> pt_regs * regs <vul-end> ) { u64 <vul-start> ( event , <vul-end> & data ,\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> pt_regs * regs <vul-end> ) { u64 <vul-start> ( event, <vul-end> & data,\n"
 },
 {
  "id": 1381,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int flashsv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { int buf_size = avpkt -> size ; FlashSVContext * s = avctx -> priv_data ; int h_blocks , v_blocks , h_part , v_part , i , j , ret ; GetBitContext gb ; int last_blockwidth = s -> block_width ; int last_blockheight = s -> block_height ; if ( buf_size == 0 ) return 0 ; if ( buf_size < 4 ) return - 1 ; init_get_bits ( & gb , avpkt -> data , buf_size * 8 ) ; s -> block_width = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_width = get_bits ( & gb , 12 ) ; s -> block_height = 16 * ( get_bits ( & gb , 4 ) + 1 ) ; s -> image_height = get_bits ( & gb , 12 ) ; if ( last_blockwidth != s -> block_width || last_blockheight != s -> block_height ) av_freep ( & s -> blocks ) ; if ( s -> ver == 2 ) { skip_bits ( & gb , 6 ) ; if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"iframe\" ) ; return AVERROR_PATCHWELCOME ; } if ( get_bits1 ( & gb ) ) { avpriv_request_sample ( avctx , \"Custom palette\" ) ; return AVERROR_PATCHWELCOME ; } } h_blocks = s -> image_width / s -> block_width ; h_part = s -> image_width % s -> block_width ; v_blocks = s",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , \"Block parameters invalid\\\\n\" ) ; return AVERROR_INVALIDDATA ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> 8 ) ; if ( s -> block_width == 0 || s -> block_height == 0 ) { avpriv_request_sample ( avctx, \"iframe\" ) ; return AVERROR_PATCHWELCOME ; }\n"
 },
 {
  "id": 1382,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static long ioctl_file_dedupe_range ( struct file * file , void __user * arg ) { struct file_dedupe_range __user * argp = arg ; struct file_dedupe_range * same = NULL ; int ret ; unsigned long size ; u16 count ; if ( get_user ( count , & argp -> dest_count ) ) { ret = - EFAULT ; goto out ; } size = offsetof ( struct file_dedupe_range __user , info [ count ] ) ; same = memdup_user ( argp , size ) ; if ( IS_ERR ( same ) ) { ret = PTR_ERR ( same ) ; same = NULL ; goto out ; } <vul-start> ret = vfs_dedupe_file_range ( file , same ) ; <vul-end> if ( ret ) goto out ; ret = copy_to_user ( argp , same , size ) ; if ( ret ) ret = - EFAULT ; out : kfree ( same ) ; return ret ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> out ; } same -> dest_count = count ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> out ; } if ( count >= MAX_DEST_COUNT ) same -> size = 0 ;\n"
 },
 {
  "id": 1383,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , \" #%u type=%s id=%s \" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <vul-start> < ep2 ) <vul-end> ND_PRINT ( (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, cp, ep2, <vul-end> map, nmap\n"
 },
 {
  "id": 1384,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int msr_open ( struct inode * inode , struct file * file ) { unsigned int cpu ; <vul-start> struct cpuinfo_x86 * c ; <vul-end> cpu = iminor ( file -> f_path . dentry -> d_inode ) ; if ( cpu >= nr_cpu_ids || ! cpu_online ( cpu ) ) return - ENXIO ; c = & cpu_data ( cpu ) ; if ( ! cpu_has ( c , X86_FEATURE_MSR ) ) return - EIO ; return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> cpuinfo_x86 * c ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> cpuinfo_x86 * c ; if (! capable_wrt_inode_uidgid ( inode ) ) return - EACCES\n"
 },
 {
  "id": 1385,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void bond_setup ( struct net_device * bond_dev ) { struct bonding * bond = netdev_priv ( bond_dev ) ; rwlock_init ( & bond -> lock ) ; rwlock_init ( & bond -> curr_slave_lock ) ; bond -> params = bonding_defaults ; bond -> dev = bond_dev ; INIT_LIST_HEAD ( & bond -> vlan_list ) ; ether_setup ( bond_dev ) ; bond_dev -> netdev_ops = & bond_netdev_ops ; bond_dev -> ethtool_ops = & bond_ethtool_ops ; bond_set_mode_ops ( bond , bond -> params . mode ) ; bond_dev -> destructor = bond_destructor ; bond_dev -> tx_queue_len = 0 ; bond_dev -> flags |= IFF_MASTER | IFF_MULTICAST ; bond_dev -> priv_flags |= IFF_BONDING ; <vul-start> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <vul-end> bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ; bond_dev -> features |= NETIF_F_LLTX ; bond_dev -> hw_features = BOND_VLAN_FEATURES | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER ; bond_dev -> hw_features &= ~ ( NETIF_F_ALL_CSUM & ~ NETIF_F_NO_CSUM ) ; bond_dev -> features |= bond_dev -> hw_features ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <vul-end> ; bond_dev ->\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <vul-end> ; bond_dev ->\n"
 },
 {
  "id": 1386,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp9_receive_compressed_data ( VP9Decoder * pbi , <vul-start> size_t size , const uint8_t * * psource , <vul-end> int64_t time_stamp ) { <vul-start> VP9_COMMON * const cm = & pbi -> common ; <vul-end> const uint8_t * source = * psource ; int retcode = 0 ; cm -> error . error_code = VPX_CODEC_OK ; if ( size == 0 ) { <vul-start> if ( cm -> frame_refs [ 0 ] . idx != INT_MAX ) <vul-end> cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ; } <vul-start> if ( cm -> new_fb_idx >= 0 && cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count == 0 ) <vul-end> <vul-start> cm -> release_fb_cb ( cm -> cb_priv , <vul-end> <vul-start> & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) ; <vul-end> cm -> new_fb_idx = get_free_fb ( cm ) ; <vul-start> if ( setjmp ( cm -> error . jmp ) ) { <vul-end> <vul-start> cm -> error . setjmp = 0 ; <vul-end> <vul-start> if ( cm -> frame_refs [ 0 ] . idx != INT_MAX ) <vul-end> cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ; if ( cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; return - 1 ; } cm -> error . setjmp = 1 ; <vul-start> retcode = vp9_decode_frame ( pbi , source , source + size , psource ) ; <vul-end> <vul-start> if ( retcode < 0 ) {",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * * psource <vul-end> ) { VP9_COMMON <vul-start> { VP9_COMMON * volatile <vul-start> pbi -> common ; BufferPool * volatile const pool = cm -> buffer_pool ; RefCntBuffer * volatile const frame_bufs = cm -> buffer_pool -> frame_bufs <vul-start> ] . idx > 0 ) { assert ( cm -> frame_refs [ 0 ] . buf != NULL ) ; <vul-end> cm -> frame_refs <vul-start> 1 ; } } pbi -> ready_for_new_data = 0 ; if ( ! pbi -> frame_parallel_decode && <vul-end> cm -> new_fb_idx <vul-start> >= 0 && <vul-end> frame_bufs [ cm <vul-start> == 0 ) pool <vul-end> -> release_fb_cb ( <vul-start> -> release_fb_cb ( pool <vul-end> -> cb_priv , <vul-start> cb_priv , & <vul-end> frame_bufs [ cm <vul-start> ; if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; cm -> cur_frame = & pool -> frame_bufs [ cm -> new_fb_idx ] ; pbi -> hold_ref_buf = 0 ; if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; vp9_frameworker_lock_stats ( worker ) ; frame_bufs [ cm -> new_fb_idx ] . frame_worker_owner = worker ; pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; vp9_frameworker_unlock_stats ( worker ) ; } else { pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; } if ( <vul-start> ) ) { const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; int i ; <vul-start> = 0 ; pbi -> ready_for_new_data = 1 ; winterface -> sync ( & pbi -> lf_worker ) ; for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { winterface -> sync ( & pbi -> tile_workers [ i ] ) ; } lock_buffer_pool ( pool ) ; if ( pbi -> hold_ref_buf == 1 ) { int ref_index = 0 , mask ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( ( mask & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; } pbi -> hold_ref_buf = 0 ; } decrease_ref_count ( cm -> new_fb_idx , frame_bufs , pool ) ; unlock_buffer_pool ( pool ) ; vpx_clear_system_state ( ) <vul-end> ; return - <vul-start> = 1 ; <vul-end> vp9_decode_frame ( pbi <vul-start> psource ) ; swap_frame_buffers ( pbi ) ; vpx_clear_system_state ( ) ; if ( ! cm -> show_existing_frame ) { cm -> last_show_frame = cm -> show_frame ; cm -> prev_frame = cm -> cur_frame ; if ( cm -> seg . enabled && ! pbi -> frame_parallel_decode ) vp9_swap_current_and_last_seg_map ( cm ) ; } if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; vp9_frameworker_lock_stats ( worker ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } frame_worker_data -> frame_decoded = 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } else { cm -> last_width = cm -> width ; cm -> last_height = cm -> height ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } } <vul-end> cm -> error <vul-start> -> error . <vul-end> setjmp = 0 <vul-start> setjmp = 0 <vul-end> ; return retcode <vul-start> retcode ; } <vul-end>      \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * pbi, int64_t <vul-end> size, const <vul-start> pbi -> common ; VP9EncoderConfig * oxcf = & pbi -> oxcf <vul-start> 0 ) { lock_buffer_pool ( cm ) ; if (! pbi -> frame_parallel_decode ) { vpx_free_frame_buffers ( cm ) ; return - 1 ; } if (! pbi -> frame_workers ) { vpx_clear_system_state ( ) ; vpx_clear_system_state ( ) ; } <vul-start> == 0 ) { <vul-start> cb_priv, & <vul-end> cm -> frame_bufs <vul-start> raw_frame_buffer ) ; } <vul-start> ; if (! pbi -> frame_workers ) { vpx_free_frame_buffers ( cm ) ; return - 1 ; } if ( <vul-start> ) ) { <vul-end> return - 1 <vul-start> = 1 ; } <vul-start> 0 ) { vpx_clear_system_state ( ) ; vpx_clear_system_state ( ) ; <vul-start> 0 ) { vpx_error <vul-end>. error_code = <vul-start> = VPX_CODEC_ERROR ; vpx_error <vul-end>. setjmp = <vul-start> setjmp = 0 ; if (! pbi -> show_existing_frame ) vpx_error <vul-end>. setjmp = <vul-start> = 0 ; <vul-end> cm -> frame_bufs <vul-start> 0 ]. ref_count -- ; unlock_buffer_pool ( cm ) ; <vul-start> 0 ) { vpx_error <vul-end>. error_code = <vul-start> = VPX_CODEC_ERROR ; vpx_error <vul-end>. setjmp = <vul-start> = 0 ; <vul-end> cm -> frame_bufs <vul-start> -> new_fb_idx = get_free_fb ( cm ) ; } <vul-end> return retcode ;\n"
 },
 {
  "id": 1387,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; char * identifier ; char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ; while ( ! stop ) { switch ( * ip ) { case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ;",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> -> length , 0 ,\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>. re -> flags <vul-end>, NULL,\n"
 },
 {
  "id": 1388,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void update_mbgraph_mb_stats ( VP9_COMP * cpi , MBGRAPH_MB_STATS * stats , YV12_BUFFER_CONFIG * buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref , <vul-start> int_mv * prev_golden_ref_mv , <vul-end> YV12_BUFFER_CONFIG * alt_ref , int mb_row , int mb_col ) { <vul-start> MACROBLOCK * const x = & cpi -> mb ; <vul-end> MACROBLOCKD * const xd = & x -> e_mbd ; int intra_error ; VP9_COMMON * cm = & cpi -> common ; x -> plane [ 0 ] . src . buf = buf -> y_buffer + mb_y_offset ; x -> plane [ 0 ] . src . stride = buf -> y_stride ; xd -> plane [ 0 ] . dst . buf = get_frame_new_buffer ( cm ) -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . dst . stride = get_frame_new_buffer ( cm ) -> y_stride ; intra_error = find_best_16x16_intra ( cpi , & stats -> ref [ INTRA_FRAME ] . m . mode ) ; if ( intra_error <= 0 ) intra_error = 1 ; stats -> ref [ INTRA_FRAME ] . err = intra_error ; if ( golden_ref ) { int g_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = golden_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = golden_ref -> y_stride ; g_motion_error = do_16x16_motion_search ( cpi , prev_golden_ref_mv , & stats -> ref [ GOLDEN_FRAME ] . m . mv , mb_row , mb_col ) ; stats -> ref [ GOLDEN_FRAME ] . err = g_motion_error",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * golden_ref , const MV <vul-end> * prev_golden_ref_mv , <vul-start> & cpi -> td .\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * golden_ref, YV12_BUFFER_CONFIG * alt_ref, <vul-start> & cpi -> td.\n"
 },
 {
  "id": 1389,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 static ssize_t rpmsg_eptdev_write_iter ( struct kiocb * iocb , struct iov_iter * from ) { struct file * filp = iocb -> ki_filp ; struct rpmsg_eptdev * eptdev = filp -> private_data ; size_t len = iov_iter_count ( from ) ; void * kbuf ; int ret ; kbuf = kzalloc ( len , GFP_KERNEL ) ; if ( ! kbuf ) return - ENOMEM ; if ( ! copy_from_iter_full ( kbuf , len , from ) ) <vul-start> return - EFAULT ; <vul-end> if ( mutex_lock_interruptible ( & eptdev -> ept_lock ) ) { ret = - ERESTARTSYS ; goto free_kbuf ; } if ( ! eptdev -> ept ) { ret = - EPIPE ; goto unlock_eptdev ; } if ( filp -> f_flags & O_NONBLOCK ) ret = rpmsg_trysend ( eptdev -> ept , kbuf , len ) ; else ret = rpmsg_send ( eptdev -> ept , kbuf , len ) ; unlock_eptdev : mutex_unlock ( & eptdev -> ept_lock ) ; free_kbuf : kfree ( kbuf ) ; return ret < 0 ? ret : len ; }",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> from ) ) { ret = <vul-end> - EFAULT ; <vul-start> - EFAULT ; goto free_kbuf ; }\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> return - EFAULT ; if ( len > RPMSG_MAX_SIZE ) return - EMSGSIZE\n"
 },
 {
  "id": 1390,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <vul-end> { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start>       static\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>       static\n"
 },
 {
  "id": 1391,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 gboolean _pango_emoji_iter_next ( PangoEmojiIter * iter ) { PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID ; if ( iter -> end == iter -> text_end ) return FALSE ; iter -> start = iter -> end ; for ( ; iter -> end < iter -> text_end ; iter -> end = g_utf8_next_char ( iter -> end ) ) { gunichar ch = g_utf8_get_char ( iter -> end ) ; if ( ( ! ( ch == kZeroWidthJoinerCharacter && ! iter -> is_emoji ) && ch != kVariationSelector15Character && ch != kVariationSelector16Character && ch != kCombiningEnclosingCircleBackslashCharacter && ! _pango_Is_Regional_Indicator ( ch ) && ! ( ( ch == kLeftSpeechBubbleCharacter || ch == kRainbowCharacter || ch == kMaleSignCharacter || ch == kFemaleSignCharacter || ch == kStaffOfAesculapiusCharacter ) && ! iter -> is_emoji ) ) || current_emoji_type == PANGO_EMOJI_TYPE_INVALID ) { current_emoji_type = _pango_get_emoji_type ( ch ) ; } if ( g_utf8_next_char ( iter -> end ) < iter -> text_end ) { gunichar peek_char = g_utf8_get_char ( g_utf8_next_char ( iter -> end ) ) ; if ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_EMOJI && peek_char == kVariationSelector15Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT ; } if ( ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_TEXT || _pango_Is_Emoji_Keycap_Base ( ch ) ) && peek_char == kVariationSelector16Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( _pango_Is_Emoji_Keycap_Base ( ch ) && peek_char == kCombiningEnclosingKeycapCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } ; if ( _pango_Is_Regional_Indicator ( ch ) && _pango_Is_Regional_Indicator ( peek_char ) ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( ( ch == kEyeCharacter || ch == kWavingWhiteFlagCharacter ) && peek_char == kZeroWidthJoinerCharacter ) { current_emoji_type =",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> current_emoji_type ) ; if ( iter -> is_emoji ) { if ( _pango_emoji_iter_is_type_prefix ( iter ) ) { iter -> is_emoji = FALSE ; break ; } }\n"
 },
 {
  "id": 1392,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int imagetobmp ( opj_image_t * image , const char * outfile ) { int w , h ; int i , pad ; FILE * fdest = NULL ; int adjustR , adjustG , adjustB ; if ( image -> comps [ 0 ] . prec < 8 ) { fprintf ( stderr , \"Unsupported number of components: %d\\\\n\" , image -> comps [ 0 ] . prec ) ; return 1 ; } if ( image -> numcomps >= 3 && image -> comps [ 0 ] . dx == image -> comps [ 1 ] . dx && image -> comps [ 1 ] . dx == image -> comps [ 2 ] . dx && image -> comps [ 0 ] . dy == image -> comps [ 1 ] . dy && image -> comps [ 1 ] . dy == image -> comps [ 2 ] . dy && image -> comps [ 0 ] . prec == image -> comps [ 1 ] . prec && image -> comps [ 1 ] . prec == image -> comps [ 2 ] . prec ) { fdest = fopen ( outfile , \"wb\" ) ; if ( ! fdest ) { fprintf ( stderr , \"ERROR -> failed to open %s for writing\\\\n\" , outfile ) ; return 1 ; } w = ( int ) image -> comps [ 0 ] . w ; h = ( int ) image -> comps [ 0 ] . h ; fprintf ( fdest , \"BM\" ) ; fprintf ( fdest ,",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> { for ( pad = ( <vul-end> w % 4\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> 0 ) { if ( w < 0 || h < 0 || w > 3 || h > 3 ) { fprintf ( fdest, \"ERROR -> failed to resize image\\\\n\" ) ; return 1 ; } <vul-start> fdest ) ; <vul-end> } fclose (\n"
 },
 {
  "id": 1393,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static cJSON * cJSON_New_Item ( void ) { cJSON * node = ( cJSON * ) cJSON_malloc ( sizeof ( cJSON ) ) ; if ( node ) memset ( node , 0 , sizeof ( cJSON ) ) ; return node ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: \n"
 },
 {
  "id": 1394,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 cJSON * cJSON_DetachItemFromArray ( cJSON * array , int which ) { cJSON * c = array -> child ; <vul-start> while ( c && which > 0 ) { <vul-end> <vul-start> c = c -> next ; <vul-end> -- which ; } if ( ! c ) return 0 ; if ( c -> prev ) c -> prev -> next = c -> next ; if ( c -> next ) c -> next -> prev = c -> prev ; if ( c == array -> child ) array -> child = c -> next ; c -> prev = c -> next = 0 ; return c ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> > 0 ) <vul-end> c = c <vul-start> c -> next , which -- ; <vul-end> if ( !\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> > 0 ) <vul-end> c = c <vul-start> c -> next, which -- ; <vul-end> if (!\n"
 },
 {
  "id": 1395,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int sandbox ( void * sandbox_arg ) { ( void ) sandbox_arg ; pid_t child_pid = getpid ( ) ; if ( arg_debug ) printf ( \"Initializing child process\\\\n\" ) ; close ( parent_to_child_fds [ 1 ] ) ; close ( child_to_parent_fds [ 0 ] ) ; wait_for_other ( parent_to_child_fds [ 0 ] ) ; if ( arg_debug && child_pid == 1 ) printf ( \"PID namespace installed\\\\n\" ) ; if ( cfg . hostname ) { if ( sethostname ( cfg . hostname , strlen ( cfg . hostname ) ) < 0 ) errExit ( \"sethostname\" ) ; } if ( mount ( NULL , \"/\" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) { chk_chroot ( ) ; } preproc_mount_mnt_dir ( ) ; if ( mount ( LIBDIR \"/firejail\" , RUN_FIREJAIL_LIB_DIR , \"none\" , MS_BIND , NULL ) < 0 ) errExit ( \"mounting \" RUN_FIREJAIL_LIB_DIR ) ; if ( cfg . name ) fs_logger2 ( \"sandbox name:\" , cfg . name ) ; fs_logger2int ( \"sandbox pid:\" , ( int ) sandbox_pid ) ; if ( cfg . chrootdir ) fs_logger ( \"sandbox filesystem: chroot\" ) ; else if ( arg_overlay ) fs_logger ( \"sandbox filesystem: overlay\" ) ; else fs_logger ( \"sandbox filesystem: local\" ) ; fs_logger ( \"install mount namespace\" ) ; if ( arg_netfilter && any_bridge_configured ( ) ) { netfilter ( arg_netfilter_file ) ; } if ( arg_netfilter6 && any_bridge_configured ( ) ) { netfilter6 ( arg_netfilter6_file ) ; } int gw_cfg_failed = 0 ; if ( arg_nonetwork ) { net_if_up ( \"lo\"",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ( ) ; <vul-end> save_cpu ( ) <vul-start> rv ; } fs_rdonly ( RUN_SECCOMP_DIR ) ; # endif set_caps ( ) ; <vul-end> FILE * rj\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ) ) ; # ifdef HAVE_SECCOMP # ifdef HAVE_SECCOMP_SET_PRIVS if ( arg_privatereports ) set_privatereports ( 0 ) ; # endif <vul-start> ) ) ; # ifdef HAVE_SECCOMP_SET_PRIVS if ( arg_privatereports ) set_privatereports ( 0 ) ; # endif\n"
 },
 {
  "id": 1396,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void PNGAPI png_info_init_3 ( png_infopp ptr_ptr , png_size_t png_info_struct_size ) { png_infop info_ptr = * ptr_ptr ; png_debug ( 1 , \"in png_info_init_3\" ) ; if ( info_ptr == NULL ) return ; if ( png_sizeof ( png_info ) > png_info_struct_size ) { png_destroy_struct ( info_ptr ) ; info_ptr = ( png_infop ) png_create_struct ( PNG_STRUCT_INFO ) ; * ptr_ptr = info_ptr ; <vul-start> } <vul-end> png_memset ( info_ptr , 0 , png_sizeof ( png_info ) ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = info_ptr ; if ( info_ptr == NULL ) return ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = info_ptr ; if ( info_ptr == NULL ) return ;\n"
 },
 {
  "id": 1397,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static OPJ_BOOL opj_j2k_write_sod ( opj_j2k_t * p_j2k , opj_tcd_t * p_tile_coder , OPJ_BYTE * p_data , OPJ_UINT32 * p_data_written , OPJ_UINT32 p_total_data_size , const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { opj_codestream_info_t * l_cstr_info = 00 ; OPJ_UINT32 l_remaining_data ; assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; <vul-start> opj_write_bytes ( p_data , J2K_MS_SOD , <vul-end> 2 ) ; p_data += 2 ; l_remaining_data = p_total_data_size - 4 ; p_tile_coder -> tp_num = p_j2k -> m_specific_param . m_encoder . m_current_poc_tile_part_number ; p_tile_coder -> cur_tp_num = p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number ; # ifdef USE_JPWL assert ( 0 && \"TODO\" ) ; # endif if ( p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number == 0 ) { p_tile_coder -> tcd_image -> tiles -> packno = 0 ; if ( l_cstr_info ) { l_cstr_info -> packno = 0 ; } } * p_data_written = 0 ; if ( ! opj_tcd_encode_tile ( p_tile_coder , p_j2k -> m_current_tile_number , p_data , p_data_written , l_remaining_data , l_cstr_info , p_manager ) ) { opj_event_msg ( p_manager , EVT_ERROR , \"Cannot encode tile\\\\n\" ) ; return OPJ_FALSE ; } * p_data_written += 2 ; return OPJ_TRUE ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , \"Not enough bytes in output buffer to write SOD marker\\\\n\" ) ; return OPJ_FALSE ; }\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> p_stream ) ; if ( p_total_data_size < 2 ) { opj_event_msg ( p_manager, EVT_ERROR, \"opj_j2k_write_sod: only 2 bytes remaining in J2K\\\\n\" ) ; return FALSE ; }\n"
 },
 {
  "id": 1398,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) <vul-start> { <vul-end> kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> mixer ) { snd_usb_mixer_disconnect ( mixer ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> mixer ) { if ( mixer -> disconnected ) return ;\n"
 },
 {
  "id": 1399,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int mwifiex_ret_wmm_get_status ( struct mwifiex_private * priv , const struct host_cmd_ds_command * resp ) { u8 * curr = ( u8 * ) & resp -> params . get_wmm_status ; uint16_t resp_len = le16_to_cpu ( resp -> size ) , tlv_len ; int mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK ; bool valid = true ; struct mwifiex_ie_types_data * tlv_hdr ; struct mwifiex_ie_types_wmm_queue_status * tlv_wmm_qstatus ; struct ieee_types_wmm_parameter * wmm_param_ie = NULL ; struct mwifiex_wmm_ac_status * ac_status ; mwifiex_dbg ( priv -> adapter , INFO , \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\\\n\" , resp_len ) ; while ( ( resp_len >= sizeof ( tlv_hdr -> header ) ) && valid ) { tlv_hdr = ( struct mwifiex_ie_types_data * ) curr ; tlv_len = le16_to_cpu ( tlv_hdr -> header . len ) ; if ( resp_len < tlv_len + sizeof ( tlv_hdr -> header ) ) break ; switch ( le16_to_cpu ( tlv_hdr -> header . type ) ) { case TLV_TYPE_WMMQSTATUS : tlv_wmm_qstatus = ( struct mwifiex_ie_types_wmm_queue_status * ) tlv_hdr ; mwifiex_dbg ( priv -> adapter , CMD , \"info: CMD_RESP: WMM_GET_STATUS:\\\\t\" \"QSTATUS TLV: %d, %d, %d\\\\n\" , tlv_wmm_qstatus -> queue_index , tlv_wmm_qstatus -> flow_required , tlv_wmm_qstatus -> disabled ) ; ac_status = & priv -> wmm . ac_status [ tlv_wmm_qstatus -> queue_index ] ; ac_status -> disabled = tlv_wmm_qstatus -> disabled ; ac_status -> flow_required = tlv_wmm_qstatus -> flow_required ; ac_status -> flow_created = tlv_wmm_qstatus -> flow_created ; break ; case WLAN_EID_VENDOR_SPECIFIC : wmm_param_ie = ( struct ieee_types_wmm_parameter * ) ( curr + 2 ) ; wmm_param_ie -> vend_hdr . len = ( u8 ) tlv_len ; wmm_param_ie",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> mask ) ; if ( wmm_param_ie -> vend_hdr . len + 2 > sizeof ( struct ieee_types_wmm_parameter ) ) break ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> mask ) ; if ( wmm_param_ie -> vend_hdr. len + 2 > IEEE80211_MAX_WMM_PARAM_SET_COUNT ) { mwifiex_dbg ( priv -> adapter, ERROR, \"Invalid param length!\\\\n\" ) ; break ; }\n"
 },
 {
  "id": 1400,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 static void toggle_os_keylockstates ( int fd , int changedlockstates ) { BTIF_TRACE_EVENT ( \"%s: fd = %d, changedlockstates = 0x%x\" , __FUNCTION__ , fd , changedlockstates ) ; UINT8 hidreport [ 9 ] ; int reportIndex ; memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; reportIndex = 4 ; if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_CAPSLOCK ) { BTIF_TRACE_DEBUG ( \"%s Setting CAPSLOCK\" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_CAPSLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_NUMLOCK ) { BTIF_TRACE_DEBUG ( \"%s Setting NUMLOCK\" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_NUMLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_SCROLLLOCK ) { BTIF_TRACE_DEBUG ( \"%s Setting SCROLLLOCK\" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_SCROLLLOCK ; } BTIF_TRACE_DEBUG ( \"Writing hidreport #1 to os: \" \"%s: %x %x %x\" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( \"%s: %x %x %x\" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( \"%s: %x %x %x\" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; <vul-start> usleep ( 200000 ) ; <vul-end> memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; BTIF_TRACE_DEBUG ( \"Writing hidreport #2 to os: \"",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ) ) ; TEMP_FAILURE_RETRY ( <vul-start> usleep ( 200000 )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ) ) ; TEMP_FAILURE_RETRY ( <vul-start> usleep ( 200000 )\n"
 },
 {
  "id": 1401,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 BOOL nego_read_request ( rdpNego * nego , wStream * s ) { BYTE li ; BYTE type ; UINT16 length ; if ( ! tpkt_read_header ( s , & length ) ) return FALSE ; if ( ! tpdu_read_connection_request ( s , & li , length ) ) return FALSE ; if ( li != Stream_GetRemainingLength ( s ) + 6 ) { WLog_ERR ( TAG , \"Incorrect TPDU length indicator.\" ) ; return FALSE ; } if ( ! nego_read_request_token_or_cookie ( nego , s ) ) { WLog_ERR ( TAG , \"Failed to parse routing token or cookie.\" ) ; return FALSE ; } if ( Stream_GetRemainingLength ( s ) >= 8 ) { Stream_Read_UINT8 ( s , type ) ; if ( type != TYPE_RDP_NEG_REQ ) { WLog_ERR ( TAG , \"Incorrect negotiation request type %\" PRIu8 \"\" , type ) ; return FALSE ; } <vul-start> nego_process_negotiation_request ( nego , s ) ; <vul-end> } return tpkt_ensure_stream_consumed ( s , length ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> FALSE ; } if ( ! <vul-start> , s ) ) return FALSE\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> FALSE ; } if (! <vul-start>, s ) ) return FALSE\n"
 },
 {
  "id": 1402,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int l2tp_ip6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_l2tpip6 * , lsa , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; <vul-start> struct ipv6_pinfo * np = inet6_sk ( sk ) ; <vul-end> struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int transhdrlen = 4 ; int ulen = len + transhdrlen ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( lsa ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( lsa -> l2tp_family && lsa -> l2tp_family != AF_INET6 ) return - EAFNOSUPPORT ; daddr = & lsa -> l2tp_addr ; if ( np -> sndflow ) { fl6 . flowlabel = lsa -> l2tp_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , &",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ( sk ) ; struct ipv6_txoptions * opt_to_free = NULL <vul-start> } if ( ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <vul-end> if ( flowlabel <vul-start> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ( sk ) ; struct ipv6_txoptions * opt_to_free = NULL <vul-start> NULL ; } opt_to_free = opt ; <vul-start> : fl6_sock_release ( opt_to_free <vul-end> ) ; return\n"
 },
 {
  "id": 1403,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void smp_task_done ( struct sas_task * task ) { <vul-start> if ( ! del_timer ( & task -> slow_task -> timer ) ) <vul-end> return ; complete ( & task -> slow_task -> completion ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> task ) { <vul-end> del_timer ( & <vul-start> -> timer ) <vul-end> ; complete (\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> task ) { <vul-end> complete ( &\n"
 },
 {
  "id": 1404,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int cli_scanpe ( cli_ctx * ctx ) { uint16_t e_magic ; uint16_t nsections ; uint32_t e_lfanew ; uint32_t ep , vep ; uint8_t polipos = 0 ; time_t timestamp ; struct pe_image_file_hdr file_hdr ; union { struct pe_image_optional_hdr64 opt64 ; struct pe_image_optional_hdr32 opt32 ; } pe_opt ; struct pe_image_section_hdr * section_hdr ; char sname [ 9 ] , epbuff [ 4096 ] , * tempfile ; uint32_t epsize ; ssize_t bytes , at ; <vul-start> unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ; <vul-end> unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ; int ( * upxfn ) ( const char * , uint32_t , char * , uint32_t * , uint32_t , uint32_t , uint32_t ) = NULL ; const char * src = NULL ; char * dest = NULL ; int ndesc , ret = CL_CLEAN , upack = 0 , native = 0 ; size_t fsize ; <vul-start> uint32_t valign , falign , hdr_size , j ; <vul-end> struct cli_exe_section * exe_sections ; char timestr [ 32 ] ; struct pe_image_data_dir * dirs ; struct cli_bc_ctx * bc_ctx ; fmap_t * map ; struct cli_pe_hook_data pedata ; # ifdef HAVE__INTERNAL__SHA_COLLECT int sha_collect = ctx -> sha_collect ; # endif const char * archtype = NULL , * subsystem = NULL ; uint32_t viruses_found = 0 ; # if HAVE_JSON int toval = 0 ; struct json_object * pe_json = NULL ; char jsonbuf [",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int i , j , <vul-start> overlays = 0 , rescan = 1 <vul-start> falign , hdr_size <vul-end> ; struct cli_exe_section <vul-start> ; # endif while ( rescan == 1 ) { rescan = 0 ; <vul-start> ++ ) { exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; if ( exe_sections [ i ] . rsz ) { if ( ! CLI_ISCONTAINED ( 0 , fsize , exe_sections [ i ] . uraw , exe_sections [ i ] . ursz ) || exe_sections [ i ] . raw >= fsize ) { cli_dbgmsg ( \"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\\\n\" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; if ( nsections == 1 ) { free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , \"Heuristics.Broken.Executable\" ) ; return CL_VIRUS ; } return CL_CLEAN ; } for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & exe_sections [ j ] , & exe_sections [ j + 1 ] , sizeof ( struct cli_exe_section ) ) ; for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & section_hdr [ j ] , & section_hdr [ j + 1 ] , sizeof ( struct pe_image_section_hdr ) ) ; nsections -- ; rescan = 1 ; break ; } } } } for ( i = 0 ; i < nsections ; i ++ ) { <vul-start> ] = 0 <vul-end> ; # if <vul-start> rsz ) { <vul-end> if ( SCAN_ALGO\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, at ; # if HAVE_JSON int have_json_option = 0, opt_json = 0 ; # endif <vul-start> hdr_size, j, has_json_option = 0 <vul-start> ; if ( has_json_option ) { if ( <vul-start> return CL_VIRUS ; } has_json_option = 1 ; <vul-start> } if ( has_json_option ) { if ( <vul-start> return CL_VIRUS ; }\n"
 },
 {
  "id": 1405,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) { struct tcp_options_received tcp_opt ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct dst_entry * dst ; __u8 rcv_wscale ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) ) goto out ; mss = __cookie_v6_check ( ipv6_hdr ( skb ) , th , cookie ) ; if ( mss == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , 0 , NULL ) ; if ( ! cookie_timestamp_decode ( & tcp_opt ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp6_request_sock_ops , sk , false ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> tfo_listener = false ; if ( security_inet_conn_request ( sk , skb , req ) ) goto out_free ; req ->",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> & fl6 , rcu_dereference ( <vul-start> np -> opt )\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <vul-start> & fl6, rcu_dereference ( <vul-start> np -> opt ) <vul-start>, & final ) ; rcu_read_unlock (\n"
 },
 {
  "id": 1406,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ; ue -> card = card ; ue ->\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> - ENOMEM ; memset ( & ue -> info, 0, sizeof ( ue -> info ) ) ;\n"
 },
 {
  "id": 1407,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 int ext4_setattr ( struct dentry * dentry , struct iattr * attr ) { struct inode * inode = d_inode ( dentry ) ; int error , rc = 0 ; int orphan = 0 ; const unsigned int ia_valid = attr -> ia_valid ; error = inode_change_ok ( inode , attr ) ; if ( error ) return error ; if ( is_quota_modification ( inode , attr ) ) { error = dquot_initialize ( inode ) ; if ( error ) return error ; } if ( ( ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { handle_t * handle ; handle = ext4_journal_start ( inode , EXT4_HT_QUOTA , ( EXT4_MAXQUOTAS_INIT_BLOCKS ( inode -> i_sb ) + EXT4_MAXQUOTAS_DEL_BLOCKS ( inode -> i_sb ) ) + 3 ) ; if ( IS_ERR ( handle ) ) { error = PTR_ERR ( handle ) ; goto err_out ; } error = dquot_transfer ( inode , attr ) ; if ( error ) { ext4_journal_stop ( handle ) ; return error ; } if ( attr -> ia_valid & ATTR_UID ) inode -> i_uid = attr -> ia_uid ; if ( attr -> ia_valid & ATTR_GID ) inode -> i_gid = attr -> ia_gid ; error = ext4_mark_inode_dirty ( handle , inode ) ; ext4_journal_stop ( handle ) ; } if ( attr -> ia_valid & ATTR_SIZE ) { handle_t * handle ; loff_t oldsize = inode -> i_size ;",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <vul-start> ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) ; } if ( shrink ) ext4_truncate ( inode ) ; <vul-start> ( shrink ) <vul-end> } if (\n"
 },
 {
  "id": 1408,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void save_bt_to_dump_dir ( const char * bt , const char * exe , const char * reason ) { time_t t = time ( NULL ) ; const char * iso_date = iso_date_string ( & t ) ; uid_t my_euid = ( uid_t ) - 1L ; mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH ; if ( ! ( g_opts & OPT_x ) ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } <vul-start> pid_t my_pid = getpid ( ) ; <vul-end> char base [ sizeof ( \"xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu\" ) + 2 * sizeof ( long ) * 3 ] ; sprintf ( base , \"xorg-%s-%lu-%u\" , iso_date , ( long ) my_pid , g_bt_count ) ; char * path = concat_path_file ( debug_dumps_dir , base ) ; struct dump_dir * dd = dd_create ( path , my_euid , mode ) ; if ( dd ) { dd_create_basic_files ( dd , my_euid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; dd_save_text ( dd , FILENAME_ANALYZER , \"xorg\" ) ; dd_save_text ( dd , FILENAME_TYPE , \"xorg\" ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; dd_save_text ( dd , FILENAME_BACKTRACE , bt ) ; if ( ! exe ) { exe = \"/usr/bin/X\" ; if ( access ( \"/usr/bin/Xorg\" , X_OK ) == 0 ) exe = \"/usr/bin/Xorg\" ; } dd_save_text ( dd , FILENAME_EXECUTABLE , exe ) ; dd_close ( dd ) ; notify_new_path ( path ) ; } free ( path ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ) ; } if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( \"Not going to make dump directories world readable because PrivateReports is on\" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ; } if ( g_bt_count > 1024 ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }\n"
 },
 {
  "id": 1409,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 IHEVCD_ERROR_T ihevcd_parse_sps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i ; WORD32 vps_id ; WORD32 sps_max_sub_layers ; WORD32 sps_id ; WORD32 sps_temporal_id_nesting_flag ; sps_t * ps_sps ; profile_tier_lvl_info_t s_ptl ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; BITS_PARSE ( \"video_parameter_set_id\" , value , ps_bitstrm , 4 ) ; vps_id = value ; vps_id = CLIP3 ( vps_id , 0 , MAX_VPS_CNT - 1 ) ; BITS_PARSE ( \"sps_max_sub_layers_minus1\" , value , ps_bitstrm , 3 ) ; sps_max_sub_layers = value + 1 ; sps_max_sub_layers = CLIP3 ( sps_max_sub_layers , 1 , 7 ) ; BITS_PARSE ( \"sps_temporal_id_nesting_flag\" , value , ps_bitstrm , 1 ) ; sps_temporal_id_nesting_flag = value ; ret = ihevcd_profile_tier_level ( ps_bitstrm , & ( s_ptl ) , 1 , ( sps_max_sub_layers - 1 ) ) ; UEV_PARSE ( \"seq_parameter_set_id\" , value , ps_bitstrm ) ; sps_id = value ; if ( ( sps_id >= MAX_SPS_CNT ) || ( sps_id < 0 ) ) { if ( ps_codec -> i4_sps_done ) return IHEVCD_UNSUPPORTED_SPS_ID ; else sps_id = 0 ; } ps_sps = ( ps_codec -> s_parse . ps_sps_base + MAX_SPS_CNT - 1 ) ; ps_sps -> i1_sps_id = sps_id ; ps_sps -> i1_vps_id = vps_id ; ps_sps -> i1_sps_max_sub_layers = sps_max_sub_layers ; ps_sps -> i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag ; ps_codec -> i4_sps_id = sps_id ; memcpy ( & ps_sps -> s_ptl , & s_ptl , sizeof ( profile_tier_lvl_info_t ) ) ; UEV_PARSE ( \"chroma_format_idc\" , value , ps_bitstrm ) ; ps_sps -> i1_chroma_format_idc = value ; if ( ps_sps ->",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> + 1 ; if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) { return IHEVCD_INVALID_PARAMETER ; } <vul-start> = value ; if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) { return IHEVCD_INVALID_PARAMETER ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> + 1 ; if ( ( ps_sps -> i1_sps_max_dec_pic_buffering [ i ] > ps_codec -> i4_max_pic_buffering ) || ( ps_sps -> i1_sps_max_num_reorder_pics > ps_codec -> i4_max_pic_buffering ) ) { return IHEVCD_INVALID_PARAMETER ; }\n"
 },
 {
  "id": 1410,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void put_crypt_info ( struct fscrypt_info * ci ) { if ( ! ci ) return ; <vul-start> key_put ( ci -> ci_keyring_key ) ; <vul-end> crypto_free_skcipher ( ci -> ci_ctfm ) ; kmem_cache_free ( fscrypt_info_cachep , ci ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ) return ; <vul-end> crypto_free_skcipher ( ci\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ) return ; if ( ci -> ci_keyring_key )\n"
 },
 {
  "id": 1411,
  "question": "CWE-78 Code Input Vulnerable Code Is: CWE-78 int imap_subscribe ( char * path , bool subscribe ) { struct ImapData * idata = NULL ; char buf [ LONG_STRING ] ; char mbox [ LONG_STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct ImapMbox mx ; <vul-start> if ( ! mx_is_imap ( path ) || imap_parse_path ( path , & mx ) || ! mx . mbox ) <vul-end> { mutt_error ( _ ( \"Bad mailbox name\" ) ) ; return - 1 ; } idata = imap_conn_find ( & ( mx . account ) , 0 ) ; if ( ! idata ) goto fail ; imap_fix_path ( idata , mx . mbox , buf , sizeof ( buf ) ) ; if ( ! * buf ) mutt_str_strfcpy ( buf , \"INBOX\" , sizeof ( buf ) ) ; if ( ImapCheckSubscribed ) { mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; <vul-start> snprintf ( mbox , sizeof ( mbox ) , \"%smailboxes \\\\\"%s\\\\\"\" , subscribe ? \"\" : \"un\" , path ) ; <vul-end> if ( mutt_parse_rc_line ( mbox , & token , & err ) ) mutt_debug ( 1 , \"Error adding subscribed mailbox: %s\\\\n\" , errstr ) ; FREE ( & token . data ) ; } if ( subscribe ) mutt_message ( _ ( \"Subscribing to %s...\" ) , buf ) ; else mutt_message ( _ ( \"Unsubscribing from %s...\" ) , buf ) ; imap_munge_mbox_name ( idata , mbox",
  "golden_answers": [
   "CWE-78 Fixed Code Lines are: <vul-start> ImapMbox mx ; size_t len = 0 ; <vul-start> errstr ) ; len = <vul-start> mbox ) , \"%smailboxes \" <vul-end> , subscribe ? <vul-start> \"\" : \"un\" ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-78 Fixed Code Lines are: <vul-start> ImapMbox mx ; int ret ; <vul-start> errstr ) ; ret = snprintf ( mbox, sizeof ( mbox ), \"%smailboxes \\\\\"%s\\\\\"\", subscribe? \"\" : \"un\", path ) ; if ( ret >= sizeof ( mbox ) ) { mutt_error ( _ ( \"Error adding subscribed mailbox: %s\\\\n\" ), errstr ) ; FREE ( & token. data ) ; return - 1 ; } <vul-start>, \"%smailboxes \\\\\"%s\\\\\"\", ret <vul-end>, path )\n"
 },
 {
  "id": 1412,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void handle_ppp ( netdissect_options * ndo , u_int proto , const u_char * p , int length ) { if ( ( proto & 0xff00 ) == 0x7e00 ) { ppp_hdlc ( ndo , p - 1 , length ) ; return ; } switch ( proto ) { case PPP_LCP : case PPP_IPCP : case PPP_OSICP : case PPP_MPLSCP : case PPP_IPV6CP : case PPP_CCP : case PPP_BACP : handle_ctrl_proto ( ndo , proto , p , length ) ; break ; case PPP_ML : handle_mlppp ( ndo , p , length ) ; break ; case PPP_CHAP : handle_chap ( ndo , p , length ) ; break ; case PPP_PAP : handle_pap ( ndo , p , length ) ; break ; case PPP_BAP : handle_bap ( ndo , p , length ) ; break ; case ETHERTYPE_IP : case PPP_VJNC : case PPP_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : case PPP_IPV6 : ip6_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPX : case PPP_IPX : ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : <vul-start> isoclns_print ( ndo , p , length , length ) ; <vul-end> break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST : mpls_print ( ndo , p , length ) ; break ; case PPP_COMP : ND_PRINT ( ( ndo , \"compressed PPP data\" ) ) ; break ; default : ND_PRINT ( ( ndo , \"%s \" , tok2str ( ppptype2str , \"unknown PPP protocol (0x%04x)\" , proto",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> p , length <vul-end> ) ; break\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> p, length <vul-end> ) ; break <vul-start> p, length <vul-end> ) ; break\n"
 },
 {
  "id": 1413,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 void big_key_describe ( const struct key * key , struct seq_file * m ) { size_t datalen = ( size_t ) key -> payload . data [ big_key_len ] ; seq_puts ( m , key -> description ) ; <vul-start> if ( key_is_instantiated ( key ) ) <vul-end> seq_printf ( m , \": %zu [%s]\" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\" ) ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_positive <vul-end> ( key )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_positive <vul-end> ( key )\n"
 },
 {
  "id": 1414,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int read_exceptions ( struct pstore * ps , int ( * callback ) ( void * callback_context , chunk_t old , chunk_t new ) , void * callback_context ) { int r , full = 1 ; for ( ps -> current_area = 0 ; full ; ps -> current_area ++ ) { r = area_io ( ps , READ ) ; if ( r ) return r ; r = insert_exceptions ( ps , callback , callback_context , & full ) ; if ( r ) return r ; } ps -> current_area -- ; <vul-start> return 0 ; <vul-end> }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> current_area -- ; skip_metadata ( ps ) ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> current_area -- ; if ( ps -> current_area < 0 ) return - EFAULT ;\n"
 },
 {
  "id": 1415,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } <vul-start> DPRINTF ( \"Data ready tag=0x%x len=%zd\\\\n\" , r -> req . tag , r -> iov . iov_len ) ; <vul-end> <vul-start> n = r -> iov . iov_len / 512 ; <vul-end> r -> sector += n ; r -> sector_count -= n ; <vul-start> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <vul-end> }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , r -> qiov . size <vul-end> ) ; n <vul-start> = r -> qiov . size <vul-end> / 512 ; <vul-start> , r -> qiov . size <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } DPRINTF ( \"Data ready tag=0x%x len=%zu\\\\n\" <vul-end>, r -> <vul-start>. tag, r -> iov. size <vul-end> ) ; n <vul-start> = r -> qiov. size <vul-end> / 512 ; <vul-start> -= n ; r -> iov. size -= n ;\n"
 },
 {
  "id": 1416,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 asmlinkage long sys_oabi_semtimedop ( int semid , struct oabi_sembuf __user * tsops , unsigned nsops , const struct timespec __user * timeout ) { struct sembuf * sops ; struct timespec local_timeout ; long err ; int i ; <vul-start> if ( nsops < 1 ) <vul-end> return - EINVAL ; sops = kmalloc ( sizeof ( * sops ) * nsops , GFP_KERNEL ) ; if ( ! sops ) return - ENOMEM ; err = 0 ; for ( i = 0 ; i < nsops ; i ++ ) { __get_user_error ( sops [ i ] . sem_num , & tsops -> sem_num , err ) ; __get_user_error ( sops [ i ] . sem_op , & tsops -> sem_op , err ) ; __get_user_error ( sops [ i ] . sem_flg , & tsops -> sem_flg , err ) ; tsops ++ ; } if ( timeout ) { err |= copy_from_user ( & local_timeout , timeout , sizeof ( * timeout ) ) ; timeout = & local_timeout ; } if ( err ) { err = - EFAULT ; } else { mm_segment_t fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; err = sys_semtimedop ( semid , sops , nsops , timeout ) ; set_fs ( fs ) ; } kfree ( sops ) ; return err ; }",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> nsops < 1 || nsops > SEMOPM\n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> ( nsops < 2 <vul-end> ) return -\n"
 },
 {
  "id": 1417,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_rc_get_one_pass_cbr_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; int target ; if ( ( cm -> current_video_frame == 0 || <vul-start> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <vul-end> rc -> frames_to_key == 0 || <vul-start> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <vul-end> cm -> frame_type = KEY_FRAME ; rc -> this_key_frame_forced = cm -> current_video_frame != 0 && rc -> frames_to_key == 0 ; <vul-start> rc -> frames_to_key = cpi -> key_frame_frequency ; <vul-end> rc -> kf_boost = DEFAULT_KF_BOOST ; <vul-start> rc -> source_alt_ref_active = 0 ; <vul-end> target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } else { cm -> frame_type = INTER_FRAME ; <vul-start> target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; <vul-end> <vul-start> } <vul-end> vp9_rc_set_frame_target ( cpi , target ) ; <vul-start> rc -> frames_till_gf_update_due = INT_MAX ; <vul-end> rc -> baseline_gf_interval = INT_MAX ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 0 || ( cpi <vul-end> -> frame_flags & <vul-start> . auto_key && 0 <vul-end> ) ) ) <vul-start> = cpi -> oxcf . key_freq <vul-end> ; rc -> <vul-start> source_alt_ref_active = 0 <vul-end> ; } else <vul-start> = INTER_FRAME ; } if ( rc -> frames_till_gf_update_due == 0 ) { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( cpi ) ; else rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) rc -> frames_till_gf_update_due = rc -> frames_to_key ; cpi -> refresh_golden_frame = 1 ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; else target = <vul-end> calc_pframe_target_size_one_pass_cbr ( cpi <vul-start> cpi ) ; <vul-end> vp9_rc_set_frame_target ( cpi <vul-start> target ) ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ; else cpi -> resize_pending = 0 <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 0 || ( cpi <vul-end> -> frame_flags & <vul-start>. auto_key && 0 <vul-end> ) ) ) <vul-start> ) ) { cpi <vul-end> -> frame_type = <vul-start> = cpi -> oxcf. key_freq <vul-end> ; rc -> <vul-start> ; rc -> source_alt_ref_active <vul-end> = 0 ; <vul-start> = calc_pframe_target_size_one_pass_cbr ( cpi ) ; vp9_rc_set_frame_target ( cpi <vul-end>, target ) <vul-start> target ) ; <vul-end> }    \n"
 },
 {
  "id": 1418,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 GF_Err latm_dmx_process ( GF_Filter * filter ) { GF_LATMDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u32 pos ; <vul-start> u8 * data , * output ; <vul-end> <vul-start> u32 pck_size , prev_pck_size ; <vul-end> u64 cts = GF_FILTER_NO_TS ; if ( ctx -> in_error ) return ctx -> in_error ; if ( ! ctx -> duration . num ) latm_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> latm_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } <vul-start> } <vul-end> <vul-start> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <vul-end> if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck && ! ctx -> resume_from ) { if ( ctx -> latm_buffer_size + pck_size > ctx -> latm_buffer_alloc ) { ctx -> latm_buffer_alloc = ctx -> latm_buffer_size + pck_size ; ctx -> latm_buffer = gf_realloc ( ctx -> latm_buffer , ctx -> latm_buffer_alloc ) ; } memcpy ( ctx -> latm_buffer + ctx -> latm_buffer_size",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> u8 * data = NULL <vul-start> ; u32 pck_size = 0 <vul-start> ; } } else { <vul-start> pck_size ) ; }\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> u32 pos ; GF_FilterPacket * src_pck, * output ; <vul-start> ; u32 pck_size ; u32 prev_pck_size ; int ret <vul-end> ; if ( <vul-start> GF_OK ; } if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck ) { <vul-start> pck_size ) ; if ( data ) memcpy ( ctx -> latm_buffer + ctx -> latm_buffer_size, data, pck_size ) ; ctx -> latm_buffer_size = 0 ; } <vul-start> ) ; } src_pck = ( u8 * ) gf_filter_pck_get_data ( pck, & pck_size ) ; if ( src_pck ) gf_filter_pck_unref ( src_pck ) ; dst_pck = NULL ; if ( ctx -> opid &&! ctx -> is_playing ) return GF_NON_COMPLIANT_BITSTREAM ; if ( ctx -> src_pck ) gf_filter_pck_unref ( dst_pck ) ; if ( pck ) { <vul-start> = sap ; src_pck = pck ; } else { <vul-start> output ) ; dst_pck = NULL ; } <vul-start> ) ; } ret = gf_filter_pck_send ( dst_pck ) ; if ( ret == GF_NON_COMPLIANT_BITSTREAM ) { if ( ctx -> opid ) gf_filter_pid_drop_packet ( ctx -> opid ) ; return GF_NON_COMPLIANT_BITSTREAM ; } ctx -> in_error = GF_NON_COMPLIANT_BITSTREAM ; if ( ctx -> resume_from ) ctx -> resume_from = pos ; if ( pck ) { <vul-start> = pos ; <vul-end> ctx -> opid <vul-start> = sap ; src_pck = NULL ; } if ( pck ) { ctx -> src_pck = dst_pck ; } if ( pck ) { ctx -> src_pck = src_pck ; } ctx -> in_seek = GF_"
 },
 {
  "id": 1419,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int VP8_UVSSE ( MACROBLOCK * x ) { unsigned char * uptr , * vptr ; unsigned char * upred_ptr = ( * ( x -> block [ 16 ] . base_src ) + x -> block [ 16 ] . src ) ; unsigned char * vpred_ptr = ( * ( x -> block [ 20 ] . base_src ) + x -> block [ 20 ] . src ) ; int uv_stride = x -> block [ 16 ] . src_stride ; unsigned int sse1 = 0 ; unsigned int sse2 = 0 ; int mv_row = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . row ; int mv_col = x -> e_mbd . mode_info_context -> mbmi . mv . as_mv . col ; int offset ; int pre_stride = x -> e_mbd . pre . uv_stride ; if ( mv_row < 0 ) mv_row -= 1 ; else mv_row += 1 ; if ( mv_col < 0 ) mv_col -= 1 ; else mv_col += 1 ; mv_row /= 2 ; mv_col /= 2 ; offset = ( mv_row >> 3 ) * pre_stride + ( mv_col >> 3 ) ; uptr = x -> e_mbd . pre . u_buffer + offset ; vptr = x -> e_mbd . pre . v_buffer + offset ; if ( ( mv_row | mv_col ) & 7 ) { <vul-start> vp8_sub_pixel_variance8x8 ( uptr , pre_stride , <vul-end> mv_col & 7 , mv_row & 7 , upred_ptr , uv_stride , & sse2 ) ; <vul-start> vp8_sub_pixel_variance8x8 ( vptr , pre_stride , <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 7 ) { vpx_sub_pixel_variance8x8 <vul-end> ( uptr , <vul-start> sse2 ) ; vpx_sub_pixel_variance8x8 <vul-end> ( vptr , <vul-start> } else { vpx_variance8x8 <vul-end> ( uptr , <vul-start> sse2 ) ; vpx_variance8x8 <vul-end> ( vptr ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 7 ) { vpx_sub_pixel_variance8x8 <vul-end> ( uptr, <vul-start> sse2 ) ; vpx_sub_pixel_variance8x8 <vul-end> ( vptr, <vul-start> } else { vpx_variance8x8 <vul-end> ( uptr, <vul-start> sse2 ) ; vpx_variance8x8 <vul-end> ( vptr,\n"
 },
 {
  "id": 1420,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void super_block_uvrd ( const VP9_COMP * cpi , MACROBLOCK * x , <vul-end> int * rate , int64_t * distortion , int * skippable , int64_t * sse , BLOCK_SIZE bsize , int64_t ref_best_rd ) { MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-start> TX_SIZE uv_txfm_size = get_uv_tx_size ( mbmi ) ; <vul-end> int plane ; int pnrate = 0 , pnskip = 1 ; int64_t pndist = 0 , pnsse = 0 ; <vul-start> if ( ref_best_rd < 0 ) <vul-end> <vul-start> goto term ; <vul-end> <vul-start> if ( is_inter_block ( mbmi ) ) { <vul-end> int plane ; for ( plane = 1 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_subtract_plane ( x , bsize , plane ) ; } * rate = 0 ; * distortion = 0 ; * sse = 0 ; * skippable = 1 ; for ( plane = 1 ; plane < MAX_MB_PLANE ; ++ plane ) { txfm_rd_in_plane ( x , & pnrate , & pndist , & pnskip , & pnsse , <vul-start> ref_best_rd , plane , bsize , uv_txfm_size , <vul-end> cpi -> sf . use_fast_coef_costing ) ; if ( pnrate == INT_MAX ) <vul-start> goto term ; <vul-end> * rate += pnrate ; * distortion += pndist ; * sse += pnsse ; * skippable &= pnskip ; } <vul-start> return ; <vul-end> term : * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> super_block_uvrd ( const <vul-start> -> mbmi ; const TX_SIZE uv_tx_size <vul-end> = get_uv_tx_size ( <vul-start> get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] <vul-start> = 0 ; int is_cost_valid = 1 ; <vul-start> < 0 ) is_cost_valid = 0 <vul-end> ; if ( <vul-start> ( mbmi ) && is_cost_valid <vul-start> , bsize , uv_tx_size <vul-end> , cpi -> <vul-start> == INT_MAX ) { is_cost_valid = 0 ; break ; } <vul-end> * rate += <vul-start> pnskip ; } if ( ! is_cost_valid ) { * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } return is_cost_valid <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> super_block_uvrd ( const <vul-start> get_uv_tx_size ( mbmi, xd -> bd <vul-start> < 0 ) { * rate = INT_MAX ; * distortion = INT_MAX ; * sse = INT_MAX ; return 0 ; } <vul-end> if ( is_inter_block <vul-start> mbmi ) ) return 0 ; <vul-end> * rate = <vul-start> == INT_MAX ) { * rate = INT_MAX ; * distortion = INT_MAX ; * sse = INT_MAX ; return 0 ; } <vul-end> * rate += <vul-start> pnskip ; } if ( ref_best_rd == 0 ) { * rate = INT_MAX ; * distortion = INT_MAX ; * sse = INT_MAX ; * skippable = 0 ; return 1 ; } <vul-start> ; } return 0 <vul-end> ; }  \n"
 },
 {
  "id": 1421,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 <vul-start> int sctp_verify_asconf ( const struct sctp_association * asoc , <vul-end> <vul-start> struct sctp_paramhdr * param_hdr , void * chunk_end , <vul-end> struct sctp_paramhdr * * errp ) { <vul-start> sctp_addip_param_t * asconf_param ; <vul-end> union sctp_params param ; <vul-start> int length , plen ; <vul-end> <vul-start> param . v = ( sctp_paramhdr_t * ) param_hdr ; <vul-end> while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param . p -> length ) ; * errp = param . p ; if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ; switch ( param . p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ; plen = ntohs ( asconf_param -> param_hdr . length ) ; if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ; break ; default : break ; } param . v += WORD_ROUND ( length ) ; } if ( param . v != chunk_end ) return 0 ; return 1 ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start>       bool <vul-end> sctp_verify_asconf ( const <vul-start> asoc , struct sctp_chunk * chunk , bool addr_param_needed <vul-end> , struct sctp_paramhdr <vul-start> errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <vul-end> ; union sctp_params <vul-start> sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <vul-end> param . v <vul-start> param . v != chunk -> chunk_end ) return false ; return true <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> asoc, struct sctp_params * param_hdr, const <vul-start> void * chunk_end, int param_hdr_len <vul-start> errp ) { const <vul-start> sctp_addip_param_t * asconf_param = NULL <vul-start>, plen ; if ( param_hdr_len < sizeof ( struct sctp_paramhdr_t ) ) return 0 ; <vul-start> * ) param_hdr ; if ( param. v < param_hdr_len ) return 0\n"
 },
 {
  "id": 1422,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void http_splitheader ( struct http * hp , int req ) { char * p , * q , * * hh ; int n ; char buf [ 20 ] ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; if ( req ) { memset ( hp -> req , 0 , sizeof hp -> req ) ; hh = hp -> req ; } else { memset ( hp -> resp , 0 , sizeof hp -> resp ) ; hh = hp -> resp ; } n = 0 ; p = hp -> rxbuf ; while ( vct_islws ( * p ) ) p ++ ; hh [ n ++ ] = p ; while ( ! vct_islws ( * p ) ) p ++ ; <vul-start> assert ( ! vct_iscrlf ( * p ) ) ; <vul-end> * p ++ = '\\\\0' ; while ( vct_issp ( * p ) ) p ++ ; <vul-start> assert ( ! vct_iscrlf ( * p ) ) ; <vul-end> hh [ n ++ ] = p ; while ( ! vct_islws ( * p ) ) p ++ ; <vul-start> if ( vct_iscrlf ( * p ) ) { <vul-end> hh [ n ++ ] = NULL ; q = p ; p += vct_skipcrlf ( p ) ; * q = '\\\\0' ; } else { * p ++ = '\\\\0' ; while ( vct_issp ( * p ) ) p ++ ; hh [ n ++ ] = p ; <vul-start> while ( ! vct_iscrlf ( * p ) ) <vul-end>",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ! vct_iscrlf ( <vul-end> p ) ) <vul-start> ! vct_iscrlf ( <vul-end> p ) ) <vul-start> ( vct_iscrlf ( <vul-end> p ) ) <vul-start> ! vct_iscrlf ( <vul-end> p ) ) <vul-start> ( vct_iscrlf ( <vul-end> p ) ) <vul-start> ! vct_iscrlf ( <vul-end> p ) )\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>! vct_iscrlf ( <vul-end> p ) ) <vul-start>! vct_iscrlf ( <vul-end> p ) ) <vul-start> ( vct_iscrlf ( <vul-end> p ) ) <vul-start>! vct_iscrlf ( <vul-end> p ) )\n"
 },
 {
  "id": 1423,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void snd_msndmidi_input_read ( void * mpuv ) { unsigned long flags ; struct snd_msndmidi * mpu = mpuv ; void * pwMIDQData = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ; <vul-start> spin_lock_irqsave ( & mpu -> input_lock , flags ) ; <vul-end> <vul-start> while ( readw ( mpu -> dev -> MIDQ + JQS_wTail ) != <vul-end> readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) { u16 wTmp , val ; val = readw ( pwMIDQData + 2 * readw ( mpu -> dev -> MIDQ + JQS_wHead ) ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , 1 ) ; <vul-start> wTmp = readw ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; <vul-end> if ( wTmp > readw ( mpu -> dev -> MIDQ + JQS_wSize ) ) writew ( 0 , mpu -> dev -> MIDQ + JQS_wHead ) ; else writew ( wTmp , mpu -> dev -> MIDQ + JQS_wHead ) ; } spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> + MIDQ_DATA_BUFF ; u16 head , tail , size ; <vul-start> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <vul-end> , 1 ) <vul-start> 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head , <vul-end> mpu -> dev <vul-start> + JQS_wHead ) ; } out : <vul-end> spin_unlock_irqrestore ( &\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> + MIDQ_DATA_BUFF ; unsigned int midq_tail, midq_wHead ; <vul-start> flags ) ; midq_tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; midq_wHead = ( mpu -> dev -> MIDQ + JQS_wHead ) + 1 ; spin_unlock_irqrestore ( & mpu -> input_lock, flags ) ; if ( midq_tail!= midq_wHead ) { <vul-start> 1 ) ; if ( midq_tail!= midq_wHead ) snd_rawmidi_receive ( mpu -> substream_input, ( unsigned char * ) & val, 1 ) ; } else { <vul-start> + JQS_wHead ) ; } <vul-end> } spin_unlock_irqrestore (\n"
 },
 {
  "id": 1424,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int handle_pte_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * pte , pmd_t * pmd , unsigned int flags ) { pte_t entry ; spinlock_t * ptl ; entry = * pte ; barrier ( ) ; if ( ! pte_present ( entry ) ) { if ( pte_none ( entry ) ) { <vul-start> if ( vma -> vm_ops ) { <vul-end> if ( likely ( vma -> vm_ops -> fault ) ) return do_fault ( mm , vma , address , pte , <vul-start> pmd , flags , entry ) ; <vul-end> } return do_anonymous_page ( mm , vma , address , <vul-start> pte , pmd , flags ) ; <vul-end> } return do_swap_page ( mm , vma , address , pte , pmd , flags , entry ) ; } if ( pte_protnone ( entry ) ) return do_numa_page ( mm , vma , address , entry , pte , pmd ) ; ptl = pte_lockptr ( mm , pmd ) ; spin_lock ( ptl ) ; if ( unlikely ( ! pte_same ( * pte , entry ) ) ) goto unlock ; if ( flags & FAULT_FLAG_WRITE ) { if ( ! pte_write ( entry ) ) return do_wp_page ( mm , vma , address , pte , pmd , ptl , entry ) ; entry = pte_mkdirty ( entry ) ; } entry = pte_mkyoung ( entry ) ; if ( ptep_set_access_flags ( vma , address , pte , entry , flags & FAULT_FLAG_WRITE ) ) { update_mmu_cache (",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> -> vm_ops ) <vul-end> return do_fault ( <vul-start> , pte , pmd , flags , entry ) ; <vul-end> return do_anonymous_page ( <vul-start> , address , pte , pmd , <vul-end> flags ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ) ) { struct vm_area_struct * vma_vm_ops = vma -> vm_ops ; if ( vma_is_vma ( vma ) ) { if ( unlikely (! vma -> vm_ops -> fault ) ) return VM_FAULT_SIGBUS ; <vul-end> return do_anonymous_page ( <vul-start>, pmd, vma_vm_ops -> fault ) ; } <vul-end> } return do_swap_page\n"
 },
 {
  "id": 1425,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 xfs_failaddr_t xfs_dinode_verify ( struct xfs_mount * mp , xfs_ino_t ino , struct xfs_dinode * dip ) { xfs_failaddr_t fa ; uint16_t mode ; uint16_t flags ; uint64_t flags2 ; uint64_t di_size ; if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) return __this_address ; if ( dip -> di_version >= 3 ) { if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) return __this_address ; if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , XFS_DINODE_CRC_OFF ) ) return __this_address ; if ( be64_to_cpu ( dip -> di_ino ) != ino ) return __this_address ; if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; } di_size = be64_to_cpu ( dip -> di_size ) ; if ( di_size & ( 1ULL << 63 ) ) return __this_address ; mode = be16_to_cpu ( dip -> di_mode ) ; if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) return __this_address ; if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) return __this_address ; if ( mode && be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > be64_to_cpu ( dip -> di_nblocks ) ) return __this_address ; if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) return __this_address ; flags = be16_to_cpu ( dip -> di_flags ) ; if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && ! mp -> m_rtdev_targp ) return",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <vul-end> } else {\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> case S_IFDIR : if ( dip -> di_size!= sizeof ( struct xfs_dinode ) ) return __this_address ;\n"
 },
 {
  "id": 1426,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int hidp_setup_hid ( struct hidp_session * session , struct hidp_connadd_req * req ) { struct hid_device * hid ; int err ; session -> rd_data = kzalloc ( req -> rd_size , GFP_KERNEL ) ; if ( ! session -> rd_data ) return - ENOMEM ; if ( copy_from_user ( session -> rd_data , req -> rd_data , req -> rd_size ) ) { err = - EFAULT ; goto fault ; } session -> rd_size = req -> rd_size ; hid = hid_allocate_device ( ) ; if ( IS_ERR ( hid ) ) { err = PTR_ERR ( hid ) ; goto fault ; } session -> hid = hid ; hid -> driver_data = session ; hid -> bus = BUS_BLUETOOTH ; hid -> vendor = req -> vendor ; hid -> product = req -> product ; hid -> version = req -> version ; hid -> country = req -> country ; <vul-start> strncpy ( hid -> name , req -> name , 128 ) ; <vul-end> snprintf ( hid -> phys , sizeof ( hid -> phys ) , \"%pMR\" , & bt_sk ( session -> ctrl_sock -> sk ) -> src ) ; snprintf ( hid -> uniq , sizeof ( hid -> uniq ) , \"%pMR\" , & bt_sk ( session -> ctrl_sock -> sk ) -> dst ) ; hid -> dev . parent = & session -> conn -> dev ; hid -> ll_driver = & hidp_hid_driver ; hid -> hid_get_raw_report = hidp_get_raw_report ; hid -> hid_output_raw_report = hidp_output_raw_report ; if ( hid_ignore ( hid",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> -> name , sizeof ( req -> name ) - 1 <vul-end> ) ; snprintf\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> name, 128 ) ; if ( strlen ( hid -> name ) >= sizeof ( hid -> name ) ) return - EINVAL ; memset ( hid -> name, 0, sizeof ( hid -> name )\n"
 },
 {
  "id": 1427,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 uint16_t dm9000ReadPhyReg ( uint8_t address ) { <vul-start> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <vul-end> <vul-start> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRR ) ; <vul-end> <vul-start> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <vul-end> { } <vul-start> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <vul-end> usleep ( 5 ) ; <vul-start> return ( dm9000ReadReg ( DM9000_REG_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_REG_EPDRL ) ; <vul-end> }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> { dm9000WriteReg ( DM9000_EPAR <vul-end> , 0x40 | <vul-start> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <vul-end> ) ; while <vul-start> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <vul-end> ) != 0 <vul-start> } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <vul-end> ) ; usleep <vul-start> ( dm9000ReadReg ( DM9000_EPDRH <vul-end> ) << 8 <vul-start> | dm9000ReadReg ( DM9000_EPDRL <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> { dm9000WriteReg ( DM9000_EPAR <vul-end>, 0x40 | <vul-start> ; dm9000WriteReg ( DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <vul-end> ) ; while <vul-start> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <vul-end> )!= 0 <vul-start> } dm9000WriteReg ( DM9000_EPCR, DM9000_EPCR_EPOS <vul-end> ) ; usleep <vul-start> ( dm9000ReadReg ( DM9000_EPDRH <vul-end> ) << 8 <vul-start> | dm9000ReadReg ( DM9000_EPDRL <vul-end> ) ; }\n"
 },
 {
  "id": 1428,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , \"Can\\'t allocate %lu bytes of memory for \" \"t2p_readwrite_pdf_image, %s\" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> , buffer , t2p -> tiff_datasize ,\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start>, buffer, bufferoffset, <vul-end> i, t2p\n"
 },
 {
  "id": 1429,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int __ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * daddr , * final_p , final ; struct dst_entry * dst ; struct flowi6 fl6 ; struct ip6_flowlabel * flowlabel = NULL ; struct ipv6_txoptions * opt ; int addr_type ; int err ; if ( usin -> sin6_family == AF_INET ) { if ( __ipv6_only_sock ( sk ) ) return - EAFNOSUPPORT ; err = __ip4_datagram_connect ( sk , uaddr , addr_len ) ; goto ipv4_connected ; } if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type == IPV6_ADDR_ANY ) { usin -> sin6_addr . s6_addr [ 15 ] = 0x01 ; } daddr = & usin -> sin6_addr ; if ( addr_type == IPV6_ADDR_MAPPED ) { struct sockaddr_in sin ; if ( __ipv6_only_sock ( sk ) ) { err = - ENETUNREACH ;",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> -> opt : rcu_dereference ( <vul-start> np -> opt ) <vul-start> , & final ) ; rcu_read_unlock (\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ) ) ; rcu_read_lock ( ) ; <vul-start> -> opt ; rcu_read_unlock ( ) ; <vul-start> & fl6, rcu_dereference ( opt ) <vul-end>, & final\n"
 },
 {
  "id": 1430,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 <vul-start> jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) <vul-end> { jas_matrix_t * matrix ; <vul-start> int i ; <vul-end> size_t size ; matrix = 0 ; if ( numrows < 0 || numcols < 0 ) { goto error ; } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { goto error ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { goto error ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { goto error ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix ->",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> * jas_matrix_create ( jas_matind_t numrows , jas_matind_t <vul-end> numcols ) { <vul-start> * matrix ; jas_matind_t <vul-end> i ; size_t\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> * jas_matrix_create ( jas_matind_t numrows, jas_matind_t <vul-end> numcols ) { <vul-start> * matrix ; jas_matind_t <vul-end> i ; size_t\n"
 },
 {
  "id": 1431,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int inode_change_ok ( const struct inode * inode , struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_SIZE ) { int error = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( error ) return error ; } if ( ia_valid & ATTR_FORCE ) return 0 ; if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && <vul-start> ! inode_capable ( inode , CAP_CHOWN ) ) <vul-end> return - EPERM ; if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) && <vul-start> ! inode_capable ( inode , CAP_CHOWN ) ) <vul-end> return - EPERM ; if ( ia_valid & ATTR_MODE ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && <vul-start> ! inode_capable ( inode , CAP_FSETID ) ) <vul-end> attr -> ia_mode &= ~ S_ISGID ; } if ( ia_valid & ( ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET ) ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; } return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ) && ! capable_wrt_inode_uidgid <vul-end> ( inode , <vul-start> ) && ! capable_wrt_inode_uidgid <vul-end> ( inode , <vul-start> ) && ! capable_wrt_inode_uidgid <vul-end> ( inode ,\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ) &&! capable_wrt_inode_uidgid <vul-end> ( inode, <vul-start> ) &&! capable_wrt_inode_uidgid <vul-end> ( inode, <vul-start> ) &&! capable_wrt_inode_uidgid <vul-end> ( inode,\n"
 },
 {
  "id": 1432,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; <vul-start> int family = sk -> sk_family ; <vul-end> struct sockaddr_in * sin ; struct sockaddr_in6 * sin6 ; struct sk_buff * skb ; int copied , err ; pr_debug ( \"ping_recvmsg(sk=%p,sk->num=%u)\\\\n\" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; <vul-start> if ( addr_len ) { <vul-end> if ( family == AF_INET ) * addr_len = sizeof ( * sin ) ; else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> sk -> sk_family <vul-end> ; struct sk_buff <vul-start> goto out ; <vul-end> if ( flags <vul-start> AF_INET ) { struct sockaddr_in * <vul-start> ) ) ; * addr_len = sizeof ( * sin ) ; <vul-start> skb ) ; <vul-end> struct sockaddr_in6 * <vul-start> struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * <vul-start> ) -> iif ) ; * addr_len = sizeof ( * sin6\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> sk -> sk_family <vul-end> ; struct sk_buff <vul-start> ; if ( addr_len && <vul-start> ; if ( addr_len && <vul-start> ) -> iif ) ; * addr_len = sizeof ( * sin ) ; if ( addr_len && <vul-end> inet6_sk ( sk <vul-start> AF_INET ) { struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; <vul-start> ; if ( addr_len &&\n"
 },
 {
  "id": 1433,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int cypress_open ( struct tty_struct * tty , struct usb_serial_port * port ) { struct cypress_private * priv = usb_get_serial_port_data ( port ) ; struct usb_serial * serial = port -> serial ; unsigned long flags ; int result = 0 ; if ( ! priv -> comm_is_ok ) return - EIO ; usb_clear_halt ( serial -> dev , 0x81 ) ; usb_clear_halt ( serial -> dev , 0x02 ) ; spin_lock_irqsave ( & priv -> lock , flags ) ; priv -> bytes_in = 0 ; priv -> bytes_out = 0 ; priv -> cmd_count = 0 ; priv -> rx_flags = 0 ; spin_unlock_irqrestore ( & priv -> lock , flags ) ; cypress_send ( port ) ; if ( tty ) cypress_set_termios ( tty , port , & priv -> tmp_termios ) ; <vul-start> if ( ! port -> interrupt_in_urb ) { <vul-end> dev_err ( & port -> dev , \"%s - interrupt_in_urb is empty!\\\\n\" , __func__ ) ; return - 1 ; } usb_fill_int_urb ( port -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , port -> interrupt_in_endpointAddress ) , port -> interrupt_in_urb -> transfer_buffer , port -> interrupt_in_urb -> transfer_buffer_length , cypress_read_int_callback , port , priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb , GFP_KERNEL ) ; if ( result ) { dev_err ( & port -> dev , \"%s - failed submitting read urb, error %d\\\\n\" , __func__ , result ) ; cypress_set_dead ( port ) ; } return result ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> tmp_termios ) ; <vul-end> usb_fill_int_urb ( port\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> ; if ( port -> interrupt_in_urb ) { usb_fill_int_urb ( port -> interrupt_in_urb, serial -> dev, usb_rcvintpipe ( serial -> dev, port -> interrupt_in_endpointAddress ), port -> interrupt_in_urb -> transfer_buffer, port -> interrupt_in_urb -> transfer_buffer_length, cypress_read_int_callback, port, priv -> read_urb_interval ) ; } else <vul-end> { dev_err (\n"
 },
 {
  "id": 1434,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int packet_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; struct packet_sock * po = pkt_sk ( sk ) ; int ret ; if ( level != SOL_PACKET ) return - ENOPROTOOPT ; switch ( optname ) { case PACKET_ADD_MEMBERSHIP : case PACKET_DROP_MEMBERSHIP : { struct packet_mreq_max mreq ; int len = optlen ; memset ( & mreq , 0 , sizeof ( mreq ) ) ; if ( len < sizeof ( struct packet_mreq ) ) return - EINVAL ; if ( len > sizeof ( mreq ) ) len = sizeof ( mreq ) ; if ( copy_from_user ( & mreq , optval , len ) ) return - EFAULT ; if ( len < ( mreq . mr_alen + offsetof ( struct packet_mreq , mr_address ) ) ) return - EINVAL ; if ( optname == PACKET_ADD_MEMBERSHIP ) ret = packet_mc_add ( sk , & mreq ) ; else ret = packet_mc_drop ( sk , & mreq ) ; return ret ; } case PACKET_RX_RING : case PACKET_TX_RING : { union tpacket_req_u req_u ; int len ; switch ( po -> tp_version ) { case TPACKET_V1 : case TPACKET_V2 : len = sizeof ( req_u . req ) ; break ; case TPACKET_V3 : default : len = sizeof ( req_u . req3 ) ; break ; } if ( optlen < len ) return - EINVAL ; if ( copy_from_user ( & req_u . req , optval",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if ( <vul-start> . pg_vec ) { ret = <vul-end> - EBUSY ; <vul-start> - EBUSY ; } else { <vul-end> po -> tp_version <vul-start> = val ; ret = 0 ; } release_sock ( sk ) ; return ret ; <vul-end> } case PACKET_RESERVE\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> - EINVAL ; lock_sock ( sk ) ; <vul-start>. pg_vec ) { ret = <vul-end> - EBUSY ; <vul-start> - EBUSY ; goto out ; } <vul-start> val ) ) ) return ret ; out : release_sock ( sk ) <vul-end> ; switch ( <vul-start> = val ; ret = 0 ; out : <vul-end> return - EINVAL\n"
 },
 {
  "id": 1435,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static gboolean cosine_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <vul-start> int pkt_len ; <vul-end> char line [ COSINE_LINE_LENGTH ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) return FALSE ; if ( file_gets ( line , COSINE_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <vul-start> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <vul-end> if ( pkt_len == - 1 ) return FALSE ; <vul-start> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <vul-end> err_info ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> err_info ) { <vul-end> char line [ <vul-start> FALSE ; } return parse_cosine_packet <vul-end> ( wth -> <vul-start> , phdr , buf , line <vul-end> , err ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> err_info ) { <vul-end> char line [ <vul-start> FALSE ; } if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return <vul-end> parse_cosine_hex_dump ( wth <vul-start>, phdr, * err <vul-end>, err_info )\n"
 },
 {
  "id": 1436,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 SQLITE_PRIVATE int sqlite3VtabEponymousTableInit ( Parse * pParse , Module * pMod ) { const sqlite3_module * pModule = pMod -> pModule ; Table * pTab ; char * zErr = 0 ; int rc ; sqlite3 * db = pParse -> db ; if ( pMod -> pEpoTab ) return 1 ; if ( pModule -> xCreate != 0 && pModule -> xCreate != pModule -> xConnect ) return 0 ; pTab = sqlite3DbMallocZero ( db , sizeof ( Table ) ) ; if ( pTab == 0 ) return 0 ; pTab -> zName = sqlite3DbStrDup ( db , pMod -> zName ) ; if ( pTab -> zName == 0 ) { sqlite3DbFree ( db , pTab ) ; return 0 ; } pMod -> pEpoTab = pTab ; pTab -> nTabRef = 1 ; pTab -> pSchema = db -> aDb [ 0 ] . pSchema ; assert ( pTab -> nModuleArg == 0 ) ; pTab -> iPKey = - 1 ; <vul-start> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <vul-end> <vul-start> addModuleArgument ( db , pTab , 0 ) ; <vul-end> <vul-start> addModuleArgument ( db , pTab , sqlite3DbStrDup ( db , pTab -> zName ) ) ; <vul-end> rc = vtabCallConstructor ( db , pTab , pMod , pModule -> xConnect , & zErr ) ; if ( rc ) { sqlite3ErrorMsg ( pParse , \"%s\" , zErr ) ; sqlite3DbFree ( db , zErr ) ; sqlite3VtabEponymousTableClear ( db , pMod ) ; return 0 ; } return 1",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ; addModuleArgument ( pParse <vul-end> , pTab , <vul-start> ; addModuleArgument ( pParse <vul-end> , pTab , <vul-start> ; addModuleArgument ( pParse <vul-end> , pTab ,\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; addModuleArgument ( pParse <vul-end>, pTab, <vul-start> ; addModuleArgument ( pParse <vul-end>, pTab, <vul-start> ; addModuleArgument ( pParse <vul-end>, pTab,\n"
 },
 {
  "id": 1437,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int send_event ( int fd , uint16_t type , uint16_t code , int32_t value ) { struct uinput_event event ; BTIF_TRACE_DEBUG ( \"%s type:%u code:%u value:%d\" , __FUNCTION__ , type , code , value ) ; memset ( & event , 0 , sizeof ( event ) ) ; event . type = type ; event . code = code ; event . value = value ; <vul-start> return write ( fd , & event , sizeof ( event ) ) ; <vul-end> }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> value ; return TEMP_FAILURE_RETRY ( <vul-start> event ) ) )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> value ; return TEMP_FAILURE_RETRY ( <vul-start> ( event ) )\n"
 },
 {
  "id": 1438,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int format8BIM ( Image * ifile , Image * ofile ) { char temp [ MagickPathExtent ] ; unsigned int foundOSType ; int ID , resCount , i , c ; ssize_t count ; unsigned char * PString , * str ; resCount = 0 ; foundOSType = 0 ; ( void ) foundOSType ; c = ReadBlobByte ( ifile ) ; while ( c != EOF ) { if ( c == '8' ) { unsigned char buffer [ 5 ] ; buffer [ 0 ] = ( unsigned char ) c ; for ( i = 1 ; i < 4 ; i ++ ) { c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; buffer [ i ] = ( unsigned char ) c ; } buffer [ 4 ] = 0 ; if ( strcmp ( ( const char * ) buffer , \"8BIM\" ) == 0 ) foundOSType = 1 ; else continue ; } else { c = ReadBlobByte ( ifile ) ; continue ; } ID = ReadBlobMSBSignedShort ( ifile ) ; if ( ID < 0 ) return ( - 1 ) ; { unsigned char plen ; c = ReadBlobByte ( ifile ) ; if ( c == EOF ) return ( - 1 ) ; plen = ( unsigned char ) c ; PString = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( plen + MagickPathExtent ) , sizeof ( * PString ) ) ; if ( PString == ( unsigned",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> size_t ) count + 1\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> char * ) AcquireQuantumMemory2 <vul-end> ( ( size_t\n"
 },
 {
  "id": 1439,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 struct dst_entry * inet_csk_route_req ( struct sock * sk , const struct request_sock * req ) { struct rtable * rt ; const struct inet_request_sock * ireq = inet_rsk ( req ) ; <vul-start> struct ip_options * opt = inet_rsk ( req ) -> opt ; <vul-end> struct net * net = sock_net ( sk ) ; struct flowi4 fl4 ; flowi4_init_output ( & fl4 , sk -> sk_bound_dev_if , sk -> sk_mark , RT_CONN_FLAGS ( sk ) , RT_SCOPE_UNIVERSE , sk -> sk_protocol , inet_sk_flowi_flags ( sk ) , <vul-start> ( opt && opt -> srr ) ? opt -> faddr : ireq -> rmt_addr , <vul-end> ireq -> loc_addr , ireq -> rmt_port , inet_sk ( sk ) -> inet_sport ) ; security_req_classify_flow ( req , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) goto no_route ; <vul-start> if ( opt && opt -> is_strictroute && rt -> rt_dst != rt -> rt_gateway ) <vul-end> goto route_err ; return & rt -> dst ; route_err : ip_rt_put ( rt ) ; no_route : IP_INC_STATS_BH ( net , IPSTATS_MIB_OUTNOROUTES ) ; return NULL ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct ip_options_rcu <vul-end> * opt = <vul-start> && opt -> opt . <vul-start> ? opt -> opt . <vul-start> && opt -> opt .\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct ip_options_rcu * inet_opt <vul-end> = inet_rsk ( <vul-start> ( req ) <vul-end> ; struct net <vul-start> ), ( inet_opt && inet_opt -> opt. <vul-end> srr )? <vul-start> ; if ( inet_opt && inet_opt -> opt. <vul-end> is_strictroute && rt\n"
 },
 {
  "id": 1440,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int ParseDateTime ( char * timestr , char * lowstr , char * * field , int * ftype , int * numfields , char * * endstr ) { int nf = 0 ; char * lp = lowstr ; * endstr = timestr ; while ( * ( * endstr ) != '\\\\0' ) { <vul-start> field [ nf ] = lp ; <vul-end> if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) * lp ++ = * ( * endstr ) ++ ; if ( * ( * endstr ) == ':' ) { ftype [ nf ] = DTK_TIME ; * lp ++ = * ( * endstr ) ++ ; while ( isdigit ( ( unsigned char ) * ( * endstr ) ) || ( * ( * endstr ) == ':' ) || ( * ( * endstr ) == '.' ) ) * lp ++ = * ( * endstr ) ++ ; } else if ( * ( * endstr ) == '-' || * ( * endstr ) == '/' || * ( * endstr ) == '.' ) { char * dp = ( * endstr ) ; * lp ++ = * ( * endstr ) ++ ; if ( isdigit ( ( unsigned char ) * ( * endstr ) ) ) { ftype [ nf ] = (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ] = lp ; if ( nf >= MAXDATEFIELDS ) return - 1 <vul-start> nf ++ ; <vul-end> } * numfields\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> '\\\\0' ) { if ( nf >= MAXDATEFIELDS ) return - 1 ; <vul-start> nf ++ ; <vul-end> } * numfields\n"
 },
 {
  "id": 1441,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case ' ' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { <vul-start> int a = getnum ( L , fmt , MAXALIGN ) ; <vul-end> if ( ! isp2 ( a ) ) luaL_error ( L , \"alignment %d is not a power of 2\" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , \"invalid format option \\'%c\\'\" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> = getnum ( <vul-end> fmt , MAXALIGN\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = getnum ( L, <vul-end> fmt, MAXALIGN\n"
 },
 {
  "id": 1442,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void safe_fprintf ( FILE * f , const char * fmt , ... ) { char fmtbuff_stack [ 256 ] ; char outbuff [ 256 ] ; char * fmtbuff_heap ; char * fmtbuff ; int fmtbuff_length ; int length , n ; va_list ap ; const char * p ; unsigned i ; wchar_t wc ; char try_wc ; fmtbuff_heap = NULL ; fmtbuff_length = sizeof ( fmtbuff_stack ) ; fmtbuff = fmtbuff_stack ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; while ( length < 0 || length >= fmtbuff_length ) { if ( length >= fmtbuff_length ) fmtbuff_length = length + 1 ; else if ( fmtbuff_length < 8192 ) fmtbuff_length *= 2 ; else if ( fmtbuff_length < 1000000 ) fmtbuff_length += fmtbuff_length / 4 ; else { length = fmtbuff_length ; fmtbuff_heap [ length - 1 ] = '\\\\0' ; break ; } free ( fmtbuff_heap ) ; fmtbuff_heap = malloc ( fmtbuff_length ) ; if ( fmtbuff_heap != NULL ) { fmtbuff = fmtbuff_heap ; va_start ( ap , fmt ) ; length = vsnprintf ( fmtbuff , fmtbuff_length , fmt , ap ) ; va_end ( ap ) ; } else { length = sizeof ( fmtbuff_stack ) - 1 ; break ; } } if ( mbtowc ( NULL , NULL , 1 ) == - 1 ) { free ( fmtbuff_heap ) ; return ; } p = fmtbuff ; i = 0 ; try_wc = 1 ; while",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> outbuff ) - 128 <vul-end> ) ) {\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> if ( i + sizeof ( outbuff )\n"
 },
 {
  "id": 1443,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int test_candidate_kf ( struct twopass_rc * twopass , <vul-end> const FIRSTPASS_STATS * last_frame , const FIRSTPASS_STATS * this_frame , const FIRSTPASS_STATS * next_frame ) { int is_viable_kf = 0 ; <vul-start> if ( ( this_frame -> pcnt_second_ref < 0.10 ) && <vul-end> <vul-start> ( next_frame -> pcnt_second_ref < 0.10 ) && <vul-end> ( ( this_frame -> pcnt_inter < 0.05 ) || ( ( ( this_frame -> pcnt_inter - this_frame -> pcnt_neutral ) < 0.35 ) && ( ( this_frame -> intra_error / <vul-start> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < 2.5 ) && <vul-end> ( ( fabs ( last_frame -> coded_error - this_frame -> coded_error ) / <vul-start> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > 0.40 ) || <vul-end> ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) / <vul-start> DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > 0.40 ) || <vul-end> ( ( next_frame -> intra_error / <vul-start> DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) ) ) ) ) { <vul-end> int i ; const FIRSTPASS_STATS * start_pos = twopass -> stats_in ; FIRSTPASS_STATS local_next_frame = * next_frame ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double decay_accumulator = 1.0 ; for ( i = 0 ; i < 16 ; ++ i ) { <vul-start> double next_iiratio = ( IIKFACTOR1 * local_next_frame . intra_error / <vul-end> DOUBLE_DIVIDE_CHECK ( local_next_frame . coded_error ) ) ; <vul-start> if ( next_iiratio > RMAX ) <vul-end> next_iiratio = RMAX ; if ( local_next_frame . pcnt_inter > 0.85 ) decay_accumulator *= local_next_frame . pcnt_inter ; else decay_accumulator *=",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> int test_candidate_kf ( TWO_PASS <vul-end> * twopass , <vul-start> = 0 ; double pcnt_intra = 1.0 - this_frame -> pcnt_inter ; double modified_pcnt_inter = this_frame -> pcnt_inter - this_frame -> pcnt_neutral ; <vul-start> -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH <vul-end> ) && ( <vul-start> -> pcnt_second_ref < SECOND_REF_USEAGE_THRESH ) && ( ( this_frame -> pcnt_inter < VERY_LOW_INTER_THRESH ) || ( ( pcnt_intra > MIN_INTRA_LEVEL ) && ( pcnt_intra > ( INTRA_VS_INTER_THRESH * modified_pcnt_inter ) <vul-end> ) && ( <vul-start> ) ) < KF_II_ERR_THRESHOLD <vul-end> ) && ( <vul-start> coded_error ) > ERR_CHANGE_THRESHOLD <vul-end> ) || ( <vul-start> intra_error ) > ERR_CHANGE_THRESHOLD <vul-end> ) || ( <vul-start> ) ) > II_IMPROVEMENT_THRESHOLD <vul-end> ) ) ) <vul-start> next_iiratio = ( BOOST_FACTOR <vul-end> * local_next_frame . <vul-start> ( next_iiratio > KF_II_MAX ) next_iiratio = KF_II_MAX <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> int test_candidate_kf ( VP9_COMP * cpi <vul-end>, const FIRSTPASS_STATS <vul-start> = 0 ; const FIRSTPASS_STATS * last_frame = & cpi -> stats_in ; const FIRSTPASS_STATS * next_frame = & cpi -> stats_in ; <vul-start> if ( ( last_frame <vul-end> -> pcnt_second_ref < <vul-start> < 0.10 ) || ( next_frame <vul-end> -> pcnt_second_ref < <vul-start> < 0.10 ) || ( ( last_frame <vul-end> -> intra_error / <vul-start> ) < 2.5 ) || ( ( last_frame <vul-end> -> coded_error - <vul-start> coded_error ) > 0.25 ) || ( ( next_frame <vul-end> -> intra_error / <vul-start> ) > 0.40 ) || ( ( last_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) <vul-start> ) { double next_iiratio = ( IIKFACTOR1 * this_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( local_next_frame. coded_error ) ) ; if ( <vul-end> local_next_frame. pcnt_inter <vul-start> local_next_frame. pcnt_inter < 0.85 ) next_iiratio = RMAX ; if ( next_frame. pcnt_inter - this_frame -> pcnt_neutral < 0.25 ) next_iiratio = 3.0 ; if ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > 0.40 ) { break ; } <vul-end> boost_score += ( <vul-start> ) { double old_boost_score = 0.0 ; double decay_accumulator = 1.0 ; if ( cpi -> intra_pct < 20.0 ) { old_boost_score = old_boost_score + 1.0 ; decay_accumulator = old_boost_score - 1.0 ; if ( decay_accumulator > 20.0 ) { break ; } old_boost_score = boost_score ; if ( local_next_frame. intra_pct > 0."
 },
 {
  "id": 1444,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; env -> cur_state = state ; init_reg_state ( env , state -> regs ) ; state -> parent = NULL ; insn_idx = 0 ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( env , \"invalid insn idx %d insn_cnt %d\\\\n\" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , \"BPF program is too large. Processed %d insn\\\\n\" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) verbose ( env , \"\\\\nfrom %d to %d: safe\\\\n\" , prev_insn_idx , insn_idx ) ; else verbose ( env , \"%d: safe\\\\n\" , insn_idx ) ; } goto process_bpf_exit ; } if",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <vul-start> insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( is_alu_op ( env, insn ) ) return err ; if ( <vul-start> == BPF_ALU64 ) <vul-end> goto check_alu_op ; <vul-start> return err ; <vul-end> err = check_reg_arg <vul-start> class == BPF_ALU64 || class == BPF_LDX\n"
 },
 {
  "id": 1445,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 void mp_encode_lua_table_as_array ( lua_State * L , mp_buf * buf , int level ) { # if LUA_VERSION_NUM < 502 size_t len = lua_objlen ( L , - 1 ) , j ; # else size_t len = lua_rawlen ( L , - 1 ) , j ; # endif mp_encode_array ( L , buf , len ) ; <vul-start> for ( j = 1 ; j <= len ; j ++ ) { <vul-end> lua_pushnumber ( L , j ) ; lua_gettable ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> len ) ; luaL_checkstack ( L , 1 , \"in function mp_encode_lua_table_as_array\" ) ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> len ) ; if ( len > LUA_MAXDIGS ) { luaL_error ( L, 3, \"in function mp_encode_lua_table_as_array\" ) ; return ; }\n"
 },
 {
  "id": 1446,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 php_http_url_t * php_http_url_parse ( const char * str , size_t len , unsigned flags TSRMLS_DC ) { <vul-start> size_t maxlen = 3 * len ; <vul-end> struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ; state -> end = str + len ; state -> ptr = str ; state -> flags = flags ; state -> maxlen = maxlen ; TSRMLS_SET_CTX ( state -> ts ) ; if ( ! parse_scheme ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Failed to parse URL scheme: \\'%s\\'\" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_hier ( state ) ) { efree ( state ) ; return NULL ; } if ( ! parse_query ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Failed to parse URL query: \\'%s\\'\" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_fragment ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Failed to parse URL fragment: \\'%s\\'\" , state -> ptr ) ; efree ( state ) ; return NULL ; } return ( php_http_url_t * ) state ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 3 * len + 8\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> size_t maxlen = 5 <vul-end> * len ;\n"
 },
 {
  "id": 1447,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static irqreturn_t snd_msnd_interrupt ( int irq , void * dev_id ) { struct snd_msnd * chip = dev_id ; void * pwDSPQData = chip -> mappedbase + DSPQ_DATA_BUFF ; <vul-start> while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) { <vul-end> u16 wTmp ; snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * readw ( chip -> DSPQ + JQS_wHead ) ) ) ; <vul-start> wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ; <vul-end> <vul-start> if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) <vul-end> writew ( 0 , chip -> DSPQ + JQS_wHead ) ; else writew ( wTmp , chip -> DSPQ + JQS_wHead ) ; <vul-start> } <vul-end> inb ( chip -> io + HP_RXL ) ; return IRQ_HANDLED ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> + DSPQ_DATA_BUFF ; u16 head , tail , size ; head <vul-end> = readw ( <vul-start> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <vul-end> readw ( chip <vul-start> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <vul-end> , chip -> <vul-start> ) ; } out :\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> + DSPQ_DATA_BUFF ; struct snd_msnd_loop_ctrl ctrl = { 0 } ; <vul-start> ) ) ; ctrl. data1 = pwDSPQData + 2 * readw ( chip -> DSPQ + JQS_wHead ) ; <vul-start> + 1 ; mutex_lock ( & ctrl. lock ) ; <vul-start> JQS_wHead ) ; mutex_unlock ( & ctrl. lock ) ; }\n"
 },
 {
  "id": 1448,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 PyMODINIT_FUNC PyInit__ast3 ( void ) { PyObject * m , * d ; if ( ! init_types ( ) ) return NULL ; <vul-start> m = PyModule_Create ( & _astmodule3 ) ; <vul-end> if ( ! m ) return NULL ; d = PyModule_GetDict ( m ) ; if ( PyDict_SetItemString ( d , \"AST\" , ( PyObject * ) & AST_type ) < 0 ) return NULL ; if ( PyModule_AddIntMacro ( m , PyCF_ONLY_AST ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"mod\" , ( PyObject * ) mod_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Module\" , ( PyObject * ) Module_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Interactive\" , ( PyObject * ) Interactive_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Expression\" , ( PyObject * ) Expression_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"FunctionType\" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"Suite\" , ( PyObject * ) Suite_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"stmt\" , ( PyObject * ) stmt_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"FunctionDef\" , ( PyObject * ) FunctionDef_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , \"AsyncFunctionDef\" , ( PyObject * ) AsyncFunctionDef_type ) < 0 ) return NULL ; if (",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> PyModule_Create ( & _astmodule <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> return NULL ; if ( PyDict_SetItemString ( d, \"ImportFrom\", ( PyObject * ) ImportFrom_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d, \"Interactive\", ( PyObject * ) Interactive_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d, \"Expression\", ( PyObject * ) Expression_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d, \"Suite\", ( PyObject * ) Suite_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d, \"Yield\", ( PyObject * ) AsyncYield_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d, \"Raise\", ( PyObject * ) Raise_type ) < 0 ) return NULL ;\n"
 },
 {
  "id": 1449,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int ptrace_check_attach ( struct task_struct * child , bool ignore_state ) { int ret = - ESRCH ; read_lock ( & tasklist_lock ) ; <vul-start> if ( ( child -> ptrace & PT_PTRACED ) && child -> parent == current ) { <vul-end> <vul-start> spin_lock_irq ( & child -> sighand -> siglock ) ; <vul-end> WARN_ON_ONCE ( task_is_stopped ( child ) ) ; <vul-start> if ( ignore_state || ( task_is_traced ( child ) && <vul-end> ! ( child -> jobctl & JOBCTL_LISTENING ) ) ) <vul-start> ret = 0 ; <vul-end> spin_unlock_irq ( & child -> sighand -> siglock ) ; } read_unlock ( & tasklist_lock ) ; <vul-start> if ( ! ret && ! ignore_state ) <vul-end> <vul-start> ret = wait_task_inactive ( child , TASK_TRACED ) ? 0 : - ESRCH ; <vul-end> return ret ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ; if ( <vul-end> child -> ptrace <vul-start> child -> ptrace <vul-end> && child -> <vul-start> current ) { WARN_ON ( child -> state == __TASK_TRACED <vul-end> ) ; if <vul-start> ( ignore_state || ptrace_freeze_traced ( child <vul-end> ) ) ret <vul-start> ret = 0 <vul-end> ; } read_unlock <vul-start> ! ignore_state ) { if ( ! <vul-end> wait_task_inactive ( child <vul-start> ( child , __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = <vul-end> - ESRCH ; <vul-start> - ESRCH ; } }\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ; if ( <vul-end> child -> ptrace <vul-start> & PT_PTRACED ) { if (! ignore_state ) ret = 0 ; spin_unlock_irq ( & child -> sighand -> siglock ) ; if ( child -> state!= TASK_TRACED ) ret = - ESRCH ; } else if ( <vul-end> child -> parent <vul-start> current ) { <vul-end> WARN_ON_ONCE ( task_is_stopped <vul-start> ) ) ; spin_lock ( & child -> sighand -> siglock ) ; <vul-start> = 0 ; } <vul-start>! ignore_state ) { if (! ignore_state ) ret = ptrace_check_attach ( child, ignore_state ) ; else <vul-start> - ESRCH ; } spin_unlock ( & tasklist_lock ) ; }\n"
 },
 {
  "id": 1450,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static void free_user ( struct kref * ref ) { struct ipmi_user * user = container_of ( ref , struct ipmi_user , refcount ) ; <vul-start> kfree ( user ) ; <vul-end> }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> refcount ) ; if ( user -> data ) kfree ( user -> data ) ;\n"
 },
 {
  "id": 1451,
  "question": "CWE-285 Code Input Vulnerable Code Is: CWE-285 int ext2_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <vul-start> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <vul-end> if ( error < 0 ) return error ; else { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; <vul-start> if ( error == 0 ) <vul-end> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext2_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext2_xattr_set ( inode , name_index , \"\" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }",
  "golden_answers": [
   "CWE-285 Fixed Code Lines are: <vul-start> { error = posix_acl_update_mode ( inode <vul-end> , & inode <vul-start> inode -> i_mode , & acl ) ; if ( error ) return error ; <vul-end> inode -> i_ctime <vul-start> inode ) ; <vul-end> } break ;\n"
  ],
  "generated_answer": "CWE-285 Fixed Code Lines are: <vul-start> { error = posix_acl_update_mode ( inode <vul-end>, & inode <vul-start> inode -> i_mode, & acl ) ; if ( error ) return error ; <vul-end> inode -> i_ctime <vul-start> inode ) ; <vul-end> } break ;\n"
 },
 {
  "id": 1452,
  "question": "CWE-78 Code Input Vulnerable Code Is: CWE-78 static int download ( struct SPDBDownloader * pd ) { SPDBDownloaderOpt * opt = pd -> opt ; <vul-start> char * curl_cmd = NULL ; <vul-end> char * extractor_cmd = NULL ; char * abspath_to_archive = NULL ; char * abspath_to_file = NULL ; char * archive_name = NULL ; size_t archive_name_len = 0 ; char * symbol_store_path = NULL ; char * dbg_file = NULL ; char * guid = NULL ; char * archive_name_escaped = NULL ; char * user_agent = NULL ; char * symbol_server = NULL ; int res = 0 ; int cmd_ret ; if ( ! opt -> dbg_file || ! * opt -> dbg_file ) { return 0 ; } <vul-start> if ( ! checkCurl ( ) ) { <vul-end> return 0 ; } archive_name_len = strlen ( opt -> dbg_file ) ; archive_name = malloc ( archive_name_len + 1 ) ; if ( ! archive_name ) { return 0 ; } memcpy ( archive_name , opt -> dbg_file , archive_name_len + 1 ) ; archive_name [ archive_name_len - 1 ] = '_' ; <vul-start> symbol_store_path = r_str_escape ( opt -> symbol_store_path ) ; <vul-end> dbg_file = r_str_escape ( opt -> dbg_file ) ; guid = r_str_escape ( opt -> guid ) ; archive_name_escaped = r_str_escape ( archive_name ) ; user_agent = r_str_escape ( opt -> user_agent ) ; symbol_server = r_str_escape ( opt -> symbol_server ) ; <vul-start> abspath_to_archive = r_str_newf ( \"%s%s%s%s%s%s%s\" , <vul-end> symbol_store_path , R_SYS_DIR , dbg_file , R_SYS_DIR , guid , R_SYS_DIR , archive_name_escaped ) ; abspath_to_file = strdup ( abspath_to_archive ) ;",
  "golden_answers": [
   "CWE-78 Fixed Code Lines are: <vul-start> -> opt ; <vul-end> int res = <vul-start> 0 ; } char * abspath_to_file = r_str_newf ( \"%s%s%s%s%s%s%s\" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , opt -> dbg_file ) ; if ( r_file_exists ( abspath_to_file ) ) { eprintf ( \"File already downloaded.\\\\n\" ) ; free ( abspath_to_file ) ; return 1 ; } if ( checkExtract ( ) || opt -> extract == 0 ) { char * extractor_cmd = NULL ; char * archive_name = strdup ( opt -> dbg_file ) ; archive_name [ strlen ( archive_name ) <vul-end> - 1 ] <vul-start> = '_' ; char * abspath_to_archive = r_str_newf ( \"%s%s%s%s%s%s%s\" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , archive_name ) ; eprintf ( \"Attempting to download compressed pdb in %s\\\\n\" , abspath_to_archive ) ; char * abs_arch_esc = r_str_escape_sh ( abspath_to_archive ) ; # if __WINDOWS__ char * abs_file_esc = r_str_escape_sh ( abspath_to_file ) ; extractor_cmd <vul-end> = r_str_newf ( <vul-start> = r_str_newf ( \"expand \\\\\"%s\\\\\" \\\\\"%s\\\\\"\" , abs_arch_esc , abs_file_esc ) ; free ( abs_file_esc <vul-end> ) ; # <vul-start> ; # else <vul-end> char * abspath_to_dir <vul-start> abspath_to_archive ) ; char * abs_dir_esc = r_str_escape_sh ( abspath_to_dir ) ; <vul-start> = r_str_newf ( \"cabextract -d \\\\\"%s\\\\\" \\\\\"%s\\\\\"\" , abs_arch_esc , abs_dir_esc ) ; free ( abs_dir_esc ) ; free <vul-end> ( abspath_to_dir ) <vul-start> ; # endif free ( abs_arch_esc ) ; res = download_and_write ( opt , archive_name <vul-end> ) ; if <vul-start> extract > 0 && res ) { eprintf ( \"Attempting to decompress pdb\\\\n\" ) ; if ( res && <vul-end> ( ( cmd_ret <vul-start> ) ; } free ( archive_name ) ; free ( abspath_to_archive <vul-end> ) ; } <vul-start> \"Falling back to uncompressed pdb\\\\n\" ) ; <vul-end> eprintf ( \"Attempting to download uncompressed pdb in %s\\\\n\" <vul-start> abspath_to_file ) ; res = download_and_write ( opt , opt -> dbg_file ) ; } free ( abspath_to_file <vul-end> ) ; return\n"
  ],
  "generated_answer": "CWE-78 Fixed Code Lines are: <vul-start> ; char * tmp_curl_cmd = NULL ; char * <vul-start> 0 ; } tmp_curl_cmd = r_str_newf ( \"%s%s%s%s%s\", R_SYS_DIR, dbg_file, R_SYS_DIR, guid, R_SYS_DIR, archive_name_escaped ) ; if ( tmp_curl_cmd ) { eprintf ( \"Fail to override existing curl command\\\\n\" ) ; res = 0 ; } <vul-start> = '_' ; archive_name_len = strlen ( tmp_curl_cmd ) ; tmp_curl_cmd = r_str_newf ( \"%s%s%s%s%s\", R_SYS_DIR, dbg_file, R_SYS_DIR, guid, R_SYS_DIR, archive_name_escaped, tmp_curl_cmd, tmp_curl_cmd ) ; if ( tmp_curl_cmd ) { r_free ( tmp_curl_cmd ) ; res = 0 ; } r_free ( tmp_curl_cmd ) ; <vul-start> symbol_server ) ; tmp_curl_cmd = r_str_newf ( \"%s%s%s%s%s%s\", R_SYS_DIR, dbg_file, R_SYS_DIR, guid, R_SYS_DIR, archive_name_escaped ) ; if ( tmp_curl_cmd ) { <vul-start> ( cmd_ret = r_sys_cmd ( tmp_curl_cmd ) )!= 0 ) { eprintf ( \"cab extractor exited with error %d\\\\n\", cmd_ret ) ; res = 0 ; } r_file_rm ( abspath_to_archive ) ; } R_FREE ( curl_cmd ) ; } if ( res == 0 ) { eprintf ( \"Falling back to uncompressed pdb\\\\n\" ) ; res = 1 ; archive_name_escaped = '\\\\0' ; tmp_curl_cmd = r_str_newf ( \"curl -sfLA \\\\\"%s\\\\\" \\\\\"%s/%s/%s\\\\\"\", opt -> user_agent, opt -> symbol_server, opt -> dbg_file, opt -> guid, archive_name_escaped, tmp_curl_cmd ) ; if ( tmp_curl_cmd ) { <vul-start> ) ; } r_free ( tmp_"
 },
 {
  "id": 1453,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 PHP_MINIT_FUNCTION ( spl_array ) { REGISTER_SPL_STD_CLASS_EX ( ArrayObject , spl_array_object_new , spl_funcs_ArrayObject ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Aggregate ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayObject , Countable ) ; memcpy ( & spl_handler_ArrayObject , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; spl_handler_ArrayObject . clone_obj = spl_array_object_clone ; spl_handler_ArrayObject . read_dimension = spl_array_read_dimension ; spl_handler_ArrayObject . write_dimension = spl_array_write_dimension ; spl_handler_ArrayObject . unset_dimension = spl_array_unset_dimension ; spl_handler_ArrayObject . has_dimension = spl_array_has_dimension ; spl_handler_ArrayObject . count_elements = spl_array_object_count_elements ; spl_handler_ArrayObject . get_properties = spl_array_get_properties ; <vul-start> spl_handler_ArrayObject . get_debug_info = spl_array_get_debug_info ; <vul-end> spl_handler_ArrayObject . read_property = spl_array_read_property ; spl_handler_ArrayObject . write_property = spl_array_write_property ; spl_handler_ArrayObject . get_property_ptr_ptr = spl_array_get_property_ptr_ptr ; spl_handler_ArrayObject . has_property = spl_array_has_property ; spl_handler_ArrayObject . unset_property = spl_array_unset_property ; spl_handler_ArrayObject . compare_objects = spl_array_compare_objects ; REGISTER_SPL_STD_CLASS_EX ( ArrayIterator , spl_array_object_new , spl_funcs_ArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Iterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , ArrayAccess ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , SeekableIterator ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Serializable ) ; REGISTER_SPL_IMPLEMENTS ( ArrayIterator , Countable ) ; memcpy ( & spl_handler_ArrayIterator , & spl_handler_ArrayObject , sizeof ( zend_object_handlers ) ) ; spl_ce_ArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_SUB_CLASS_EX ( RecursiveArrayIterator , ArrayIterator , spl_array_object_new , spl_funcs_RecursiveArrayIterator ) ; REGISTER_SPL_IMPLEMENTS ( RecursiveArrayIterator , RecursiveIterator ) ; spl_ce_RecursiveArrayIterator -> get_iterator = spl_array_get_iterator ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , \"STD_PROP_LIST\" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayObject , \"ARRAY_AS_PROPS\" , SPL_ARRAY_ARRAY_AS_PROPS ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , \"STD_PROP_LIST\" , SPL_ARRAY_STD_PROP_LIST ) ; REGISTER_SPL_CLASS_CONST_LONG ( ArrayIterator , \"ARRAY_AS_PROPS\" , SPL_ARRAY_ARRAY_AS_PROPS",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> get_debug_info = spl_array_get_debug_info ; spl_handler_ArrayObject . get_gc = spl_array_get_gc\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> ; spl_handler_ArrayObject. get_gc = spl_array_get_gc ; spl_handler_ArrayObject.\n"
 },
 {
  "id": 1454,
  "question": "CWE-401 Code Input Vulnerable Code Is: CWE-401 int i2400m_op_rfkill_sw_toggle ( struct wimax_dev * wimax_dev , enum wimax_rf_state state ) { int result ; struct i2400m * i2400m = wimax_dev_to_i2400m ( wimax_dev ) ; struct device * dev = i2400m_dev ( i2400m ) ; struct sk_buff * ack_skb ; struct { struct i2400m_l3l4_hdr hdr ; struct i2400m_tlv_rf_operation sw_rf ; } __packed * cmd ; char strerr [ 32 ] ; d_fnstart ( 4 , dev , \"(wimax_dev %p state %d)\\\\n\" , wimax_dev , state ) ; result = - ENOMEM ; cmd = kzalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; if ( cmd == NULL ) goto error_alloc ; cmd -> hdr . type = cpu_to_le16 ( I2400M_MT_CMD_RF_CONTROL ) ; cmd -> hdr . length = sizeof ( cmd -> sw_rf ) ; cmd -> hdr . version = cpu_to_le16 ( I2400M_L3L4_VERSION ) ; cmd -> sw_rf . hdr . type = cpu_to_le16 ( I2400M_TLV_RF_OPERATION ) ; cmd -> sw_rf . hdr . length = cpu_to_le16 ( sizeof ( cmd -> sw_rf . status ) ) ; switch ( state ) { case WIMAX_RF_OFF : cmd -> sw_rf . status = cpu_to_le32 ( 2 ) ; break ; case WIMAX_RF_ON : cmd -> sw_rf . status = cpu_to_le32 ( 1 ) ; break ; default : BUG ( ) ; } ack_skb = i2400m_msg_to_dev ( i2400m , cmd , sizeof ( * cmd ) ) ; result = PTR_ERR ( ack_skb ) ; if ( IS_ERR ( ack_skb ) ) { dev_err ( dev , \"Failed to issue \\'RF Control\\' command: %d\\\\n\" , result ) ; goto error_msg_to_dev ;",
  "golden_answers": [
   "CWE-401 Fixed Code Lines are: <vul-start> ; error_cmd : kfree_skb ( ack_skb ) ; error_msg_to_dev : error_alloc : d_fnend ( 4 , dev , \"(wimax_dev %p state %d) = %d\\\\n\" , wimax_dev , state , result ) ; <vul-start> kfree ( cmd <vul-end> ) ; return\n"
  ],
  "generated_answer": "CWE-401 Fixed Code Lines are: <vul-start> ; error_cmd : kfree_skb ( cmd ) ;\n"
 },
 {
  "id": 1455,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static void process_lru_command ( conn * c , token_t * tokens , const size_t ntokens ) { uint32_t pct_hot ; uint32_t pct_warm ; double hot_factor ; int32_t ttl ; double factor ; set_noreply_maybe ( c , tokens , ntokens ) ; if ( strcmp ( tokens [ 1 ] . value , \"tune\" ) == 0 && ntokens >= 7 ) { if ( ! safe_strtoul ( tokens [ 2 ] . value , & pct_hot ) || ! safe_strtoul ( tokens [ 3 ] . value , & pct_warm ) || ! safe_strtod ( tokens [ 4 ] . value , & hot_factor ) || ! safe_strtod ( tokens [ 5 ] . value , & factor ) ) { out_string ( c , \"ERROR\" ) ; } else { if ( pct_hot + pct_warm > 80 ) { out_string ( c , \"ERROR hot and warm pcts must not exceed 80\" ) ; } else if ( factor <= 0 || hot_factor <= 0 ) { out_string ( c , \"ERROR hot/warm age factors must be greater than 0\" ) ; } else { settings . hot_lru_pct = pct_hot ; settings . warm_lru_pct = pct_warm ; settings . hot_max_factor = hot_factor ; settings . warm_max_factor = factor ; out_string ( c , \"OK\" ) ; } } <vul-start> } else if ( strcmp ( tokens [ 1 ] . value , \"mode\" ) == 0 && ntokens >= 3 && <vul-end> settings . lru_maintainer_thread ) { if ( strcmp ( tokens [ 2 ] . value , \"flat\" ) == 0 ) {",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> && ntokens >= 4 <vul-end> && settings . <vul-start> && ntokens >= 4 <vul-end> && settings .\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> } } else <vul-end> { if ( <vul-start> } } else <vul-end> { if ( <vul-start> } } else <vul-end> { if ( <vul-start> } } else <vul-end> { if (\n"
 },
 {
  "id": 1456,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 void jas_matrix_divpow2 ( jas_matrix_t * matrix , int n ) { <vul-start> int i ; <vul-end> int j ; jas_seqent_t * rowstart ; <vul-start> int rowstep ; <vul-end> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = ( * data >= 0 ) ? ( ( * data ) >> n ) : ( - ( ( - ( * data ) ) >> n ) ) ; } } } }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> n ) { jas_matind_t i ; jas_matind_t <vul-end> j ; jas_seqent_t <vul-start> * rowstart ; jas_matind_t <vul-end> rowstep ; jas_seqent_t\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> n ) { jas_matind_t i ; jas_matind_t <vul-end> j ; jas_seqent_t <vul-start> * rowstart ; jas_matind_t <vul-end> rowstep ; jas_seqent_t\n"
 },
 {
  "id": 1457,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 <vul-start> static int isofs_read_inode ( struct inode * inode ) <vul-end> { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO \"%s: out of memory\\\\n\" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> inode * inode , int relocated <vul-start> de , inode , relocated\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> inode * inode, struct mb2_cache * ext <vul-start> high_sierra ) { if ( ext -> size!= de -> i_size ) goto out_badread ;\n"
 },
 {
  "id": 1458,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 rdpCredssp * credssp_new ( freerdp * instance , rdpTransport * transport , rdpSettings * settings ) { rdpCredssp * credssp ; credssp = ( rdpCredssp * ) malloc ( sizeof ( rdpCredssp ) ) ; ZeroMemory ( credssp , sizeof ( rdpCredssp ) ) ; if ( credssp != NULL ) { HKEY hKey ; LONG status ; DWORD dwType ; DWORD dwSize ; credssp -> instance = instance ; credssp -> settings = settings ; credssp -> server = settings -> ServerMode ; credssp -> transport = transport ; credssp -> send_seq_num = 0 ; credssp -> recv_seq_num = 0 ; ZeroMemory ( & credssp -> negoToken , sizeof ( SecBuffer ) ) ; ZeroMemory ( & credssp -> pubKeyAuth , sizeof ( SecBuffer ) ) ; <vul-start> ZeroMemory ( & credssp -> authInfo , sizeof ( SecBuffer ) ) ; <vul-end> if ( credssp -> server ) { status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE , _T ( \"Software\\\\\\\\FreeRDP\\\\\\\\Server\" ) , 0 , KEY_READ | KEY_WOW64_64KEY , & hKey ) ; if ( status == ERROR_SUCCESS ) { status = RegQueryValueEx ( hKey , _T ( \"SspiModule\" ) , NULL , & dwType , NULL , & dwSize ) ; if ( status == ERROR_SUCCESS ) { credssp -> SspiModule = ( LPTSTR ) malloc ( dwSize + sizeof ( TCHAR ) ) ; status = RegQueryValueEx ( hKey , _T ( \"SspiModule\" ) , NULL , & dwType , ( BYTE * ) credssp -> SspiModule , & dwSize ) ; if ( status == ERROR_SUCCESS ) { _tprintf ( _T ( \"Using SSPI",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ( SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ) ) ; credssp -> server = 0 ;\n"
 },
 {
  "id": 1459,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void copy_fields ( const FieldMatchContext * fm , AVFrame * dst , const AVFrame * src , int field ) { int plane ; <vul-start> for ( plane = 0 ; plane < 4 && src -> data [ plane ] ; plane ++ ) <vul-end> av_image_copy_plane ( dst -> data [ plane ] + field * dst -> linesize [ plane ] , dst -> linesize [ plane ] << 1 , src -> data [ plane ] + field * src -> linesize [ plane ] , src -> linesize [ plane ] << 1 , get_width ( fm , src , plane ) , get_height ( fm , src , plane ) / 2 ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> src -> data [ plane ] && src -> linesize\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> [ plane ] && src -> linesize [ plane ]\n"
 },
 {
  "id": 1460,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 int sqlite3ExprCodeTarget ( Parse * pParse , Expr * pExpr , int target ) { Vdbe * v = pParse -> pVdbe ; int op ; int inReg = target ; int regFree1 = 0 ; int regFree2 = 0 ; int r1 , r2 ; Expr tempX ; int p5 = 0 ; assert ( target > 0 && target <= pParse -> nMem ) ; if ( v == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return 0 ; } expr_code_doover : if ( pExpr == 0 ) { op = TK_NULL ; } else { op = pExpr -> op ; } switch ( op ) { case TK_AGG_COLUMN : { AggInfo * pAggInfo = pExpr -> pAggInfo ; struct AggInfo_col * pCol = & pAggInfo -> aCol [ pExpr -> iAgg ] ; if ( ! pAggInfo -> directMode ) { assert ( pCol -> iMem > 0 ) ; return pCol -> iMem ; } else if ( pAggInfo -> useSortingIdx ) { sqlite3VdbeAddOp3 ( v , OP_Column , pAggInfo -> sortingIdxPTab , pCol -> iSorterColumn , target ) ; return target ; } } case TK_COLUMN : { int iTab = pExpr -> iTable ; if ( ExprHasProperty ( pExpr , EP_FixedCol ) ) { int iReg = sqlite3ExprCodeTarget ( pParse , pExpr -> pLeft , target ) ; <vul-start> int aff = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ; <vul-end> if ( aff > SQLITE_AFF_BLOB ) { static const char zAff [ ] = \"B\\\\000C\\\\000D\\\\000E\" ; assert",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ; int aff ; if ( pExpr -> y . pTab ) { aff <vul-start> iColumn ) ; } else { aff = pExpr -> affExpr ; }\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> target ) ; sqlite3_int64 <vul-end> aff = sqlite3TableColumnAffinity <vul-start>. pTab, 0 ) ; if ( aff == SQLITE_AFF_BLOB ) { sqlite3VdbeAddOp2 ( v, OP_Affinity, iReg, 0 ) ; iReg = target ; } else <vul-end> if ( aff\n"
 },
 {
  "id": 1461,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 void inet_sock_destruct ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; __skb_queue_purge ( & sk -> sk_error_queue ) ; sk_mem_reclaim ( sk ) ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state != TCP_CLOSE ) { pr_err ( \"Attempt to release TCP socket in state %d %p\\\\n\" , sk -> sk_state , sk ) ; return ; } if ( ! sock_flag ( sk , SOCK_DEAD ) ) { pr_err ( \"Attempt to release alive inet socket %p\\\\n\" , sk ) ; return ; } WARN_ON ( atomic_read ( & sk -> sk_rmem_alloc ) ) ; WARN_ON ( atomic_read ( & sk -> sk_wmem_alloc ) ) ; WARN_ON ( sk -> sk_wmem_queued ) ; WARN_ON ( sk -> sk_forward_alloc ) ; <vul-start> kfree ( inet -> opt ) ; <vul-end> dst_release ( rcu_dereference_check ( sk -> sk_dst_cache , 1 ) ) ; sk_refcnt_debug_dec ( sk ) ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ; kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 ) <vul-end> ) ; dst_release\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> sk_forward_alloc ) ; atomic_dec ( & inet -> inet_opt -> refcnt ) ;\n"
 },
 {
  "id": 1462,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static identifier new_identifier ( const char * n , struct compiling * c ) { PyObject * id = PyUnicode_DecodeUTF8 ( n , strlen ( n ) , NULL ) ; if ( ! id ) return NULL ; assert ( PyUnicode_IS_READY ( id ) ) ; if ( ! PyUnicode_IS_ASCII ( id ) ) { PyObject * id2 ; <vul-start> if ( ! c -> c_normalize && ! init_normalization ( c ) ) { <vul-end> Py_DECREF ( id ) ; return NULL ; } <vul-start> PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , id ) ; <vul-end> <vul-start> id2 = PyObject_Call ( c -> c_normalize , c -> c_normalize_args , NULL ) ; <vul-end> Py_DECREF ( id ) ; if ( ! id2 ) return NULL ; id = id2 ; } PyUnicode_InternInPlace ( & id ) ; if ( PyArena_AddPyObject ( c -> c_arena , id ) < 0 ) { Py_DECREF ( id ) ; return NULL ; } return id ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> * id2 ; PyObject * form ; PyObject * args [ 2 ] ; _Py_IDENTIFIER ( NFKC ) ; <vul-start> NULL ; } form = _PyUnicode_FromId ( & PyId_NFKC ) ; if ( form == NULL ) { Py_DECREF ( id ) ; return NULL ; } args [ 0 ] = form ; args [ 1 ] = id ; id2 = _PyObject_FastCall <vul-end> ( c -> <vul-start> -> c_normalize , args , 2 ) ; Py_DECREF ( id ) ; if ( ! id2 ) return NULL ; if ( ! PyUnicode_Check ( id2 ) ) { PyErr_Format ( PyExc_TypeError , \"unicodedata.normalize() must return a string, not \" \"%.200s\" , Py_TYPE ( id2 ) -> tp_name ) ; Py_DECREF ( id2 ) ; return NULL ; } <vul-end> id = id2\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>! c -> c_method <vul-end> &&! init_normalization <vul-start> ( c ) &&! c -> c_forward_as_string &&! init_type_normalize <vul-start> NULL ; } id2 = PyObject_Call ( c -> c_method <vul-end>, c -> <vul-start> c -> c_normalize_args <vul-end>, NULL )\n"
 },
 {
  "id": 1463,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void Huff_Compress ( msg_t * mbuf , int offset ) { int i , ch , size ; byte seq [ 65536 ] ; byte * buffer ; huff_t huff ; size = mbuf -> cursize - offset ; buffer = mbuf -> data + + offset ; if ( size <= 0 ) { return ; } Com_Memset ( & huff , 0 , sizeof ( huff_t ) ) ; huff . tree = huff . lhead = huff . loc [ NYT ] = & ( huff . nodeList [ huff . blocNode ++ ] ) ; huff . tree -> symbol = NYT ; huff . tree -> weight = 0 ; huff . lhead -> next = huff . lhead -> prev = NULL ; huff . tree -> parent = huff . tree -> left = huff . tree -> right = NULL ; seq [ 0 ] = ( size >> 8 ) ; seq [ 1 ] = size & 0xff ; bloc = 16 ; for ( i = 0 ; i < size ; i ++ ) { ch = buffer [ i ] ; <vul-start> Huff_transmit ( & huff , ch , seq ) ; <vul-end> Huff_addRef ( & huff , ( byte ) ch ) ; } bloc += 8 ; mbuf -> cursize = ( bloc >> 3 ) + offset ; Com_Memcpy ( mbuf -> data + offset , seq , ( bloc >> 3 ) ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ch , seq , size << 3\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> i ] ; if (! <vul-start>, seq ) ) { return ; } <vul-end> Huff_addRef ( &\n"
 },
 {
  "id": 1464,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static netsnmp_pdu * _clone_pdu_header ( netsnmp_pdu * pdu ) { netsnmp_pdu * newpdu ; struct snmp_secmod_def * sptr ; int ret ; if ( ! pdu ) return NULL ; newpdu = ( netsnmp_pdu * ) malloc ( sizeof ( netsnmp_pdu ) ) ; if ( ! newpdu ) return NULL ; memmove ( newpdu , pdu , sizeof ( netsnmp_pdu ) ) ; newpdu -> variables = NULL ; newpdu -> enterprise = NULL ; newpdu -> community = NULL ; newpdu -> securityEngineID = NULL ; newpdu -> securityName = NULL ; newpdu -> contextEngineID = NULL ; newpdu -> contextName = NULL ; newpdu -> transport_data = NULL ; if ( snmp_clone_mem ( ( void * * ) & newpdu -> enterprise , pdu -> enterprise , sizeof ( oid ) * pdu -> enterprise_length ) || snmp_clone_mem ( ( void * * ) & newpdu -> community , pdu -> community , pdu -> community_len ) || snmp_clone_mem ( ( void * * ) & newpdu -> contextEngineID , pdu -> contextEngineID , pdu -> contextEngineIDLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> securityEngineID , pdu -> securityEngineID , pdu -> securityEngineIDLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> contextName , pdu -> contextName , pdu -> contextNameLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> securityName , pdu -> securityName , pdu -> securityNameLen ) || snmp_clone_mem ( ( void * * ) & newpdu -> transport_data , pdu -> transport_data , pdu -> transport_data_length )",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> NULL ; } sptr = find_sec_mod ( newpdu -> securityModel ) ; if ( sptr && sptr -> pdu_clone ) { ret = sptr -> pdu_clone ( pdu , newpdu <vul-end> ) ; if <vul-start> NULL ; } <vul-end> } return newpdu\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> NULL ; } newpdu -> security_state = NULL ; <vul-start> NULL ; } newpdu -> security_model = pdu -> securityModel ;\n"
 },
 {
  "id": 1465,
  "question": "CWE-254 Code Input Vulnerable Code Is: CWE-254 UWORD16 impeg2d_get_mb_addr_incr ( stream_t * ps_stream ) { UWORD16 u2_mb_addr_incr = 0 ; <vul-start> while ( impeg2d_bit_stream_nxt ( ps_stream , MB_ESCAPE_CODE_LEN ) == MB_ESCAPE_CODE ) <vul-end> { impeg2d_bit_stream_flush ( ps_stream , MB_ESCAPE_CODE_LEN ) ; u2_mb_addr_incr += 33 ; } u2_mb_addr_incr += impeg2d_dec_vld_symbol ( ps_stream , gai2_impeg2d_mb_addr_incr , MB_ADDR_INCR_LEN ) + MB_ADDR_INCR_OFFSET ; return ( u2_mb_addr_incr ) ; }",
  "golden_answers": [
   "CWE-254 Fixed Code Lines are: <vul-start> ) == MB_ESCAPE_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset\n"
  ],
  "generated_answer": "CWE-254 Fixed Code Lines are: <vul-start> ) == MB_ESCAPE_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset\n"
 },
 {
  "id": 1466,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int tt_s2_4600_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; <vul-start> struct dw2102_state * state = d -> priv ; <vul-end> u8 obuf [ 3 ] = { 0xe , 0x80 , 0 } ; u8 ibuf [ ] = { 0 } ; struct i2c_adapter * i2c_adapter ; struct i2c_client * client ; struct i2c_board_info board_info ; struct m88ds3103_platform_data m88ds3103_pdata = { } ; struct ts2020_config ts2020_config = { } ; <vul-start> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x02 ; <vul-end> <vul-start> obuf [ 2 ] = 1 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; msleep ( 300 ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x83 ; <vul-end> <vul-start> obuf [ 2 ] = 0 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d , obuf , 3 , ibuf , 1 , 0 ) < 0 ) <vul-end> err ( \"command 0x0e transfer failed.\" ) ; <vul-start> obuf [ 0 ] = 0xe ; <vul-end> <vul-start> obuf [ 1 ] = 0x83 ; <vul-end> <vul-start> obuf [ 2 ] = 1 ; <vul-end> <vul-start> if ( dvb_usb_generic_rw ( d , obuf , 3 ,",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> d -> priv <vul-end> ; struct i2c_adapter <vul-start> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <vul-start> ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x02 ; state -> data <vul-end> [ 2 ] <vul-start> ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> 300 ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> ( d , state -> data <vul-end> , 3 , <vul-start> , 3 , state -> data <vul-end> , 1 , <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> ( d , state -> data , 1 , state -> data <vul-end> , 1 , <vul-start> err ( \"command 0x51 transfer failed.\" ) ; mutex_unlock ( & d -> data_mutex\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> d -> priv <vul-end> ; struct i2c_adapter <vul-start> ( d, state -> data <vul-end>, 3, <vul-start>, 3, state -> data <vul-end>, 1, <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x02 ; state -> data <vul-end> [ 2 ] <vul-start> ( d, state -> data <vul-end>, 3, <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> ( d, state -> data <vul-end>, 3, <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0xe ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> \"command 0x0e transfer failed.\" ) ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> ; if ( dvb_usb_generic_rw ( d, state -> data <vul-end>, 3, <vul-start> ( d, state -> data <vul-end>, 3, <vul-start> \"command 0x51 transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0x02 ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> \"command 0x51 transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0x68 ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> ; if ( dvb_usb_generic_rw ( d, state -> data <vul-end>, 3, <vul-start> \"command 0x68 transfer failed.\" ) ; state -> data <vul-end> [ 1 ] <vul-start> = 0x83 ; state -> data <vul-end> [ 2 ] <vul-start> \"command 0x68 transfer failed.\" ) ; state -> data <vul-end> [ 0 ] <vul-start> = 0x51 ; state -> data <vul-end> [ 1 ] <vul-start> = 0x82 ; state -> data <vul-end> [ 2 ] <vul-start> ( d, state -> data <vul-end>, 3, <vul-start> ibuf, 1 <vul-end>, 0"
 },
 {
  "id": 1467,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int jas_iccgetsint32 ( jas_stream_t * in , jas_iccsint32_t * val ) { <vul-start> ulonglong tmp ; <vul-end> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; <vul-start> * val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( longlong , ( ( ( ~ tmp ) & <vul-end> <vul-start> 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( longlong , tmp ) ; <vul-end> return 0 ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> val ) { jas_ulonglong <vul-end> tmp ; if <vul-start> - JAS_CAST ( jas_longlong <vul-end> , ( ( <vul-start> : JAS_CAST ( jas_longlong <vul-end> , tmp )\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> val ) { jas_ulonglong <vul-end> tmp ; if <vul-start> val = ( JAS_CAST ( longlong <vul-end>, ( ( <vul-start> tmp ) & 0x7fffffff ) + 1 <vul-end> ) ) : <vul-start> : JAS_CAST ( longlong <vul-end>, tmp )\n"
 },
 {
  "id": 1468,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void handle_associated_event ( struct cpu_hw_events * cpuc , int idx , struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event * event = cpuc -> events [ idx ] ; struct hw_perf_event * hwc = & event -> hw ; mipspmu_event_update ( event , hwc , idx ) ; data -> period = event -> hw . last_period ; if ( ! mipspmu_event_set_period ( event , hwc , idx ) ) return ; <vul-start> if ( perf_event_overflow ( event , 0 , data , regs ) ) <vul-end> mipspmu -> disable_event ( idx ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ( event , <vul-end> data , regs\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ( event, <vul-end> data, regs\n"
 },
 {
  "id": 1469,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static mrb_value fiber_switch ( mrb_state * mrb , mrb_value self , mrb_int len , const mrb_value * a , mrb_bool resume , mrb_bool vmexec ) { struct mrb_context * c = fiber_check ( mrb , self ) ; struct mrb_context * old_c = mrb -> c ; <vul-start> mrb_value value ; <vul-end> <vul-start> fiber_check_cfunc ( mrb , c ) ; <vul-end> <vul-start> if ( resume && c -> status == MRB_FIBER_TRANSFERRED ) { <vul-end> mrb_raise ( mrb , E_FIBER_ERROR , \"resuming transferred fiber\" ) ; } <vul-start> if ( c -> status == MRB_FIBER_RUNNING || c -> status == MRB_FIBER_RESUMED ) { <vul-end> mrb_raise ( mrb , E_FIBER_ERROR , \"double resume (fib)\" ) ; } <vul-start> if ( c -> status == MRB_FIBER_TERMINATED ) { <vul-end> mrb_raise ( mrb , E_FIBER_ERROR , \"resuming dead fiber\" ) ; } <vul-start> mrb -> c -> status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED ; <vul-end> c -> prev = resume ? mrb -> c : ( c -> prev ? c -> prev : mrb -> root_c ) ; <vul-start> if ( c -> status == MRB_FIBER_CREATED ) { <vul-end> mrb_value * b , * e ; <vul-start> if ( len >= c -> stend - c -> stack ) { <vul-end> mrb_raise ( mrb , E_FIBER_ERROR , \"too many arguments to fiber\" ) ; } b = c -> stack + 1 ; e = b + len ; while ( b < e ) { * b ++ = * a ++ ; } c -> cibase -> argc = ( int ) len ; value",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> -> c ; enum mrb_fiber_state status ; <vul-start> , c ) ; status = c -> status <vul-start> ( resume && <vul-end> status == MRB_FIBER_TRANSFERRED <vul-start> } if ( <vul-end> status == MRB_FIBER_RUNNING <vul-start> == MRB_FIBER_RUNNING || <vul-end> status == MRB_FIBER_RESUMED <vul-start> } if ( <vul-end> status == MRB_FIBER_TERMINATED <vul-start> ) ; } old_c <vul-end> -> status = <vul-start> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( <vul-end> status == MRB_FIBER_CREATED <vul-start> * e ; mrb_stack_extend ( mrb , len + 2 ) ; <vul-end> b = c <vul-start> ) ; } <vul-end> if ( vmexec\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -> c ; int ctx_is_intra_only = false ; <vul-start> mrb_value value ; inttra_only = ( c -> status == MRB_FIBER_CREATED )? 1 : 0 ; <vul-start> ( resume && ctx_is_intra_only && ( <vul-start> status == MRB_FIBER_TRANSFERRED || ctx_is_intra_only ) <vul-start> } if ( ctx_is_intra_only && ( <vul-start> status == MRB_FIBER_RUNNING || ctx_is_intra_only ) <vul-start> } if ( ctx_is_intra_only && ( <vul-start> status == MRB_FIBER_TERMINATED || ctx_is_intra_only ) <vul-start> ; if ( ctx_is_intra_only && ( <vul-start> status == MRB_FIBER_CREATED || c -> status == MRB_FIBER_RUNNING ) <vul-start> * e ; mrb_int argc = ( int ) len ; <vul-start> ) ; } if (! resume && ctx_is_intra_only ) { mrb_raise ( mrb, E_FIBER_ERROR, \"intra mode not intra mode\" ) ; } <vul-start> mrb, c ) ; if (! ctx_is_intra_only\n"
 },
 {
  "id": 1470,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 int ssl3_get_key_exchange ( SSL * s ) { # ifndef OPENSSL_NO_RSA unsigned char * q , md_buf [ EVP_MAX_MD_SIZE * 2 ] ; # endif EVP_MD_CTX md_ctx ; unsigned char * param , * p ; int al , j , ok ; long i , param_len , n , alg_k , alg_a ; EVP_PKEY * pkey = NULL ; const EVP_MD * md = NULL ; # ifndef OPENSSL_NO_RSA RSA * rsa = NULL ; # endif # ifndef OPENSSL_NO_DH DH * dh = NULL ; # endif # ifndef OPENSSL_NO_ECDH EC_KEY * ecdh = NULL ; BN_CTX * bn_ctx = NULL ; EC_POINT * srvr_ecpoint = NULL ; int curve_nid = 0 ; int encoded_pt_len = 0 ; # endif <vul-start> n = s -> method -> ssl_get_message ( s , <vul-end> SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ; <vul-start> if ( ! ok ) return ( ( int ) n ) ; <vul-end> if ( s -> s3 -> tmp . message_type != SSL3_MT_SERVER_KEY_EXCHANGE ) { <vul-start> # ifndef OPENSSL_NO_PSK <vul-end> <vul-start> if ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) <vul-end> { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> ; # endif EVP_MD_CTX_init ( & md_ctx ) ; <vul-start> ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <vul-start> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <vul-start> OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <vul-start> . new_cipher -> algorithm_auth <vul-end> ; al =\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> ; # endif SSL_CIPHER * c ; <vul-start> (! ok ||! SSL_CIPHER_IS_EXPORT ( s -> s3 -> tmp. new_cipher ) <vul-start> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( s -> s3 -> tmp. new_cipher == NULL ) { al = SSL_AD_UNSUPPORTED ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE, SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } <vul-end> s -> session <vul-start> -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif <vul-end> return ( 1 <vul-start> ) ; } <vul-end>      \n"
 },
 {
  "id": 1471,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <vul-start> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <vul-end> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , message ) \\\\\\n{ <vul-end> if ( tile_image <vul-start> ) ) ; \\\\\\n} <vul-end> char geometry [ <vul-start> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( length <vul-start> ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( <vul-start> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" <vul-start> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" <vul-start> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" <vul-start> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( length <vul-start> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; if ( length > <vul-start> image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ; <vul-start> 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , \"InsufficientImageDataInFile\" ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, message ) \\\\\\n{ <vul-end> if ( tile_image <vul-start> ) ) ; \\\\\\n} <vul-end> char geometry [ <vul-start> ) break ; if ( <vul-end> fputc ( c <vul-start>, file )!= c ) break\n"
 },
 {
  "id": 1472,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void write_mv_update ( const vp9_tree_index * tree , <vul-end> <vul-start> vp9_prob probs [ ] , <vul-end> const unsigned int counts [ ] , <vul-start> int n , vp9_writer * w ) { <vul-end> int i ; unsigned int branch_ct [ 32 ] [ 2 ] ; assert ( n <= 32 ) ; vp9_tree_probs_from_distribution ( tree , branch_ct , counts ) ; for ( i = 0 ; i < n - 1 ; ++ i ) update_mv ( w , branch_ct [ i ] , & probs [ i ] , MV_UPDATE_PROB ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> write_mv_update ( const vpx_tree_index <vul-end> * tree , <vul-start> * tree , vpx_prob <vul-end> probs [ ] <vul-start> int n , vpx_writer <vul-end> * w )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> write_mv_update ( const vpx_tree_index <vul-end> * tree, <vul-start> * tree, vpx_prob <vul-end> probs [ ] <vul-start> int n, vpx_writer <vul-end> * w )\n"
 },
 {
  "id": 1473,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int sctp_setsockopt_auto_asconf ( struct sock * sk , char __user * optval , unsigned int optlen ) { int val ; struct sctp_sock * sp = sctp_sk ( sk ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; if ( ! sctp_is_ep_boundall ( sk ) && val ) return - EINVAL ; if ( ( val && sp -> do_auto_asconf ) || ( ! val && ! sp -> do_auto_asconf ) ) return 0 ; <vul-start> if ( val == 0 && sp -> do_auto_asconf ) { <vul-end> list_del ( & sp -> auto_asconf_list ) ; sp -> do_auto_asconf = 0 ; } else if ( val && ! sp -> do_auto_asconf ) { list_add_tail ( & sp -> auto_asconf_list , & sock_net ( sk ) -> sctp . auto_asconf_splist ) ; sp -> do_auto_asconf = 1 ; } <vul-start> return 0 ; <vul-end> }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> return 0 ; spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <vul-start> 1 ; } spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> return 0 ; spin_lock_bh ( & sock_net ( sk ) -> sctp. addr_wq_lock ) ; <vul-start> do_auto_asconf ) { spin_unlock_bh ( & sock_net ( sk ) -> sctp. addr_wq_lock ) ; <vul-start> 1 ; } spin_unlock_bh ( & sock_net ( sk ) -> sctp. addr_wq_lock ) ;\n"
 },
 {
  "id": 1474,
  "question": "CWE-120 Code Input Vulnerable Code Is: CWE-120 void test_base64_decode ( void ) { char buffer [ 16 ] ; <vul-start> int len = mutt_b64_decode ( buffer , encoded ) ; <vul-end> if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) { TEST_MSG ( \"Expected: %zu\" , sizeof ( clear ) - 1 ) ; TEST_MSG ( \"Actual : %zu\" , len ) ; } buffer [ len ] = '\\\\0' ; if ( ! TEST_CHECK ( strcmp ( buffer , clear ) == 0 ) ) { TEST_MSG ( \"Expected: %s\" , clear ) ; TEST_MSG ( \"Actual : %s\" , buffer ) ; } }",
  "golden_answers": [
   "CWE-120 Fixed Code Lines are: <vul-start> buffer , encoded , sizeof ( buffer )\n"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> 16 ] ; size_t <vul-end> len = mutt_b64_decode\n"
 },
 {
  "id": 1475,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put (",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> rds_loop_transport ; } <vul-end> } conn ->\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> rds_loop_transport ; } if ( is_outgoing && trans -> t_name ) { trans = & rds_loop_transport ; }\n"
 },
 {
  "id": 1476,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_iht4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride , <vul-end> int tx_type ) { const transform_2d IHT_4 [ ] = { <vul-start> { idct4 , idct4 } , <vul-end> { iadst4 , idct4 } , { idct4 , iadst4 } , { iadst4 , iadst4 } } ; int i , j ; <vul-start> int16_t out [ 4 * 4 ] ; <vul-end> <vul-start> int16_t * outptr = out ; <vul-end> <vul-start> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <vul-end> for ( i = 0 ; i < 4 ; ++ i ) { IHT_4 [ tx_type ] . rows ( input , outptr ) ; input += 4 ; outptr += 4 ; } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j * 4 + i ] ; IHT_4 [ tx_type ] . cols ( temp_in , temp_out ) ; <vul-start> for ( j = 0 ; j < 4 ; ++ j ) <vul-end> <vul-start> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) <vul-end> <vul-start> + dest [ j * stride + i ] ) ; <vul-end> } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> vp9_iht4x4_16_add_c ( const tran_low_t <vul-end> * input , <vul-start> = { { idct4_c , idct4_c } , { iadst4_c , idct4_c } , { idct4_c , iadst4_c } , { iadst4_c , iadst4_c <vul-end> } } ; <vul-start> , j ; tran_low_t <vul-end> out [ 4 <vul-start> 4 ] ; tran_low_t <vul-end> * outptr = <vul-start> = out ; tran_low_t <vul-end> temp_in [ 4 <vul-start> ++ j ) { <vul-start> i ] = clip_pixel_add ( <vul-end> dest [ j <vul-start> + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) ) ; } <vul-end> } }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vp9_iht4x4_16_add_c ( const tran_low_t <vul-end> * input, <vul-start> = { { idct5, idct5 }, { iadst5, iadst5 }, { iadst5, iadst5 } } ; tran_low_t <vul-end> out [ 4 <vul-start> 4 ] ; tran_low_t <vul-end> * outptr = <vul-start> = out ; tran_low_t <vul-end> temp_in [ 4 <vul-start> ++ j ) { <vul-start> i ] = clip_pixel_add ( <vul-end> dest [ j <vul-start> + i ], ROUND_POWER_OF_TWO ( temp_out [ j ], 4 ) ) ; } <vul-end> } }  \n"
 },
 {
  "id": 1477,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 stmt_ty <vul-start> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <vul-end> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! value ) { PyErr_SetString ( PyExc_ValueError , \"field value is required for Assign\" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Assign_kind ; p -> v . Assign . targets = targets ; p -> v . Assign . value = value ; <vul-start> p -> lineno = lineno ; <vul-end> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> expr_ty value , string type_comment , <vul-start> ; p -> v . Assign . type_comment = type_comment ; p ->\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> expr_ty value, string type_comment, <vul-start> ; p -> v. Assign. type_comment = type_comment ; p ->\n"
 },
 {
  "id": 1478,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <vul-start> if ( context -> curY >= p -> height ) { <vul-end> context -> pass ++ ; context -> curY",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 4 ; <vul-end> break ; case <vul-start> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 8 ; <vul-end> break ; case <vul-start> += 4 ; <vul-end> break ; case <vul-start> ; break ; } while ( ++ context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 4 ; break ; }\n"
 },
 {
  "id": 1479,
  "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 char * compose_path ( ctrl_t * ctrl , char * path ) { struct stat st ; static char rpath [ PATH_MAX ] ; char * name , * ptr ; char dir [ PATH_MAX ] = { 0 } ; strlcpy ( dir , ctrl -> cwd , sizeof ( dir ) ) ; DBG ( \"Compose path from cwd: %s, arg: %s\" , ctrl -> cwd , path ? : \"\" ) ; if ( ! path || ! strlen ( path ) ) goto check ; if ( path ) { if ( path [ 0 ] != '/' ) { if ( dir [ strlen ( dir ) - 1 ] != '/' ) strlcat ( dir , \"/\" , sizeof ( dir ) ) ; } strlcat ( dir , path , sizeof ( dir ) ) ; } check : while ( ( ptr = strstr ( dir , \"//\" ) ) ) memmove ( ptr , & ptr [ 1 ] , strlen ( & ptr [ 1 ] ) + 1 ) ; if ( ! chrooted ) { size_t len = strlen ( home ) ; DBG ( \"Server path from CWD: %s\" , dir ) ; if ( len > 0 && home [ len - 1 ] == '/' ) len -- ; memmove ( dir + len , dir , strlen ( dir ) + 1 ) ; memcpy ( dir , home , len ) ; DBG ( \"Resulting non-chroot path: %s\" , dir ) ; } if ( ! stat (",
  "golden_answers": [
   "CWE-22 Fixed Code Lines are: <vul-start> && strncmp ( rpath <vul-end> , home ,\n"
  ],
  "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start>! chrooted && home &&\n"
 },
 {
  "id": 1480,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <vul-start> pinctrl_unregister ( gpio_dev -> pctrl ) ; <vul-end> return 0 ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> gc ) ; <vul-end> return 0 ;\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> gc ) ; <vul-end> return 0 ;\n"
 },
 {
  "id": 1481,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , <vul-start> u64 nr , int nmi , <vul-end> struct perf_sample_data * data , struct pt_regs * regs ) { struct swevent_htable * swhash = & __get_cpu_var ( swevent_htable ) ; struct perf_event * event ; struct hlist_node * node ; struct hlist_head * head ; rcu_read_lock ( ) ; head = find_swevent_head_rcu ( swhash , type , event_id ) ; if ( ! head ) goto end ; hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_swevent_match ( event , type , event_id , data , regs ) ) <vul-start> perf_swevent_event ( event , nr , nmi , data , regs ) ; <vul-end> } end : rcu_read_unlock ( ) ; }",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> , u64 nr <vul-end> , struct perf_sample_data <vul-start> , nr , <vul-end> data , regs\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> u64 nr, <vul-end> struct perf_sample_data * <vul-start>, nr, <vul-end> data, regs\n"
 },
 {
  "id": 1482,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; <vul-start> if ( likely ( walk . nbytes == nbytes ) ) <vul-end> { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , nbytes ) ; return blkcipher_walk_done ( desc , & walk , 0 ) ; } while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . src . virt . addr , walk . dst . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> iv ) ; <vul-end> while ( walk\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> iv ) ; <vul-end> while ( walk\n"
 },
 {
  "id": 1483,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static int iwgif_read_image ( struct iwgifrcontext * rctx ) { int retval = 0 ; struct lzwdeccontext d ; size_t subblocksize ; int has_local_ct ; int local_ct_size ; unsigned int root_codesize ; if ( ! iwgif_read ( rctx , rctx -> rbuf , 9 ) ) goto done ; rctx -> image_left = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 0 ] ) ; rctx -> image_top = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 2 ] ) ; rctx -> image_width = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 4 ] ) ; <vul-start> rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; <vul-end> rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ; has_local_ct = ( int ) ( ( rctx -> rbuf [ 8 ] >> 7 ) & 0x01 ) ; if ( has_local_ct ) { local_ct_size = ( int ) ( rctx -> rbuf [ 8 ] & 0x07 ) ; rctx -> colortable . num_entries = 1 << ( 1 + local_ct_size ) ; } if ( has_local_ct ) { if ( ! iwgif_read_color_table ( rctx , & rctx -> colortable ) ) goto done ; } if ( rctx -> has_transparency ) { rctx -> colortable . entry [ rctx -> trans_color_index ] . a = 0 ; } if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; root_codesize =",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> ] ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , \"Invalid image dimensions\" ) ; goto done ; }\n"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> -> rbuf [ 7 <vul-end> ] ) ;\n"
 },
 {
  "id": 1484,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void vqp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct vqp_common_header_t * vqp_common_header ; const struct vqp_obj_tlv_t * vqp_obj_tlv ; const u_char * tptr ; uint16_t vqp_obj_len ; uint32_t vqp_obj_type ; <vul-start> int tlen ; <vul-end> uint8_t nitems ; tptr = pptr ; tlen = len ; vqp_common_header = ( const struct vqp_common_header_t * ) pptr ; <vul-start> ND_TCHECK ( * vqp_common_header ) ; <vul-end> if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) { ND_PRINT ( ( ndo , \"VQP version %u packet not supported\" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , \"VQPv%u %s Message, error-code %s (%u), length %u\" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , \"unknown (%u)\" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , \"unknown (%u)\" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , len ) ) ; return ; } nitems = vqp_common_header -> nitems ; ND_PRINT ( ( ndo , \"\\\\n\\\\tVQPv%u, %s Message, error-code %s (%u), seq 0x%08x, items %u, length %u\" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , \"unknown (%u)\" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , \"unknown (%u)\" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , EXTRACT_32BITS ( & vqp_common_header -> sequence ) , nitems , len ) ) ; tptr += sizeof ( const struct vqp_common_header_t ) ; tlen -= sizeof ( const struct vqp_common_header_t",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> uint32_t vqp_obj_type ; u_int <vul-end> tlen ; uint8_t <vul-start> * vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <vul-start> ) tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <vul-start> vqp_obj_len ) ; if ( vqp_obj_len > tlen ) goto trunc ; <vul-start> case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ; <vul-start> case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> uint32_t vqp_obj_type ; uint32_t <vul-end> nitems ; tptr <vul-start> vqp_common_header ) ; if ( len < sizeof ( struct vqp_obj_tlv_t ) ) { ND_PRINT ( ( ndo, \"(invalid length)\" ) ) ; break ; } <vul-start> case VQP_OBJ_MAC_ADDRESS : ND_TCHECK_32BITS ( vqp_obj_tlv -> obj_type ) ; <vul-start> vqp_obj_len ) ; if ( len < 4 ) { ND_PRINT ( ( ndo, \"(invalid length)\" ) ) ; break ; } <vul-start> case VQP_OBJ_MAC_ADDRESS : ND_TCHECK_16BITS ( vqp_obj_tlv -> obj_length ) ;\n"
 },
 {
  "id": 1485,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; FieldOrderContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int h , plane , line_step , line_size , line ; uint8_t * data ; if ( ! frame -> interlaced_frame || frame -> top_field_first == s -> dst_tff ) return ff_filter_frame ( outlink , frame ) ; av_dlog ( ctx , \"picture will move %s one line\\\\n\" , s -> dst_tff ? \"up\" : \"down\" ) ; h = frame -> height ; <vul-start> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <vul-end> line_step = frame -> linesize [ plane ] ; line_size = s -> line_size [ plane ] ; data = frame -> data [ plane ] ; if ( s -> dst_tff ) { for ( line = 0 ; line < h ; line ++ ) { if ( 1 + line < frame -> height ) { memcpy ( data , data + line_step , line_size ) ; } else { memcpy ( data , data - line_step - line_step , line_size ) ; } data += line_step ; } } else { data += ( h - 1 ) * line_step ; for ( line = h - 1 ; line >= 0 ; line -- ) { if ( line > 0 ) { memcpy ( data , data - line_step , line_size )",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> [ plane ] && frame -> linesize [ plane ]\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> [ plane ] && frame -> linesize [ plane ]\n"
 },
 {
  "id": 1486,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( \"Aiee, killing interrupt handler!\" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( \"Attempted to kill the idle task!\" ) ; tracehook_report_exit ( & code ) ; validate_creds_for_do_exit ( tsk ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT \"Fixing recursive fault but reboot is needed!\\\\n\" ) ; tsk -> flags |= PF_EXITPIDONE ; set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule ( ) ; } exit_irq_thread ( ) ; exit_signals ( tsk ) ; smp_mb ( ) ; spin_unlock_wait ( & tsk -> pi_lock ) ; if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO \"note: %s[%d] exited with preempt_count %d\\\\n\" , current -> comm , task_pid_nr ( current ) , preempt_count ( ) ) ; acct_update_integrals ( tsk ) ; group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ; if ( group_dead ) { hrtimer_cancel ( & tsk -> signal -> real_timer ) ; exit_itimers ( tsk -> signal ) ; if ( tsk -> mm ) setmax_mm_hiwater_rss ( & tsk -> signal -> maxrss , tsk -> mm ) ; } acct_collect ( code , group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ;",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ) exit_io_context ( tsk\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> -> io_context ) { struct file * file = tsk -> io_context ; if ( unlikely ( file ) ) file_put ( file ) ; exit_io_context ( ) ; } <vul-end> if ( tsk\n"
 },
 {
  "id": 1487,
  "question": "CWE-269 Code Input Vulnerable Code Is: CWE-269 static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { <vul-start> rcu_read_lock ( ) ; <vul-end> <vul-start> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <vul-end> rcu_read_unlock ( ) ; }",
  "golden_answers": [
   "CWE-269 Fixed Code Lines are: <vul-start> new_parent ) { <vul-end> __ptrace_link ( child <vul-start> , new_parent , current_cred ( ) <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-269 Fixed Code Lines are: <vul-start> new_parent ) { struct mm_struct * old_mm = child -> mm ; <vul-start> new_parent ) ) ; if ( old_mm &&! try_get_task_struct ( old_mm ) ) { __ptrace_link ( child, new_parent, old_mm ) ; } else { __ptrace_link ( child, new_parent, current_cred ( new_parent ) ) ; } } <vul-end> rcu_read_unlock ( )\n"
 },
 {
  "id": 1488,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static void dns_resolver_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <vul-start> if ( key_is_instantiated ( key ) ) { <vul-end> int err = PTR_ERR ( key -> payload . data [ dns_key_error ] ) ; if ( err ) seq_printf ( m , \": %d\" , err ) ; else seq_printf ( m , \": %u\" , key -> datalen ) ; } }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_positive <vul-end> ( key )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( key_is_positive <vul-end> ( key )\n"
 },
 {
  "id": 1489,
  "question": "CWE-763 Code Input Vulnerable Code Is: CWE-763 <vul-start> static void pcrypt_free ( struct crypto_instance * inst ) <vul-end> { <vul-start> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <vul-end> crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }",
  "golden_answers": [
   "CWE-763 Fixed Code Lines are: <vul-start> pcrypt_free ( struct aead_instance <vul-end> * inst ) <vul-start> * ctx = aead_instance_ctx <vul-end> ( inst )\n"
  ],
  "generated_answer": "CWE-763 Fixed Code Lines are: <vul-start> void pcrypt_free ( struct pcrypt_instance * instance <vul-end> ) { struct <vul-start> ) { struct crypto_skcipher * skcipher = instance -> crypto_skcipher ; struct <vul-start> pcrypt_instance_ctx * ctx ; ctx = container_of ( instance, struct pcrypt_instance_ctx, spawn ) ; crypto_drop_aead ( & ctx -> spawn ) ; kfree ( instance <vul-end> ) ; }\n"
 },
 {
  "id": 1490,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int atusb_read_reg ( struct atusb * atusb , uint8_t reg ) { struct usb_device * usb_dev = atusb -> usb_dev ; int ret ; <vul-start> uint8_t value ; <vul-end> dev_dbg ( & usb_dev -> dev , \"atusb: reg = 0x%x\\\\n\" , reg ) ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , <vul-start> 0 , reg , & value , 1 , 1000 ) ; <vul-end> <vul-start> return ret >= 0 ? value : ret ; <vul-end> <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <vul-end> ; dev_dbg ( <vul-start> , reg , buffer <vul-end> , 1 , <vul-start> 1000 ) ; if ( <vul-end> ret >= 0 <vul-start> ret >= 0 ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return <vul-end> ret ; } <vul-start> ret ; } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ; uint8_t value ; unsigned long data <vul-start>, reg, ( void * ) <vul-start> 1000 ) ; if ( ret < 1 ) { dev_err ( & usb_dev -> dev, \"atusb: read from device failed: %d\\\\n\", ret ) ; return ret ; } data = ( uint8_t * ) & value ; <vul-start> >= 0? data <vul-end> : ret ; <vul-start> : ret ; dev_dbg ( & usb_dev -> dev, \"atusb: reg = 0x%x\\\\n\", reg ) ; return ret >= 0? value : 0 ;\n"
 },
 {
  "id": 1491,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int cib_remote_signon ( cib_t * cib , const char * name , enum cib_conn_type type ) { int rc = pcmk_ok ; cib_remote_opaque_t * private = cib -> variant_opaque ; if ( private -> passwd == NULL ) { struct termios settings ; int rc ; rc = tcgetattr ( 0 , & settings ) ; settings . c_lflag &= ~ ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; fprintf ( stderr , \"Password: \" ) ; private -> passwd = calloc ( 1 , 1024 ) ; rc = scanf ( \"%s\" , private -> passwd ) ; fprintf ( stdout , \"\\\\n\" ) ; if ( rc < 1 ) { private -> passwd = NULL ; } settings . c_lflag |= ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; } if ( private -> server == NULL || private -> user == NULL ) { rc = - EINVAL ; } if ( rc == pcmk_ok ) { <vul-start> rc = cib_tls_signon ( cib , & ( private -> command ) ) ; <vul-end> } if ( rc == pcmk_ok ) { <vul-start> rc = cib_tls_signon ( cib , & ( private -> callback ) ) ; <vul-end> } if ( rc == pcmk_ok ) { xmlNode * hello = cib_create_op ( 0 , private -> callback . token , CRM_OP_REGISTER , NULL , NULL , NULL , 0 , NULL ) ; crm_xml_add ( hello , F_CIB_CLIENTNAME , name ) ; crm_send_remote_msg ( private -> command . session ,",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> -> command ) , FALSE <vul-start> -> callback ) , TRUE\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> pcmk_ok ) { private -> command. token = crm_generate_token ( name, private -> passwd ) ; if (! private -> command. token ) { <vul-start> ) ) ; } else { rc = - EINVAL ; } <vul-start> pcmk_ok ) { private -> callback. token = crm_generate_token ( name, private -> passwd ) ; if (! private -> callback. token ) { <vul-start> ) ) ; } else { rc = - EINVAL ; }\n"
 },
 {
  "id": 1492,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_iovlen = 1 ; msg . msg_iov = & iov ; iov . iov_len = size ; iov . iov_base = ubuf ; <vul-start> msg . msg_name = ( struct sockaddr * ) & address ; <vul-end> <vul-start> msg . msg_namelen = sizeof ( address ) ; <vul-end> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> . msg_name = addr ? <vul-start> ) & address : NULL <vul-start> . msg_namelen = 0 <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = ubuf ; memset ( & address, 0, sizeof ( address ) ) ; <vul-start> sizeof ( address ) ; memset ( & address, 0, sizeof ( address )\n"
 },
 {
  "id": 1493,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> int main_loop ( int argc , const char * * argv_ ) { <vul-end> vpx_codec_ctx_t decoder ; char * fn = NULL ; int i ; uint8_t * buf = NULL ; size_t bytes_in_buffer = 0 , buffer_size = 0 ; FILE * infile ; int frame_in = 0 , frame_out = 0 , flipuv = 0 , noblit = 0 ; <vul-start> int do_md5 = 0 , progress = 0 ; <vul-end> int stop_after = 0 , postproc = 0 , summary = 0 , quiet = 1 ; int arg_skip = 0 ; <vul-start> int ec_enabled = 0 ; <vul-end> const VpxInterface * interface = NULL ; const VpxInterface * fourcc_interface = NULL ; uint64_t dx_time = 0 ; struct arg arg ; char * * argv , * * argi , * * argj ; int single_file ; int use_y4m = 1 ; <vul-start> vpx_codec_dec_cfg_t cfg = { 0 } ; <vul-end> # if CONFIG_VP8_DECODER vp8_postproc_cfg_t vp8_pp_cfg = { 0 } ; int vp8_dbg_color_ref_frame = 0 ; int vp8_dbg_color_mb_modes = 0 ; int vp8_dbg_color_b_modes = 0 ; int vp8_dbg_display_mv = 0 ; # endif int frames_corrupted = 0 ; int dec_flags = 0 ; int do_scale = 0 ; vpx_image_t * scaled_img = NULL ; <vul-start> int frame_avail , got_data ; <vul-end> int num_external_frame_buffers = 0 ; <vul-start> struct ExternalFrameBufferList ext_fb_list = { 0 } ; <vul-end> const char * outfile_pattern = NULL ; char outfile_name [ PATH_MAX ] = { 0 } ; FILE * outfile = NULL ; MD5Context md5_ctx ; unsigned char md5_digest [ 16 ] ; <vul-start>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>       static <vul-start> progress = 0 , frame_parallel = 0 <vul-start> ; int ec_enabled = 0 ; int keep_going <vul-start> = 1 ; int opt_yv12 = 0 ; int opt_i420 = 0 ; <vul-start> = { 0 , 0 , 0 } ; # if CONFIG_VP9_HIGHBITDEPTH int output_bit_depth = 0 ; # endif <vul-end> # if CONFIG_VP8_DECODER <vul-start> = NULL ; # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * img_shifted = NULL ; # endif <vul-start> frame_avail , got_data , flush_decoder = 0 <vul-start> = { 0 , NULL <vul-start> input = { NULL , NULL <vul-end> } ; struct <vul-start> struct VpxInputContext vpx_input_ctx ; # if CONFIG_WEBM_IO <vul-end> struct WebmInputContext webm_ctx <vul-start> struct WebmInputContext webm_ctx ; memset ( & ( webm_ctx ) , 0 , sizeof ( webm_ctx ) ) <vul-end> ; input . <vul-start> ; input . webm_ctx = & webm_ctx ; # endif input . <vul-start> = & vpx_input_ctx <vul-end> ; exec_name = <vul-start> = 1 ; opt_yv12 = 1 ; # if CONFIG_VP9_HIGHBITDEPTH output_bit_depth = 8 ; # endif <vul-start> = 0 ; opt_i420 = 1 ; <vul-start> arg , & rawvideo , argi ) ) { use_y4m = 0 ; } else if ( arg_match ( & arg , & <vul-start> arg ) ; # if CONFIG_VP9_DECODER || CONFIG_VP10_DECODER <vul-start> arg , & frameparallelarg , argi ) ) frame_parallel = 1 ; # endif else if ( arg_match ( & arg , & <vul-start> arg ) ; else if ( arg_match ( & arg , & continuearg , argi ) ) keep_going = 1 ; # if CONFIG_VP9_HIGHBITDEPTH else if ( arg_match ( & arg , & outbitdeptharg , argi ) ) { output_bit_depth = arg_parse_uint ( & arg ) ; } # endif <vul-start> ! fn ) { free ( argv ) ; <vul-start> ( ) ; } <vul-start> infile ) { fatal ( \"Failed to open input file \\'%s\\'\" <vul-end> , strcmp ( <vul-start> : \"stdin\" ) <vul-end> ; } # <vul-start> stderr , \"YUV4MPEG2 not supported with output patterns,\" \" try --i420 or --yv12 or --rawvideo.\\\\n\" <vul-end> ) ; return <vul-start> : 0 ) | ( frame_parallel ? VPX_CODEC_USE_FRAME_THREADING : 0 ) <vul-start> , interface -> codec_interface ( ) , <vul-end> & cfg , <vul-start> ; int corrupted = 0 <vul-start> detail ) ; if ( ! keep_going ) <vul-start> ) ; } else { flush_decoder = 1 ; } } else { flush_decoder = 1 ; <vul-start> timer ) ; if ( flush_decoder ) { if ( vpx_codec_decode ( & decoder , NULL , 0 , NULL , 0 ) ) { warn ( \"Failed to flush decoder: %s\" , vpx_codec_error ( & decoder ) ) ; } } <vul-start> ; if ( ! frame_parallel && <vul-start> ) ) ; if ( ! keep_going ) <vul-start> ( NULL , img -> fmt <vul-end> , display_width , <vul-start> , 16 ) ; scaled_img -> bit_depth = img -> bit_depth <vul-start> d_h ) { # if CONFIG_LIBYUV libyuv_scale <vul-end> ( img , <vul-start> = scaled_img ; # else fprintf ( stderr , \"Failed  to scale output frame: %s.\\\\n\" \"Scaling is disabled in this configuration. \" \"To enable scaling, configure with --enable-libyuv\\\\n\" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( ! output_bit_depth ) { output_bit_depth = img -> bit_depth ; } if ( output_bit_depth != img -> bit_depth ) { const vpx_img_fmt_t shifted_fmt = output_bit_depth == 8 ? img -> fmt ^ ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) : img -> fmt | VPX_IMG_FMT_HIGHBITDEPTH ; if ( img_shifted && img_shifted_realloc_required ( img , img_shifted , shifted_fmt ) ) { vpx_img_free ( img_shifted ) ; img_shifted = NULL ; } if ( ! img_shifted ) { img_shifted = vpx_img_alloc ( NULL , shifted_fmt , img -> d_w , img -> d_h , 16 ) ; img_shifted -> bit_depth = output_bit_depth ; } if ( output_bit_depth > img -> bit_depth ) { vpx_img_upshift ( img_shifted , img , output_bit_depth - img -> bit_depth ) ; } else { vpx_img_downshift ( img_shifted , img , img -> bit_depth - output_bit_depth ) ; } img = img_shifted ; } # endif <vul-end> if ( single_file <vul-start> ; if ( img -> fmt == VPX_IMG_FMT_I440 || img -> fmt == VPX_IMG_FMT_I44016 ) { fprintf ( stderr , \"Cannot produce y4m output for 440 sampling.\\\\n\" ) ; goto fail ; } if ( <vul-start> img -> fmt , img -> bit_depth <vul-start> ; } } else { if ( frame_out == 1 ) { if ( opt_i420 ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , \"Cannot produce i420 output for bit-stream.\\\\n\" ) ; goto fail ; } } if ( opt_yv12 ) { if ( ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) || img -> bit_depth != 8 ) { fprintf ( stderr , \"Cannot produce yv12 output for bit-stream.\\\\n\" ) ; goto fail ; } } } } <vul-start> } } } <vul-end> } if ( <vul-start> scaled_img ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img_shifted ) vpx_img_free ( img_shifted ) ; # endif\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> argv_ ) { int exit_code = 0 ; <vul-start> 0 ; int <vul-end> stop_after = 0 <vul-start> 0 ; int <vul-end> arg_skip = 0 <vul-start> = 1 ; <vul-end> # if CONFIG_VP8_DECODER <vul-start> ; int frame_avail = 0 ; int got_data <vul-end> ; int num_external_frame_buffers <vul-start> = 0 ; <vul-end> const char * <vul-start> 16 ] ; <vul-end> if ( arg_match <vul-start> arg ) ; # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth = 0 ; int use_lowbitdepth = 0 ; # endif <vul-start> arg, & use_i4marg <vul-end>, argi ) <vul-start> 16 ] ; int do_md5 = 1 ; int flipuv = 0 ; int noblit = 0 ; int progress = 0 ; int stop_after = 0 ; int postproc = 0 ; int summary = 0 ; int arg_skip = 0 ; int quiet = 0 ; int arg_skip = 0 ; int arg_loop_arg = 0 ; <vul-start> arg, & <vul-end> scalearg, argi <vul-start> argi ) ) do_scale = 1 ; else if ( arg_match ( & arg, & fb_arg, argi ) ) do_scale = 1 ; else if ( arg_match ( & arg, & use_i4marg, argi ) ) do_scale = 1 ; else if ( arg_match ( & arg, & use_i4marg, argi ) ) do_scale = 1 ; else if ( arg_match ( & arg, & use_i4marg, argi ) ) do_scale = 0 ; else if ( arg_match ( & arg, & fb_arg, argi ) ) num_external_frame_buffers = arg_parse_uint ( & arg ) ; # if CONFIG_VP10_DECODER <vul-start> arg ) ; # else vp8_pp_cfg. post_proc_flag |= VP8_POSTPROC_V12 ; vp8_pp_cfg. noise_level = arg_parse_uint ( & arg ) ; # endif <vul-start> 16 ] ; int do_md5 = 1 ; int <vul-start> arg ) ; # if CONFIG_VP10_DECODER else if ( arg_match ("
 },
 {
  "id": 1494,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) { MACROBLOCKD * const xd = & x -> e_mbd ; MV tmp_mv = { 0 , 0 } ; MV ref_mv_full = { ref_mv -> row >> 3 , ref_mv -> col >> 3 } ; <vul-start> int num00 , tmp_err , n , sr = 0 ; <vul-end> int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ; <vul-start> int new_mv_mode_penalty = 256 ; <vul-end> <vul-start> const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ; <vul-end> while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ; step_param += sr ; further_steps -= sr ; v_fn_ptr . vf = get_block_variance_fn ( bsize ) ; <vul-start> tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , <vul-end> step_param , <vul-start> x -> sadperbit16 , & num00 , & v_fn_ptr , <vul-end> x -> nmvjointcost , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; <vul-start> best_mv",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> tmp_err , n <vul-end> ; const BLOCK_SIZE <vul-start> bsize ] ; const <vul-start> int new_mv_mode_penalty = NEW_MV_MODE_PENALTY ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param <vul-end> ; const int <vul-start> ; const int sr = get_search_range ( cpi ) <vul-end> ; step_param += <vul-start> bsize ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ; } # endif <vul-start> x , & cpi -> ss_cfg , & <vul-start> , & v_fn_ptr <vul-end> , ref_mv ) <vul-start> = tmp_err ; * best_mv = tmp_mv <vul-end> ; } n <vul-start> diamond_search_sad ( x , & cpi -> ss_cfg <vul-start> & v_fn_ptr , <vul-end> ref_mv ) ; <vul-start> = tmp_err ; * best_mv = tmp_mv <vul-end> ; } }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> } ; int <vul-end> tmp_err, n <vul-start> ] ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; vp9_variance_fn_ptr_t v_fn_ptr = xd -> fn_ptr [ bsize ] ; int <vul-start> int quart_frm = MIN2 ( cpi -> oxcf. width, cpi -> oxcf. height ) ; while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ; step_param += further_steps ; v_fn_ptr. vf = get_block_variance_fn ( bsize ) ; tmp_err = cpi -> diamond_search_sad ( x, & ref_mv_full, & tmp_mv, step_param, x -> sadperbit16, & num00, & v_fn_ptr, x -> nmvjointcost, x -> mvcost, ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x, & tmp_mv, ref_mv, & v_fn_ptr, 1 ) ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv. row ; best_mv -> col = tmp_mv. col ; } n = num00 ; num00 = 0 ; while ( num00 < further_steps ) { ++ n ; if ( tmp_err < INT_MAX - step_param ) tmp_err += step_param ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv. row ; best_mv -> col = tmp_mv. col ; } } tmp_err = num00 ; num00 = 0 ; while ( num00 < further_steps ) { -- num00 ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_"
 },
 {
  "id": 1495,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) { <vul-end> uint32_t ret_cnt = 0 ; uint8_t command = 0 ; uint8_t channel = 0 ; uint8_t data_1 = 0 ; uint8_t data_2 = 0 ; char * text = NULL ; <vul-start> if ( event_data [ 0 ] >= 0x80 ) { <vul-end> command = * event_data & 0xf0 ; channel = * event_data ++ & 0x0f ; <vul-start> ret_cnt ++ ; <vul-end> } else { command = running_event & 0xf0 ; channel = running_event & 0x0f ; } switch ( command ) { case 0x80 : _SETUP_NOTEOFF : <vul-start> data_1 = * event_data ++ ; <vul-end> data_2 = * event_data ++ ; _WM_midi_setup_noteoff ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0x90 : if ( event_data [ 1 ] == 0 ) goto _SETUP_NOTEOFF ; <vul-start> data_1 = * event_data ++ ; <vul-end> data_2 = * event_data ++ ; midi_setup_noteon ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xa0 : <vul-start> data_1 = * event_data ++ ; <vul-end> data_2 = * event_data ++ ; midi_setup_aftertouch ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xb0 : <vul-start> data_1 = * event_data ++ ; <vul-end> data_2 = * event_data ++ ; midi_setup_control ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xc0 : data_1 = * event_data ++ ; midi_setup_patch ( mdi ,",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> * event_data , uint32_t siz , <vul-start> ; if ( ! siz ) goto shortbuf ; if ( <vul-start> ; ret_cnt ++ ; if ( -- siz == 0 ) goto shortbuf <vul-start> : _SETUP_NOTEOFF : if ( siz < 2 ) goto shortbuf ; <vul-start> goto _SETUP_NOTEOFF ; if ( siz < 2 ) goto shortbuf ; <vul-start> case 0xa0 : if ( siz < 2 ) goto shortbuf ; <vul-start> case 0xb0 : if ( siz < 2 ) goto shortbuf ; <vul-start> case 0xe0 : if ( siz < 2 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 4 ) goto shortbuf ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ; ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <vul-start> ) ) { if ( siz < 3 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 3 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 2 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 5 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 7 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 6 ) goto shortbuf ; <vul-start> ) ) { if ( siz < 4 ) goto shortbuf ; <vul-start> ; if ( -- siz && <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> += tmp_length ; if ( -- siz < tmp_length ) goto shortbuf ; <vul-start> { do { if ( ! siz ) break ; <vul-start> event_data ++ ; siz -- ; <vul-start> ) ; } if ( ! siz ) goto shortbuf ; <vul-start> event_data ++ ; ret_cnt ++ ; if ( -- siz < sysex_len ) goto shortbuf ; <vul-start> sysex_len ) break <vul-end> ; sysex_store = <vul-start> return ret_cnt ; shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , \"(input too short)\" , 0 ) ; return 0 ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>, uint8_t running_event, bool use_16bit_internal_idid <vul-start> = NULL ; uint32_t data_length = 0 ; <vul-start> & 0x0f ; event_data ++ ; ret_cnt ++ ; <vul-start> : _SETUP_NOTEOFF : if (! use_16bit_internal_idid ) { <vul-start> goto _SETUP_NOTEOFF ; } <vul-start> case 0xa0 : if (! use_16bit_internal_idid ) { <vul-start> event_data ++ ; ret_cnt ++ ; } <vul-start> case 0xb0 : if (! use_16bit_internal_idid ) { <vul-start> ret_cnt ++ ; } <vul-start> 0x7f ) { if (! use_16bit_internal_idid ) { <vul-start> 0x7f ) ; } <vul-start> > 0x7f ) { <vul-start> 0x7f ) ; } <vul-start> text = malloc ( tmp_length + 1 ) ; memcpy ( text, event_data, tmp_length ) ; text [ tmp_length ] = '\\\\0' ; midi_setup_trackname ( mdi, text ) ; ret_cnt += tmp_length ; } else { event_data ++ ; ret_cnt ++ ; } <vul-end> if ( mdi <vul-start> ret_cnt ++ ; if (! use_16bit_internal_idid ) { <vul-start> 0x7f ) ; } <vul-start> text = malloc ( <vul-end> tmp_length + 1 <vul-start> ; ret_cnt += tmp_length ; } else { event_data ++ ; ret_cnt ++ ; if (! use_16bit_internal_idid ) { <vul-start> 0x7f ) ; } <vul-end> if ( mdi <vul-start> { do { if (! use_16bit_internal_idid ) { <vul-start> event_data ++ ; ret_cnt ++ ; } <vul-end> while ( * <vul-start> > 0x7f ) ; text [ tmp_length ] = '\\\\0' ; midi_setup_trackname ( mdi, text ) ; ret_cnt += tmp_length ; } <vul-end> event_data ++ ; <vul-start> ret_cnt ++ ; if (! use_16bit_internal_idid ) { <vul-start> event_data ++ ; ret_cnt ++ ; if"
 },
 {
  "id": 1496,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int flakey_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct flakey_c * fc = ti -> private ; <vul-start> return __blkdev_driver_ioctl ( fc -> dev -> bdev , fc -> dev -> mode , cmd , arg ) ; <vul-end> }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if <vul-end> ( fc -> <vul-start> ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <vul-start> -> bdev , <vul-end> dev -> mode\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if <vul-end> ( fc -> <vul-start> ( fc -> start || ti -> len!= i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL, cmd ) ; return r? : __blkdev_driver_ioctl ( <vul-start> -> bdev, <vul-end> dev -> mode\n"
 },
 {
  "id": 1497,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int main ( int argc , char * * argv ) { char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; const char * spacestr = \" \" ; <vul-start> char buf [ L_BUF_SIZE ] ; <vul-end> l_uint8 * allheaders ; l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; size_t nbytes ; L_BYTEA * ba , * ba2 ; SARRAY * sa , * safirst ; static char mainName [ ] = \"xtractprotos\" ; if ( argc == 1 ) { fprintf ( stderr , \"xtractprotos [-prestring=<string>] [-protos=<where>] \" \"[list of C files]\\\\n\" \"where the prestring is prepended to each prototype, and \\\\n\" \"protos can be either \\'inline\\' or the name of an output \" \"prototype file\\\\n\" ) ; return 1 ; } prestring = outprotos = NULL ; in_line = FALSE ; nflags = 0 ; maxindex = L_MIN ( 3 , argc ) ; for ( i = 1 ; i < maxindex ; i ++ ) { if ( argv [ i ] [ 0 ] == '-' ) { if ( ! strncmp ( argv [ i ] , \"-prestring\" , 10 ) ) { nflags ++ ; <vul-start> ret = sscanf ( argv [ i ] + 1 , \"prestring=%s\" , buf ) ; <vul-end> if ( ret != 1 ) { fprintf ( stderr , \"parse failure for prestring\\\\n\" ) ; return 1 ; } <vul-start> if ( ( len = strlen ( buf ) ) > L_BUF_SIZE - 3",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; l_uint8 <vul-start> + 1 , \"prestring=%490s\" <vul-end> , buf ) <vul-start> ) ) > L_BUFSIZE <vul-end> - 3 ) <vul-start> + 1 , \"protos=%490s\" <vul-end> , buf ) <vul-start> ( buf , L_BUFSIZE <vul-end> , \" *  These prototypes were autogen\\'d by xtractprotos, v. %s\" , <vul-start> ( buf , L_BUFSIZE <vul-end> , \"cpp -ansi -DNO_PROTOS %s %s\" ,\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> buf [ L_BUF_SIZE + 3 <vul-start> nflags ++ ; buf [ len ] = '\\\\0' ; prestring = stringNew ( buf ) ; len = <vul-end> ( len = <vul-start> ) ) > L_BUF_SIZE - 3 <vul-end> ) { L_WARNING <vul-start> ; ret = l_scanf <vul-end> ( argv [ <vul-start> + 1, \"protos=%511s\", buf, len + 1 <vul-end> ) ; if <vul-start> ( buf, L_BUF_SIZE <vul-end>, \" * These prototypes were autogen\\'d by xtractprotos v. %s\", <vul-start> ; snprintf ( buf, L_BUF_SIZE <vul-end>, \" * These prototypes were autogen\\'d by xtractprotos v. %s\",\n"
 },
 {
  "id": 1498,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 l_int32 gplotAddPlot ( GPLOT * gplot , NUMA * nax , NUMA * nay , l_int32 plotstyle , const char * plottitle ) { <vul-start> char buf [ L_BUF_SIZE ] ; <vul-end> char emptystring [ ] = \"\" ; char * datastr , * title ; l_int32 n , i ; l_float32 valx , valy , startx , delx ; SARRAY * sa ; PROCNAME ( \"gplotAddPlot\" ) ; if ( ! gplot ) return ERROR_INT ( \"gplot not defined\" , procName , 1 ) ; if ( ! nay ) return ERROR_INT ( \"nay not defined\" , procName , 1 ) ; if ( plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES ) return ERROR_INT ( \"invalid plotstyle\" , procName , 1 ) ; if ( ( n = numaGetCount ( nay ) ) == 0 ) return ERROR_INT ( \"no points to plot\" , procName , 1 ) ; if ( nax && ( n != numaGetCount ( nax ) ) ) return ERROR_INT ( \"nax and nay sizes differ\" , procName , 1 ) ; if ( n == 1 && plotstyle == GPLOT_LINES ) { L_INFO ( \"only 1 pt; changing style to points\\\\n\" , procName ) ; plotstyle = GPLOT_POINTS ; } numaGetParameters ( nay , & startx , & delx ) ; numaAddNumber ( gplot -> plotstyles , plotstyle ) ; if ( plottitle ) { title = stringNew ( plottitle ) ; sarrayAddString ( gplot -> plottitles , title , L_INSERT ) ; } else { sarrayAddString ( gplot -> plottitles , emptystring , L_COPY ) ; } gplot",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; char <vul-start> ( buf , L_BUFSIZE <vul-end> , \"%s.data.%d\" , <vul-start> ( buf , L_BUFSIZE <vul-end> , \"%f %f\\\\n\" ,\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> char buf [ L_BUFSIZE <vul-end> ] ; char <vul-start> ( buf, L_BUFSIZE <vul-end>, \"%s.data.%d\", <vul-start> ( buf, L_BUFSIZE <vul-end>, \"%f %f\\\\n\",\n"
 },
 {
  "id": 1499,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int propagate_one ( struct mount * m ) { struct mount * child ; int type ; if ( IS_MNT_NEW ( m ) ) return 0 ; if ( ! is_subdir ( mp -> m_dentry , m -> mnt . mnt_root ) ) return 0 ; if ( peers ( m , last_dest ) ) { type = CL_MAKE_SHARED ; } else { <vul-start> struct mount * n , * p ; <vul-end> for ( n = m ; ; n = p ) { p = n -> mnt_master ; <vul-start> if ( p == dest_master || IS_MNT_MARKED ( p ) ) { <vul-end> while ( last_dest -> mnt_master != p ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } if ( ! peers ( n , last_dest ) ) { last_source = last_source -> mnt_master ; last_dest = last_source -> mnt_parent ; } break ; } } type = CL_SLAVE ; if ( IS_MNT_SHARED ( m ) ) type |= CL_MAKE_SHARED ; } if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED ; child = copy_tree ( last_source , last_source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) return PTR_ERR ( child ) ; child -> mnt . mnt_flags &= ~ MNT_LOCKED ; mnt_set_mountpoint ( m , mp , child ) ; last_dest = m ; last_source = child ; if ( m -> mnt_master != dest_master ) { read_seqlock_excl ( & mount_lock ) ; SET_MNT_MARK ( m -> mnt_master ) ; read_sequnlock_excl ( &",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> , * p ; bool done <vul-start> p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <vul-end> type = CL_SLAVE\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, * p ; if ( last_source == m -> mnt_master ) return 0 <vul-start> p ) ) continue ; <vul-end> } type =\n"
 },
 {
  "id": 1500,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 int dse_bind ( Slapi_PBlock * pb ) { ber_tag_t method ; struct berval * cred ; Slapi_Value * * bvals ; struct dse * pdse ; Slapi_Attr * attr ; Slapi_DN * sdn = NULL ; Slapi_Entry * ec = NULL ; if ( slapi_pblock_get ( pb , SLAPI_PLUGIN_PRIVATE , & pdse ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_TARGET_SDN , & sdn ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & method ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_CREDENTIALS , & cred ) < 0 ) { slapi_send_ldap_result ( pb , LDAP_OPERATIONS_ERROR , NULL , NULL , 0 , NULL ) ; return SLAPI_BIND_FAIL ; } if ( method == LDAP_AUTH_SIMPLE && cred -> bv_len == 0 ) { slapi_send_ldap_result ( pb , LDAP_SUCCESS , NULL , NULL , 0 , NULL ) ; return ( SLAPI_BIND_FAIL ) ; } ec = dse_get_entry_copy ( pdse , sdn , DSE_USE_LOCK ) ; if ( ec == NULL ) { <vul-start> slapi_send_ldap_result ( pb , LDAP_NO_SUCH_OBJECT , NULL , NULL , 0 , NULL ) ; <vul-end> return ( SLAPI_BIND_FAIL ) ; } switch ( method ) { case LDAP_AUTH_SIMPLE : { Slapi_Value cv ; if ( slapi_entry_attr_find ( ec , \"userpassword\" , & attr ) != 0 ) { <vul-start> slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ; <vul-end> slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } bvals = attr_get_present_values ( attr ) ; slapi_value_init_berval ( & cv , cred ) ; if ( slapi_pw_find_sv ( bvals , & cv ) !=",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> NULL ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , \"Entry does not exist\" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <vul-end> , NULL , <vul-start> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , \"Entry does not have userpassword set\" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <vul-end> , NULL , <vul-start> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , \"Invalid credentials\" ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ( pb, LDAP_OPERATIONS_ERROR <vul-end>, NULL, <vul-start> ( pb, LDAP_INAPPROPRIATE_AUTH <vul-end>, NULL, <vul-start> ( pb, LDAP_INVALID_CREDENTIALS, NULL, <vul-end> NULL, 0 <vul-start> 0 ) { slapi_entry_free ( ec ) ; slapi_send_ldap_result ( pb, LDAP_INVALID_CREDENTIALS <vul-end>, NULL, <vul-start> ( pb, LDAP_INAPPROPRIATE_AUTH <vul-end>, NULL,\n"
 },
 {
  "id": 1501,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void receive_tcppacket ( connection_t * c , const char * buffer , int len ) { <vul-start> vpn_packet_t outpkt ; <vul-end> outpkt . len = len ; if ( c -> options & OPTION_TCPONLY ) outpkt . priority = 0 ; else outpkt . priority = - 1 ; memcpy ( outpkt . data , buffer , len ) ; receive_packet ( c -> node , & outpkt ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { vpn_packet_t outpkt ; if ( len > sizeof outpkt . data ) return\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { vpn_packet_t outpkt ; memset ( & outpkt, 0, sizeof ( outpkt ) )\n"
 },
 {
  "id": 1502,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( \"Usage: %s mj2filename output_location\\\\n\" , argv [ 0 ] ) ; printf ( \"Example: %s foreman.mj2 output/foreman\\\\n\" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , \"rb\" ) ; if ( ! file ) { fprintf ( stderr , \"failed to open %s for reading\\\\n\" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf (",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> file ) ; int num = snprintf <vul-end> ( outfilename , <vul-start> ( outfilename , sizeof ( outfilename ) , <vul-start> snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , \"maximum length of output prefix exceeded\\\\n\" ) ; return 1 ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, \"%s_%05d.j2k\", exec_name <vul-end>, snum )\n"
 },
 {
  "id": 1503,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int propagate_mnt ( struct mount * dest_mnt , struct mountpoint * dest_mp , struct mount * source_mnt , struct hlist_head * tree_list ) { struct mount * m , * n ; int ret = 0 ; user_ns = current -> nsproxy -> mnt_ns -> user_ns ; last_dest = dest_mnt ; <vul-start> last_source = source_mnt ; <vul-end> mp = dest_mp ; list = tree_list ; dest_master = dest_mnt -> mnt_master ; for ( n = next_peer ( dest_mnt ) ; n != dest_mnt ; n = next_peer ( n ) ) { ret = propagate_one ( n ) ; if ( ret ) goto out ; } for ( m = next_group ( dest_mnt , dest_mnt ) ; m ; m = next_group ( m , dest_mnt ) ) { n = m ; do { ret = propagate_one ( n ) ; if ( ret ) goto out ; n = next_peer ( n ) ; } while ( n != m ) ; } out : read_seqlock_excl ( & mount_lock ) ; hlist_for_each_entry ( n , tree_list , mnt_hash ) { m = n -> mnt_parent ; if ( m -> mnt_master != dest_mnt -> mnt_master ) CLEAR_MNT_MARK ( m -> mnt_master ) ; } read_sequnlock_excl ( & mount_lock ) ; return ret ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> = dest_mnt ; first_source = source_mnt ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> = dest_mnt ; <vul-end> mp = dest_mp\n"
 },
 {
  "id": 1504,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 __be32 nfsd4_set_nfs4_acl ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct nfs4_acl * acl ) { __be32 error ; int host_error ; struct dentry * dentry ; struct inode * inode ; struct posix_acl * pacl = NULL , * dpacl = NULL ; unsigned int flags = 0 ; error = fh_verify ( rqstp , fhp , 0 , NFSD_MAY_SATTR ) ; if ( error ) return error ; dentry = fhp -> fh_dentry ; inode = d_inode ( dentry ) ; <vul-start> if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) ) <vul-end> return nfserr_attrnotsupp ; if ( S_ISDIR ( inode -> i_mode ) ) flags = NFS4_ACL_DIR ; host_error = nfs4_acl_nfsv4_to_posix ( acl , & pacl , & dpacl , flags ) ; if ( host_error == - EINVAL ) return nfserr_attrnotsupp ; if ( host_error < 0 ) goto out_nfserr ; <vul-start> host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ; <vul-end> if ( host_error < 0 ) <vul-start> goto out_release ; <vul-end> if ( S_ISDIR ( inode -> i_mode ) ) { <vul-start> host_error = inode -> i_op -> set_acl ( inode , dpacl , <vul-end> ACL_TYPE_DEFAULT ) ; } <vul-start> out_release : <vul-end> posix_acl_release ( pacl ) ; posix_acl_release ( dpacl ) ; out_nfserr : if ( host_error == - EOPNOTSUPP ) return nfserr_attrnotsupp ; else return nfserrno ( host_error ) ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ; if ( <vul-end> S_ISDIR ( inode <vul-start> goto out_nfserr ; fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <vul-end> ) ; if <vul-start> 0 ) goto out_drop_lock <vul-end> ; if ( <vul-start> { host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <vul-end> ) ; } <vul-start> ) ; } out_drop_lock : fh_unlock ( fhp ) ; <vul-end> posix_acl_release ( pacl\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> if (! NFS4_ACL_ACCESS ( inode ) ||! NFS4_ACL_DYNAMIC ( inode ) ) return nfserr_attrnotsupp ; if ( S_ISDIR ( inode -> i_mode ) ) { host_error = set_posix_acl ( inode, pacl, ACL_TYPE_ACCESS <vul-end> ) ; if <vul-start> 0 ) goto out_nfserr <vul-end> ; if ( <vul-start> { host_error = set_posix_acl ( inode, dpacl, ACL_TYPE_DEFAULT <vul-end> ) ; } <vul-start> ) ; } <vul-end> posix_acl_release ( pacl\n"
 },
 {
  "id": 1505,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( \"HIVEX_DEBUG\" ) ; if ( debug && STREQ ( debug , \"1\" ) ) h -> msglvl = 2 ; DEBUG ( 2 , \"created handle %p\" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; h -> size = statbuf . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , \"%s: file is too small to be a Windows NT Registry hive file\" , filename ) ; goto",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ENOTSUP , \"%s: page size %zu at 0x%zx, bad registry\" , filename , page_size , off ) ; goto error ; } if ( off + page_size > h -> size ) { SET_ERRNO ( ENOTSUP , \"%s: page size %zu at 0x%zx extends beyond end of file, bad registry\"\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> error ; } if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL, \"%s: file is too small to be a Windows NT Registry hive file\", filename ) ; goto error ; }\n"
 },
 {
  "id": 1506,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static void pci_bus_write_dsdt ( int bus ) { struct businfo * bi ; struct slotinfo * si ; struct pci_vdev * dev ; int count , func , slot ; bi = pci_businfo [ bus ] ; if ( bi == NULL ) { if ( bus != 0 ) return ; } dsdt_line ( \" Device (PCI%01X)\" , bus ) ; dsdt_line ( \" {\" ) ; dsdt_line ( \" Name (_HID, EisaId (\\\\\"PNP0A03\\\\\"))\" ) ; dsdt_line ( \" Name (_ADR, Zero)\" ) ; dsdt_line ( \" Method (_BBN, 0, NotSerialized)\" ) ; dsdt_line ( \" {\" ) ; dsdt_line ( \" Return (0x%08X)\" , bus ) ; dsdt_line ( \" }\" ) ; dsdt_line ( \" Name (_CRS, ResourceTemplate ()\" ) ; dsdt_line ( \" {\" ) ; dsdt_line ( \" WordBusNumber (ResourceProducer, MinFixed, \" \"MaxFixed, PosDecode,\" ) ; dsdt_line ( \" 0x0000, // Granularity\" ) ; dsdt_line ( \" 0x%04X, // Range Minimum\" , bus ) ; dsdt_line ( \" 0x%04X, // Range Maximum\" , bus ) ; dsdt_line ( \" 0x0000, // Translation Offset\" ) ; dsdt_line ( \" 0x0001, // Length\" ) ; dsdt_line ( \" ,, )\" ) ; if ( bus == 0 ) { dsdt_indent ( 3 ) ; dsdt_fixed_ioport ( 0xCF8 , 8 ) ; dsdt_unindent ( 3 ) ; dsdt_line ( \" WordIO (ResourceProducer, MinFixed, MaxFixed, \" \"PosDecode, EntireRange,\" ) ; dsdt_line ( \" 0x0000, // Granularity\" ) ; dsdt_line ( \" 0x0000, // Range Minimum\" ) ; dsdt_line ( \" 0x0CF7, // Range Maximum\" ) ; dsdt_line ( \" 0x0000, // Translation Offset\" )",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> ; } } <vul-end> dsdt_line ( \"      WordIO (ResourceProducer, MinFixed, MaxFixed, \"\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> ; } } if ( bi == NULL ) { dsdt_line ( \" })\" ) ; return ; } <vul-end> dsdt_line ( \" WordIO (ResourceProducer MinFixedMaxFixed \"\n"
 },
 {
  "id": 1507,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 static int fb_mmap ( struct file * file , struct vm_area_struct * vma ) { struct fb_info * info = file_fb_info ( file ) ; struct fb_ops * fb ; <vul-start> unsigned long off ; <vul-end> unsigned long start ; u32 len ; if ( ! info ) return - ENODEV ; <vul-start> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) <vul-end> return - EINVAL ; <vul-start> off = vma -> vm_pgoff << PAGE_SHIFT ; <vul-end> fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; <vul-start> if ( fb -> fb_mmap ) { <vul-end> int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . smem_len ) ; if ( off >= len ) { off -= len ; if ( info -> var . accel_flags ) { mutex_unlock ( & info -> mm_lock ) ; return - EINVAL ; } start = info -> fix . mmio_start ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . mmio_len ) ; } mutex_unlock ( & info -> mm_lock ) ; start &= PAGE_MASK ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) return - EINVAL ; off += start ; vma -> vm_pgoff =",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start> ; unsigned long mmio_pgoff <vul-end> ; unsigned long <vul-start> - ENODEV ; fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; if ( fb -> fb_mmap ) { int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = info -> fix . smem_len ; mmio_pgoff = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ; if ( <vul-end> vma -> vm_pgoff <vul-start> vma -> vm_pgoff >= mmio_pgoff ) { vma -> vm_pgoff -= mmio_pgoff ; start = info -> fix . mmio_start ; len = info -> fix . mmio_len ; } mutex_unlock <vul-end> ( & info <vul-start> mm_lock ) ; <vul-end> vma -> vm_page_prot <vul-start> , vma , start ) ; return vm_iomap_memory ( vma , start , len ) <vul-end> ; }  \n"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> * fb ; int res <vul-end> ; if ( <vul-start> - ENODEV ; <vul-end> fb = info <vul-start> mm_lock ) ; res = fb_mmap ( info, vma ) ; mutex_unlock ( & info -> mm_lock ) ; <vul-start> vm_flags ) ; <vul-end> if ( io_remap_pfn_range\n"
 },
 {
  "id": 1508,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <vul-start> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <vul-end> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ) break ; <vul-end> rinfo [ val\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start>, SZ_SG_REQ_INFO ) ; rinfo [ val ]. usr_ptr = 0\n"
 },
 {
  "id": 1509,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int obj2ast_comprehension ( PyObject * obj , comprehension_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; <vul-start> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <vul-end> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <vul-start> if ( tmp == NULL ) goto failed ; <vul-end> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"target\\\\\" missing from comprehension\" ) ; return 1 ; } <vul-start> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <vul-end> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <vul-start> if ( tmp == NULL ) goto failed ; <vul-end> res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <vul-start> } else { <vul-end> PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"iter\\\\\" missing from comprehension\" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) { int res ; Py_ssize_t len ; <vul-start> Py_ssize_t i ; <vul-end> tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , \"comprehension field \\\\\"ifs\\\\\" must be a list, not",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <vul-end> if ( tmp <vul-start> == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"target\\\\\" missing from comprehension\" ) ; return 1 ; } else { int res <vul-end> ; res = <vul-start> ) ; } if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <vul-end> if ( tmp <vul-start> == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"iter\\\\\" missing from comprehension\" ) ; return 1 ; } else { int res <vul-end> ; res = <vul-start> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"ifs\\\\\" missing from comprehension\" ) ; return 1 ; } else <vul-end> { int res <vul-start> ; Py_ssize_t i <vul-end> ; if ( <vul-start> ) { expr_ty val <vul-end> ; res = <vul-start> ) , & val <vul-end> , arena ) <vul-start> , i , val <vul-end> ) ; } <vul-start> ) ; } if ( lookup_attr_id <vul-end> ( obj , <vul-start> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <vul-end> if ( tmp <vul-start> == NULL ) { PyErr_SetString ( PyExc_TypeError , \"required field \\\\\"is_async\\\\\" missing from comprehension\" ) ; return 1 ; } else { int res <vul-end> ; res = <vul-start> ( tmp ) <vul-end> ; } *\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ; if ( lookup_attr_id <vul-end> ( obj, <vul-start>, & PyId_target, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"target\\\\\" missing from comprehension\" ) ; return 1 ; } else <vul-end> { int res <vul-start> ) ; } if ( lookup_attr_id <vul-end> ( obj, <vul-start>, & PyId_iter, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"iter\\\\\" missing from comprehension\" ) ; return 1 ; } else { int res <vul-end> ; res = <vul-start> ) ; } if ( lookup_attr_id <vul-end> ( obj, <vul-start> obj, & PyId_ifs, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"ifs\\\\\" missing from comprehension\" ) ; return 1 ; } else { <vul-end> int res ; <vul-start> ; Py_ssize_t i <vul-end> ; if ( <vul-start> ) { expr_ty val <vul-end> ; res = <vul-start> ), & val <vul-end>, arena ) <vul-start>, i, val <vul-end> ) ; } <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_target, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"target\\\\\" missing from comprehension\" ) ; return 1 ; } else { <vul-end> res = obj2ast_expr <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_iter, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \"required field \\\\\"iter\\\\\" missing from comprehension\" ) ; return 1 ; } else { <vul-start> ) ; } if ( lookup_attr_id ( obj, & PyId_ifs, & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError, \""
 },
 {
  "id": 1510,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static pngquant_error rwpng_read_image24_libpng ( FILE * infile , png24_image * mainprog_ptr , int verbose ) { png_structp png_ptr = NULL ; png_infop info_ptr = NULL ; png_size_t rowbytes ; int color_type , bit_depth ; png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , rwpng_error_handler , verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler ) ; if ( ! png_ptr ) { return PNG_OUT_OF_MEMORY_ERROR ; } info_ptr = png_create_info_struct ( png_ptr ) ; if ( ! info_ptr ) { png_destroy_read_struct ( & png_ptr , NULL , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( setjmp ( mainprog_ptr -> jmpbuf ) ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return LIBPNG_FATAL_ERROR ; } # if defined ( PNG_SKIP_sRGB_CHECK_PROFILE ) && defined ( PNG_SET_OPTION_SUPPORTED ) png_set_option ( png_ptr , PNG_SKIP_sRGB_CHECK_PROFILE , PNG_OPTION_ON ) ; # endif # if PNG_LIBPNG_VER >= 10500 && defined ( PNG_UNKNOWN_CHUNKS_SUPPORTED ) png_set_keep_unknown_chunks ( png_ptr , PNG_HANDLE_CHUNK_IF_SAFE , ( png_const_bytep ) \"pHYs\\\\0iTXt\\\\0tEXt\\\\0zTXt\" , 4 ) ; # endif png_set_read_user_chunk_fn ( png_ptr , & mainprog_ptr -> chunks , read_chunk_callback ) ; struct rwpng_read_data read_data = { infile , 0 } ; png_set_read_fn ( png_ptr , & read_data , user_read_data ) ; png_read_info ( png_ptr , info_ptr ) ; png_get_IHDR ( png_ptr , info_ptr , & mainprog_ptr -> width , & mainprog_ptr -> height , & bit_depth , & color_type , NULL , NULL , NULL ) ; <vul-start> if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) { <vul-end> png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( ! ( color_type &",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> NULL ) ; <vul-end> if ( ! <vul-start> ; if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ; if ( rowbytes == 0 ) { fprintf ( stderr, \"pngquant readpng: image is missing data\\\\n\" ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( <vul-start> ; if ( rowbytes == 0 ) { fprintf ( stderr, \"pngquant readpng: image is missing data\\\\n\" ) ; png_destroy_read_struct ( & png_ptr, & info_ptr, NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (\n"
 },
 {
  "id": 1511,
  "question": "CWE-611 Code Input Vulnerable Code Is: CWE-611 void * merge_directory_configs ( apr_pool_t * mp , void * _parent , void * _child ) { directory_config * parent = ( directory_config * ) _parent ; directory_config * child = ( directory_config * ) _child ; directory_config * merged = create_directory_config ( mp , NULL ) ; # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , \"Merge parent %pp child %pp RESULT %pp\" , _parent , _child , merged ) ; # endif if ( merged == NULL ) return NULL ; merged -> is_enabled = ( child -> is_enabled == NOT_SET ? parent -> is_enabled : child -> is_enabled ) ; merged -> reqbody_access = ( child -> reqbody_access == NOT_SET ? parent -> reqbody_access : child -> reqbody_access ) ; merged -> reqbody_buffering = ( child -> reqbody_buffering == NOT_SET ? parent -> reqbody_buffering : child -> reqbody_buffering ) ; merged -> reqbody_inmemory_limit = ( child -> reqbody_inmemory_limit == NOT_SET ? parent -> reqbody_inmemory_limit : child -> reqbody_inmemory_limit ) ; merged -> reqbody_limit = ( child -> reqbody_limit == NOT_SET ? parent -> reqbody_limit : child -> reqbody_limit ) ; merged -> reqbody_no_files_limit = ( child -> reqbody_no_files_limit == NOT_SET ? parent -> reqbody_no_files_limit : child -> reqbody_no_files_limit ) ; merged -> resbody_access = ( child -> resbody_access == NOT_SET ? parent -> resbody_access : child -> resbody_access ) ; merged -> of_limit = ( child -> of_limit == NOT_SET ? parent -> of_limit : child -> of_limit ) ; merged -> if_limit_action = ( child -> if_limit_action == NOT_SET ? parent -> if_limit_action : child",
  "golden_answers": [
   "CWE-611 Fixed Code Lines are: <vul-start> crypto_hash_framesrc_pm ) ; merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ;\n"
  ],
  "generated_answer": "CWE-611 Fixed Code Lines are: <vul-start> crypto_hash_framesrc_pm ) ; if ( child -> phase_request_headers == NOT_SET ) { merged -> phase_request_headers = apr_array_copy ( parent -> phase_request_headers ) ; merged -> phase_request_body = apr_array_copy ( child -> phase_request_body ) ; } if ( child -> phase_response_headers == NOT_SET ) { merged -> phase_response_headers = apr_array_copy ( child -> phase_response_headers ) ; merged -> phase_response_body = apr_array_copy ( child -> phase_response_body ) ; }\n"
 },
 {
  "id": 1512,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void isoclns_print ( netdissect_options * ndo , <vul-start> const uint8_t * p , u_int length , u_int caplen ) <vul-end> { <vul-start> if ( caplen <= 1 ) { <vul-end> ND_PRINT ( ( ndo , \"|OSI\" ) ) ; return ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"OSI NLPID %s (0x%02x): \" , tok2str ( nlpid_values , \"Unknown\" , * p ) , * p ) ) ; switch ( * p ) { case NLPID_CLNP : if ( ! clnp_print ( ndo , p , length ) ) <vul-start> print_unknown_data ( ndo , p , \"\\\\n\\\\t\" , caplen ) ; <vul-end> break ; case NLPID_ESIS : esis_print ( ndo , p , length ) ; return ; case NLPID_ISIS : if ( ! isis_print ( ndo , p , length ) ) <vul-start> print_unknown_data ( ndo , p , \"\\\\n\\\\t\" , caplen ) ; <vul-end> break ; case NLPID_NULLNS : ND_PRINT ( ( ndo , \"%slength: %u\" , ndo -> ndo_eflag ? \"\" : \", \" , length ) ) ; break ; case NLPID_Q933 : q933_print ( ndo , p + 1 , length - 1 ) ; break ; case NLPID_IP : ip_print ( ndo , p + 1 , length - 1 ) ; break ; case NLPID_IP6 : ip6_print ( ndo , p + 1 , length - 1 ) ; break ; case NLPID_PPP : ppp_print ( ndo , p + 1 , length - 1 ) ; break ; default : if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , u_int length <vul-end> ) { if <vul-start> { if ( ! ND_TTEST ( * p ) <vul-end> ) { ND_PRINT <vul-start> , \"\\\\n\\\\t\" , length <vul-end> ) ; break <vul-start> , \"\\\\n\\\\t\" , length <vul-end> ) ; break <vul-start> ; if ( length <vul-end> > 1 ) <vul-start> , \"\\\\n\\\\t\" , length <vul-end> ) ; break\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> length, u_int length_left ) { if ( length_left < 1 ) { ND_PRINT ( ( ndo, \"|OSI\" ) ) ; return ; } <vul-end> if ( ndo <vul-start> { if ( length_left <= <vul-end> 1 ) { <vul-start>, \"\\\\n\\\\t\", length_left <vul-end> ) ; break <vul-start>, p, length_left, <vul-start>, p, length_left, <vul-start> ; if ( length_left <= 1 ) { ND_PRINT ( ( ndo, \"|OSI\" ) ) ; return ; } if ( <vul-start>, \"\\\\n\\\\t\", length_left <vul-end> ) ; break\n"
 },
 {
  "id": 1513,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int xid_map_enter ( netdissect_options * ndo , const struct sunrpc_msg * rp , const u_char * bp ) { const struct ip * ip = NULL ; const struct ip6_hdr * ip6 = NULL ; struct xid_map_entry * xmep ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0 ) ; switch ( IP_V ( ( const struct ip * ) bp ) ) { case 4 : ip = ( const struct ip * ) bp ; break ; case 6 : ip6 = ( const struct ip6_hdr * ) bp ; break ; default : return ( 1 ) ; } xmep = & xid_map [ xid_map_next ] ; if ( ++ xid_map_next >= XIDMAPSIZE ) xid_map_next = 0 ; UNALIGNED_MEMCPY ( & xmep -> xid , & rp -> rm_xid , sizeof ( xmep -> xid ) ) ; if ( ip ) { xmep -> ipver = 4 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip -> ip_src , sizeof ( ip -> ip_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip -> ip_dst , sizeof ( ip -> ip_dst ) ) ; } else if ( ip6 ) { xmep -> ipver = 6 ; UNALIGNED_MEMCPY ( & xmep -> client , & ip6 -> ip6_src , sizeof ( ip6 -> ip6_src ) ) ; UNALIGNED_MEMCPY ( & xmep -> server , & ip6 -> ip6_dst , sizeof ( ip6 -> ip6_dst ) ) ; } <vul-start> xmep -> proc = EXTRACT_32BITS ( & rp -> rm_call",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ) ; } if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <vul-start> rm_call . cb_proc ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) ; } if ( rp -> rm_call. cb_vers == 0 ) { xmep -> vers = ND_TTEST_32BITS ( & rp -> rm_call. cb_vers ) ; } else { xmep -> vers = ND_TTEST_32BITS ( & rp -> rm_call. cb_vers ) ; }\n"
 },
 {
  "id": 1514,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <vul-start> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <vul-end> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr )",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> = 0 ; if ( unlikely (! skb -> len - hlen ) ) goto fail_toobig ;\n"
 },
 {
  "id": 1515,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static bool blk_kick_flush ( struct request_queue * q , struct blk_flush_queue * fq ) { struct list_head * pending = & fq -> flush_queue [ fq -> flush_pending_idx ] ; struct request * first_rq = list_first_entry ( pending , struct request , flush . list ) ; struct request * flush_rq = fq -> flush_rq ; if ( fq -> flush_pending_idx != fq -> flush_running_idx || list_empty ( pending ) ) return false ; if ( ! list_empty ( & fq -> flush_data_in_flight ) && time_before ( jiffies , fq -> flush_pending_since + FLUSH_PENDING_TIMEOUT ) ) return false ; fq -> flush_pending_idx ^= 1 ; blk_rq_init ( q , flush_rq ) ; if ( q -> mq_ops ) { <vul-start> flush_rq -> mq_ctx = first_rq -> mq_ctx ; <vul-end> <vul-start> flush_rq -> tag = first_rq -> tag ; <vul-end> } flush_rq -> cmd_type = REQ_TYPE_FS ; flush_rq -> cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ ; flush_rq -> rq_disk = first_rq -> rq_disk ; flush_rq -> end_io = flush_end_io ; return blk_flush_queue_rq ( flush_rq , false ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <vul-start> first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> -> mq_ops ) <vul-end> flush_rq -> mq_ctx <vul-start> -> mq_ctx ; <vul-end> flush_rq -> tag <vul-start> first_rq -> tag ; <vul-end> flush_rq -> cmd_type\n"
 },
 {
  "id": 1516,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int __sys_sendmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned flags , struct used_address * used_address ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct sockaddr_storage address ; struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; unsigned char ctl [ sizeof ( struct cmsghdr ) + 20 ] __attribute__ ( ( aligned ( sizeof ( __kernel_size_t ) ) ) ) ; unsigned char * ctl_buf = ctl ; int err , ctl_len , iov_size , total_len ; err = - EFAULT ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) ) return - EFAULT ; err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ) ; if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ) ; if ( ! iov ) goto out ; } if ( MSG_CMSG_COMPAT & flags ) { err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; } else err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; if ( err < 0 ) goto out_freeiov",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> ( used_address && msg_sys -> msg_name && <vul-start> -> name , msg_sys <vul-end> -> msg_name , <vul-start> -> msg_namelen ; if ( msg_sys -> msg_name ) <vul-start> -> name , msg_sys <vul-end> -> msg_name ,\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> |= MSG_DONTWAIT ; memcpy ( & used_address -> name, msg -> msg_name, sizeof ( used_address -> name ) ) ; <vul-start> -> msg_namelen && <vul-end> used_address -> name_len <vul-start> used_address -> name_len == <vul-end> msg_sys -> msg_namelen <vul-start> -> msg_namelen ; memcpy <vul-end> ( & used_address\n"
 },
 {
  "id": 1517,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 SYSCALL_DEFINE1 ( timer_getoverrun , timer_t , timer_id ) { struct k_itimer * timr ; int overrun ; unsigned long flags ; timr = lock_timer ( timer_id , & flags ) ; if ( ! timr ) return - EINVAL ; <vul-start> overrun = timr -> it_overrun_last ; <vul-end> unlock_timer ( timr , flags ) ; return overrun ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> ; overrun = timer_overrun_to_int ( timr , 0 ) <vul-end> ; unlock_timer (\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = timr -> it_overrun_count <vul-end> ; unlock_timer (\n"
 },
 {
  "id": 1518,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <vul-start> lock_sock ( sk ) ; <vul-end> msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ( sk ) <vul-end> ; for (\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ( sk ) <vul-end> ; for (\n"
 },
 {
  "id": 1519,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int rawsock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied ; int rc ; pr_debug ( \"sock=%p sk=%p len=%zu flags=%d\\\\n\" , sock , sk , len , flags ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rc ) ; if ( ! skb ) return rc ; <vul-start> msg -> msg_namelen = 0 ; <vul-end> copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; return rc ? : copied ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> return rc ; <vul-end> copied = skb\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> return rc ; <vul-end> copied = skb\n"
 },
 {
  "id": 1520,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int choose_volume ( struct archive_read * a , struct iso9660 * iso9660 ) { struct file_info * file ; int64_t skipsize ; struct vd * vd ; const void * block ; char seenJoliet ; vd = & ( iso9660 -> primary ) ; if ( ! iso9660 -> opt_support_joliet ) iso9660 -> seenJoliet = 0 ; if ( iso9660 -> seenJoliet && vd -> location > iso9660 -> joliet . location ) vd = & ( iso9660 -> joliet ) ; <vul-start> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <vul-end> skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position = skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Failed to read full block when scanning \" \"ISO9660 directory list\" ) ; return ( ARCHIVE_FATAL ) ; } seenJoliet = iso9660 -> seenJoliet ; iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; if ( vd == & ( iso9660 -> primary ) && iso9660 -> seenRockridge && iso9660 -> seenJoliet ) iso9660 -> seenJoliet = 0 ; if ( vd == & ( iso9660 -> primary ) && ! iso9660 -> seenRockridge && iso9660 -> seenJoliet ) { vd = & ( iso9660 -> joliet ) ;",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> = LOGICAL_BLOCK_SIZE * ( int64_t ) <vul-start> = LOGICAL_BLOCK_SIZE * ( int64_t )\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> joliet ) ; if ( vd -> location < vd -> size || ( int ) vd -> location > vd -> size ) { archive_set_error ( & a -> archive, ARCHIVE_ERRNO_MISC, \"Invalid directory entry location\" ) ; return ( ARCHIVE_FATAL ) ; } <vul-start> = LOGICAL_BLOCK_SIZE * ( int64_t ) <vul-start> vd -> location <vul-end> ; skipsize =\n"
 },
 {
  "id": 1521,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , <vul-start> const TileInfo * const tile , <vul-end> BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) { MACROBLOCKD * xd = & x -> e_mbd ; <vul-start> VP9_COMMON * cm = & cpi -> common ; <vul-end> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <vul-start> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <vul-end> int bestsme = INT_MAX ; <vul-start> int further_steps , step_param ; <vul-end> int sadpb = x -> sadperbit16 ; MV mvp_full ; int ref = mbmi -> ref_frame [ 0 ] ; <vul-start> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <vul-end> int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; <vul-start> int tmp_row_max = x -> mv_row_max ; <vul-end> const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ; MV pred_mv [ 3 ] ; <vul-start> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <vul-end> <vul-start> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <vul-end> <vul-start> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <vul-end> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) backup_yv12 [ i ] = xd",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * x , <vul-end> BLOCK_SIZE bsize , <vul-start> -> e_mbd ; const <vul-start> { { 0 , 0 <vul-start> INT_MAX ; int <vul-end> step_param ; int <vul-start> MV ref_mv = x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> x -> mv_row_max ; int cost_list [ 5 ] <vul-start> 0 ] = x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> 1 ] = x -> mbmi_ext <vul-end> -> ref_mvs [ <vul-start> [ ref ] <vul-end> ; if ( <vul-start> -> sf . mv . auto_mv_step_size && cm -> <vul-end> show_frame ) { <vul-start> ( vp9_init_search_range ( <vul-end> x -> max_mv_context <vul-start> -> mv_step_param ) / 2 <vul-end> ; } else <vul-start> bsize < BLOCK_64X64 <vul-end> ) { int <vul-start> 2 * ( b_width_log2_lookup [ BLOCK_64X64 ] <vul-end> - MIN ( <vul-start> - MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <vul-end> ) ) ; <vul-start> [ bsize ] <vul-end> ; int tlevel <vul-start> += 2 ; if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <vul-start> <= ALTREF_FRAME && cm -> <vul-end> show_frame ; ++ <vul-start> ref ] . row = 0 ; x -> pred_mv [ ref ] . col <vul-end> = 0 ; <vul-start> < MAX_MB_PLANE ; ++ i <vul-end> ) xd -> <vul-start> } return ; } <vul-start> >>= 3 ; bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <vul-end> ; if ( <vul-start> < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step <vul-end> ( x , <vul-start> & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , <vul-start> bsize ] , <vul-end> cpi -> sf <vul-start> -> sf . mv . subpel_force_stop , <vul-end> cpi -> sf <vul-start> -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <vul-end> , & x <vul-start> [ ref ] , NULL , 0 , 0 <vul-start> sf . adaptive_motion_search <vul-end> ) x -> <vul-start> [ ref ] <vul-end> = tmp_mv -> <vul-start> = tmp_mv -> as_mv <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * x, <vul-end> BLOCK_SIZE bsize, <vul-start> -> e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; <vul-start> mbmi ; struct buf_2d <vul-end> backup_yv12 [ MAX_MB_PLANE <vul-start> ; int bestsme, step_param ; MV ref_mv <vul-end> ; MV mvp_full <vul-start> 0 ] ; const <vul-start> ; pred_mv [ ref ] = x -> pred_mv [ ref ] ; pred_mv [ <vul-start> ] ) { memcpy ( & <vul-start> i ]. as_mv, & tmp_mv -> as_mv ) ; step_param = MIN ( step_param, tmp_mv -> as_mv <vul-end> ) ; } <vul-start> ; } } } else if ( sf -> mv_search_method == HEX && x -> max_mv_search_steps == MAX_MB_PLANE ) { int further_steps, step_param ; int sadpb = x -> sadperbit16 ; MV mvp_full ; int ref = mbmi -> ref_frame [ 0 ] ; MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ]. as_mv ; int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; int tmp_row_min = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi, ref ) ; <vul-start> 0 ] = ref_mv <vul-end> [ 0 ] <vul-start> 1 ] = ref_mv <vul-end> [ 1 ] <vul-start> 1 ] = ref_mv <vul-end> [ 2 ] <vul-start> 2 ] = ref_mv <vul-end> [ 3 ] <vul-start> ] ) { memcpy ( & <vul-start> [ i ]. as_mv, & tmp_mv -> as_mv ) ; step_param = MAX ( step_param, <vul-end> bestsme ) ; <vul-start> bestsme ) { int i ; for ( i = LAST_FRAME ; i < MAX_MB_PLANE"
 },
 {
  "id": 1522,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static INT AirPDcapDecryptWPABroadcastKey ( const EAPOL_RSN_KEY * pEAPKey , guint8 * decryption_key , PAIRPDCAP_SEC_ASSOCIATION sa , guint eapol_len ) { guint8 key_version ; guint8 * key_data ; guint8 * szEncryptedKey ; guint16 key_bytes_len = 0 ; guint16 key_len ; static AIRPDCAP_KEY_ITEM dummy_key ; AIRPDCAP_SEC_ASSOCIATION * tmp_sa ; key_version = AIRPDCAP_EAP_KEY_DESCR_VER ( pEAPKey -> key_information [ 1 ] ) ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_length ) ; } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_data_len ) ; if ( key_bytes_len < 16 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } } <vul-start> if ( key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) { <vul-end> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } key_data = ( guint8 * ) pEAPKey + sizeof ( EAPOL_RSN_KEY ) ; szEncryptedKey = ( guint8 * ) g_memdup ( key_data , key_bytes_len ) ; DEBUG_DUMP ( \"Encrypted Broadcast key:\" , szEncryptedKey , key_bytes_len ) ; DEBUG_DUMP ( \"KeyIV:\" , pEAPKey -> key_iv , 16 ) ; DEBUG_DUMP ( \"decryption_key:\" , decryption_key , 16 ) ; tmp_sa = ( AIRPDCAP_SEC_ASSOCIATION * ) g_malloc ( sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { guint8 new_key [ 32 ] ; guint8 dummy [ 256 ] ; rc4_state_struct rc4_state ; sa -> wpa . key_ver = ( key_bytes_len >= TKIP_GROUP_KEY_LEN ) ? AIRPDCAP_WPA_KEY_VER_NOT_CCMP : AIRPDCAP_WPA_KEY_VER_AES_CCMP ; memcpy ( new_key , pEAPKey -> key_iv , 16 ) ;",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> } if ( ( <vul-start> key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <vul-end> key_bytes_len > eapol_len <vul-start> sizeof ( EAPOL_RSN_KEY )\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } if ( ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) && <vul-start> key_bytes_len < GROUP_KEY_MIN_LEN )\n"
 },
 {
  "id": 1523,
  "question": "CWE-310 Code Input Vulnerable Code Is: CWE-310 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <vul-start> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <vul-end> <vul-start> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <vul-end> sizeof ( ualg -> cru_driver_name ) ) ; <vul-start> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <vul-end> <vul-start> CRYPTO_MAX_ALG_NAME ) ; <vul-end> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <vul-start> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , \"%s\" , \"larval\" ) ; <vul-end> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE",
  "golden_answers": [
   "CWE-310 Fixed Code Lines are: <vul-start> skb ) { strncpy ( <vul-end> ualg -> cru_name <vul-start> -> cru_name , <vul-end> alg -> cra_name <vul-start> ) ) ; strncpy ( <vul-end> ualg -> cru_driver_name <vul-start> -> cru_driver_name , <vul-end> alg -> cra_driver_name <vul-start> ) ) ; strncpy ( <vul-end> ualg -> cru_module_name <vul-start> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <vul-end> ; ualg -> <vul-start> crypto_report_larval rl ; strncpy <vul-end> ( rl . <vul-start> . type , \"larval\" , sizeof ( rl . type ) <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-310 Fixed Code Lines are: <vul-start> skb ) { strncpy <vul-end> ( & ualg <vul-start> ) ) ; strncpy <vul-end> ( & ualg <vul-start> ) ) ; strncpy <vul-end> ( & ualg <vul-start> ), CRYPTO_MAX_ALG_NAME ) ; strncpy ( & ualg -> cru_flags, alg -> cra_flags <vul-start>. type, sizeof ( rl. type ) <vul-end>, \"%s\",\n"
 },
 {
  "id": 1524,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int lzxd_decompress ( struct lzxd_stream * lzx , off_t out_bytes ) { register unsigned int bit_buffer ; register int bits_left , i = 0 ; unsigned char * i_ptr , * i_end ; register unsigned short sym ; int match_length , length_footer , extra , verbatim_bits , bytes_todo ; int this_run , main_element , aligned_bits , j ; unsigned char * window , * runsrc , * rundest , buf [ 12 ] ; unsigned int frame_size = 0 , end_frame , match_offset , window_posn ; unsigned int R0 , R1 , R2 ; if ( ! lzx || ( out_bytes < 0 ) ) return MSPACK_ERR_ARGS ; if ( lzx -> error ) return lzx -> error ; i = lzx -> o_end - lzx -> o_ptr ; if ( ( off_t ) i > out_bytes ) i = ( int ) out_bytes ; if ( i ) { if ( lzx -> sys -> write ( lzx -> output , lzx -> o_ptr , i ) != i ) { return lzx -> error = MSPACK_ERR_WRITE ; } lzx -> o_ptr += i ; lzx -> offset += i ; out_bytes -= i ; } if ( out_bytes == 0 ) return MSPACK_ERR_OK ; RESTORE_BITS ; window = lzx -> window ; window_posn = lzx -> window_posn ; R0 = lzx -> R0 ; R1 = lzx -> R1 ; R2 = lzx -> R2 ; end_frame = ( unsigned int ) ( ( lzx -> offset + out_bytes ) / LZX_FRAME_SIZE ) + 1 ; while ( lzx -> frame < end_frame",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> case LZX_BLOCKTYPE_UNCOMPRESSED : if ( window_posn + this_run > lzx -> window_size ) { D ( ( \"match ran over window boundary\" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> case LZX_BLOCKTYPE_UNCOMPRESSED : if ( lzx -> block_remaining < LZX_BLOCK_OFFSET ) { D ( ( \"invalid block length\" ) ) return MSPACK_ERR_DECRUNCH ; }\n"
 },
 {
  "id": 1525,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t ctrl_set_previewpp ( vpx_codec_alg_priv_t * ctx , <vul-start> int ctr_id , va_list args ) { <vul-end> # if CONFIG_VP9_POSTPROC <vul-start> vp8_postproc_cfg_t * config = va_arg ( args , vp8_postproc_cfg_t * ) ; <vul-end> ( void ) ctr_id ; if ( config != NULL ) { ctx -> preview_ppcfg = * config ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } # else ( void ) ctx ; <vul-start> ( void ) ctr_id ; <vul-end> ( void ) args ; return VPX_CODEC_INCAPABLE ; # endif }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * ctx , <vul-end> va_list args ) <vul-start> vp8_postproc_cfg_t * ) <vul-end> ; if ( <vul-start> ( void ) <vul-end> args ; return\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * ctx, <vul-end> va_list args ) <vul-start> vp8_postproc_cfg_t * ) <vul-end> ; if ( <vul-start> ( void ) <vul-end> args ; return\n"
 },
 {
  "id": 1526,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_reset_segment_features ( struct segmentation * seg ) { seg -> enabled = 0 ; seg -> update_map = 0 ; seg -> update_data = 0 ; <vul-start> vpx_memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; <vul-end> vp9_clearall_segfeatures ( seg ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; memset <vul-end> ( seg ->\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = 0 ; memset <vul-end> ( seg ->\n"
 },
 {
  "id": 1527,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( \"error: cannot get box\\\\n\" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( \"error: expecting signature box\\\\n\" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( \"incorrect magic number\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( \"expecting file type box\\\\n\" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { <vul-start> jas_eprintf",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> { jas_eprintf ( \"got box type %s\\\\n\" <vul-end> , box ->\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> { jas_eprintf ( \"box type %s\\\\n\" <vul-end>, box ->\n"
 },
 {
  "id": 1528,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , <vul-start> offset , <vul-end> pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , \"\\\\122\\\\314\"",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> , one , pixel_info_length ; ssize_t count , offset <vul-end> , y ; <vul-start> ; if ( ( offset < 0 ) || ( <vul-start> ) > pixel_info_length ) <vul-start> + plane ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , \"UnableToReadImageData\" ) ; } <vul-start> + offset ; <vul-end> for ( i\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>, one, pixel_info_length ; ssize_t count, offset <vul-end>, y ; <vul-start> ; if ( ( offset < 0 ) || ( <vul-start> ) > pixel_info_length ) <vul-start> ; if ( ( offset < 0 ) || ( <vul-start> ) > pixel_info_length )\n"
 },
 {
  "id": 1529,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int unix_dgram_sendmsg ( struct socket * sock , struct msghdr * msg , size_t len ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_un * , sunaddr , msg -> msg_name ) ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie scm ; int max_level ; int data_len = 0 ; <vul-start> wait_for_unix_gc ( ) ; <vul-end> err = scm_send ( sock , msg , & scm , false ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) { data_len = min_t",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> = 0 ; int sk_locked ; <vul-start> out_free ; } sk_locked = 0 ; <vul-start> other ) ; restart_locked : <vul-start> ; if ( unlikely ( <vul-start> SOCK_DEAD ) ) ) <vul-start> other ) ; if ( ! sk_locked ) unix_state_lock ( sk ) ; <vul-start> = 0 ; <vul-end> if ( unix_peer <vul-start> ) = NULL ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <vul-start> } if ( unlikely ( <vul-start> other ) ) ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <vul-end> if ( ! <vul-start> if ( ! sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <vul-end> ) { err <vul-start> - EAGAIN ; sk_locked = 1 ; <vul-start> out_unlock ; } if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <vul-end> if ( sock_flag <vul-start> ; out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> = 0 ; bool peer_wakeup = false ; <vul-start> out_free ; } if ( sock_flag ( other, SOCK_DEAD ) ) { unix_state_unlock ( other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; goto restart ; } <vul-start> other ) { unix_dgram_peer_wake_disconnect ( sk, other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; goto out_unlock ; } if ( unix_peer_wake_disconnect ( sk, other ) ) goto out_unlock ; <vul-start> ) ) { unix_state_unlock ( sk ) ; <vul-start> out_unlock ; } err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other, SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb, sock, other ) ; skb_queue_tail ( & other -> sk_receive_queue, skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( sk ) ; if ( peer_wakeup ) { unix_dgram_peer_wake_disconnect ( sk, other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; goto out_unlock ; } <vul-end> unix_state_unlock ( sk <vul-start> unix_state_unlock ( other ) ; out_free : if ( peer_wakeup ) unix_state_unlock ( sk\n"
 },
 {
  "id": 1530,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( \"%s unable to load config file; attempting to transcode legacy file.\" , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( \"%s unable to transcode legacy file, starting unconfigured.\" , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( \"%s unable to allocate a config object.\" , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } btif_config_remove_unpaired ( config ) ; <vul-start> alarm_timer = alarm_new ( ) ; <vul-end> if ( ! alarm_timer ) { LOG_ERROR ( \"%s unable to create alarm.\" , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> config ) ; if ( ! is_restricted_mode ( ) ) btif_config_remove_restricted ( config ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> config ) ; btif_config_remove_unpaired ( config ) ;\n"
 },
 {
  "id": 1531,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int main ( void ) { <vul-start> # line 52 \"dt_test2.pgc\" <vul-end> date date1 ; <vul-start> # line 53 \"dt_test2.pgc\" <vul-end> timestamp ts1 , ts2 ; <vul-start> # line 54 \"dt_test2.pgc\" <vul-end> char * text ; <vul-start> # line 55 \"dt_test2.pgc\" <vul-end> interval * i1 ; <vul-start> # line 56 \"dt_test2.pgc\" <vul-end> date * dc ; <vul-start> # line 57 \"dt_test2.pgc\" <vul-end> int i , j ; char * endptr ; ECPGdebug ( 1 , stderr ) ; ts1 = PGTYPEStimestamp_from_asc ( \"2003-12-04 17:34:29\" , NULL ) ; text = PGTYPEStimestamp_to_asc ( ts1 ) ; printf ( \"timestamp: %s\\\\n\" , text ) ; free ( text ) ; date1 = PGTYPESdate_from_timestamp ( ts1 ) ; dc = PGTYPESdate_new ( ) ; * dc = date1 ; text = PGTYPESdate_to_asc ( * dc ) ; printf ( \"Date of timestamp: %s\\\\n\" , text ) ; free ( text ) ; PGTYPESdate_free ( dc ) ; for ( i = 0 ; dates [ i ] ; i ++ ) { bool err = false ; date1 = PGTYPESdate_from_asc ( dates [ i ] , & endptr ) ; if ( date1 == INT_MIN ) { err = true ; } text = PGTYPESdate_to_asc ( date1 ) ; printf ( \"Date[%d]: %s (%c - %c)\\\\n\" , i , err ? \"-\" : text , endptr ? 'N' : 'Y' , err ? 'T' : 'F' ) ; free ( text ) ; if ( ! err ) { for ( j = 0 ; times [ j ] ; j ++ ) { int length = strlen",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { # line 62 <vul-end> \"dt_test2.pgc\" date date1 <vul-start> ; # line 63 <vul-end> \"dt_test2.pgc\" timestamp ts1 <vul-start> ; # line 64 <vul-end> \"dt_test2.pgc\" char * <vul-start> ; # line 65 <vul-end> \"dt_test2.pgc\" interval * <vul-start> ; # line 66 <vul-end> \"dt_test2.pgc\" date * <vul-start> ; # line 67 <vul-end> \"dt_test2.pgc\" int i\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { # line 51 <vul-end> \"dt_test2.pgc\" date date1 <vul-start> ; # line 51 <vul-end> \"dt_test2.pgc\" timestamp ts1 <vul-start> ; # line 54 <vul-end> \"dt_test2.pgc\" char * <vul-start> ; # line 55 <vul-end> \"dt_test2.pgc\" interval * <vul-start> ; # line 56 <vul-end> \"dt_test2.pgc\" date * <vul-start> ; # line 57 <vul-end> \"dt_test2.pgc\" int i\n"
 },
 {
  "id": 1532,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , \"ES-IS\" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? \"bad pkt!\" : \"no header at all!\" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * esis_header ) ; li = esis_header -> length_indicator ; optr = pptr ; if ( esis_header -> nlpid != NLPID_ESIS ) { ND_PRINT ( ( ndo , \" nlpid 0x%02x packet not supported\" , esis_header -> nlpid ) ) ; return ; } if ( esis_header -> version != ESIS_VERSION ) { ND_PRINT ( ( ndo , \" version %d packet not supported\" , esis_header -> version ) ) ; return ; } if ( li > length ) { ND_PRINT ( ( ndo , \" length indicator(%u) > PDU size (%u)!\" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , \" length indicator %u < min PDU size:\" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , \"%02X\" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ; if ( snpal == 6 ) ND_PRINT ( ( ndo , \"\\\\n\\\\t  SNPA (length: %u): %s\" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , \"\\\\n\\\\t  SNPA (length: %u): %s\" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <vul-end> 0 ) ND_PRINT <vul-start> ( ndo , \"\\\\n\\\\t  NET (length: %u) %s\" , netal , <vul-end> isonsap_string ( ndo\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> -= netal ; ND_TCHECK2 ( * pptr, snpa ) ; <vul-start> == 0 ) { <vul-start> ) ) ; } else { ND_PRINT ( ( ndo, \"[|esis]\" ) ) ; }\n"
 },
 {
  "id": 1533,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void mp_decode_to_lua_array ( lua_State * L , mp_cur * c , size_t len ) { assert ( len <= UINT_MAX ) ; int index = 1 ; <vul-start> lua_newtable ( L ) ; <vul-end> while ( len -- ) { lua_pushnumber ( L , index ++ ) ; mp_decode_to_lua_type ( L , c ) ; if ( c -> err ) return ; lua_settable ( L , - 3 ) ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> lua_newtable ( L ) ; luaL_checkstack ( L , 1 , \"in function mp_decode_to_lua_array\"\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = 1 ; luaL_checkstack ( L, 1, \"in function mp_decode_to_lua_array\" <vul-end> ) ; while\n"
 },
 {
  "id": 1534,
  "question": "CWE-665 Code Input Vulnerable Code Is: CWE-665 static struct ib_ucontext * hns_roce_alloc_ucontext ( struct ib_device * ib_dev , struct ib_udata * udata ) { int ret = 0 ; struct hns_roce_ucontext * context ; <vul-start> struct hns_roce_ib_alloc_ucontext_resp resp ; <vul-end> struct hns_roce_dev * hr_dev = to_hr_dev ( ib_dev ) ; resp . qp_tab_size = hr_dev -> caps . num_qps ; context = kmalloc ( sizeof ( * context ) , GFP_KERNEL ) ; if ( ! context ) return ERR_PTR ( - ENOMEM ) ; ret = hns_roce_uar_alloc ( hr_dev , & context -> uar ) ; if ( ret ) goto error_fail_uar_alloc ; if ( hr_dev -> caps . flags & HNS_ROCE_CAP_FLAG_RECORD_DB ) { INIT_LIST_HEAD ( & context -> page_list ) ; mutex_init ( & context -> page_mutex ) ; } ret = ib_copy_to_udata ( udata , & resp , sizeof ( resp ) ) ; if ( ret ) goto error_fail_copy_to_udata ; return & context -> ibucontext ; error_fail_copy_to_udata : hns_roce_uar_free ( hr_dev , & context -> uar ) ; error_fail_uar_alloc : kfree ( context ) ; return ERR_PTR ( ret ) ; }",
  "golden_answers": [
   "CWE-665 Fixed Code Lines are: <vul-start> struct hns_roce_ib_alloc_ucontext_resp resp = { }\n"
  ],
  "generated_answer": "CWE-665 Fixed Code Lines are: <vul-start> struct hns_roce_ib_alloc_ucontext_resp resp ; memset ( & resp, 0, sizeof ( resp ) )\n"
 },
 {
  "id": 1535,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; if ( ( data && ! orig_data ) || ! sbi ) goto out_free_base ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) goto out_free_base ; sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg ( sb ,",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , \"first meta block group too large: %u \" \"(group descriptor block count %u)\" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ( sb ) ; if ( db_count > EXT4_MAX_BLOCKS ) goto out_free_base\n"
 },
 {
  "id": 1536,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static void ov518_mode_init_regs ( struct sd * sd ) { struct gspca_dev * gspca_dev = ( struct gspca_dev * ) sd ; int hsegs , vsegs , packet_size ; struct usb_host_interface * alt ; struct usb_interface * intf ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , \"Couldn\\'t get altsetting\\\\n\" ) ; sd -> gspca_dev . usb_err = - EIO ; return ; } <vul-start> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <vul-end> ov518_reg_w32 ( sd , R51x_FIFO_PSIZE , packet_size & ~ 7 , 2 ) ; reg_w ( sd , 0x2b , 0 ) ; reg_w ( sd , 0x2c , 0 ) ; reg_w ( sd , 0x2d , 0 ) ; reg_w ( sd , 0x2e , 0 ) ; reg_w ( sd , 0x3b , 0 ) ; reg_w ( sd , 0x3c , 0 ) ; reg_w ( sd , 0x3d , 0 ) ; reg_w ( sd , 0x3e , 0 ) ; if ( sd -> bridge == BRIDGE_OV518 ) { reg_w_mask ( sd , 0x20 , 0x08 , 0x08 ) ; reg_w_mask ( sd , 0x28 , 0x80 , 0xf0 ) ; reg_w_mask ( sd , 0x38 , 0x80 , 0xf0 ) ; } else { reg_w ( sd , 0x28 , 0x80 ) ; reg_w ( sd , 0x38 , 0x80 ) ; } hsegs",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV ; return ; }\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> return ; } if ( alt -> desc. bNumEndpoints < 1 ) { sd -> gspca_dev. usb_err = - ENODEV ; return ; }\n"
 },
 {
  "id": 1537,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; <vul-start> fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; <vul-end> if ( fd < 0 ) return - errno ; if ( mode != MODE_INVALID ) { r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> path, O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY | O_NOCTTY_NOLOCK <vul-end>, mode >\n"
 },
 {
  "id": 1538,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void _isdn_setup ( struct net_device * dev ) { isdn_net_local * lp = netdev_priv ( dev ) ; ether_setup ( dev ) ; dev -> flags = IFF_NOARP | IFF_POINTOPOINT ; <vul-start> dev -> header_ops = NULL ; <vul-end> dev -> netdev_ops = & isdn_netdev_ops ; dev -> tx_queue_len = 30 ; lp -> p_encap = ISDN_NET_ENCAP_RAWIP ; lp -> magic = ISDN_NET_MAGIC ; lp -> last = lp ; lp -> next = lp ; lp -> isdn_device = - 1 ; lp -> isdn_channel = - 1 ; lp -> pre_device = - 1 ; lp -> pre_channel = - 1 ; lp -> exclusive = - 1 ; lp -> ppp_slot = - 1 ; lp -> pppbind = - 1 ; skb_queue_head_init ( & lp -> super_tx_queue ) ; lp -> l2_proto = ISDN_PROTO_L2_X75I ; lp -> l3_proto = ISDN_PROTO_L3_TRANS ; lp -> triggercps = 6000 ; lp -> slavedelay = 10 * HZ ; lp -> hupflags = ISDN_INHUP ; lp -> onhtime = 10 ; lp -> dialmax = 1 ; lp -> flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL ; lp -> cbdelay = 25 ; lp -> dialtimeout = - 1 ; lp -> dialwait = 5 * HZ ; lp -> dialstarted = 0 ; lp -> dialwait_timer = 0 ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->\n"
 },
 {
  "id": 1539,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int raptor_rdfxml_parse_start ( raptor_parser * rdf_parser ) { raptor_uri * uri = rdf_parser -> base_uri ; raptor_rdfxml_parser * rdf_xml_parser ; rdf_xml_parser = ( raptor_rdfxml_parser * ) rdf_parser -> context ; if ( ! uri ) return 1 ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NORMALIZE_LANGUAGE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NORMALIZE_LANGUAGE ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_NET , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_NET ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_FILE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; <vul-start> if ( rdf_parser -> uri_filter ) <vul-end> raptor_sax2_set_uri_filter ( rdf_xml_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ; raptor_sax2_parse_start ( rdf_xml_parser -> sax2 , uri ) ; if ( rdf_xml_parser -> id_set ) { raptor_free_id_set ( rdf_xml_parser -> id_set ) ; rdf_xml_parser -> id_set = NULL ; } if ( RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_CHECK_RDF_ID ) ) { rdf_xml_parser -> id_set = raptor_new_id_set ( rdf_parser -> world ) ; if ( ! rdf_xml_parser -> id_set ) return 1 ; } return 0 ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL, RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;\n"
 },
 {
  "id": 1540,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int newkeys_to_blob ( struct sshbuf * m , struct ssh * ssh , int mode ) { struct sshbuf * b ; struct sshcipher_ctx * cc ; struct sshcomp * comp ; struct sshenc * enc ; struct sshmac * mac ; struct newkeys * newkey ; int r ; if ( ( newkey = ssh -> state -> newkeys [ mode ] ) == NULL ) return SSH_ERR_INTERNAL_ERROR ; enc = & newkey -> enc ; mac = & newkey -> mac ; comp = & newkey -> comp ; cc = ( mode == MODE_OUT ) ? ssh -> state -> send_context : ssh -> state -> receive_context ; if ( ( r = cipher_get_keyiv ( cc , enc -> iv , enc -> iv_len ) ) != 0 ) return r ; if ( ( b = sshbuf_new ( ) ) == NULL ) return SSH_ERR_ALLOC_FAIL ; if ( ( r = sshbuf_put_cstring ( b , enc -> name ) ) != 0 || ( r = sshbuf_put ( b , & enc -> cipher , sizeof ( enc -> cipher ) ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> enabled ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> block_size ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> key , enc -> key_len ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> iv , enc -> iv_len ) ) != 0 ) goto out ; if ( cipher_authlen",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( r = <vul-end> sshbuf_put_cstring ( b\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> comp -> enabled <vul-end> ) )!=\n"
 },
 {
  "id": 1541,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <vul-start> u16 offset = sizeof ( struct ipv6hdr ) ; <vul-end> unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset <= packet_len ) { struct ipv6_opt_hdr * exthdr ; <vul-start> switch ( * * nexthdr ) { <vul-end> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <vul-start> offset += ipv6_optlen ( exthdr ) ; <vul-end> * nexthdr = & exthdr -> nexthdr ; } return - EINVAL ; }",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> nexthdr ) { unsigned int <vul-end> offset = sizeof <vul-start> * exthdr ; unsigned int len ; <vul-start> offset ) ; len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <vul-end> ; * nexthdr\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> ( struct ipv6hdr ) ; struct ipv6_txoptions * opt <vul-start> * exthdr ; opt = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <vul-start> offset ) ; if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; <vul-start> ( exthdr ) ; opt -> opt. optlen = offset\n"
 },
 {
  "id": 1542,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static Image * handle_add_command ( GraphicsManager * self , const GraphicsCommand * g , const uint8_t * payload , bool * is_dirty , uint32_t iid ) { # define ABRT ( code , ... ) { set_add_response ( # code , __VA_ARGS__ ) ; self -> loading_image = 0 ; if ( img ) img -> data_loaded = false ; return NULL ; } # define MAX_DATA_SZ ( 4u * 100000000u ) has_add_respose = false ; bool existing , init_img = true ; Image * img = NULL ; unsigned char tt = g -> transmission_type ? g -> transmission_type : 'd' ; enum FORMATS { RGB = 24 , RGBA = 32 , PNG = 100 } ; uint32_t fmt = g -> format ? g -> format : RGBA ; if ( tt == 'd' && self -> loading_image ) init_img = false ; if ( init_img ) { self -> last_init_graphics_command = * g ; self -> last_init_graphics_command . id = iid ; self -> loading_image = 0 ; if ( g -> data_width > 10000 || g -> data_height > 10000 ) ABRT ( EINVAL , \"Image too large\" ) ; remove_images ( self , add_trim_predicate , 0 ) ; img = find_or_create_image ( self , iid , & existing ) ; if ( existing ) { free_load_data ( & img -> load_data ) ; img -> data_loaded = false ; free_refs_data ( img ) ; * is_dirty = true ; self -> layers_dirty = true ; } else { img -> internal_id = internal_id_counter ++ ; img -> client_id =",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> ( EBADF , \"Failed to open file for graphics transmission with error: [%d] %s\" <vul-end> , errno ,\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> - 1 ) { <vul-start> ) ) ; close ( fd ) ; }\n"
 },
 {
  "id": 1543,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) { struct rds_info_message minfo ; minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ; minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ; if ( flip ) { minfo . laddr = daddr ; minfo . faddr = saddr ; minfo . lport = inc -> i_hdr . h_dport ; minfo . fport = inc -> i_hdr . h_sport ; } else { minfo . laddr = saddr ; minfo . faddr = daddr ; minfo . lport = inc -> i_hdr . h_sport ; minfo . fport = inc -> i_hdr . h_dport ; } <vul-start> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <vul-end> }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> h_dport ; } minfo . flags = 0 ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> h_dport ; } minfo. op_flags = 0 ;\n"
 },
 {
  "id": 1544,
  "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 static int ip_setup_cork ( struct sock * sk , struct inet_cork * cork , struct ipcm_cookie * ipc , struct rtable * * rtp ) { struct inet_sock * inet = inet_sk ( sk ) ; <vul-start> struct ip_options * opt ; <vul-end> struct rtable * rt ; opt = ipc -> opt ; if ( opt ) { if ( cork -> opt == NULL ) { cork -> opt = kmalloc ( sizeof ( struct ip_options ) + 40 , sk -> sk_allocation ) ; if ( unlikely ( cork -> opt == NULL ) ) return - ENOBUFS ; } <vul-start> memcpy ( cork -> opt , opt , sizeof ( struct ip_options ) + opt -> optlen ) ; <vul-end> cork -> flags |= IPCORK_OPT ; cork -> addr = ipc -> addr ; } rt = * rtp ; if ( unlikely ( ! rt ) ) return - EFAULT ; * rtp = NULL ; cork -> fragsize = inet -> pmtudisc == IP_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; cork -> dst = & rt -> dst ; cork -> length = 0 ; cork -> tx_flags = ipc -> tx_flags ; cork -> page = NULL ; cork -> off = 0 ; return 0 ; }",
  "golden_answers": [
   "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct ip_options_rcu <vul-end> * opt ; <vul-start> -> opt , & opt -> <vul-start> + opt -> opt .\n"
  ],
  "generated_answer": "CWE-362 Fixed Code Lines are: <vul-start> ) ; struct ip_options_rcu <vul-end> * opt ; <vul-start> sizeof ( struct ip_options_rcu <vul-end> ) + opt <vul-start> + opt -> opt.\n"
 },
 {
  "id": 1545,
  "question": "CWE-22 Code Input Vulnerable Code Is: CWE-22 int set_interface_var ( const char * iface , const char * var , const char * name , uint32_t val ) { FILE * fp ; char spath [ 64 + IFNAMSIZ ] ; <vul-start> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <vul-end> return - 1 ; if ( access ( spath , F_OK ) != 0 ) return - 1 ; fp = fopen ( spath , \"w\" ) ; if ( ! fp ) { if ( name ) flog ( LOG_ERR , \"failed to set %s (%u) for %s: %s\" , name , val , iface , strerror ( errno ) ) ; return - 1 ; } fprintf ( fp , \"%u\" , val ) ; fclose ( fp ) ; return 0 ; }",
  "golden_answers": [
   "CWE-22 Fixed Code Lines are: <vul-start> sizeof ( spath ) ) return - 1 ; if ( strstr ( name , \"..\" ) || strchr ( name , '/'\n"
  ],
  "generated_answer": "CWE-22 Fixed Code Lines are: <vul-start>, iface ) < <vul-end> sizeof ( spath\n"
 },
 {
  "id": 1546,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void copy_to_user_policy ( struct xfrm_policy * xp , struct xfrm_userpolicy_info * p , int dir ) <vul-start> { <vul-end> memcpy ( & p -> sel , & xp -> selector , sizeof ( p -> sel ) ) ; memcpy ( & p -> lft , & xp -> lft , sizeof ( p -> lft ) ) ; memcpy ( & p -> curlft , & xp -> curlft , sizeof ( p -> curlft ) ) ; p -> priority = xp -> priority ; p -> index = xp -> index ; p -> sel . family = xp -> family ; p -> dir = dir ; p -> action = xp -> action ; p -> flags = xp -> flags ; p -> share = XFRM_SHARE_ANY ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> dir ) { memset ( p , 0 , sizeof ( * p ) ) ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> dir ) { if ( xp -> family == AF_INET ) p -> sel. family = AF_INET ; else p -> sel. family = AF_INET6 ;\n"
 },
 {
  "id": 1547,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static void setup_test_dir ( char * tmp_dir , const char * files , ... ) { va_list ap ; assert_se ( mkdtemp ( tmp_dir ) != NULL ) ; va_start ( ap , files ) ; while ( files != NULL ) { _cleanup_free_ char * path = strappend ( tmp_dir , files ) ; <vul-start> assert_se ( touch_file ( path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) == 0 ) ; <vul-end> files = va_arg ( ap , const char * ) ; } va_end ( ap ) ; }",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> , GID_INVALID , MODE_INVALID <vul-end> ) == 0\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start> ; assert_se ( safe_touch_file <vul-end> ( path, <vul-start>, GID_INVALID, MODE_INVALID <vul-end> ) == 0\n"
 },
 {
  "id": 1548,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static INLINE void add_token_no_extra ( TOKENEXTRA * * t , <vul-start> const vp9_prob * context_tree , <vul-end> uint8_t token , uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> t , const vpx_prob <vul-end> * context_tree ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> t, const vpx_prob <vul-end> * context_tree,\n"
 },
 {
  "id": 1549,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <vul-start> strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <vul-end> <vul-start> strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <vul-end> sizeof ( ualg -> cru_driver_name ) ) ; <vul-start> strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <vul-end> sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 ; ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = refcount_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <vul-start> strlcpy ( rl . type , \"larval\" , sizeof ( rl . type ) ) ; <vul-end> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ;",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> skb ) { strncpy <vul-end> ( ualg -> <vul-start> ) ) ; strncpy <vul-end> ( ualg -> <vul-start> ) ) ; strncpy <vul-end> ( ualg -> <vul-start> crypto_report_larval rl ; strncpy <vul-end> ( rl .\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> skb ) { strncpy <vul-end> ( ualg -> <vul-start> ) ) ; strncpy <vul-end> ( ualg -> <vul-start> ) ) ; strncpy <vul-end> ( ualg -> <vul-start> crypto_report_larval rl ; strncpy <vul-end> ( rl.\n"
 },
 {
  "id": 1550,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int packet_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; struct packet_sock * po = pkt_sk ( sk ) ; int ret ; if ( level != SOL_PACKET ) return - ENOPROTOOPT ; switch ( optname ) { case PACKET_ADD_MEMBERSHIP : case PACKET_DROP_MEMBERSHIP : { struct packet_mreq_max mreq ; int len = optlen ; memset ( & mreq , 0 , sizeof ( mreq ) ) ; if ( len < sizeof ( struct packet_mreq ) ) return - EINVAL ; if ( len > sizeof ( mreq ) ) len = sizeof ( mreq ) ; if ( copy_from_user ( & mreq , optval , len ) ) return - EFAULT ; if ( len < ( mreq . mr_alen + offsetof ( struct packet_mreq , mr_address ) ) ) return - EINVAL ; if ( optname == PACKET_ADD_MEMBERSHIP ) ret = packet_mc_add ( sk , & mreq ) ; else ret = packet_mc_drop ( sk , & mreq ) ; return ret ; } case PACKET_RX_RING : case PACKET_TX_RING : { union tpacket_req_u req_u ; int len ; switch ( po -> tp_version ) { case TPACKET_V1 : case TPACKET_V2 : len = sizeof ( req_u . req ) ; break ; case TPACKET_V3 : default : len = sizeof ( req_u . req3 ) ; break ; } if ( optlen < len ) return - EINVAL ; if ( copy_from_user ( & req_u . req , optval",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if ( <vul-start> . pg_vec ) { ret = <vul-end> - EBUSY ; <vul-start> - EBUSY ; } else { <vul-end> po -> tp_version <vul-start> = val ; ret = 0 ; } release_sock ( sk ) ; return ret ; <vul-end> } case PACKET_RESERVE\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> - EINVAL ; lock_sock ( sk ) ; <vul-start>. pg_vec ) { ret = <vul-end> - EBUSY ; <vul-start> - EBUSY ; goto out ; } <vul-start> val ) ) ) return ret ; out : release_sock ( sk ) <vul-end> ; return 0 <vul-start> return 0 ; out : release_sock ( sk ) ; return ret ;\n"
 },
 {
  "id": 1551,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static int dissect_u3v ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) { gint offset = 0 ; proto_tree * u3v_tree = NULL , * ccd_tree_flag , * u3v_telegram_tree = NULL , * ccd_tree = NULL ; gint data_length = 0 ; gint req_id = 0 ; gint command_id = - 1 ; gint status = 0 ; guint prefix = 0 ; proto_item * ti = NULL ; proto_item * item = NULL ; const char * command_string ; usb_conv_info_t * usb_conv_info ; gint stream_detected = FALSE ; gint control_detected = FALSE ; u3v_conv_info_t * u3v_conv_info = NULL ; gencp_transaction_t * gencp_trans = NULL ; usb_conv_info = ( usb_conv_info_t * ) data ; u3v_conv_info = ( u3v_conv_info_t * ) usb_conv_info -> class_data ; if ( ! u3v_conv_info ) { u3v_conv_info = wmem_new0 ( wmem_file_scope ( ) , u3v_conv_info_t ) ; <vul-start> usb_conv_info -> class_data = u3v_conv_info ; <vul-end> } prefix = tvb_get_letohl ( tvb , 0 ) ; if ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) { control_detected = TRUE ; } if ( ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix ) ) ) || ( usb_conv_info -> endpoint == u3v_conv_info -> ep_stream ) ) { stream_detected = TRUE ; } if ( control_detected || stream_detected ) { if ( usb_conv_info -> interfaceClass == IF_CLASS_UNKNOWN && usb_conv_info -> interfaceSubclass == IF_SUBCLASS_UNKNOWN ) { usb_conv_info ->",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> class_data = u3v_conv_info ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> class_data = u3v_conv_info ; } else if ( ( usb_conv_info -> class_data!= NULL ) && ( usb_conv_info -> class_data -> length < 2 ) ) { return 0\n"
 },
 {
  "id": 1552,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static int traceDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * option , * ovalue , * tok ; route = state -> route ; route -> trace = httpCreateTrace ( route -> trace ) ; for ( option = stok ( sclone ( value ) , \" \\\\t\" , & tok ) ; option ; option = stok ( 0 , \" \\\\t\" , & tok ) ) { <vul-start> option = stok ( option , \" =\\\\t,\" , & ovalue ) ; <vul-end> ovalue = strim ( ovalue , \"\\\\\"\\'\" , MPR_TRIM_BOTH ) ; if ( smatch ( option , \"content\" ) ) { httpSetTraceContentSize ( route -> trace , ( ssize ) getnum ( ovalue ) ) ; } else { httpSetTraceEventLevel ( route -> trace , option , atoi ( ovalue ) ) ; } } return 0 ; }",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> { option = ssplit <vul-end> ( option ,\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>, & ovalue, sizeof ( ovalue )\n"
 },
 {
  "id": 1553,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) { size_t width = ( 79 - strlen ( prefix ) ) ; if ( ! config -> mute ) { size_t len ; char * ptr ; char * print_buffer ; print_buffer = curlx_mvaprintf ( fmt , ap ) ; if ( ! print_buffer ) return ; len = strlen ( print_buffer ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( prefix , config -> errors ) ; if ( len > width ) { size_t cut = width - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } if ( 0 == cut ) cut = width - 1 ; ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( \"\\\\n\" , config -> errors ) ; ptr += cut + 1 ; <vul-start> len -= cut ; <vul-end> } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } curl_free ( print_buffer ) ; } }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> len -= cut + 1\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> + 1 ; if ( len < cut )\n"
 },
 {
  "id": 1554,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_iht8x8_64_add_c ( const int16_t * input , uint8_t * dest , int stride , <vul-end> int tx_type ) { int i , j ; <vul-start> int16_t out [ 8 * 8 ] ; <vul-end> <vul-start> int16_t * outptr = out ; <vul-end> <vul-start> int16_t temp_in [ 8 ] , temp_out [ 8 ] ; <vul-end> const transform_2d ht = IHT_8 [ tx_type ] ; for ( i = 0 ; i < 8 ; ++ i ) { ht . rows ( input , outptr ) ; input += 8 ; outptr += 8 ; } for ( i = 0 ; i < 8 ; ++ i ) { for ( j = 0 ; j < 8 ; ++ j ) temp_in [ j ] = out [ j * 8 + i ] ; ht . cols ( temp_in , temp_out ) ; <vul-start> for ( j = 0 ; j < 8 ; ++ j ) <vul-end> <vul-start> dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) <vul-end> <vul-start> + dest [ j * stride + i ] ) ; <vul-end> } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> vp9_iht8x8_64_add_c ( const tran_low_t <vul-end> * input , <vul-start> , j ; tran_low_t <vul-end> out [ 8 <vul-start> 8 ] ; tran_low_t <vul-end> * outptr = <vul-start> = out ; tran_low_t <vul-end> temp_in [ 8 <vul-start> ++ j ) { <vul-start> i ] = clip_pixel_add ( <vul-end> dest [ j <vul-start> + i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) ) ; } <vul-end> } }  \n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> vp9_iht8x8_64_add_c ( const tran_low_t <vul-end> * input, <vul-start>, j ; tran_low_t <vul-end> out [ 8 <vul-start> 8 ] ; tran_low_t <vul-end> * outptr = <vul-start> = out ; tran_low_t <vul-end> temp_in [ 8 <vul-start> ++ j ) { <vul-start> i ] = clip_pixel_add ( <vul-end> dest [ j <vul-start> + i ], ROUND_POWER_OF_TWO ( temp_out [ j ], 5 ) ) ; } <vul-end> } }  \n"
 },
 {
  "id": 1555,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 int sfgets ( void ) { struct pollfd pfd ; int pollret ; ssize_t readnb ; signed char seen_r = 0 ; <vul-start> static size_t scanned ; <vul-end> static size_t readnbd ; if ( scanned > ( size_t ) 0U ) { readnbd -= scanned ; memmove ( cmd , cmd + scanned , readnbd ) ; scanned = ( size_t ) 0U ; } pfd . fd = clientfd ; # ifdef __APPLE_CC__ pfd . events = POLLIN | POLLERR | POLLHUP ; # else pfd . events = POLLIN | POLLPRI | POLLERR | POLLHUP ; # endif while ( scanned < cmdsize ) { if ( scanned >= readnbd ) { pfd . revents = 0 ; while ( ( pollret = poll ( & pfd , 1U , idletime * 1000UL ) ) < 0 && errno == EINTR ) ; if ( pollret == 0 ) { return - 1 ; } if ( pollret <= 0 || ( pfd . revents & ( POLLERR | POLLHUP | POLLNVAL ) ) != 0 ) { return - 2 ; } if ( ( pfd . revents & ( POLLIN | POLLPRI ) ) == 0 ) { continue ; } if ( readnbd >= cmdsize ) { break ; } # ifdef WITH_TLS if ( tls_cnx != NULL ) { while ( ( readnb = SSL_read ( tls_cnx , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } else # endif { while ( ( readnb = read",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> = 0 ; <vul-end> if ( scanned\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> = 0 ; size_t scanned = 0 ; size_t <vul-end> readnbd ; if\n"
 },
 {
  "id": 1556,
  "question": "CWE-399 Code Input Vulnerable Code Is: CWE-399 void cib_remote_connection_destroy ( gpointer user_data ) { <vul-start> cib_client_t * client = user_data ; <vul-end> if ( client == NULL ) { return ; } crm_trace ( \"Cleaning up after client disconnect: %s/%s\" , crm_str ( client -> name ) , client -> id ) ; if ( client -> id != NULL ) { if ( ! g_hash_table_remove ( client_list , client -> id ) ) { crm_err ( \"Client %s not found in the hashtable\" , client -> name ) ; } } crm_trace ( \"Destroying %s (%p)\" , client -> name , user_data ) ; num_clients -- ; crm_trace ( \"Num unfree\\'d clients: %d\" , num_clients ) ; <vul-start> free ( client -> name ) ; <vul-end> free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ; <vul-start> free ( client ) ; <vul-end> crm_trace ( \"Freed the cib client\" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } return ; }",
  "golden_answers": [
   "CWE-399 Fixed Code Lines are: <vul-start> client = user_data ; int csock = 0 <vul-start> num_clients ) ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } if ( client -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) { void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ; csock = GPOINTER_TO_INT ( sock_ptr ) ; if ( client -> handshake_complete ) { gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ; } gnutls_deinit ( * client -> session ) ; gnutls_free ( client -> session ) ; } # endif } else { csock = GPOINTER_TO_INT ( client -> session ) ; } client -> session = NULL ; if ( csock > 0 ) { close ( csock ) ; } <vul-start> free ( client -> recv_buf ) ; free ( client\n"
  ],
  "generated_answer": "CWE-399 Fixed Code Lines are: <vul-start> user_data ) { int i ; for ( i = 0 ; i < num_clients ; ++ i ) { cib_client_t * client = & client -> client [ i ] ; <vul-end> crm_trace ( \"Cleaning up after client disconnect: %s/%s\" <vul-start> num_clients ) ; if ( client -> name!= NULL ) { crm_str ( client -> name ) ; free ( client -> callback_id ) ; free ( client -> id ) ; free ( client -> user ) ; } free ( client ) ; crm_trace ( \"Freed the cib client\" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } <vul-end> return ; } <vul-start> user ) ; <vul-end> crm_trace ( \"Freed the cib client\"\n"
 },
 {
  "id": 1557,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void test_modules ( ) { assert_true_rule ( <vul-start> \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.one + 1 == tests.constants.two \\\\\\n }\" , <vul-end> NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.foo == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.constants.empty == \\\\\"\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.empty() == \\\\\"\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[1].i == 1 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.struct_array[0].i == 1 or true \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.integer_array[0] == 0 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.integer_array[1] == 1 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_array[0] == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_array[2] == \\\\\"baz\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_dict[\\\\\"foo\\\\\"] == \\\\\"foo\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.string_dict[\\\\\"bar\\\\\"] == \\\\\"bar\\\\\" \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.isum(1,2) == 3 \\\\\\n }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.one + 1 == tests.constants.two \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.foo == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.constants.empty == \\\\\"\\\\\"  \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.empty() == \\\\\"\\\\\"  \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.struct_array[1].i == 1 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.struct_array[0].i == 1 or true \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[0] == 0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[1] == 1 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.integer_array[256] == 256 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_array[0] == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_array[2] == \\\\\"baz\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_dict[\\\\\"foo\\\\\"] == \\\\\"foo\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.string_dict[\\\\\"bar\\\\\"] == \\\\\"bar\\\\\" \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.isum(1,2) == 3 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.isum(1,2,3) == 6 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.fsum(1.0,2.0) == 3.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.fsum(1.0,2.0,3.0) == 6.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.foobar(1) == tests.foobar(1) \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.foobar(1) != tests.foobar(2) \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n       rule test { \\\\\\n        condition: tests.length(\\\\\"dummy\\\\\") == 5 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.struct_array[0].i == 1 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.isum(1,1) == 3 \\\\\\n      }\" <vul-end> , NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.fsum(1.0,1.0) == 3.0 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo/,\\\\\"foo\\\\\") == 3 \\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo/,\\\\\"bar\\\\\") == -1\\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo.bar/i,\\\\\"FOO\\\\\\\\nBAR\\\\\") == -1\\\\\\n      }\" , NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n      rule test { condition: tests.match(/foo.bar/is,\\\\\"FOO\\\\\\\\nBAR\\\\\") == 7\\\\\\n      }\" <vul-end> , NULL )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_one + 1 == tests.const_two \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_one == 3 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_false_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_empty == \\\\\"\\\\\" \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_array[0].i == 1 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_array[1].i == 1 or true \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_array[2].i == 2 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_array[3].i == 3 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_array[4].i == 4 \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_array[5].i == 5 or true \\\\\\n }\" <vul-end>, NULL ) <vul-start> ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_array[6].i == 6 \\\\\\n }\", NULL ) ; assert_true_rule ( \"import \\\\\"tests\\\\\" \\\\\\n rule test { \\\\\\n condition: tests.const_array[7].i == 6 \\\\\\n }\", NULL ) ;"
 },
 {
  "id": 1558,
  "question": "CWE-415 Code Input Vulnerable Code Is: CWE-415 int read_file ( struct sc_card * card , char * str_path , unsigned char * * data , size_t * data_len ) { struct sc_path path ; struct sc_file * file ; unsigned char * p ; int ok = 0 ; int r ; size_t len ; sc_format_path ( str_path , & path ) ; if ( SC_SUCCESS != sc_select_file ( card , & path , & file ) ) { goto err ; } <vul-start> len = file ? file -> size : 4096 ; <vul-end> p = realloc ( * data , len ) ; if ( ! p ) { goto err ; } * data = p ; * data_len = len ; r = sc_read_binary ( card , 0 , p , len , 0 ) ; if ( r < 0 ) goto err ; * data_len = r ; ok = 1 ; err : sc_file_free ( file ) ; return ok ; }",
  "golden_answers": [
   "CWE-415 Fixed Code Lines are: <vul-start> len = file && file -> size > 0\n"
  ],
  "generated_answer": "CWE-415 Fixed Code Lines are: <vul-start> err ; } if (! file ) { goto err ; }\n"
 },
 {
  "id": 1559,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , \"%s()\\\\n\" , __func__ ) ; <vul-start> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , <vul-end> flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , \"%s(), Received truncated frame (%zd < %zd)!\\\\n\" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , \"%s(), Starting IrTTP\\\\n\" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> __func__ ) ; msg -> msg_namelen = 0 ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ( sk, 1 <vul-end>, & err\n"
 },
 {
  "id": 1560,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , void * data ) <vul-end> { <vul-start> return usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , <vul-end> RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE , <vul-start> indx , 0 , data , size , 500 ) ; <vul-end> <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> u16 size , const <vul-start> data ) { void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <vul-end> usb_control_msg ( dev <vul-start> , 0 , buf <vul-end> , size , <vul-start> 500 ) ; kfree ( buf ) ; return ret ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * dev, int cmd, <vul-start> data ) { int ret ; ret = <vul-end> usb_control_msg ( dev <vul-start>, indx, cmd <vul-end>, data, <vul-start> 500 ) ; if ( ret < size ) { dev_err ( & dev -> dev, \"%s: failed to set registers: %d, %d\\\\n\", __func__, ret, size ) ; return - EIO ; } return ret ;\n"
 },
 {
  "id": 1561,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static __u8 * mr_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <vul-start> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <vul-end> hid_info ( hdev , \"fixing up button/consumer in HID report descriptor\\\\n\" ) ; rdesc [ 30 ] = 0x0c ; } return rdesc ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * rsize >= 31 <vul-end> && rdesc [\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * rsize >= 29 <vul-end> && rdesc [\n"
 },
 {
  "id": 1562,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 CURLcode Curl_smtp_escape_eob ( struct connectdata * conn , const ssize_t nread ) { ssize_t i ; ssize_t si ; struct Curl_easy * data = conn -> data ; struct SMTP * smtp = data -> req . protop ; char * scratch = data -> state . scratch ; char * newscratch = NULL ; char * oldscratch = NULL ; size_t eob_sent ; if ( ! scratch || data -> set . crlf ) { oldscratch = scratch ; <vul-start> scratch = newscratch = malloc ( 2 * data -> set . buffer_size ) ; <vul-end> if ( ! newscratch ) { failf ( data , \"Failed to alloc scratch buffer!\" ) ; return CURLE_OUT_OF_MEMORY ; } <vul-start> } <vul-end> eob_sent = smtp -> eob ; for ( i = 0 , si = 0 ; i < nread ; i ++ ) { if ( SMTP_EOB [ smtp -> eob ] == data -> req . upload_fromhere [ i ] ) { smtp -> eob ++ ; if ( 2 == smtp -> eob || SMTP_EOB_LEN == smtp -> eob ) smtp -> trailing_crlf = TRUE ; else smtp -> trailing_crlf = FALSE ; } else if ( smtp -> eob ) { memcpy ( & scratch [ si ] , & SMTP_EOB [ eob_sent ] , smtp -> eob - eob_sent ) ; si += smtp -> eob - eob_sent ; if ( SMTP_EOB [ 0 ] == data -> req . upload_fromhere [ i ] ) smtp -> eob = 1 ; else smtp -> eob = 0 ; eob_sent =",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ( 2 * UPLOAD_BUFSIZE <vul-end> ) ; if <vul-start> ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> = scratch ; if ( data -> set. buffer_size > 0 ) { <vul-start> ; } } else { failf ( data, \"Failed to allocate scratch buffer!\" ) ; return CURLE_OUT_OF_MEMORY ; } }\n"
 },
 {
  "id": 1563,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 mod_ty PyAST_obj2mod ( PyObject * ast , PyArena * arena , int mode ) { mod_ty res ; PyObject * req_type [ 3 ] ; <vul-start> char * req_name [ ] = { \"Module\" , \"Expression\" , \"Interactive\" } ; <vul-end> int isinstance ; req_type [ 0 ] = ( PyObject * ) Module_type ; req_type [ 1 ] = ( PyObject * ) Expression_type ; req_type [ 2 ] = ( PyObject * ) Interactive_type ; <vul-start> assert ( 0 <= mode && mode <= 2 ) ; <vul-end> if ( ! init_types ( ) ) return NULL ; isinstance = PyObject_IsInstance ( ast , req_type [ mode ] ) ; if ( isinstance == - 1 ) return NULL ; if ( ! isinstance ) { PyErr_Format ( PyExc_TypeError , \"expected %s node, got %.400s\" , req_name [ mode ] , Py_TYPE ( ast ) -> tp_name ) ; return NULL ; } if ( obj2ast_mod ( ast , & res , arena ) != 0 ) return NULL ; else return res ; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> \"Expression\" , \"Interactive\" , \"FunctionType\" <vul-start> && mode <= 3 <vul-end> ) ; if\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ] = { \"Expr\", \"Interactive\" } ; PyObject * type_comment <vul-end> ; int isinstance <vul-start> ) Interactive_type ; type_comment = ( PyObject * ) Type_comment_type ; <vul-start> mode <= 2 ) ; if ( type_comment!= NULL ) { PyErr_Format ( PyExc_TypeError, \"expected %s node got %.400s\", req_name [ mode ], Py_TYPE ( ast ) -> tp_name ) ; return NULL ; } assert ( 0 <= mode && mode <= 3\n"
 },
 {
  "id": 1564,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) { struct sock * sk ; struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; <vul-start> int n , len ; <vul-end> skb -> sk = NULL ; <vul-start> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <vul-end> len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ; <vul-start> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <vul-end> rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; return 0 ; } sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; if ( sk == NULL || sk_acceptq_is_full ( sk ) || ( make = rose_make_new ( sk ) ) == NULL ) { rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; return 0 ; } skb -> sk = make ; make -> sk_state = TCP_ESTABLISHED ; make_rose = rose_sk ( make ) ; make_rose -> lci = lci ; make_rose -> dest_addr = facilities . dest_addr ; make_rose -> dest_call = facilities . dest_call ; make_rose -> dest_ndigis = facilities . dest_ndigis ; for ( n = 0 ; n < facilities . dest_ndigis",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; int n <vul-end> ; skb -> <vul-start> rose_facilities_struct ) ) <vul-end> ; if ( <vul-start> -> data + ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <vul-end> & facilities )\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> rose_facilities_struct facilities ; struct rose_device * dev ; <vul-start> = NULL ; if ( skb -> len < ROSE_MIN_LEN ) { rose_transmit_clear_request ( neigh, lci, ROSE_INVALID_FACILITY, 76 ) ; return 0 ; } <vul-start> ) ) ; dev = rose_find_device ( skb -> data + len + 4, & facilities ) ; if (! dev ) { rose_transmit_clear_request ( neigh, lci, ROSE_NETWORK_CONGESTION, 120 ) ; return 0 ; } <vul-start>! rose_parse_facilities ( dev, <vul-start> -> data + n + sizeof ( struct rose_facilities_struct ) <vul-end>, & facilities\n"
 },
 {
  "id": 1565,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , \"\\\\n\\\\t %s (%u), length: %u\" , tok2str ( bgp_capcode_values , \"Unknown\" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { <vul-start> case BGP_CAPCODE_MP : <vul-end> ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\tAFI %s (%u), SAFI %s (%u)\" , tok2str ( af_values , \"Unknown\" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , \"Unknown\" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ; ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\tRestart Flags: [%s], Restart Time %us\" , ( ( opt [ i + 2 ] ) & 0x80 ) ? \"R\" : \"none\" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , \"\\\\n\\\\t\\\\t AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %s\" , tok2str",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> case BGP_CAPCODE_MP : ND_TCHECK_8BITS ( opt + i + 5 ) ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> case BGP_CAPCODE_MP : ND_TCHECK_16BITS ( opt + i + 2 ) ;\n"
 },
 {
  "id": 1566,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static void parse_sec_attr_44 ( sc_file_t * file , const u8 * buf , size_t len ) { const int df_idx [ 8 ] = { SC_AC_OP_DELETE , SC_AC_OP_CREATE , SC_AC_OP_CREATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , SC_AC_OP_LOCK , SC_AC_OP_DELETE , - 1 } ; const int ef_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_UPDATE , SC_AC_OP_WRITE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; const int efi_idx [ 8 ] = { SC_AC_OP_READ , SC_AC_OP_ERASE , SC_AC_OP_UPDATE , SC_AC_OP_INVALIDATE , SC_AC_OP_REHABILITATE , - 1 , SC_AC_OP_ERASE , - 1 } ; u8 bValue ; int i ; int iKeyRef = 0 ; int iMethod ; int iPinCount ; int iOffset = 0 ; int iOperation ; const int * p_idx ; while ( len > 1 ) { size_t iACLen = buf [ iOffset ] & 0x0F ; if ( iACLen > len ) break ; iMethod = SC_AC_NONE ; if ( buf [ iOffset ] & 0X80 ) { size_t iParmLen = 1 ; size_t iKeyLen = 0 ; if ( buf [ iOffset ] & 0x20 ) iKeyLen ++ ; if ( buf [ iOffset + 1 ] & 0x40 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x20 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x10 ) iParmLen ++ ; if ( buf [ iOffset + 1 ] & 0x08 ) iParmLen ++ ; if ( iKeyLen ) { int iSC ; if ( len < 1 + ( size_t ) iACLen ) break ;",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> iPinCount = iACLen > 0 ? iACLen - 1 : 0 <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> break ; } if ( iACLen < 1 ) break ;\n"
 },
 {
  "id": 1567,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static apr_status_t parse_chunk_size ( http_ctx_t * ctx , const char * buffer , apr_size_t len , int linelimit ) { apr_size_t i = 0 ; while ( i < len ) { char c = buffer [ i ] ; ap_xlate_proto_from_ascii ( & c , 1 ) ; <vul-start> if ( ctx -> state == BODY_CHUNK_END ) { <vul-end> if ( c == LF ) { <vul-start> ctx -> state = BODY_CHUNK ; <vul-end> } i ++ ; continue ; } if ( ctx -> state == BODY_CHUNK ) { if ( ! apr_isxdigit ( c ) ) { <vul-start> return APR_EGENERAL ; <vul-end> } else { ctx -> state = BODY_CHUNK_PART ; } ctx -> remaining = 0 ; <vul-start> ctx -> chunkbits = sizeof ( long ) * 8 ; <vul-end> ctx -> chunk_used = 0 ; } <vul-start> if ( c == ';' || c == CR ) { <vul-end> ctx -> state = BODY_CHUNK_EXT ; } <vul-start> else if ( c == LF ) { <vul-end> if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state != BODY_CHUNK_EXT ) { <vul-start> int xvalue = 0 ; <vul-end> if ( ! ctx -> remaining && c == '0' ) { i ++ ; <vul-start> continue ; <vul-end> } if ( c >= '0' && c <= '9' ) { xvalue = c - '0' ; } else if ( c >= 'A' && c <= 'F' ) { xvalue = c -",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> state == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF <vul-start> state = BODY_CHUNK ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <vul-start> ) { return APR_EINVAL <vul-end> ; } else <vul-start> = sizeof ( apr_off_t <vul-end> ) * 8 <vul-start> ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <vul-end> ) { ctx <vul-start> else if ( ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART <vul-end> ) { int <vul-start> { int xvalue <vul-end> ; if ( <vul-start> ++ ; continue ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <vul-start> else { return APR_EINVAL <vul-end> ; } ctx <vul-start> | xvalue ; if ( <vul-end> ctx -> remaining <vul-start> APR_ENOSPC ; } } else { return APR_EGENERAL ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> ; if ( i >= len && ctx -> chunk_used >= linelimit ) { return APR_EGENERAL ; } if ( <vul-start> LF ) { i ++ ; continue ; } if ( ctx -> state == BODY_CHUNK ) { if (! apr_isxdigit ( c ) ) { return APR_EGENERAL ; } else { <vul-start> = BODY_CHUNK ; } i ++ ; continue ; } <vul-end> } if ( <vul-start> ) ) { i ++ ; continue ; } if ( ctx -> chunkbits == 0 ) { return APR_ENOSPC ; } <vul-start> = 0 ; <vul-end> } else if <vul-start> LF ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_END ) { if ( c == LF ) { ctx -> state = BODY_CHUNK ; } else { ctx -> state = BODY_CHUNK_PART ; } ctx -> remaining = 0 ; ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits <= 0 || ctx -> remaining < 0 ) { return APR_ENOSPC ; } } i ++ ; } ctx -> chunk_used += len ; if ( ctx -> chunk_used < 0 || ctx -> chunk_used > linelimit ) { <vul-end> return APR_ENOSPC ; <vul-start> APR_ENOSPC ; } <vul-end>      \n"
 },
 {
  "id": 1568,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 pdf_t * pdf_new ( const char * name ) { const char * n ; pdf_t * pdf ; <vul-start> pdf = calloc ( 1 , sizeof ( pdf_t ) ) ; <vul-end> if ( name ) { if ( ( n = strrchr ( name , '/' ) ) ) ++ n ; else n = name ; <vul-start> pdf -> name = malloc ( strlen ( n ) + 1 ) ; <vul-end> strcpy ( pdf -> name , n ) ; } else { <vul-start> pdf -> name = malloc ( strlen ( \"Unknown\" ) + 1 ) ; <vul-end> strcpy ( pdf -> name , \"Unknown\" ) ; } return pdf ; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ; pdf = safe_calloc ( <vul-end> sizeof ( pdf_t <vul-start> -> name = safe_calloc <vul-end> ( strlen ( <vul-start> -> name = safe_calloc <vul-end> ( strlen (\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; pdf = safe_calloc ( <vul-end> sizeof ( pdf_t <vul-start> -> name = safe_calloc <vul-end> ( strlen ( <vul-start> -> name = safe_calloc <vul-end> ( strlen (\n"
 },
 {
  "id": 1569,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int pci_emul_alloc_resource ( uint64_t * baseptr , uint64_t limit , uint64_t size , uint64_t * addr ) { uint64_t base ; <vul-start> assert ( ( size & ( size - 1 ) ) == 0 ) ; <vul-end> base = roundup2 ( * baseptr , size ) ; if ( base + size <= limit ) { * addr = base ; * baseptr = base + size ; return 0 ; } else return - 1 ; }",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> uint64_t base ; if <vul-end> ( ( size <vul-start> 1 ) ) != 0 ) { pr_err ( \"%s: Cannot alloc invalid size %lld resource\\\\n\" , __func__ , size ) ; return - 1 ; } <vul-end> base = roundup2\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start> uint64_t base ; if ( size > UINT64_MAX - 1 ) { return - 1 ; } <vul-end> base = roundup2\n"
 },
 {
  "id": 1570,
  "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ; <vul-start> krb5_data rspac ; <vul-end> const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signedpath = 0 ; Key * tkey_check ; Key * tkey_sign ; int flags = HDB_F_FOR_TGS_REQ ; memset ( & sessionkey , 0 , sizeof ( sessionkey ) ) ; memset",
  "golden_answers": [
   "CWE-295 Fixed Code Lines are: <vul-start> ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <vul-start> , cp , tgt_realm ,\n"
  ],
  "generated_answer": "CWE-295 Fixed Code Lines are: <vul-start> ; krb5_data rspac = NULL <vul-start> out ; } if (! rspac ) { ret = KRB5KDC_ERR_NOENTRY ; krb5_free_principal ( context, sp ) ; ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; }\n"
 },
 {
  "id": 1571,
  "question": "CWE-763 Code Input Vulnerable Code Is: CWE-763 static int remarkupvals ( global_State * g ) { lua_State * thread ; lua_State * * p = & g -> twups ; int work = 0 ; while ( ( thread = * p ) != NULL ) { work ++ ; lua_assert ( ! isblack ( thread ) ) ; if ( isgray ( thread ) && thread -> openupval != NULL ) p = & thread -> twups ; else { UpVal * uv ; <vul-start> * p = thread -> twups ; <vul-end> thread -> twups = thread ; for ( uv = thread -> openupval ; uv != NULL ; uv = uv -> u . open . next ) { <vul-start> work ++ ; <vul-end> if ( ! iswhite ( uv ) ) markvalue ( g , uv -> v ) ; } } } return work ; }",
  "golden_answers": [
   "CWE-763 Fixed Code Lines are: <vul-start> * uv ; lua_assert ( ! isold ( thread ) || thread -> openupval == NULL ) ; <vul-start> next ) { lua_assert ( getage ( uv ) <= getage ( thread ) ) ;\n"
  ],
  "generated_answer": "CWE-763 Fixed Code Lines are: <vul-start> * uv ; int count = 0 ; <vul-start> next ) { if ( count == 1 ) count ++ ;\n"
 },
 {
  "id": 1572,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ; <vul-start> px -> ft -> data = px ; <vul-end> px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> size ) ; if ( ! px -> ft ) { return FALSE ; }\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> size ) ; if ( px -> ft == NULL ) return FALSE ;\n"
 },
 {
  "id": 1573,
  "question": "CWE-284 Code Input Vulnerable Code Is: CWE-284 int bta_co_rfc_data_outgoing_size ( void * user_data , int * size ) { pthread_mutex_lock ( & slot_lock ) ; uint32_t id = ( uintptr_t ) user_data ; int ret = false ; * size = 0 ; rfc_slot_t * slot = find_rfc_slot_by_id ( id ) ; if ( ! slot ) goto out ; <vul-start> if ( ioctl ( slot -> fd , FIONREAD , size ) == 0 ) { <vul-end> ret = true ; } else { LOG_ERROR ( \"%s unable to determine bytes remaining to be read on fd %d: %s\" , __func__ , slot -> fd , strerror ( errno ) ) ; cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; return ret ; }",
  "golden_answers": [
   "CWE-284 Fixed Code Lines are: <vul-start> ; if ( TEMP_FAILURE_RETRY ( <vul-start> FIONREAD , size )\n"
  ],
  "generated_answer": "CWE-284 Fixed Code Lines are: <vul-start> ; if ( TEMP_FAILURE_RETRY ( <vul-start> FIONREAD, size )\n"
 },
 {
  "id": 1574,
  "question": "CWE-918 Code Input Vulnerable Code Is: CWE-918 static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , \"Source string too long\" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , \"Read from client failed: %s\" , errbuf ) ; return - 1 ; } source [ nread ] = '\\\\0' ; plen -= nread ; <vul-start> if ( ( fp = pcap_open_live ( source , <vul-end> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error",
  "golden_answers": [
   "CWE-918 Fixed Code Lines are: <vul-start> ; if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , \"Source string refers to a remote device\" ) ; goto error ; } if (\n"
  ],
  "generated_answer": "CWE-918 Fixed Code Lines are: <vul-start> ( fp = pcap_open_live2 <vul-end> ( source,\n"
 },
 {
  "id": 1575,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int archive_read_format_rar_read_data ( struct archive_read * a , const void * * buff , size_t * size , int64_t * offset ) { struct rar * rar = ( struct rar * ) ( a -> format -> data ) ; int ret ; if ( rar -> has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW ) { rar -> has_encrypted_entries = 0 ; } if ( rar -> bytes_unconsumed > 0 ) { __archive_read_consume ( a , rar -> bytes_unconsumed ) ; rar -> bytes_unconsumed = 0 ; } * buff = NULL ; if ( rar -> entry_eof || rar -> offset_seek >= rar -> unp_size ) { * size = 0 ; * offset = rar -> offset ; if ( * offset < rar -> unp_size ) * offset = rar -> unp_size ; return ( ARCHIVE_EOF ) ; } switch ( rar -> compression_method ) { case COMPRESS_METHOD_STORE : ret = read_data_stored ( a , buff , size , offset ) ; break ; case COMPRESS_METHOD_FASTEST : case COMPRESS_METHOD_FAST : case COMPRESS_METHOD_NORMAL : case COMPRESS_METHOD_GOOD : case COMPRESS_METHOD_BEST : ret = read_data_compressed ( a , buff , size , offset ) ; <vul-start> if ( ret != ARCHIVE_OK && ret != ARCHIVE_WARN ) <vul-end> __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context ) ; <vul-start> break ; <vul-end> default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Unsupported compression method for RAR file.\" ) ; ret = ARCHIVE_FATAL ; break ; } return ( ret ) ; }",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> != ARCHIVE_WARN ) { <vul-start> ppmd7_context ) ; rar -> start_new_table = 1 ; }\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start>!= ARCHIVE_WARN ) { if ( rar -> ppmd7_context. pmd7_context ) { <vul-start> ppmd7_context ) ; rar -> ppmd7_context. pmd7_context = NULL ; } }\n"
 },
 {
  "id": 1576,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 void handle_stdfmna ( struct pt_regs * regs , unsigned long sfar , unsigned long sfsr ) { unsigned long pc = regs -> tpc ; unsigned long tstate = regs -> tstate ; u32 insn ; u64 value ; u8 freg ; int flag ; struct fpustate * f = FPUSTATE ; if ( tstate & TSTATE_PRIV ) die_if_kernel ( \"stdfmna from kernel\" , regs ) ; <vul-start> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , sfar ) ; <vul-end> if ( test_thread_flag ( TIF_32BIT ) ) pc = ( u32 ) pc ; if ( get_user ( insn , ( u32 __user * ) pc ) != - EFAULT ) { int asi = decode_asi ( insn , regs ) ; freg = ( ( insn >> 25 ) & 0x1e ) | ( ( insn >> 20 ) & 0x20 ) ; value = 0 ; flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; if ( ( asi > ASI_SNFL ) || ( asi < ASI_P ) ) goto daex ; save_and_clear_fpu ( ) ; if ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) value = * ( u64 * ) & f -> regs [ freg ] ; switch ( asi ) { case ASI_P : case ASI_S : break ; case ASI_PL : case ASI_SL : value = __swab64p ( & value ) ; break ; default : goto daex ; } if ( put_user ( value >> 32 , ( u32 __user * ) sfar ) || __put_user ( (",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <vul-end> , regs ,\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> PERF_COUNT_SW_ALIGNMENT_FAULTS, 1 <vul-end>, regs,\n"
 },
 {
  "id": 1577,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 const vpx_codec_cx_pkt_t * vpx_codec_get_cx_data ( vpx_codec_ctx_t * ctx , vpx_codec_iter_t * iter ) { const vpx_codec_cx_pkt_t * pkt = NULL ; if ( ctx ) { if ( ! iter ) ctx -> err = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else <vul-start> pkt = ctx -> iface -> enc . get_cx_data ( ctx -> priv -> alg_priv , iter ) ; <vul-end> } if ( pkt && pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { vpx_codec_priv_t * const priv = ctx -> priv ; char * const dst_buf = ( char * ) priv -> enc . cx_data_dst_buf . buf ; if ( dst_buf && pkt -> data . raw . buf != dst_buf && pkt -> data . raw . sz + priv -> enc . cx_data_pad_before + priv -> enc . cx_data_pad_after <= priv -> enc . cx_data_dst_buf . sz ) { vpx_codec_cx_pkt_t * modified_pkt = & priv -> enc . cx_data_pkt ; memcpy ( dst_buf + priv -> enc . cx_data_pad_before , pkt -> data . raw . buf , pkt -> data . raw . sz ) ; * modified_pkt = * pkt ; modified_pkt -> data . raw . buf = dst_buf ; modified_pkt -> data . raw . sz += priv -> enc . cx_data_pad_before + priv -> enc . cx_data_pad_after ; pkt = modified_pkt ; } if ( dst_buf == pkt -> data",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> . get_cx_data ( get_alg_priv ( ctx ) <vul-end> , iter )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>. get_cx_data ( get_alg_priv ( ctx ) <vul-end>, iter )\n"
 },
 {
  "id": 1578,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int vp9_get_qindex ( const struct segmentation * seg , int segment_id , int base_qindex ) { <vul-start> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_ALT_Q ) ) { <vul-end> <vul-start> const int data = vp9_get_segdata ( seg , segment_id , SEG_LVL_ALT_Q ) ; <vul-end> const int seg_qindex = seg -> abs_delta == SEGMENT_ABSDATA ? data : base_qindex + data ; return clamp ( seg_qindex , 0 , MAXQ ) ; } else { return base_qindex ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { if ( segfeature_active <vul-end> ( seg , <vul-start> int data = get_segdata <vul-end> ( seg ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { if ( segfeature_active <vul-end> ( seg, <vul-start> int data = get_segdata <vul-end> ( seg,\n"
 },
 {
  "id": 1579,
  "question": "CWE-77 Code Input Vulnerable Code Is: CWE-77 void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) { char * buf = mutt_str_strdup ( src ) ; imap_utf_encode ( idata , & buf ) ; <vul-start> imap_quote_string ( dest , dlen , buf ) ; <vul-end> FREE ( & buf ) ; }",
  "golden_answers": [
   "CWE-77 Fixed Code Lines are: <vul-start> dlen , buf , false\n"
  ],
  "generated_answer": "CWE-77 Fixed Code Lines are: <vul-start> buf ) ; if (! buf ) return ;\n"
 },
 {
  "id": 1580,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 int config__parse_args ( struct mosquitto_db * db , struct mosquitto__config * config , int argc , char * argv [ ] ) { int i ; int port_tmp ; for ( i = 1 ; i < argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , \"-c\" ) || ! strcmp ( argv [ i ] , \"--config-file\" ) ) { if ( i < argc - 1 ) { db -> config_file = argv [ i + 1 ] ; if ( config__read ( db , config , false ) ) { log__printf ( NULL , MOSQ_LOG_ERR , \"Error: Unable to open configuration file.\" ) ; return MOSQ_ERR_INVAL ; } } else { log__printf ( NULL , MOSQ_LOG_ERR , \"Error: -c argument given, but no config file specified.\" ) ; return MOSQ_ERR_INVAL ; } i ++ ; } else if ( ! strcmp ( argv [ i ] , \"-d\" ) || ! strcmp ( argv [ i ] , \"--daemon\" ) ) { config -> daemon = true ; } else if ( ! strcmp ( argv [ i ] , \"-h\" ) || ! strcmp ( argv [ i ] , \"--help\" ) ) { print_usage ( ) ; return MOSQ_ERR_INVAL ; } else if ( ! strcmp ( argv [ i ] , \"-p\" ) || ! strcmp ( argv [ i ] , \"--port\" ) ) { if ( i < argc - 1 ) { port_tmp = atoi ( argv [ i + 1 ] ) ; if ( port_tmp < 1",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start> endif config -> default_listener. socket_domain = config -> default_listener. socket_domain ; config ->\n"
 },
 {
  "id": 1581,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void yv12_extend_frame_bottom_c ( YV12_BUFFER_CONFIG * ybf ) { int i ; unsigned char * src_ptr1 , * src_ptr2 ; unsigned char * dest_ptr2 ; unsigned int Border ; int plane_stride ; int plane_height ; Border = ybf -> border ; plane_stride = ybf -> y_stride ; plane_height = ybf -> y_height ; src_ptr1 = ybf -> y_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) Border ; i ++ ) { <vul-start> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <vul-end> dest_ptr2 += plane_stride ; } plane_stride = ybf -> uv_stride ; plane_height = ybf -> uv_height ; Border /= 2 ; src_ptr1 = ybf -> u_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <vul-start> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <vul-end> dest_ptr2 += plane_stride ; } src_ptr1 = ybf -> v_buffer - Border ; src_ptr2 = src_ptr1 + ( plane_height * plane_stride ) - plane_stride ; dest_ptr2 = src_ptr2 + plane_stride ; for ( i = 0 ; i < ( int ) ( Border ) ; i ++ ) { <vul-start> vpx_memcpy ( dest_ptr2 , src_ptr2 , plane_stride ) ; <vul-end> dest_ptr2 += plane_stride ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2 , <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2 , <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2 ,\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2, <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2, <vul-start> ++ ) { memcpy <vul-end> ( dest_ptr2,\n"
 },
 {
  "id": 1582,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> static void <vul-end> swabHorDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <vul-start> horDiff32 ( tif , cp0 , cc ) ; <vul-end> TIFFSwabArrayOfLong ( wp , wc ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> swabHorDiff32 ( TIFF <vul-start> / 4 ; if ( ! <vul-start> , cc ) ) return 0 <vul-start> wc ) ; return 1 ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start>     static int <vul-end> swabHorDiff32 ( TIFF <vul-start> / 4 ; if ( wc > 0xFFFFFFFFU - 3 ) { TIFFErrorExt ( tif -> tif_clientdata, \"horDiff32\", \"%s\", \"(too many nested levels, not recursing)\" ) ; return 0 ; } <vul-start> wc ) ; return 1 ;\n"
 },
 {
  "id": 1583,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 IHEVCD_ERROR_T ihevcd_parse_sps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 i ; WORD32 vps_id ; WORD32 sps_max_sub_layers ; WORD32 sps_id ; WORD32 sps_temporal_id_nesting_flag ; sps_t * ps_sps ; profile_tier_lvl_info_t s_ptl ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 ctb_log2_size_y = 0 ; BITS_PARSE ( \"video_parameter_set_id\" , value , ps_bitstrm , 4 ) ; vps_id = value ; vps_id = CLIP3 ( vps_id , 0 , MAX_VPS_CNT - 1 ) ; BITS_PARSE ( \"sps_max_sub_layers_minus1\" , value , ps_bitstrm , 3 ) ; sps_max_sub_layers = value + 1 ; sps_max_sub_layers = CLIP3 ( sps_max_sub_layers , 1 , 7 ) ; BITS_PARSE ( \"sps_temporal_id_nesting_flag\" , value , ps_bitstrm , 1 ) ; sps_temporal_id_nesting_flag = value ; ret = ihevcd_profile_tier_level ( ps_bitstrm , & ( s_ptl ) , 1 , ( sps_max_sub_layers - 1 ) ) ; UEV_PARSE ( \"seq_parameter_set_id\" , value , ps_bitstrm ) ; sps_id = value ; if ( ( sps_id >= MAX_SPS_CNT ) || ( sps_id < 0 ) ) { if ( ps_codec -> i4_sps_done ) return IHEVCD_UNSUPPORTED_SPS_ID ; else sps_id = 0 ; } ps_sps = ( ps_codec -> s_parse . ps_sps_base + MAX_SPS_CNT - 1 ) ; ps_sps -> i1_sps_id = sps_id ; ps_sps -> i1_vps_id = vps_id ; ps_sps -> i1_sps_max_sub_layers = sps_max_sub_layers ; ps_sps -> i1_sps_temporal_id_nesting_flag = sps_temporal_id_nesting_flag ; ps_codec -> i4_sps_id = sps_id ; memcpy ( & ps_sps -> s_ptl , & s_ptl , sizeof ( profile_tier_lvl_info_t ) ) ; UEV_PARSE ( \"chroma_format_idc\" , value , ps_bitstrm ) ; ps_sps -> i1_chroma_format_idc = value",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) { return IHEVCD_INVALID_PARAMETER ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> 1 ) ; if ( ( ps_sps -> i2_pic_width_in_luma_samples < 0 ) || ( ps_sps -> i2_pic_height_in_luma_samples < 0 ) ) { return IHEVCD_INVALID_PARAMETER ; }\n"
 },
 {
  "id": 1584,
  "question": "CWE-264 Code Input Vulnerable Code Is: CWE-264 static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , <vul-start> u16 selector , int seg , u8 cpl , bool in_task_switch ) <vul-end> { struct desc_struct seg_desc , old_desc ; u8 dpl , rpl ; unsigned err_vec = GP_VECTOR ; u32 err_code = 0 ; bool null_selector = ! ( selector & ~ 0x3 ) ; ulong desc_addr ; int ret ; u16 dummy ; u32 base3 = 0 ; memset ( & seg_desc , 0 , sizeof seg_desc ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) { ctxt -> ops -> get_segment ( ctxt , & dummy , & seg_desc , NULL , seg ) ; set_desc_base ( & seg_desc , selector << 4 ) ; goto load ; } else if ( seg <= VCPU_SREG_GS && ctxt -> mode == X86EMUL_MODE_VM86 ) { set_desc_base ( & seg_desc , selector << 4 ) ; set_desc_limit ( & seg_desc , 0xffff ) ; seg_desc . type = 3 ; seg_desc . p = 1 ; seg_desc . s = 1 ; seg_desc . dpl = 3 ; goto load ; } rpl = selector & 3 ; if ( ( seg == VCPU_SREG_CS || ( seg == VCPU_SREG_SS && ( ctxt -> mode != X86EMUL_MODE_PROT64 || rpl != cpl ) ) || seg == VCPU_SREG_TR ) && null_selector ) goto exception ; if ( seg == VCPU_SREG_TR && ( selector & ( 1 << 2 ) ) ) goto exception ; if ( null_selector ) goto load ; ret = read_segment_descriptor ( ctxt , selector , & seg_desc , & desc_addr ) ;",
  "golden_answers": [
   "CWE-264 Fixed Code Lines are: <vul-start> , bool in_task_switch , struct desc_struct * desc <vul-start> seg ) ; if ( desc ) * desc = seg_desc ;\n"
  ],
  "generated_answer": "CWE-264 Fixed Code Lines are: <vul-start>, bool in_task_switch, bool in_user_mode <vul-start> seg ) ; if (! in_user_mode ) err_vec = GP_VECTOR ;\n"
 },
 {
  "id": 1585,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 <vul-start> void vp9_encode_mv ( VP9_COMP * cpi , vp9_writer * w , <vul-end> const MV * mv , const MV * ref , const nmv_context * mvctx , int usehp ) { const MV diff = { mv -> row - ref -> row , mv -> col - ref -> col } ; const MV_JOINT_TYPE j = vp9_get_mv_joint ( & diff ) ; usehp = usehp && vp9_use_mv_hp ( ref ) ; vp9_write_token ( w , vp9_mv_joint_tree , mvctx -> joints , & mv_joint_encodings [ j ] ) ; if ( mv_joint_vertical ( j ) ) encode_mv_component ( w , diff . row , & mvctx -> comps [ 0 ] , usehp ) ; if ( mv_joint_horizontal ( j ) ) encode_mv_component ( w , diff . col , & mvctx -> comps [ 1 ] , usehp ) ; <vul-start> if ( ! cpi -> dummy_packing && cpi -> sf . auto_mv_step_size ) { <vul-end> unsigned int maxv = MAX ( abs ( mv -> row ) , abs ( mv -> col ) ) >> 3 ; cpi -> max_mv_magnitude = MAX ( maxv , cpi -> max_mv_magnitude ) ; } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> * cpi , vpx_writer <vul-end> * w , <vul-start> ; if ( <vul-end> cpi -> sf <vul-start> cpi -> sf . mv\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> * cpi, vpx_writer * w, const MV_SPEED * mv_w, <vul-end> vp9_writer * w <vul-start> usehp ) ; <vul-end> }    \n"
 },
 {
  "id": 1586,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 static const char * escape_xml ( const char * text ) { static char * escaped ; static size_t escaped_size ; char * out ; size_t len ; <vul-start> for ( out = escaped , len = 0 ; * text ; ++ len , ++ out , ++ text ) { <vul-end> if ( ( len + 8 ) > escaped_size ) { char * bigger_escaped ; escaped_size += 128 ; bigger_escaped = realloc ( escaped , escaped_size ) ; if ( ! bigger_escaped ) { free ( escaped ) ; escaped = NULL ; escaped_size = 0 ; return \">>> out of memory <<<\" ; } out = bigger_escaped + len ; escaped = bigger_escaped ; } switch ( * text ) { case '&' : strcpy ( out , \"&amp;\" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '<' : strcpy ( out , \"&lt;\" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; case '>' : strcpy ( out , \"&gt;\" ) ; len += strlen ( out ) - 1 ; out = escaped + len ; break ; default : * out = * text ; break ; } } * out = '\\\\x0' ; return escaped ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> size_t len ; if ( ! strlen ( text ) ) return \"empty string\" ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> text ) { if ( len >= escaped_size ) return NULL ;\n"
 },
 {
  "id": 1587,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 BOOL transport_connect_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> layer == TRANSPORT_LAYER_TSG ) return TRUE ; if ( ! transport_connect_tls ( transport ) ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { if ( ! connectErrorCode ) connectErrorCode = AUTHENTICATIONERROR ; fprintf ( stderr , \"Authentication failure, check credentials.\\\\n\" \"If credentials are valid, the NTLMSSP implementation may be to blame.\\\\n\" ) ; credssp_free ( transport -> credssp ) ; <vul-start> return FALSE ; <vul-end> } credssp_free ( transport -> credssp ) ; return TRUE ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; transport -> credssp = NULL ;\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> credssp ) ; transport -> credssp = NULL ;\n"
 },
 {
  "id": 1588,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp9_setup_past_independence ( VP9_COMMON * cm ) { struct loopfilter * const lf = & cm -> lf ; int i ; vp9_clearall_segfeatures ( & cm -> seg ) ; cm -> seg . abs_delta = SEGMENT_DELTADATA ; <vul-start> if ( cm -> last_frame_seg_map ) <vul-end> <vul-start> vpx_memset ( cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; <vul-end> vp9_zero ( lf -> last_ref_deltas ) ; vp9_zero ( lf -> last_mode_deltas ) ; set_default_lf_deltas ( lf ) ; lf -> last_sharpness_level = - 1 ; vp9_default_coef_probs ( cm ) ; <vul-start> vp9_init_mode_probs ( & cm -> fc ) ; <vul-end> <vul-start> vp9_init_mv_probs ( cm ) ; <vul-end> if ( cm -> frame_type == KEY_FRAME || cm -> error_resilient_mode || cm -> reset_frame_context == 3 ) { for ( i = 0 ; i < FRAME_CONTEXTS ; ++ i ) <vul-start> cm -> frame_contexts [ i ] = cm -> fc ; <vul-end> } else if ( cm -> reset_frame_context == 2 ) { <vul-start> cm -> frame_contexts [ cm -> frame_context_idx ] = cm -> fc ; <vul-end> } <vul-start> if ( frame_is_intra_only ( cm ) ) <vul-end> <vul-start> vpx_memset ( cm -> prev_mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * <vul-end> <vul-start> sizeof ( * cm -> prev_mip ) ) ; <vul-end> vpx_memset ( cm -> mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> mip ) ) ; vp9_zero ( cm -> ref_frame_sign_bias ) ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> cm -> last_frame_seg_map && ! cm -> frame_parallel_decode ) memset <vul-end> ( cm -> <vul-start> cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; if ( cm -> current_frame_seg_map ) memset ( cm -> current_frame_seg_map <vul-start> cm ) ; init_mode_probs ( <vul-end> cm -> fc <vul-start> ( cm ) ; cm -> fc -> initialized = 1 <vul-start> i ] = * <vul-start> frame_context_idx ] = * <vul-start> ( cm ) && <vul-end> cm -> prev_mip <vul-start> cm -> prev_mip && ! cm -> frame_parallel_decode ) memset ( cm -> prev_mip , 0 , <vul-end> cm -> mi_stride <vul-start> cm -> prev_mip <vul-end> ) ) ;\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> -> last_frame_seg_map ) memset <vul-end> ( cm -> <vul-start> -> mi_cols ), cm -> mi_rows * cm -> mi_cols <vul-start> cm ) ; memset <vul-end> ( & cm <vul-start> cm -> fc, 0, cm -> mi_rows * cm -> mi_cols ) ; vp9_zero ( lf -> last_ref_deltas ) ; vp9_zero ( lf -> last_mode_deltas ) ; set_default_lf_deltas ( lf ) ; lf -> last_sharpness_level = - 1 ; vp9_default_coef_probs ( cm ) ; vp9_init_mode_probs ( cm ) ; vp9_init_mv_probs ( cm ) ; if ( cm -> frame_type == KEY_FRAME || cm -> error_resilient_mode || cm -> reset_frame_context == 3 ) { <vul-start> cm -> fc ; } else if ( cm -> reset_frame_context == 2 ) { <vul-start> cm -> fc ; } if ( frame_is_intra_only ( cm ) ) memset <vul-end> ( cm -> <vul-start> cm ) ) memset <vul-end> ( cm -> <vul-start> ) ) ; memset <vul-end> ( cm ->\n"
 },
 {
  "id": 1589,
  "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void ip_expire ( unsigned long arg ) { struct ipq * qp ; struct net * net ; qp = container_of ( ( struct inet_frag_queue * ) arg , struct ipq , q ) ; net = container_of ( qp -> q . net , struct net , ipv4 . frags ) ; spin_lock ( & qp -> q . lock ) ; if ( qp -> q . last_in & INET_FRAG_COMPLETE ) goto out ; ipq_kill ( qp ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMTIMEOUT ) ; IP_INC_STATS_BH ( net , IPSTATS_MIB_REASMFAILS ) ; if ( ( qp -> q . last_in & INET_FRAG_FIRST_IN ) && qp -> q . fragments != NULL ) { struct sk_buff * head = qp -> q . fragments ; <vul-start> rcu_read_lock ( ) ; <vul-end> head -> dev = dev_get_by_index_rcu ( net , qp -> iif ) ; <vul-start> if ( ! head -> dev ) <vul-end> goto out_rcu_unlock ; <vul-start> if ( qp -> user == IP_DEFRAG_CONNTRACK_IN && ! skb_dst ( head ) ) { <vul-end> const struct iphdr * iph = ip_hdr ( head ) ; int err = ip_route_input ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( unlikely ( err ) ) goto out_rcu_unlock ; if ( skb_rtable ( head ) -> rt_type != RTN_LOCAL ) goto out_rcu_unlock ; <vul-start> } <vul-end> icmp_send ( head , ICMP_TIME_EXCEEDED , ICMP_EXC_FRAGTIME , 0 ) ; out_rcu_unlock : rcu_read_unlock ( ) ; } out : spin_unlock ( & qp -> q .",
  "golden_answers": [
   "CWE-000 Fixed Code Lines are: <vul-start> . fragments ; const struct iphdr * iph ; int err ; <vul-start> head -> dev ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <vul-start> == IP_DEFRAG_CONNTRACK_IN && <vul-end> skb_rtable ( head <vul-start> goto out_rcu_unlock ; <vul-end> icmp_send ( head\n"
  ],
  "generated_answer": "CWE-000 Fixed Code Lines are: <vul-start>. fragments ; struct net * net = dev_get_by_index_rcu ( net, qp -> iif ) ; if (! net <vul-end> ) goto out_rcu_unlock <vul-start> ; if ( skb_dst ( head ) && <vul-start> user == IP_DEFRAG_CONNTRACK_IN <vul-end> ) { const <vul-start> out_rcu_unlock ; } else if ( net!= net -> ipv4. dev ) { struct in_device * idev = rcu_dereference ( head -> dev ) ; if ( idev -> dead ) goto out_rcu_unlock ; }\n"
 },
 {
  "id": 1590,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; IndexPacket index ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register PixelPacket * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , blue , bytes_per_line , green , length , red ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; count = ReadBlob ( image , 2 , magick ) ; do { LongPixelPacket shift ; PixelPacket quantum_bits ; size_t profile_data , profile_size ; if ( bmp_info . ba_offset == 0 ) start_position = TellBlob ( image ) - 2 ;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ) break ; if ( bmp_info. ba_offset + bmp_info. size > TellBlob ( image ) ) ThrowReaderException ( CorruptImageError, \"ImproperImageHeader\" ) ;\n"
 },
 {
  "id": 1591,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 VOID ixheaacd_shiftrountine_with_rnd_hq ( WORD32 * qmf_real , WORD32 * qmf_imag , WORD32 * filter_states , WORD32 len , WORD32 shift ) { WORD32 * filter_states_rev = filter_states + len ; WORD32 treal , timag ; WORD32 j ; for ( j = ( len - 1 ) ; j >= 0 ; j -= 2 ) { WORD32 r1 , r2 , i1 , i2 ; i2 = qmf_imag [ j ] ; r2 = qmf_real [ j ] ; r1 = * qmf_real ++ ; i1 = * qmf_imag ++ ; <vul-start> timag = ixheaacd_add32 ( i1 , r1 ) ; <vul-end> timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; filter_states_rev [ j ] = timag ; <vul-start> treal = ixheaacd_sub32 ( i2 , r2 ) ; <vul-end> treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32 ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32 ( i2 , r2 ) ; timag = ( ixheaacd_shl32_sat ( timag , shift ) ) ; * filter_states_rev ++ = timag ; } }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ; timag = ixheaacd_add32_sat <vul-end> ( i1 , <vul-start> ; treal = ixheaacd_sub32_sat ( i2 , r2 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32_sat ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32_sat <vul-end> ( i2 ,\n"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> qmf_imag ++ ; if ( i1 > 0 && i2 > 0 ) { <vul-start> = timag ; } else { timag = ixheaacd_add32 ( i1, r1 ) ; }\n"
 },
 {
  "id": 1592,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_yv12_extend_frame_borders_c ( YV12_BUFFER_CONFIG * ybf ) { <vul-start> assert ( ybf -> y_height - ybf -> y_crop_height < 16 ) ; <vul-end> assert ( ybf -> y_width - ybf -> y_crop_width < 16 ) ; assert ( ybf -> y_height - ybf -> y_crop_height >= 0 ) ; assert ( ybf -> y_width - ybf -> y_crop_width >= 0 ) ; <vul-start> extend_plane ( ybf -> y_buffer , ybf -> y_stride , <vul-end> ybf -> y_crop_width , ybf -> y_crop_height , ybf -> border , ybf -> border , ybf -> border + ybf -> y_height - ybf -> y_crop_height , ybf -> border + ybf -> y_width - ybf -> y_crop_width ) ; extend_plane ( ybf -> u_buffer , ybf -> uv_stride , <vul-start> ( ybf -> y_crop_width + 1 ) / 2 , ( ybf -> y_crop_height + 1 ) / 2 , <vul-end> ybf -> border / 2 , ybf -> border / 2 , ( ybf -> border + ybf -> y_height - ybf -> y_crop_height + 1 ) / 2 , ( ybf -> border + ybf -> y_width - ybf -> y_crop_width + 1 ) / 2 ) ; extend_plane ( ybf -> v_buffer , ybf -> uv_stride , <vul-start> ( ybf -> y_crop_width + 1 ) / 2 , ( ybf -> y_crop_height + 1 ) / 2 , <vul-end> ybf -> border / 2 , ybf -> border / 2 , ( ybf -> border + ybf -> y_height - ybf -> y_crop_height + 1 ) / 2 , ( ybf -> border + ybf ->",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ybf ) { const int uv_border = ybf -> border / 2 ; assert ( ybf -> border % 2 == 0 ) ; <vul-start> 0 ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( ybf -> flags & YV12_FLAG_HIGHBITDEPTH ) { extend_plane_high ( ybf -> y_buffer , ybf -> y_stride , ybf -> y_crop_width , ybf -> y_crop_height , ybf -> border , ybf -> border , ybf -> border + ybf -> y_height - ybf -> y_crop_height , ybf -> border + ybf -> y_width - ybf -> y_crop_width ) ; extend_plane_high ( ybf -> u_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; extend_plane_high ( ybf -> v_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; return ; } # endif <vul-start> -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <vul-end> ) ; extend_plane <vul-start> -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <vul-end> ) ; }\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ybf ) { int uv_width, uv_height ; assert ( ybf -> y_crop_width < 16 ) ; assert ( ybf -> y_crop_height < 16 ) ; assert ( ybf -> y_width - ybf -> y_crop_width >= 0 ) ; assert ( ybf -> y_height - ybf -> y_crop_height >= 0 ) ; <vul-start> 0 ) ; # if CONFIG_VP8_HIGHBITDEPTH if ( ybf -> flags & YV12_FLAG_HIGHBITDEPTH ) { uv_width = ( ybf -> y_crop_width + 1 ) / 2 ; uv_height = ( ybf -> y_crop_height + 1 ) / 2 ; } # endif <vul-start> -> uv_stride, uv_width, uv_height, <vul-end> ybf -> border <vul-start> -> uv_stride, uv_width, uv_height, <vul-end> ybf -> border <vul-start> -> border / 2, ybf -> border / 2, ( ybf -> border + ybf -> y_width - ybf -> y_crop_width ) / 2, ( ybf -> border + ybf -> y_height - ybf -> y_crop_height + 1 ) / 2, ( ybf -> border + ybf -> y_height - ybf -> y_crop_height + 1 ) / 2, ( ybf -> border + ybf -> border + ybf -> y_crop_width - ybf -> y_crop_width ) / 2, ( ybf -> border + ybf -> y_height - ybf -> y_crop_height + 1 ) / 2, ( ybf -> border + ybf -> border + ybf -> y_crop_width - ybf -> y_crop_height ) / 2 ) ; extend_plane ( ybf -> y_buffer, ybf -> y_stride, uv_width, uv_height, ybf -> border, ybf -> border + ybf -> y_crop_width, uv_height, <vul-end> ybf -> border <vul-start> -> border / 2, ybf -> border / 2, ybf -> border + ybf -> y_width - ybf -> y_crop_height ) / 2 ) ; extend_plane ( ybf -> v_buffer, ybf -> uv_stride, uv_width"
 },
 {
  "id": 1593,
  "question": "CWE-416 Code Input Vulnerable Code Is: CWE-416 static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( \"No USB device connected to ttyUSB%i\\\\n\" , co -> index ) ; return - ENODEV ; } serial = port ->",
  "golden_answers": [
   "CWE-416 Fixed Code Lines are: <vul-start> = 0 ; info -> port = NULL ;\n"
  ],
  "generated_answer": "CWE-416 Fixed Code Lines are: <vul-start> = 0 ; error_get_interface :\n"
 },
 {
  "id": 1594,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static ALGobject * ALGnew ( PyObject * self , PyObject * args , PyObject * kwdict ) { unsigned char * key , * IV ; ALGobject * new = NULL ; int keylen , IVlen = 0 , mode = MODE_ECB , segment_size = 0 ; PyObject * counter = NULL ; int counter_shortcut = 0 ; # ifdef PCT_ARC2_MODULE int effective_keylen = 1024 ; # endif if ( ! PyArg_ParseTupleAndKeywords ( args , kwdict , \"s#|is#Oi\" # ifdef PCT_ARC2_MODULE \"i\" # endif , kwlist , & key , & keylen , & mode , & IV , & IVlen , & counter , & segment_size # ifdef PCT_ARC2_MODULE , & effective_keylen # endif ) ) { return NULL ; } if ( mode < MODE_ECB || mode > MODE_CTR ) { PyErr_Format ( PyExc_ValueError , \"Unknown cipher feedback mode %i\" , mode ) ; return NULL ; } if ( mode == MODE_PGP ) { PyErr_Format ( PyExc_ValueError , \"MODE_PGP is not supported anymore\" ) ; return NULL ; } if ( KEY_SIZE != 0 && keylen != KEY_SIZE ) { PyErr_Format ( PyExc_ValueError , \"Key must be %i bytes long, not %i\" , KEY_SIZE , keylen ) ; return NULL ; } if ( KEY_SIZE == 0 && keylen == 0 ) { PyErr_SetString ( PyExc_ValueError , <vul-start> \"Key cannot be the null string\" ) ; <vul-end> return NULL ; } if ( IVlen != BLOCK_SIZE && mode != MODE_ECB && mode != MODE_CTR ) { PyErr_Format ( PyExc_ValueError , \"IV must be %i bytes long\" , BLOCK_SIZE ) ; return NULL",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> PyExc_ValueError , \"Key cannot be the null string\" ) ; return NULL ; } if ( IVlen != 0 && mode == MODE_ECB ) { PyErr_Format ( PyExc_ValueError , \"ECB mode does not use IV\" ) ; return NULL ; } if ( IVlen != 0 && mode == MODE_CTR ) { PyErr_Format ( PyExc_ValueError , \"CTR mode needs counter parameter, not IV\"\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( PyExc_ValueError, \"Key cannot be the null string\" <vul-end> ) ; return\n"
 },
 {
  "id": 1595,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static void make_response ( struct xen_blkif_ring * ring , u64 id , unsigned short op , int st ) { <vul-start> struct blkif_response resp ; <vul-end> unsigned long flags ; union blkif_back_rings * blk_rings ; int notify ; <vul-start> resp . id = id ; <vul-end> resp . operation = op ; resp . status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : <vul-start> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <vul-end> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_32 : <vul-start> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <vul-end> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_64 : <vul-start> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <vul-end> & resp , sizeof ( resp ) ) ; break ; default : BUG ( ) ; <vul-start> } <vul-end> blk_rings -> common . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common , notify ) ; spin_unlock_irqrestore ( & ring -> blk_ring_lock , flags ) ; if ( notify ) notify_remote_via_irq ( ring -> irq ) ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> { struct blkif_response * <vul-start> int notify ; <vul-end> spin_lock_irqsave ( & <vul-start> case BLKIF_PROTOCOL_NATIVE : resp = <vul-end> RING_GET_RESPONSE ( & <vul-start> native . rsp_prod_pvt <vul-end> ) ; break <vul-start> case BLKIF_PROTOCOL_X86_32 : resp = <vul-end> RING_GET_RESPONSE ( & <vul-start> x86_32 . rsp_prod_pvt <vul-end> ) ; break <vul-start> case BLKIF_PROTOCOL_X86_64 : resp = <vul-end> RING_GET_RESPONSE ( & <vul-start> . rsp_prod_pvt ) <vul-end> ; break ; <vul-start> ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> st ) { <vul-end> unsigned long flags <vul-start> int notify ; memset ( & resp, 0, sizeof ( resp ) ) ; resp. id = id ; resp. operation = op ; resp. status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock, flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : memcpy ( RING_GET_RESPONSE ( & blk_rings -> native, blk_rings -> native. rsp_prod_pvt ) ; resp. status = st ; break ; case BLKIF_PROTOCOL_X86_32 : memcpy ( RING_GET_RESPONSE <vul-end> ( & blk_rings <vul-start> -> native. <vul-end> rsp_prod_pvt ), <vul-start> case BLKIF_PROTOCOL_X86_64 : resp. id = id ; resp. status = st ; break ; default : BUG ( ) ; } <vul-end> memcpy ( RING_GET_RESPONSE <vul-start> ) ; } blk_rings -> common. rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common, notify ) ; if ( st ) <vul-end> notify_remote_via_irq ( ring\n"
 },
 {
  "id": 1596,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 void dump_isom_sdp ( GF_ISOFile * file , char * inName , Bool is_final_name ) { const char * sdp ; u32 size , i ; FILE * dump ; if ( inName ) { char szBuf [ 1024 ] ; strcpy ( szBuf , inName ) ; if ( ! is_final_name ) { char * ext = strchr ( szBuf , '.' ) ; if ( ext ) ext [ 0 ] = 0 ; strcat ( szBuf , \"_sdp.txt\" ) ; } dump = gf_fopen ( szBuf , \"wt\" ) ; if ( ! dump ) { fprintf ( stderr , \"Failed to open %s for dumping\\\\n\" , szBuf ) ; return ; } } else { dump = stdout ; fprintf ( dump , \"* File SDP content *\\\\n\\\\n\" ) ; } gf_isom_sdp_get ( file , & sdp , & size ) ; <vul-start> fprintf ( dump , \"%s\" , sdp ) ; <vul-end> fprintf ( dump , \"\\\\r\\\\n\" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; gf_isom_sdp_track_get ( file , i + 1 , & sdp , & size ) ; fprintf ( dump , \"%s\" , sdp ) ; } fprintf ( dump , \"\\\\n\\\\n\" ) ; if ( inName ) gf_fclose ( dump ) ; }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> size ) ; if ( sdp && size )\n"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> ( dump, \"%p\", & <vul-end> sdp ) ;\n"
 },
 {
  "id": 1597,
  "question": "CWE-908 Code Input Vulnerable Code Is: CWE-908 static int kvaser_usb_leaf_flush_queue ( struct kvaser_usb_net_priv * priv ) { struct kvaser_cmd * cmd ; int rc ; <vul-start> cmd = kmalloc ( sizeof ( * cmd ) , GFP_KERNEL ) ; <vul-end> if ( ! cmd ) return - ENOMEM ; cmd -> id = CMD_FLUSH_QUEUE ; cmd -> len = CMD_HEADER_LEN + sizeof ( struct kvaser_cmd_flush_queue ) ; cmd -> u . flush_queue . channel = priv -> channel ; cmd -> u . flush_queue . flags = 0x00 ; rc = kvaser_usb_send_cmd ( priv -> dev , cmd , cmd -> len ) ; kfree ( cmd ) ; return rc ; }",
  "golden_answers": [
   "CWE-908 Fixed Code Lines are: <vul-start> ; cmd = kzalloc <vul-end> ( sizeof (\n"
  ],
  "generated_answer": "CWE-908 Fixed Code Lines are: <vul-start> ; cmd = kzalloc <vul-end> ( sizeof (\n"
 },
 {
  "id": 1598,
  "question": "CWE-617 Code Input Vulnerable Code Is: CWE-617 static int _lldp_send ( struct lldpd * global , struct lldpd_hardware * hardware , u_int8_t c_id_subtype , char * c_id , int c_id_len , u_int8_t p_id_subtype , char * p_id , int p_id_len , int shutdown ) { struct lldpd_port * port ; struct lldpd_chassis * chassis ; struct lldpd_frame * frame ; int length ; u_int8_t * packet , * pos , * tlv ; struct lldpd_mgmt * mgmt ; int proto ; u_int8_t mcastaddr [ ] = LLDP_MULTICAST_ADDR ; # ifdef ENABLE_DOT1 const u_int8_t dot1 [ ] = LLDP_TLV_ORG_DOT1 ; struct lldpd_vlan * vlan ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi ; # endif # ifdef ENABLE_DOT3 const u_int8_t dot3 [ ] = LLDP_TLV_ORG_DOT3 ; # endif # ifdef ENABLE_LLDPMED int i ; const u_int8_t med [ ] = LLDP_TLV_ORG_MED ; # endif # ifdef ENABLE_CUSTOM struct lldpd_custom * custom ; # endif port = & hardware -> h_lport ; chassis = port -> p_chassis ; length = hardware -> h_mtu ; if ( ( packet = ( u_int8_t * ) calloc ( 1 , length ) ) == NULL ) return ENOMEM ; pos = packet ; if ( ! ( POKE_BYTES ( mcastaddr , sizeof ( mcastaddr ) ) && POKE_BYTES ( & hardware -> h_lladdr , ETHER_ADDR_LEN ) && POKE_UINT16 ( ETHERTYPE_LLDP ) ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_CHASSIS_ID ) && POKE_UINT8 ( c_id_subtype ) && POKE_BYTES ( c_id , c_id_len ) && POKE_END_LLDP_TLV ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_PORT_ID ) && POKE_UINT8 ( p_id_subtype",
  "golden_answers": [
   "CWE-617 Fixed Code Lines are: <vul-start> m_family ) ; if ( proto == LLDP_MGMT_ADDR_NONE ) continue <vul-end> ; if (\n"
  ],
  "generated_answer": "CWE-617 Fixed Code Lines are: <vul-start>!= LLDP_MGMT_ADDR_NONE ) ; if (! shutdown && frame && POKE_SIZE ( frame ) > 0\n"
 },
 {
  "id": 1599,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 unsigned paravirt_patch_call ( void * insnbuf , const void * target , u16 tgt_clobbers , unsigned long addr , u16 site_clobbers , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ; <vul-start> if ( tgt_clobbers & ~ site_clobbers ) <vul-end> return len ; <vul-start> if ( len < 5 ) <vul-end> return len ; b -> opcode = 0xe8 ; b -> delta = delta ; BUILD_BUG_ON ( sizeof ( * b ) != 5 ) ; return 5 ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> ; if ( len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( \"Failing to patch indirect CALL in %ps\\\\n\" , ( void * ) addr ) ; # endif <vul-end> return len ; <vul-start> return len ; } <vul-end> b -> opcode\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ; if ( len < 5 ) return len ; if ( <vul-start> ~ site_clobbers ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( \"Failing to patch indirect code in %ps\\\\n\", ( void * ) addr ) ; # endif <vul-start> return len ; } <vul-end> b -> opcode\n"
 },
 {
  "id": 1600,
  "question": "CWE-400 Code Input Vulnerable Code Is: CWE-400 static struct task_struct * copy_process ( unsigned long clone_flags , unsigned long stack_start , struct pt_regs * regs , unsigned long stack_size , int __user * child_tidptr , struct pid * pid , int trace ) { int retval ; struct task_struct * p ; int cgroup_callbacks_done = 0 ; if ( ( clone_flags & ( CLONE_NEWNS | CLONE_FS ) ) == ( CLONE_NEWNS | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ) ; retval = security_task_create ( clone_flags ) ; if ( retval ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current ) ; if ( ! p ) goto fork_out ; ftrace_graph_init_task ( p ) ; rt_mutex_init_task ( p ) ; # ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> hardirqs_enabled ) ; DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ) ; # endif retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= p -> signal -> rlim [ RLIMIT_NPROC ] . rlim_cur ) { if ( ! capable ( CAP_SYS_ADMIN ) && ! capable ( CAP_SYS_RESOURCE ) && p -> real_cred -> user != INIT_USER ) goto bad_fork_free ; } retval",
  "golden_answers": [
   "CWE-400 Fixed Code Lines are: <vul-start> ; bad_fork_cleanup_io : if <vul-end> ( p -> <vul-start> p -> io_context ) exit_io_context ( p\n"
  ],
  "generated_answer": "CWE-400 Fixed Code Lines are: <vul-start> ; bad_fork_cleanup_io : <vul-end> bad_fork_cleanup_namespaces : exit_task_namespaces\n"
 },
 {
  "id": 1601,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int decode_dds1 ( GetByteContext * gb , uint8_t * frame , int width , int height ) { const uint8_t * frame_start = frame ; const uint8_t * frame_end = frame + width * height ; int mask = 0x10000 , bitbuf = 0 ; int i , v , offset , count , segments ; segments = bytestream2_get_le16 ( gb ) ; while ( segments -- ) { if ( bytestream2_get_bytes_left ( gb ) < 2 ) return AVERROR_INVALIDDATA ; if ( mask == 0x10000 ) { bitbuf = bytestream2_get_le16u ( gb ) ; mask = 1 ; } if ( bitbuf & mask ) { v = bytestream2_get_le16 ( gb ) ; offset = ( v & 0x1FFF ) << 2 ; count = ( ( v >> 13 ) + 2 ) << 1 ; if ( frame - frame_start < offset || frame_end - frame < count * 2 + width ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < count ; i ++ ) { frame [ 0 ] = frame [ 1 ] = frame [ width ] = frame [ width + 1 ] = frame [ - offset ] ; frame += 2 ; } } else if ( bitbuf & ( mask << 1 ) ) { v = bytestream2_get_le16 ( gb ) * 2 ; if ( frame - frame_end < v ) return AVERROR_INVALIDDATA ; frame += v ; } else { <vul-start> if ( frame_end - frame < width + 3 ) <vul-end> return AVERROR_INVALIDDATA ; frame [ 0",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> < width + 4 <vul-end> ) return AVERROR_INVALIDDATA\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> width + 3 || frame >= frame_end - width\n"
 },
 {
  "id": 1602,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 void * _TIFFmalloc ( tmsize_t s ) <vul-start> { <vul-end> return ( malloc ( ( size_t ) s ) ) ; }",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;\n"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;\n"
 },
 {
  "id": 1603,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 <vul-start> static void read_quant_matrix_ext ( MpegEncContext * s , GetBitContext * gb ) <vul-end> { int i , j , v ; <vul-start> if ( get_bits1 ( gb ) ) { <vul-end> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> intra_matrix [ j ] = v ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <vul-start> for ( i = 0 ; i < 64 ; i ++ ) { <vul-end> get_bits ( gb , 8 ) ; } } <vul-start> if ( get_bits1 ( gb ) ) { <vul-end> for ( i = 0 ; i < 64 ; i ++ ) { v = get_bits ( gb , 8 ) ; j = s -> idsp . idct_permutation [ ff_zigzag_direct [ i ] ] ; s -> chroma_intra_matrix [ j ] = v ; } } if ( get_bits1 ( gb ) ) { <vul-start> for ( i = 0 ; i < 64 ; i ++ ) { <vul-end> get_bits ( gb , 8 ) ; } } next_start_code_studio ( gb ) ; <vul-start> } <vul-end>",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start>     static int <vul-end> read_quant_matrix_ext ( MpegEncContext <vul-start> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <vul-start> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <vul-start> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <vul-start> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <vul-start> gb ) ; return 0 ;\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>     static int <vul-end> read_quant_matrix_ext ( MpegEncContext <vul-start>, v ; <vul-end> for ( i <vul-start> ) ) { return read_quant_matrix_internal ( s, gb, i ) ; } <vul-end> if ( get_bits1 <vul-start> ) ) { return read_quant_matrix_internal ( s, gb, i ) ; } <vul-end> next_start_code_studio ( gb <vul-start> gb ) ; return 0 ;\n"
 },
 {
  "id": 1604,
  "question": "CWE-200 Code Input Vulnerable Code Is: CWE-200 static int l2tp_ip6_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddr_len , int peer ) { struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) uaddr ; struct sock * sk = sock -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct l2tp_ip6_sock * lsk = l2tp_ip6_sk ( sk ) ; lsa -> l2tp_family = AF_INET6 ; lsa -> l2tp_flowinfo = 0 ; lsa -> l2tp_scope_id = 0 ; <vul-start> if ( peer ) { <vul-end> if ( ! lsk -> peer_conn_id ) return - ENOTCONN ; lsa -> l2tp_conn_id = lsk -> peer_conn_id ; lsa -> l2tp_addr = np -> daddr ; if ( np -> sndflow ) lsa -> l2tp_flowinfo = np -> flow_label ; } else { if ( ipv6_addr_any ( & np -> rcv_saddr ) ) lsa -> l2tp_addr = np -> saddr ; else lsa -> l2tp_addr = np -> rcv_saddr ; lsa -> l2tp_conn_id = lsk -> conn_id ; } if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) lsa -> l2tp_scope_id = sk -> sk_bound_dev_if ; * uaddr_len = sizeof ( * lsa ) ; return 0 ; }",
  "golden_answers": [
   "CWE-200 Fixed Code Lines are: <vul-start> = 0 ; lsa -> l2tp_unused = 0 ;\n"
  ],
  "generated_answer": "CWE-200 Fixed Code Lines are: <vul-start> ( peer ) lsa -> l2tp_conn_id = 0 ; <vul-end> if ( ipv6_addr_type\n"
 },
 {
  "id": 1605,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 int phar_parse_zipfile ( php_stream * fp , char * fname , int fname_len , char * alias , int alias_len , phar_archive_data * * pphar , char * * error ) { phar_zip_dir_end locator ; char buf [ sizeof ( locator ) + 65536 ] ; zend_long size ; php_uint16 i ; phar_archive_data * mydata = NULL ; phar_entry_info entry = { 0 } ; char * p = buf , * ext , * actual_alias = NULL ; char * metadata = NULL ; size = php_stream_tell ( fp ) ; if ( size > sizeof ( locator ) + 65536 ) { size = sizeof ( locator ) + 65536 ; if ( FAILURE == php_stream_seek ( fp , - size , SEEK_END ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , \"phar error: unable to search for end of central directory in zip-based phar \\\\\"%s\\\\\"\" , fname ) ; } return FAILURE ; } } else { php_stream_seek ( fp , 0 , SEEK_SET ) ; } if ( ! php_stream_read ( fp , buf , size ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , \"phar error: unable to read in data to search for end of central directory in zip-based phar \\\\\"%s\\\\\"\" , fname ) ; } return FAILURE ; } while ( ( p = ( char * ) memchr ( p + 1 , 'P' , ( size_t ) ( size - ( p + 1 - buf",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> entry . uncompressed_filesize || read <= 8\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> if ( read < 0 || read\n"
 },
 {
  "id": 1606,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int64_t rd_sbuv_dcpred ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ) { const VP9_COMMON * cm = & cpi -> common ; int64_t unused ; x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode = DC_PRED ; <vul-start> super_block_uvrd ( cpi , x , rate_tokenonly , distortion , <vul-end> skippable , & unused , bsize , INT64_MAX ) ; <vul-start> * rate = * rate_tokenonly + x -> intra_uv_mode_cost [ cm -> frame_type ] [ DC_PRED ] ; <vul-end> return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = DC_PRED ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; <vul-start> * rate_tokenonly + cpi <vul-end> -> intra_uv_mode_cost [\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = DC_PRED ; if ( cpi -> oxcf. aq_mode == CYCLIC_REFRESH_AQ && cm -> frame_type == KEY_FRAME ) { super_block_uvrd_ext ( cpi, x, rate_tokenonly, distortion, skippable, & unused, bsize, INT64_MAX ) ; } else { <vul-start> INT64_MAX ) ; }\n"
 },
 {
  "id": 1607,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int translate_hex_string ( char * s , char * saved_orphan ) { int c1 = * saved_orphan ; char * start = s ; char * t = s ; for ( ; * s ; s ++ ) { <vul-start> if ( isspace ( * s ) ) <vul-end> continue ; if ( c1 ) { * t ++ = ( hexval ( c1 ) << 4 ) + hexval ( * s ) ; c1 = 0 ; } else c1 = * s ; } * saved_orphan = c1 ; return t - start ; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> ( isspace ( ( unsigned char )\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> ( isspace ( ( unsigned char )\n"
 },
 {
  "id": 1608,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static void update_best_mode ( BEST_MODE * best_mode , int this_rd , RATE_DISTORTION * rd , int other_cost , MACROBLOCK * x ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; other_cost += x -> ref_frame_cost [ x -> e_mbd . mode_info_context -> mbmi . ref_frame ] ; best_mode -> yrd = RDCOST ( x -> rdmult , x -> rddiv , ( rd -> rate2 - rd -> rate_uv - other_cost ) , ( rd -> distortion2 - rd -> distortion_uv ) ) ; best_mode -> rd = this_rd ; <vul-start> vpx_memcpy ( & best_mode -> mbmode , & x -> e_mbd . mode_info_context -> mbmi , sizeof ( MB_MODE_INFO ) ) ; <vul-end> <vul-start> vpx_memcpy ( & best_mode -> partition , x -> partition_info , sizeof ( PARTITION_INFO ) ) ; <vul-end> if ( ( this_mode == B_PRED ) || ( this_mode == SPLITMV ) ) { int i ; for ( i = 0 ; i < 16 ; i ++ ) { best_mode -> bmodes [ i ] = x -> e_mbd . block [ i ] . bmi ; } } }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> = this_rd ; memcpy <vul-end> ( & best_mode <vul-start> ) ) ; memcpy <vul-end> ( & best_mode\n"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> = this_rd ; memcpy <vul-end> ( & best_mode <vul-start> ) ) ; memcpy <vul-end> ( & best_mode\n"
 },
 {
  "id": 1609,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 gdImagePtr gdImageCreate ( int sx , int sy ) { int i ; gdImagePtr im ; if ( overflow2 ( sx , sy ) ) { return NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sy ) ) { return NULL ; } <vul-start> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <vul-end> im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> AA_opacity = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> polyInts = 0 ; im -> polyAllocated = 0 ; im -> brush = 0 ; im -> tile = 0 ; im -> style = 0 ; for ( i = 0 ; i < sy ; i ++ ) { im -> pixels [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; im -> AA_opacity [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; } im -> sx = sx ; im -> sy = sy ; im -> colorsTotal = 0 ; im -> transparent = ( - 1 ) ; im -> interlace = 0 ; im -> thick = 1 ; im -> AA = 0 ; im -> AA_polygon = 0 ; for ( i = 0 ; i < gdMaxColors ; i ++",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; }\n"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> NULL ; } if ( overflow2 ( sizeof ( unsigned char * ), sx ) ) { return NULL ; } if ( overflow2 ( sizeof ( unsigned char * ), sy ) ) { return NULL ; }\n"
 },
 {
  "id": 1610,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) )",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ; olddentry = lookup_one_len ( old <vul-end> -> d_name . <vul-start> . name , old_upperdir , old <vul-end> -> d_name . <vul-start> = PTR_ERR ( olddentry <vul-end> ) ; if <vul-start> ( IS_ERR ( olddentry <vul-end> ) ) goto <vul-start> goto out_unlock ; <vul-end> err = - <vul-start> if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <vul-end> ) goto out_dput <vul-start> goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) <vul-end> ) goto out_dput <vul-start> goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <vul-start> newdentry ) ; out_dput_old : dput ( olddentry ) ;\n"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> old_upperdir ) ; err = - ENAMETOOLONG ; if (! new_upperdir ) { err = - ENAMETOOLONG ; goto out_unlock ; } <vul-start> = true ; err = ovl_check_name_collision ( new_upperdir, new -> d_name. name, new -> d_name. len, & newdentry, & old_upperdir ) ; if ( err ) goto out_unlock ; err = - ENAMETOOLONG ; if ( newdentry -> d_name. name [ 0 ]!= '\\\\0' || newdentry -> d_name. name [ 0 ]!= '\\\\0' ) { err = - ENAMETOOLONG ; goto out_unlock ; } err = - ENAMETOOLONG ; <vul-start> newdentry ) ) { err = - ENAMETOOLONG ; <vul-start> out_unlock ; } } <vul-start>!= old_upperdir ) { err = - ENAMETOOLONG ; <vul-start> goto out_dput ; } <vul-start>!= new_upperdir ) { err = - ENAMETOOLONG ; <vul-start> goto out_dput ; } <vul-start> old_upperdir ) ; err = - ENAMETOOLONG ; <vul-start> new_upperdir ) goto out_dput ; err = - ENAMETOOLONG ; <vul-start> ( newdentry ) { err = - ENAMETOOLONG ; <vul-start> out_unlock ; } } if ( err ) { err = - ENAMETOOLONG ; <vul-start> old_upperdir ) goto out_dput ; err = - ENAMETOOLONG ; <vul-start> new_upperdir ) goto out_dput ; err = - ENAMETOOLONG ; <vul-start> ( newdentry ) { err = - ENAMETOOLONG ; <vul-start> new_upperdir ) goto out_dput ; } if ( old_opaque && new_is_dir ) { err = ovl_check_name_collision ( new -> d_inode, newdentry, old_upperdir ) ; if ( err ) goto out_dput ; } if ( newdentry == trap ) { dput ( newdentry ) ; } if ( old_opaque && new_is_dir ) { err = - ENAMETOOLONG ; <vul-start> new_upperdir ) ; } if ( newdentry!= trap ) { err ="
 },
 {
  "id": 1611,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static int match_at ( regex_t * reg , const UChar * str , const UChar * end , # ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE const UChar * right_range , # endif const UChar * sstart , UChar * sprev , OnigMatchArg * msa ) { static UChar FinishCode [ ] = { OP_FINISH } ; int i , n , num_mem , best_len , pop_level ; LengthType tlen , tlen2 ; MemNumType mem ; RelAddrType addr ; UChar * s , * q , * sbegin ; int is_alloca ; char * alloc_base ; OnigStackType * stk_base , * stk , * stk_end ; OnigStackType * stkp ; OnigStackIndex si ; OnigStackIndex * repeat_stk ; OnigStackIndex * mem_start_stk , * mem_end_stk ; # ifdef USE_COMBINATION_EXPLOSION_CHECK int scv ; unsigned char * state_check_buff = msa -> state_check_buff ; int num_comb_exp_check = reg -> num_comb_exp_check ; # endif UChar * p = reg -> p ; OnigOptionType option = reg -> options ; OnigEncoding encode = reg -> enc ; OnigCaseFoldType case_fold_flag = reg -> case_fold_flag ; pop_level = reg -> stack_pop_level ; num_mem = reg -> num_mem ; STACK_INIT ( INIT_MATCH_STACK_SIZE ) ; UPDATE_FOR_STACK_REALLOC ; for ( i = 1 ; i <= num_mem ; i ++ ) { mem_start_stk [ i ] = mem_end_stk [ i ] = INVALID_STACK_INDEX ; } # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , \"match_at: str: %d, end: %d, start: %d, sprev: %d\\\\n\" , ( int ) str , ( int ) end , ( int ) sstart , ( int ) sprev ) ; fprintf ( stderr , \"size: %d, start offset: %d\\\\n\"",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> OP_EXACT1 ) ; <vul-end> DATA_ENSURE ( 1 <vul-start> ++ ; s <vul-end> ++ ; MOP_OUT\n"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> OP_EXACT1 ) ; <vul-end> DATA_ENSURE ( 1 <vul-start> goto fail ; if ( n >= end - str ) goto fail ;\n"
 }
]